[{"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Anomalies/UnusualAnomaly.yaml", "query_name": "Unusual Anomaly", "query": "// You can leave out Anomalies that are already monitored through other Analytics Rules\n//let _MonitoredRules = dynamic([\"TestAlertName\"]);\nlet query_frequency = 1h;\nlet query_lookback = 3d;\nAnomalies\n| where TimeGenerated > ago(query_frequency)\n//| where not(RuleName has_any (_MonitoredRules))\n| join kind = leftanti (\n    Anomalies\n    | where TimeGenerated between (ago(query_frequency + query_lookback)..ago(query_frequency))\n    | distinct RuleName\n) on RuleName\n", "attributes": {"description": "'Anomaly Rules generate events in the Anomalies table. This scheduled rule tries to detect Anomalies that are not usual, they could be a type of Anomaly that has recently been activated, or an infrequent type. The detected Anomaly should be reviewed, if it is relevant enough, eventually a separate scheduled Analytics Rule could be created specifically for that Anomaly Type, so an alert and/or incident is generated everytime that type of Anomaly happens.'\n", "techniques": NaN, "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimAuthentication/imAuthBruteForce.yaml", "query_name": "Brute force attack against user credentials (Uses Authentication Normalization)", "query": "let failureCountThreshold = 10;\nlet successCountThreshold = 1;\n// let authenticationWindow = 20m; // Implicit in the analytic rule query period \nimAuthentication\n| where TargetUserType != \"NonInteractive\"\n| summarize \n      StartTime = min(TimeGenerated), \n      EndTime = max(TimeGenerated), \n      IpAddresses = make_set (SrcDvcIpAddr, 100),\n      ReportedBy = make_set (strcat (EventVendor, \"/\", EventProduct), 100),\n      FailureCount = countif(EventResult=='Failure'),\n      SuccessCount = countif(EventResult=='Success')\n  by \n      TargetUserId, TargetUsername, TargetUserType \n| where FailureCount >= failureCountThreshold and SuccessCount >= successCountThreshold\n| extend\n      IpAddresses = strcat_array(IpAddresses, \", \"), \n      ReportedBy = strcat_array(ReportedBy, \", \")\n", "attributes": {"description": "'Identifies evidence of brute force activity against a user based on multiple authentication failures \nand at least one successful authentication within a given time window. Note that the query does not enforce any sequence,\nand does not require the successful authentication to occur last.\nThe default failure threshold is 10, success threshold is 1, and the default time window is 20 minutes.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimAuthentication)'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimAuthentication/imAuthPasswordSpray.yaml", "query_name": "Potential Password Spray Attack (Uses Authentication Normalization)", "query": "let FailureThreshold = 15;\nimAuthentication\n| where EventType== 'Logon' and  EventResult== 'Failure'\n// reason: creds \n| where EventResultDetails in ('No such user or password', 'Incorrect password')\n| summarize UserCount=dcount(TargetUserId), Vendors=make_set(EventVendor), Products=make_set(EventVendor)\n  , Users = make_set(TargetUserId,100) \n    by SrcDvcIpAddr, SrcGeoCountry, bin(TimeGenerated, 5m)\n| where UserCount > FailureThreshold\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcDvcIpAddr\n", "attributes": {"description": "'This query searches for failed attempts to log in from more than 15 various users within a 5 minute timeframe from the same source. This is a potential indication of a password spray attack\n To use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimAuthentication)'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimAuthentication/imAuthSigninsMultipleCountries.yaml", "query_name": "User login from different countries within 3 hours (Uses Authentication Normalization)", "query": "let timeframe = ago(3h);\nlet threshold = 2;\nimAuthentication\n| where TimeGenerated > timeframe\n| where EventType=='Logon' and EventResult=='Success'\n| where isnotempty(SrcGeoCountry)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), Vendors=make_set(EventVendor), Products=make_set(EventProduct)\n  , NumOfCountries = dcount(SrcGeoCountry)\n  by TargetUserId, TargetUsername, TargetUserType\n| where NumOfCountries >= threshold\n| extend timestamp = StartTime, AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'This query searches for successful user logins from different countries within 3 hours.\n To use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimAuthentication)'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimAuthentication/imSigninAttemptsByIPviaDisabledAccounts.yaml", "query_name": "Sign-ins from IPs that attempt sign-ins to disabled accounts (Uses Authentication Normalization)", "query": "imAuthentication\n| where EventResult =='Failure'\n| where EventResultDetails == 'User disabled'\n| summarize StartTime=min(EventStartTime), EndTime=max(EventEndTime), disabledAccountLoginAttempts = count()\n      , disabledAccountsTargeted = dcount(TargetUsername), disabledAccountSet = make_set(TargetUsername)\n      , applicationsTargeted = dcount(TargetAppName)\n      , applicationSet = make_set(TargetAppName) \n      by SrcDvcIpAddr, Type\n| order by disabledAccountLoginAttempts desc\n| join kind=leftouter \n    (\n    // Consider these IPs suspicious - and alert any related  successful sign-ins\n    imAuthentication\n    | where EventResult=='Success'\n    | summarize successfulAccountSigninCount = dcount(TargetUsername), successfulAccountSigninSet = makeset(TargetUsername, 15) by SrcDvcIpAddr, Type\n    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe\n    | where successfulAccountSigninCount < 100\n    )\n    on SrcDvcIpAddr\n| where isnotempty(successfulAccountSigninCount)\n| project StartTime, EndTime, SrcDvcIpAddr, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet, \nsuccessfulAccountSigninCount, successfulAccountSigninSet, Type\n| order by disabledAccountLoginAttempts\n| extend timestamp = StartTime, IPCustomEntity = SrcDvcIpAddr\n", "attributes": {"description": "'Identifies IPs with failed attempts to sign in to one or more disabled accounts signed in successfully to another account.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimAuthentication)'\n", "techniques": ["T1078", "T1098"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimDNS/imDns_DomainEntity_DnsEvents.yaml", "query_name": "(Preview) TI map Domain entity to Dns Events (ASIM DNS Schema)", "query": "let HAS_ANY_MAX = 10000;\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet DomainTIs= ThreatIntelligenceIndicator\n  | where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n  // Picking up only IOC's that contain the entities we want\n  | where isnotempty(DomainName)\n  | where Active == true\n  | summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId;\nlet Domains = DomainTIs | where isnotempty(DomainName) |summarize NDomains=dcount(DomainName), DomainsList=make_set(DomainName) \n  | project DomainList = iff(NDomains > HAS_ANY_MAX, dynamic([]), DomainsList) ;\nDomainTIs\n  | join (\n      _Im_Dns(starttime=ago(dt_lookBack), domain_has_any=toscalar(Domains))\n      | extend DNS_TimeGenerated = TimeGenerated\n) on $left.DomainName==$right.DnsQuery\n| where DNS_TimeGenerated < ExpirationDateTime\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Url, DNS_TimeGenerated, Dvc, SrcIpAddr, DnsQuery, DnsQueryType\n| extend timestamp = DNS_TimeGenerated, HostCustomEntity = Dvc, IPCustomEntity = SrcIpAddr, URLCustomEntity = Url\n", "attributes": {"description": "Identifies a match in DNS events from any Domain IOC from TI\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimDNS/imDns_ExcessiveNXDOMAINDNSQueries.yaml", "query_name": "Excessive NXDOMAIN DNS Queries (ASIM DNS Schema)", "query": "let threshold = 200;\n_Im_Dns(responsecodename='NXDOMAIN')\n| where isnotempty(DnsResponseCodeName)\n//| where DnsResponseCodeName =~ \"NXDOMAIN\"\n| summarize count() by SrcIpAddr, bin(TimeGenerated,15m)\n| where count_ > threshold\n| join kind=inner (_Im_Dns(responsecodename='NXDOMAIN')\n    ) on SrcIpAddr\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'This creates an incident in the event a client generates excessive amounts of DNS queries for non-existent domains. \nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema'\n", "techniques": ["T1568", "T1008"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimDNS/imDns_HighNXDomainCount_detection.yaml", "query_name": "Potential DGA detected (ASIM DNS Schema)", "query": "let referencestarttime = 10d;\nlet referenceendtime = 1d;\nlet threshold = 100;\nlet nxDomainDnsEvents = (stime:datetime, etime:datetime) \n  {_Im_Dns(responsecodename='NXDOMAIN', starttime=stime, endtime=etime)\n  | where DnsQueryTypeName in (\"A\", \"AAAA\")\n  | where ipv4_is_match(\"127.0.0.1\", SrcIpAddr) == False\n  | where DnsQuery !contains \"/\" and  DnsQuery contains \".\"};\nnxDomainDnsEvents (stime=ago(referenceendtime) ,etime=now())\n  | extend sld = tostring(split(DnsQuery, \".\")[-2])\n  | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), dcount(sld) by SrcIpAddr\n  | where dcount_sld > threshold\n  // Filter out previously seen IPs\n  | join kind=leftanti (nxDomainDnsEvents (stime=ago(referencestarttime), etime=ago(referenceendtime))\n    | extend sld = tostring(split(DnsQuery, \".\")[-2])\n    | summarize dcount(sld) by SrcIpAddr\n    | where dcount_sld > threshold ) on SrcIpAddr\n// Pull out sample NXDomain responses for those remaining potentially infected IPs\n| join kind = inner (nxDomainDnsEvents (stime=ago(referencestarttime), etime=now()) | summarize by DnsQuery, SrcIpAddr) on SrcIpAddr\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), sampleNXDomainList=make_list(DnsQuery, 100)  by SrcIpAddr, dcount_sld\n| extend timestamp = StartTimeUtc, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Identifies clients with a high NXDomain count which could be indicative of a DGA (cycling through possible C2 domains\nwhere most C2s are not live). Alert is generated when a new IP address is seen (based on not being seen associated with \nNXDomain records in prior 10-day baseline period).\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema'\n", "techniques": ["T1568", "T1008"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimDNS/imDns_IPEntity_DnsEvents.yaml", "query_name": "(Preview) TI map IP entity to Dns Events (ASIM DNS Schema)", "query": "let HAS_ANY_MAX=10000;\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet IP_TI = (ThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,\"\")\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true);\nlet TI_IP_List=IP_TI | summarize NIPs=dcount(TI_ipEntity), IP_List=make_set( TI_ipEntity) \n| project IP_List=iff(NIPs > HAS_ANY_MAX, dynamic([]), IP_List);\n_Im_Dns(starttime=ago(dt_lookBack), response_has_any_prefix=todynamic(toscalar(TI_IP_List)))\n    | extend tilist = toscalar(TI_IP_List)\n    | mv-expand tilist\n    | extend SingleIP=tostring(tilist)\n    | project-away tilist\n    | where has_ipv4(DnsResponseName, SingleIP)\n    | extend DNS_TimeGenerated = TimeGenerated\n| join IP_TI\n      on $left.SingleIP == $right.TI_ipEntity\n| where DNS_TimeGenerated >= TimeGenerated and DNS_TimeGenerated < ExpirationDateTime\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, DNS_TimeGenerated,\nTI_ipEntity, Dvc, EventSubType, SrcIpAddr, DnsQuery, DnsResponseName, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = DNS_TimeGenerated, IPCustomEntity = TI_ipEntity, HostCustomEntity = Dvc, URLCustomEntity = Url\n", "attributes": {"description": "Identifies a match in DNS events from any IP IOC from TI\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimDNS/imDNS_Miners.yaml", "query_name": "DNS events related to mining pools (ASIM DNS Schema)", "query": "let minersDomains=dynamic([\"monerohash.com\", \"do-dear.com\", \"xmrminerpro.com\", \"secumine.net\", \"xmrpool.com\", \"minexmr.org\", \"hashanywhere.com\", \n\"xmrget.com\", \"mininglottery.eu\", \"minergate.com\", \"moriaxmr.com\", \"multipooler.com\", \"moneropools.com\", \"xmrpool.eu\", \"coolmining.club\", \n\"supportxmr.com\", \"minexmr.com\", \"hashvault.pro\", \"xmrpool.net\", \"crypto-pool.fr\", \"xmr.pt\", \"miner.rocks\", \"walpool.com\", \"herominers.com\", \n\"gntl.co.uk\", \"semipool.com\", \"coinfoundry.org\", \"cryptoknight.cc\", \"fairhash.org\", \"baikalmine.com\", \"tubepool.xyz\", \"fairpool.xyz\", \"asiapool.io\", \n\"coinpoolit.webhop.me\", \"nanopool.org\", \"moneropool.com\", \"miner.center\", \"prohash.net\", \"poolto.be\", \"cryptoescrow.eu\", \"monerominers.net\", \"cryptonotepool.org\", \n\"extrmepool.org\", \"webcoin.me\", \"kippo.eu\", \"hashinvest.ws\", \"monero.farm\", \"supportxmr.com\", \"xmrpool.eu\", \"linux-repository-updates.com\", \"1gh.com\", \n\"dwarfpool.com\", \"hash-to-coins.com\", \"hashvault.pro\", \"pool-proxy.com\", \"hashfor.cash\", \"fairpool.cloud\", \"litecoinpool.org\", \"mineshaft.ml\", \"abcxyz.stream\", \n\"moneropool.ru\", \"cryptonotepool.org.uk\", \"extremepool.org\", \"extremehash.com\", \"hashinvest.net\", \"unipool.pro\", \"crypto-pools.org\", \"monero.net\", \n\"backup-pool.com\", \"mooo.com\", \"freeyy.me\", \"cryptonight.net\", \"shscrypto.net\"]);\n_Im_Dns(domain_has_any=minersDomains)\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Dvc\n", "attributes": {"description": "'Identifies IP addresses that may be performing DNS lookups associated with common currency mining pools.\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimDNS/imDNS_TorProxies.yaml", "query_name": "DNS events related to ToR proxies  (ASIM DNS Schema)", "query": "let torProxies=dynamic([\"tor2web.org\", \"tor2web.com\", \"torlink.co\", \"onion.to\", \"onion.ink\", \"onion.cab\", \"onion.nu\", \"onion.link\", \n\"onion.it\", \"onion.city\", \"onion.direct\", \"onion.top\", \"onion.casa\", \"onion.plus\", \"onion.rip\", \"onion.dog\", \"tor2web.fi\", \n\"tor2web.blutmagie.de\", \"onion.sh\", \"onion.lu\", \"onion.pet\", \"t2w.pw\", \"tor2web.ae.org\", \"tor2web.io\", \"tor2web.xyz\", \"onion.lt\", \n\"s1.tor-gateways.de\", \"s2.tor-gateways.de\", \"s3.tor-gateways.de\", \"s4.tor-gateways.de\", \"s5.tor-gateways.de\", \"hiddenservice.net\"]);\n_Im_Dns(domain_has_any=torProxies)\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Dvc\n", "attributes": {"description": "'Identifies IP addresses performing DNS lookups associated with common ToR proxies.\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimFileEvent/imFileESolarWindsSunburstSupernova.yaml", "query_name": "SUNBURST and SUPERNOVA backdoor hashes (Normalized File Events)", "query": "let SunburstMD5=dynamic([\"b91ce2fa41029f6955bff20079468448\",\"02af7cec58b9a5da1c542b5a32151ba1\",\"2c4a910a1299cdae2a4e55988a2f102e\",\"846e27a652a5e1bfbd0ddd38a16dc865\",\"4f2eb62fa529c0283b28d05ddd311fae\"]);\nlet SupernovaMD5=\"56ceb6d0011d87b6e4d7023d7ef85676\";\nimFileEvent\n| where TargetFileMD5 in(SunburstMD5) or TargetFileMD5 in(SupernovaMD5)\n| extend\n    timestamp = TimeGenerated,\n    AccountCustomEntity = User, \n    HostCustomEntity = DvcHostname,\n    FileHashCustomEntity = TargetFileMD5,\n    AlgorithmCustomEntity = \"MD5\"\n", "attributes": {"description": "Identifies SolarWinds SUNBURST and SUPERNOVA backdoor file hash IOCs in File Events\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimFileEvent)\nReferences:\n- https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n- https://gist.github.com/olafhartong/71ffdd4cab4b6acd5cbcd1a0691ff82f\n", "techniques": ["T1195", "T1059", "T1546"], "tactics": ["Execution", "Persistence", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimFileEvent/imFileEvent_Dev-0228FilePathHashesNovember2021%28ASIMVersion%29.yaml", "query_name": "Dev-0228 File Path Hashes November 2021 (ASIM Version)", "query": "let files1 = dynamic([\"C:\\\\Windows\\\\TAPI\\\\lsa.exe\", \"C:\\\\Windows\\\\TAPI\\\\pa.exe\", \"C:\\\\Windows\\\\TAPI\\\\pc.exe\", \"C:\\\\Windows\\\\TAPI\\\\Rar.exe\"]);\nlet files2 = dynamic([\"svchost.exe\",\"wdmsvc.exe\"]);\nlet FileHash1 = dynamic([\"43109fbe8b752f7a9076eaafa417d9ae5c6e827cd5374b866672263fdebd5ec3\", \"ab50d8d707b97712178a92bbac74ccc2a5699eb41c17aa77f713ff3e568dcedb\", \"010e32be0f86545e116a8bc3381a8428933eb8789f32c261c81fd5e7857d4a77\",     \"56cd102b9fc7f3523dad01d632525ff673259dbc9a091be0feff333c931574f7\"]);\nlet FileHash2 = dynamic([\"2a1044e9e6e87a032f80c6d9ea6ae61bbbb053c0a21b186ecb3b812b49eb03b7\", \"9ab7e99ed84f94a7b6409b87e56dc6e1143b05034a5e4455e8c555dbbcd0d2dd\", \"18a072ccfab239e140d8f682e2874e8ff19d94311fc8bb9564043d3e0deda54b\"]);\nimFileEvent\n| where ((FilePath has_any (files1)) and (ActingProcessSHA256 has_any (FileHash1))) or ((FilePath has_any (files2)) and (ActingProcessSHA256 has_any (FileHash2)))\n// Increase risk score if recent alerts for the host\n| join kind=leftouter (SecurityAlert\n| where ProviderName =~ \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| mv-expand todynamic(Entities)\n| extend DvcId = tostring(parse_json(Entities).MdatpDeviceId)\n| where isnotempty(DvcId)\n// Higher risk score are for Defender alerts related to threat actor\n| extend AlertRiskScore = iif(ThreatName has_any (\"Backdoor:MSIL/ShellClient.A\", \"Backdoor:MSIL/ShellClient.A!dll\", \"Trojan:MSIL/Mimikatz.BA!MTB\"), 1.0, 0.5)\n| project DvcId, AlertRiskScore) on DvcId\n| extend AlertRiskScore = iif(isempty(AlertRiskScore), 0.0, AlertRiskScore)\n| extend timestamp = TimeGenerated, HostCustomEntity = Dvc, AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'This hunting query looks for file paths/hashes related to observed activity by Dev-0228. The actor is known to use custom version of popular tool like PsExec, Procdump etc. to carry its activity.\n The risk score associated with each result is based on a number of factors, hosts with higher risk events should be investigated first.\n This query uses the Microsoft Sentinel Information Model - https://docs.microsoft.com/azure/sentinel/normalization'\n", "techniques": ["T1569", "T1003"], "tactics": ["CredentialAccess", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/ExcessiveHTTPFailuresFromSource.yaml", "query_name": "Excessive number of failed connections from a single source (ASIM Network Session schema)", "query": "let threshold = 5000;\n_Im_NetworkSession(eventresult='Failure')\n| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)\n| where Count > threshold\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, threshold\n", "attributes": {"description": "'This rule identifies that a single source generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br>\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/IPEntity_imNetworkSession.yaml", "query_name": "(Preview) TI map IP entity to Network Session Events (ASIM Network Session schema)", "query": "let HAS_ANY_MAX = 10000;\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet IP_TI=ThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,\"NO_IP\")\n// Picking up only IOC's that contain the entities we want\n| where TI_ipEntity != \"NO_IP\";\nlet IP_TI_list=toscalar(IP_TI | summarize NIoCs=dcount(TI_ipEntity), IoCs=make_set( TI_ipEntity)\n | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs));\nIP_TI\n  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n  | join kind=innerunique \n  (\n      union \n          (\n          _Im_NetworkSession (starttime=ago(dt_lookBack), dstipaddr_has_any_prefix=IP_TI_list)\n          | where isnotempty(SrcIpAddr)\n          // renaming time column so it is clear the log this came from\n          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=DstIpAddr, IoCIPDirection='Destination'\n          ),\n          (\n          _Im_NetworkSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)\n          | where isnotempty(DstIpAddr)\n          // renaming time column so it is clear the log this came from\n          | extend imNWS_TimeGenerated = TimeGenerated, IoCIP=SrcIpAddr, IoCIPDirection='Source'\n          )\n)on $left.TI_ipEntity == $right.IoCIP\n| where imNWS_TimeGenerated < ExpirationDateTime\n| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, IoCIP, IoCIPDirection\n| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, IoCIPDirection, IoCIP\n", "attributes": {"description": "'This rule identifies a match Network Sessions for which the source of destination IP address is a known IoC. <br><br>\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/PortScan.yaml", "query_name": "Port scan detected  (ASIM Network Session schema)", "query": "let PortScanThreshold = 50;\n_Im_NetworkSession\n| where ipv4_is_private(SrcIpAddr) == False\n| where SrcIpAddr !in (\"127.0.0.1\", \"::1\")\n| summarize AttemptedPortsCount=dcount(DstPortNumber), AttemptedPorts=make_set(DstPortNumber, 100), ReportedBy=make_set(strcat(EventVendor, \"/\", EventProduct), 20) by SrcIpAddr, bin(TimeGenerated, 5m)\n| where AttemptedPortsCount > PortScanThreshold\n", "attributes": {"description": "'This rule identifies a possible port scan, in which a single source tries to access a large number of different ports is a short time frame. This may indicate that a [port scanner](https://en.wikipedia.org/wiki/Port_scanner) is trying to identify open ports in order to penetrate a system.<br><br>\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'\n", "techniques": ["T1046"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimNetworkSession/PossibleBeaconingActivity.yaml", "query_name": "Potential beaconing activity (ASIM Network Session schema)", "query": "let querystarttime = 2d;\nlet queryendtime = 1d;\nlet TimeDeltaThreshold = 10;\nlet TotalEventsThreshold = 15;\nlet PercentBeaconThreshold = 80;\n_Im_NetworkSession(starttime=querystarttime, endtime=queryendtime)\n| where not(ipv4_is_private(DstIpAddr))\n| project TimeGenerated,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes\n| sort by SrcIpAddr asc,TimeGenerated asc, DstIpAddr asc, DstPortNumber asc\n| serialize\n| extend nextTimeGenerated = next(TimeGenerated, 1), nextSrcIpAddr = next(SrcIpAddr, 1)\n| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated)\n| where SrcIpAddr == nextSrcIpAddr\n//Whitelisting criteria/ threshold criteria\n| where TimeDeltainSeconds > TimeDeltaThreshold \n| project TimeGenerated, TimeDeltainSeconds,   SrcIpAddr, SrcPortNumber, DstIpAddr, DstPortNumber, DstBytes, SrcBytes\n| summarize count(), sum(DstBytes), sum(SrcBytes), make_list(TimeDeltainSeconds) \nby TimeDeltainSeconds, bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber\n| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds) = arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSrcBytes = sum(sum_SrcBytes), TotalDstBytes = sum(sum_DstBytes) \nby bin(TimeGenerated, 1h),   SrcIpAddr, DstIpAddr, DstPortNumber\n| where TotalEvents > TotalEventsThreshold \n| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100\n| where BeaconPercent > PercentBeaconThreshold\n", "attributes": {"description": "This rule identifies beaconing patterns from Network traffic logs based on recurrent frequency patterns. Such potential outbound beaconing pattern to untrusted public networks should be investigated for any malware callbacks or data exfiltration attempts as discussed in this [Blog](http://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/).\\<br><br>\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema'\n", "techniques": ["T1071", "T1571"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimProcess/imProcess_AdFind_Usage.yaml", "query_name": "Probable AdFind Recon Tool Usage (Normalized Process Events)", "query": "let args = dynamic([\"objectcategory\",\"domainlist\",\"dcmodes\",\"adinfo\",\"trustdmp\",\"computers_pwdnotreqd\",\"Domain Admins\", \"objectcategory=person\", \"objectcategory=computer\", \"objectcategory=*\",\"dclist\"]);\nlet parentProcesses = dynamic([\"pwsh.exe\",\"powershell.exe\",\"cmd.exe\"]);\nimProcessCreate\n//looks for execution from a shell\n| where ActingProcessName has_any (parentProcesses)\n| extend ActingProcessFileName = tostring(split(ActingProcessName, '\\\\')[-1])\n| where ActingProcessFileName in~ (parentProcesses)\n// main filter\n| where Process hassuffix \"AdFind.exe\" or TargetProcessSHA256 == \"c92c158d7c37fea795114fa6491fe5f145ad2f8c08776b18ae79db811e8e36a3\"\n    // AdFind common Flags to check for from various threat actor TTPs\n    or CommandLine has_any (args)\n| extend AccountCustomEntity = User, HostCustomEntity = Dvc, ProcessCustomEntity = ActingProcessName, CommandLineCustomEntity = CommandLine, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = TargetProcessSHA256\n", "attributes": {"description": "'Identifies the host and account that executed AdFind by hash and filename in addition to common and unique flags that are used by many threat actors in discovery.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)'\n", "techniques": ["T1018"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimProcess/imProcess_base64_encoded_pefile.yaml", "query_name": "Base64 encoded Windows process command-lines (Normalized Process Events)", "query": "imProcessCreate\n  | where CommandLine contains \"TVqQAAMAAAAEAAA\"\n  | where isnotempty(Process)\n  | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Dvc, ActorUsername, Process, CommandLine, ActingProcessName, EventVendor, EventProduct\n  | extend timestamp = StartTimeUtc, AccountCustomEntity = ActorUsername, HostCustomEntity = Dvc\n", "attributes": {"description": "'Identifies instances of a base64 encoded PE file header seen in the process command line parameter.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)'\n", "techniques": ["T1059", "T1027", "T1140"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimProcess/imProcess_malware_in_recyclebin.yaml", "query_name": "Malware in the recycle bin (Normalized Process Events)", "query": "let procList = dynamic([\"cmd.exe\",\"ftp.exe\",\"schtasks.exe\",\"powershell.exe\",\"rundll32.exe\",\"regsvr32.exe\",\"msiexec.exe\"]);  \nimProcessCreate\n| where CommandLine has \"recycler\"\n| where Process has_any (procList)\n| extend FileName = tostring(split(Process, '\\\\')[-1])\n| where FileName in~ (procList)\n| project StartTimeUtc = TimeGenerated, Dvc, User, Process, FileName, CommandLine, ActingProcessName, EventVendor, EventProduct\n| extend timestamp = StartTimeUtc, AccountCustomEntity = User, HostCustomEntity = Dvc\n", "attributes": {"description": "'Identifies malware that has been hidden in the recycle bin.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)'\n", "techniques": ["T1564"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimProcess/imProcess_NOBELIUM_SuspiciousRundll32Exec.yaml", "query_name": "NOBELIUM - suspicious rundll32.exe execution of vbscript (Normalized Process Events)", "query": "imProcessCreate\n| where Process hassuffix 'rundll32.exe'\n| where CommandLine  has_any ('Execute','RegRead','window.close')\n| project TimeGenerated, Dvc, User, Process, CommandLine, ActingProcessName, EventVendor, EventProduct\n| extend timestamp = TimeGenerated, HostCustomEntity = Dvc, AccountCustomEntity = User\n", "attributes": {"description": "'This query idenifies when rundll32.exe executes a specific set of inline VBScript commands\nReferences: https://www.microsoft.com/security/blog/2021/03/04/goldmax-goldfinder-sibot-analyzing-nobelium-malware/\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)'\n", "techniques": ["T1547"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimProcess/imProcess_SolarWinds_SUNBURST_Process-IOCs.yaml", "query_name": "SUNBURST suspicious SolarWinds child processes (Normalized Process Events)", "query": "let excludeProcs = dynamic([@\"\\SolarWinds\\Orion\\APM\\APMServiceControl.exe\", @\"\\SolarWinds\\Orion\\ExportToPDFCmd.Exe\", @\"\\SolarWinds.Credentials\\SolarWinds.Credentials.Orion.WebApi.exe\", @\"\\SolarWinds\\Orion\\Topology\\SolarWinds.Orion.Topology.Calculator.exe\", @\"\\SolarWinds\\Orion\\Database-Maint.exe\", @\"\\SolarWinds.Orion.ApiPoller.Service\\SolarWinds.Orion.ApiPoller.Service.exe\", @\"\\Windows\\SysWOW64\\WerFault.exe\"]);\nimProcessCreate\n| where Process hassuffix 'solarwinds.businesslayerhost.exe'\n| where not(Process has_any (excludeProcs))\n| extend\n    timestamp = TimeGenerated,\n    AccountCustomEntity = ActorUsername,\n    HostCustomEntity = User,\n    AlgorithmCustomEntity = \"MD5\",\n    FileHashCustomEntity = TargetProcessMD5 // Change to *hash* once implemented\n", "attributes": {"description": "Identifies suspicious child processes of SolarWinds.Orion.Core.BusinessLayer.dll that may be evidence of the SUNBURST backdoor\nReferences:\n- https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n- https://gist.github.com/olafhartong/71ffdd4cab4b6acd5cbcd1a0691ff82f\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)'\n", "techniques": NaN, "tactics": ["Execution", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimProcess/NewEXEdeployedviaDefaultDomainorDefaultDomainControllerPolicies%28ASIMVersion%29.yaml", "query_name": "New EXE deployed via Default Domain or Default Domain Controller Policies (ASIM Version)", "query": "let known_processes = (\n  imProcess\n  // Change these values if adjusting Query Frequency or Query Period\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where Process has_any (\"Policies\\\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\", \"Policies\\\\{31B2F340-016D-11D2-945F-00C04FB984F9}\")\n  | summarize by Process);\n  imProcess\n  // Change these values if adjusting Query Frequency or Query Period\n  | where TimeGenerated > ago(1d)\n  | where Process has_any (\"Policies\\\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\", \"Policies\\\\{31B2F340-016D-11D2-945F-00C04FB984F9}\")\n  | where Process !in (known_processes)\n  | summarize FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated) by Process, CommandLine, DvcHostname\n", "attributes": {"description": "'This detection highlights executables deployed to hosts via either the Default Domain or Default Domain Controller Policies. These policies apply to all hosts or Domain Controllers and best practice is that these policies should not be used for deployment of files.\n  A threat actor may use these policies to deploy files or scripts to all hosts in a domain.\n  This query uses the ASIM parsers and will need them deployed before usage - https://docs.microsoft.com/azure/sentinel/normalization'\n", "techniques": ["T1072", "T1570"], "tactics": ["Execution", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimProcess/Potentialre-namedsdeleteusage%28ASIMVersion%29.yaml", "query_name": "Potential re-named sdelete usage (ASIM Version)", "query": "imProcess\n  | where CommandLine has_all (\"accepteula\", \"-s\", \"-r\", \"-q\")\n  | where Process !endswith \"sdelete.exe\"\n  | where CommandLine !has \"sdelete\"\n", "attributes": {"description": "'This detection looks for command line parameters associated with the use of Sysinternals sdelete (https://docs.microsoft.com/sysinternals/downloads/sdelete) to delete multiple files on a host's C drive.\nA threat actor may re-name the tool to avoid detection and then use it for destructive attacks on a host.\nThis detection uses the ASIM imProcess parser, this will need to be deployed before use - https://docs.microsoft.com/azure/sentinel/normalization'\n", "techniques": ["T1485", "T1036"], "tactics": ["DefenseEvasion", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimProcess/SdeletedeployedviaGPOandrunrecursively%28ASIMVersion%29.yaml", "query_name": "Sdelete deployed via GPO and run recursively (ASIM Version)", "query": "imProcess\n  | where EventType =~ \"ProcessCreated\"\n  | where Process endswith \"svchost.exe\"\n  | where CommandLine has \"-k GPSvcGroup\" or CommandLine has \"-s gpsvc\"\n  | extend timekey = bin(TimeGenerated, 1m)\n  | project timekey, ActingProcessId, Dvc\n  | join kind=inner (imProcess\n  | where EventType =~ \"ProcessCreated\"\n  | where Process =~ \"sdelete.exe\" or CommandLine has \"sdelete\"\n  | where ActingProcessName endswith \"svchost.exe\"\n  | where CommandLine has_all (\"-s\", \"-r\")\n  | extend timekey = bin(TimeGenerated, 1m)\n  ) on $left.ActingProcessId == $right.ParentProcessId, timekey, Dvc\n", "attributes": {"description": "'This query looks for the Sdelete process being run recursively after being deployed to a host via GPO. Attackers could use this technique to deploy Sdelete to multiple host and delete data on them.\n  This query uses the Advanced Security Information Model. Parsers will need to be deployed before use: https://docs.microsoft.com/azure/sentinel/normalization'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimWebSession/DiscordCDNRiskyFileDownload_ASim.yaml", "query_name": "Discord CDN Risky File Download  (ASIM Web Session Schema)", "query": "let discord=dynamic([\"cdn.discordapp.com\", \"media.discordapp.com\"]);\n  _Im_WebSession(url_has_any=discord, eventresult='Success')\n  | where Url has \"attachments\"\n  | extend DiscordServerId = extract(@\"\\/attachments\\/([0-9]+)\\/\", 1, Url)\n  | summarize dcount(Url), make_set(SrcUsername), make_set(SrcIpAddr), make_set(Url), min(TimeGenerated), max(TimeGenerated), make_set(EventResult) by DiscordServerId\n  | mv-expand set_SrcUsername to typeof(string), set_Url to typeof(string), set_EventResult to typeof(string), set_SrcIpAddr to typeof(string)\n  | summarize by DiscordServerId, dcount_Url, set_SrcUsername, min_TimeGenerated, max_TimeGenerated, set_EventResult, set_SrcIpAddr, set_Url\n  | project StartTime=min_TimeGenerated, EndTime=max_TimeGenerated, Result=set_EventResult, SourceUser=set_SrcUsername, SourceIP=set_SrcIpAddr, RequestURL=set_Url\n  | where RequestURL has_any (\".bin\",\".exe\",\".dll\",\".bin\",\".msi\")\n", "attributes": {"description": "'Identifies callouts to Discord CDN addresses for risky file extensions. This detection will trigger when a callout for a risky file is made to a discord server that has only been seen once in your environment. Unique discord servers are identified using the server ID that is included in the request URL (DiscordServerId in query). Discord CDN has been used in multiple campaigns to download additional payloads.\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)'\n", "techniques": ["T1071.001"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimWebSession/ExcessiveNetworkFailuresFromSource.yaml", "query_name": "Excessive number of HTTP authentication failures from a source (ASIM Web Session schema)", "query": "let error403_count_threshold=200;\n_Im_WebSession(eventresultdetails_in=dynamic([\"403\"]))\n| extend ParsedUrl=parse_url(Url)\n| extend UrlHost=tostring(ParsedUrl[\"Host\"]), UrlSchema=tostring(ParsedUrl[\"Schema\"])\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), NumberOfErrors = count(), Urls=makeset(Url) by UrlHost, SrcIpAddr\n| where NumberOfErrors > error403_count_threshold\n| sort by NumberOfErrors desc\n| extend Url=tostring(Urls[0])\n", "attributes": {"description": "This rule identifies a source that repeatedly fails to authenticate to a web service (HTTP response code 403). This may indicate a [brute force](https://en.wikipedia.org/wiki/Brute-force_attack) or [credential stuffing](https://en.wikipedia.org/wiki/Credential_stuffing) attack.<br><br>\nThis rule uses the [Advanced Security Information Model (ASIM)](https://aka.ms/AboutSIM) and supports any web session source that complies with ASIM. \n", "techniques": ["T1110", "T1556"], "tactics": ["Persistence", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimWebSession/PossibleDGAContacts.yaml", "query_name": "Potential communication with a Domain Generation Algorithm (DGA) based hostname (ASIM Web Session schema)", "query": "let triThreshold = 500;\nlet querystarttime = 6h;\nlet dgaLengthThreshold = 8;\n// fetch the cisco umbrella top 1M domains\nlet top1M =  (externaldata (Position:int, Domain:string)   [@\"http://s3-us-west-1.amazonaws.com/umbrella-static/top-1m.csv.zip\"]  with (format=\"csv\", zipPattern=\"*.csv\"));\n// extract tri grams that are above our threshold - i.e. are common\nlet triBaseline =   top1M\n  | extend Domain = tolower(extract(\"([^.]*).{0,7}$\", 1, Domain))\n  | extend AllTriGrams = array_concat(extract_all(\"(...)\", Domain), extract_all(\"(...)\", substring(Domain, 1)), extract_all(\"(...)\", substring(Domain, 2)))\n  | mvexpand Trigram=AllTriGrams to typeof(string)\n  | summarize triCount=count() by Trigram\n  | sort by triCount desc\n  | where triCount > triThreshold\n  | distinct Trigram;\n// collect domain information from common security log, filter and extract the DGA candidate and its trigrams\nlet allDataSummarized =  _Im_WebSession  \n| where isnotempty(Url)       \n| extend Name = tolower(tostring(parse_url(Url)[\"Host\"]))\n| summarize NameCount=count() by Name\n| where Name has \".\"\n| where Name !endswith \".home\" and Name !endswith \".lan\"\n// extract DGA candidate\n| extend DGADomain = extract(\"([^.]*).{0,7}$\", 1, Name)\n| where strlen(DGADomain) > dgaLengthThreshold\n// throw out domains with number in them\n| where DGADomain matches regex \"^[A-Za-z]{0,}$\"\n// extract the tri grams from summarized data\n| extend AllTriGrams = array_concat(extract_all(\"(...)\", DGADomain), extract_all(\"(...)\", substring(DGADomain, 1)), extract_all(\"(...)\", substring(DGADomain, 2)));\n// throw out domains that have repeating tri's and/or >=3 repeating letters\nlet nonRepeatingTris =  allDataSummarized\n| join kind=leftanti\n(\n    allDataSummarized\n    | mvexpand AllTriGrams\n    | summarize count() by tostring(AllTriGrams), DGADomain\n    | where count_ > 1\n    | distinct DGADomain\n)\non DGADomain;\n// find domains that do not have a common tri in the baseline\nlet dataWithRareTris =  nonRepeatingTris\n| join kind=leftanti\n(\n    nonRepeatingTris\n    | mvexpand AllTriGrams\n    | extend Trigram = tostring(AllTriGrams)\n    | distinct Trigram, DGADomain\n    | join kind=inner\n    (\n        triBaseline\n    )\n    on Trigram\n    | distinct DGADomain\n)\non DGADomain;\ndataWithRareTris\n// join DGAs back on connection data\n| join kind=inner\n(\n    _Im_WebSession\n    | where isnotempty(Url)\n    | extend Url = tolower(Url)\n    | summarize arg_max(TimeGenerated, EventVendor,  SrcIpAddr) by Url\n    | extend Name=tostring(parse_url(Url)[\"Host\"])\n    | summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Name, SrcIpAddr, Url\n)\non Name\n| project StartTime, EndTime, Name, DGADomain, SrcIpAddr, Url, NameCount\n", "attributes": {"description": "'This rule identifies communication with hosts that have a domain name that might have been generated by a Domain Generation Algorithm (DGA). DGAs are used by malware to generate rendezvous points that are difficult to predict in advance. This detection uses the top 1 million domain names to build a model of what normal domains look like nad uses the model to identify domains that may have been randomly generated by an algorithm. You can modify the triThreshold and dgaLengthThreshold query parameters to change Analytic Rule sensitivity. The higher the numbers, the less noisy the rule is. <br>\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)'\n", "techniques": ["T1568"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimWebSession/PotentiallyHarmfulFileTypes.yaml", "query_name": "A client made a web request to a potentially harmful file (ASIM Web Session schema)", "query": "let default_file_ext_blocklist = dynamic(['.ps1', '.vbs', '.bat', '.scr']);\nlet custom_file_ext_blocklist=toscalar(_GetWatchlist('RiskyFileTypes') | extend Extension=column_ifexists(\"Extension\",\"\") | where isnotempty(Extension) | summarize make_set(Extension));\nlet file_ext_blocklist = array_concat(default_file_ext_blocklist, custom_file_ext_blocklist);\n_Im_WebSession(url_has_any=file_ext_blocklist, eventresult='Success')\n| extend requestedFileName=tostring(split(tostring(parse_url(Url)[\"Path\"]),'/')[-1])\n| extend requestedFileExt=extract(@(\\.\\w+)$,1,requestedFileName, typeof(string))\n| where requestedFileExtension in (file_ext_blocklist)\n| summarize LastAttemptTime=max(TimeGenerated), NumFailedAttempts=count() by SrcIpAddr, requestedFileName, Url\n| extend IPCustomEntity = SrcIpAddr, UrlCustomEntity=Url\n", "attributes": {"description": "'This rule identifies a web request to a URL that holds a file type, including .ps1, .bat, .vbs, and .scr that can be harmful if downloaded. This rule uses the [Advanced Security Information Model (ASIM)](https://aka.ms/AboutASIM) and supports any web session source that complies with ASIM. To use this Analytics Rule, deploy the Advanced Security Information Model (ASIM).\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimWebSession/UnusualUACryptoMiners.yaml", "query_name": "A host is potentially running a crypto miner (ASIM Web Session schema)", "query": "let threatCategory=\"Cryptominer\";\nlet knownUserAgentsIndicators = materialize(externaldata(UserAgent:string, Category:string)\n    [ @\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/UnusualUserAgents.csv\"] \n        with(format=\"csv\", ignoreFirstRecord=True));\nlet knownUserAgents=toscalar(knownUserAgentsIndicators | where Category==threatCategory | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet customUserAgents=toscalar(_GetWatchlist(\"UnusualUserAgents\") | where SearchKey==threatCategory | extend UserAgent=column_ifexists(\"UserAgent\",\"\") | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet fullUAList = array_concat(knownUserAgents,customUserAgents);\n_Im_WebSession(httpuseragent_has_any=fullUAList)\n| summarize N_Events=count() by  SrcIpAddr, Url, TimeGenerated,HttpUserAgent, SrcUsername\n", "attributes": {"description": "'This rule identifies a web request with a user agent header known to belong to a crypto miner. This indicates a crypto miner may have infected the client machine.<br>You can add custom crypto mining indicating User-Agent headers using a watchlist, for more information refer to the [UnusualUserAgents Watchlist](https://aka.ms/ASimUnusualUserAgentsWatchlist).<br><br>   This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)'\n", "techniques": NaN, "tactics": ["CommandandControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimWebSession/UnusualUAHackTool.yaml", "query_name": "A host is potentially running a hacking tool (ASIM Web Session schema)", "query": "let threatCategory=\"Hacking Tool\";\nlet knownUserAgentsIndicators = materialize(externaldata(UserAgent:string, Category:string)\n    [ @\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/UnusualUserAgents.csv\"] \n        with(format=\"csv\", ignoreFirstRecord=True));\nlet knownUserAgents=toscalar(knownUserAgentsIndicators | where Category==threatCategory | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet customUserAgents=toscalar(_GetWatchlist(\"UnusualUserAgents\") | where SearchKey==threatCategory | extend UserAgent=column_ifexists(\"UserAgent\",\"\") | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet fullUAList = array_concat(knownUserAgents,customUserAgents);\n_Im_WebSession(httpuseragent_has_any=fullUAList)\n| project SrcIpAddr, Url, TimeGenerated,HttpUserAgent, SrcUsername\n", "attributes": {"description": "'This rule identifies a web request with a user agent header known to belong to a hacking tool. This indicates a hacking tool is used on the host.<br>You can add custom hacking tool indicating User-Agent headers using a watchlist, for more information refer to the [UnusualUserAgents Watchlist](https://aka.ms/ASimUnusualUserAgentsWatchlist).<br><br>\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)'\n", "techniques": NaN, "tactics": ["CommandandControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ASimWebSession/UnusualUAPowershell.yaml", "query_name": "A host is potentially running PowerShell to send HTTP(S) requests (ASIM Web Session schema)", "query": "let threatCategory=\"Powershell\";\nlet knownUserAgentsIndicators = materialize(externaldata(UserAgent:string, Category:string)\n    [ @\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/UnusualUserAgents.csv\"]\n        with(format=\"csv\", ignoreFirstRecord=True));\nlet knownUserAgents=toscalar(knownUserAgentsIndicators | where Category==threatCategory | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet customUserAgents=toscalar(_GetWatchlist(\"UnusualUserAgents\") | where SearchKey==threatCategory | extend UserAgent=column_ifexists(\"UserAgent\",\"\") | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet fullUAList = array_concat(knownUserAgents,customUserAgents);\n_Im_WebSession(httpuseragent_has_any=fullUAList)\n| project SrcIpAddr, Url, TimeGenerated,HttpUserAgent, SrcUsername\n", "attributes": {"description": "'This rule identifies a web request with a user agent header known to belong PowerShell. <br>You can add custom Powershell indicating User-Agent headers using a watchlist, for more information refer to the [UnusualUserAgents Watchlist](https://aka.ms/ASimUnusualUserAgentsWatchlist).<br><br>\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)'\n", "techniques": NaN, "tactics": ["CommandandControl", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/AccountElevatedtoNewRole.yaml", "query_name": "Account Elevated to New Role", "query": "AuditLogs\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where OperationName =~ \"Add member to role completed (PIM activation)\"\n  | where Result =~ \"success\"\n  | extend ElevatedUser = tostring(TargetResources[2].userPrincipalName)\n  | extend displayName = tostring(TargetResources[0].displayName)\n  | extend displayName2 = tostring(TargetResources[3].displayName)\n  | extend ElevatedRole = iif(displayName =~ \"Member\", displayName2, displayName)\n  | join kind = rightanti (AuditLogs\n  | where TimeGenerated > ago(1d)\n  | where OperationName =~ \"Add member to role completed (PIM activation)\"\n  | where Result =~ \"success\"\n  | extend ElevatedUser = tostring(TargetResources[2].userPrincipalName)\n  | extend displayName = tostring(TargetResources[0].displayName)\n  | extend displayName2 = tostring(TargetResources[3].displayName)\n  | extend ElevatedRole = iif(displayName =~ \"Member\", displayName2, displayName)\n  | extend ElevatedBy = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) on ElevatedRole, ElevatedUser\n  | project-reorder ElevatedUser, ElevatedRole, ResultReason,ElevatedBy\n", "attributes": {"description": "'Detects an account that is elevated to a new role where that account has not had that role in the last 14 days.\n  Role elevations are a key mechanism for gaining permissions, monitoring which users have which roles, and for anomalies in those roles is useful for finding suspicious activity.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#changes-to-privileged-accounts'\n", "techniques": ["T1078.004"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/AdditionofaTemporaryAccessPasstoaPrivilegedAccount.yaml", "query_name": "Addition of a Temporary Access Pass to a Privileged Account", "query": "let admin_users = (IdentityInfo\n  | summarize arg_max(TimeGenerated, *) by AccountUPN\n  | where AssignedRoles contains \"admin\"\n  | summarize by tolower(AccountUPN));\n  AuditLogs\n  | where OperationName =~ \"Admin registered security info\"\n  | where ResultReason =~ \"Admin registered temporary access pass method for user\"\n  | extend userPrincipalName = tostring(TargetResources[0].userPrincipalName)\n  | where tolower(userPrincipalName) in (admin_users)\n", "attributes": {"description": "'Detects when a Temporary Access Pass (TAP) is created for a Privileged Account.\n  A Temporary Access Pass is a time-limited passcode issued by an admin that satisfies strong authentication requirements and can be used to onboard other authentication methods, including Passwordless ones such as Microsoft Authenticator or even Windows Hello.\n  A threat actor could use a TAP to register a new authentication method to maintain persistance to an account.\n  Review any TAP creations to ensure they were used legitimately.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#changes-to-privileged-accounts'\n", "techniques": ["T1078.004"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/ApplicationIDURIChanged.yaml", "query_name": "Application ID URI Changed", "query": "AuditLogs\n  | where Category == \"ApplicationManagement\"\n  | where OperationName has_any (\"Update Application\", \"Update Service principal\")\n  | extend appName = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n  | extend UPN = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend UpdatedBy = iif(isnotempty(appName), appName, UPN)\n  | extend mod_props = TargetResources[0].modifiedProperties\n  | extend AppName = tostring(TargetResources[0].displayName)\n  | mv-expand mod_props\n  | where mod_props.displayName has \"AppIdentifierUri\"\n  | extend OldURI = tostring(mod_props.oldValue)\n  | extend NewURI = tostring(mod_props.newValue)\n  | project-reorder TimeGenerated, OperationName, AppName, OldURI, NewURI, UpdatedBy\n", "attributes": {"description": "'Detects changes to an Application ID URI.\n  Monitor these changes to make sure that they were authorized.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-applications#appid-uri-added-modified-or-removed'\n", "techniques": ["T1078.004"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/ApplicationRedirectURLUpdate.yaml", "query_name": "Application Redirect URL Update", "query": "AuditLogs\n  | where Category =~ \"ApplicationManagement\"\n  | where Result =~ \"success\"\n  | where OperationName =~ 'Update Application'\n  | mv-expand TargetResources\n  | mv-expand TargetResources.modifiedProperties\n  | where TargetResources_modifiedProperties.displayName =~ \"AppAddress\"\n  | extend Key = tostring(TargetResources_modifiedProperties.displayName)\n  | extend NewValue = TargetResources_modifiedProperties.newValue\n  | extend OldValue = TargetResources_modifiedProperties.oldValue\n  | where isnotempty(Key) and isnotempty(NewValue)\n  | project-reorder Key, NewValue, OldValue\n  | extend NewUrls = extract_all('\"Address\":([^,]*)', tostring(NewValue))\n  | extend OldUrls = extract_all('\"Address\":([^,]*)', tostring(OldValue))\n  | extend AddedUrls = set_difference(NewUrls, OldUrls)\n  | where array_length(AddedUrls) > 0\n  | extend UserAgent = iif(tostring(AdditionalDetails[0].key) == \"User-Agent\", tostring(AdditionalDetails[0].value), \"\")\n  | extend AddingUser = iif(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) , tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), \"\")\n  | extend AddingApp = iif(isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalName)) , tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalName), \"\")\n  | extend AddedBy = iif(isnotempty(AddingUser), AddingUser, AddingApp)\n  | project-away AddingApp, AddingUser\n  | extend AppDisplayName = tostring(TargetResources.displayName)\n  | extend ipAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n  | project-reorder TimeGenerated, AppDisplayName, AddedUrls, AddedBy, UserAgent, ipAddress\n", "attributes": {"description": "'Detects the redirect URL of an app being changed.\n  Applications associated with URLs not controlled by the organization can pose a security risk.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-applications#application-configuration-changes'\n", "techniques": ["T1078.004"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/AuthenticationMethodChangedforPrivilegedAccount.yaml", "query_name": "Authentication Method Changed for Privileged Account", "query": "let VIPUsers = (IdentityInfo\n| where AssignedRoles contains \"Admin\"\n| summarize by tolower(AccountUPN));\nAuditLogs\n| where Category =~ \"UserManagement\"\n| where ActivityDisplayName =~ \"User registered security info\"\n| where LoggedByService =~ \"Authentication Methods\"\n| extend AccountCustomEntity = tostring(TargetResources[0].userPrincipalName), IPCustomEntity = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| where AccountCustomEntity in (VIPUsers)\n", "attributes": {"description": "'Identifies authentication methods being changed for a privileged account. This could be an indicated of an attacker adding an auth method to the account so they can have continued access.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/ChangestoApplicationLogoutURL.yaml", "query_name": "Changes to Application Logout URL", "query": "AuditLogs\n  | where Category =~ \"ApplicationManagement\"\n  | where OperationName has_any (\"Update Application\", \"Update Service principal\")\n  | extend appName = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n  | extend UPN = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend UpdatedBy = iif(isnotempty(appName), appName, UPN)\n  | extend mod_props = TargetResources[0].modifiedProperties\n  | extend AppName = tostring(TargetResources[0].displayName)\n  | mv-expand mod_props\n  | extend Action = tostring(mod_props.displayName)\n  | where Action contains \"Url\"\n  | extend OldURL = tostring(mod_props.oldValue)\n  | extend NewURL = tostring(mod_props.newValue)\n  | project-reorder TimeGenerated, OperationName, Action, AppName, OldURL, NewURL, UpdatedBy\n", "attributes": {"description": "'Detects changes to an applications sign out URL.\n  Look for any modifications to a sign out URL. Blank entries or entries to non-existent locations would stop a user from terminating a session.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-applications#logout-url-modified-or-removed'\n", "techniques": ["T1078.004"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/ChangestoApplicationOwnership.yaml", "query_name": "Changes to Application Ownership", "query": "AuditLogs\n  | where Category =~ \"ApplicationManagement\"\n  | where OperationName =~ \"Add owner to application\"\n  | extend appName = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n  | extend UPN = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend UpdatedBy = iif(isnotempty(appName), appName, UPN)\n  | extend mod_props = TargetResources[0].modifiedProperties\n  | extend AddedUser = TargetResources[0].userPrincipalName\n  | mv-expand mod_props\n  | where mod_props.displayName =~ \"Application.DisplayName\"\n  | extend AppName = tostring(parse_json(tostring(mod_props.newValue)))\n  | project-reorder TimeGenerated, OperationName, AppName, AddedUser, UpdatedBy\n", "attributes": {"description": "'Detects changes to the ownership of an appplicaiton.\n  Monitor these changes to make sure that they were authorized.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-applications#new-owner'\n", "techniques": ["T1078.004"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/ChangestoPIMSettings.yaml", "query_name": "Changes to PIM Settings", "query": "AuditLogs\n  | where Category =~ \"RoleManagement\"\n  | where OperationName =~ \"Update role setting in PIM\"\n  | extend userPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend ipAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n  | project-reorder TimeGenerated, OperationName, ResultReason, userPrincipalName, ipAddress\n", "attributes": {"description": "'PIM provides a key mechanism for assigning privileges to accounts, this query detects changes to PIM role settings.\n  Monitor these changes to ensure they are being made legitimately and don't confer more privileges than expected or reduce the security of a PIM elevation.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#changes-to-privileged-accounts'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/ConditionalAccessPolicyModifiedbyNewUser.yaml", "query_name": "Conditional Access Policy Modified by New User", "query": "let known_users = (AuditLogs\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where OperationName has \"conditional access policy\"\n  | where Result =~ \"success\"\n  | extend userPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | summarize by userPrincipalName);\n  AuditLogs\n  | where TimeGenerated > ago(1d)\n  | where OperationName has \"conditional access policy\"\n  | where Result =~ \"success\"\n  | extend userPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend CAPolicyName = tostring(TargetResources[0].displayName)\n  | extend ipAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n  | where userPrincipalName !in (known_users)\n  | extend NewPolicyValues = TargetResources[0].modifiedProperties[0].newValue\n  | extend OldPolicyValues = TargetResources[0].modifiedProperties[0].oldValue\n  | project-reorder TimeGenerated, OperationName, CAPolicyName, userPrincipalName, ipAddress, NewPolicyValues, OldPolicyValues\n", "attributes": {"description": "'Detects a Conditional Access Policy being modified by a user who has not modified a policy in the last 14 days.\n  A threat actor may try to modify policies to weaken the security controls in place.\n  Investigate any change to ensure they are approved.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-infrastructure#conditional-access'\n", "techniques": ["T1078.004"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/End-userconsentstoppedduetorisk-basedconsent.yaml", "query_name": "End-user consent stopped due to risk-based consent", "query": "AuditLogs\n  | where OperationName has \"Consent to application\"\n  | where Result =~ \"failure\"\n  | extend ipAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n  | extend userPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend userAgent = iif(AdditionalDetails[0].key == \"User-Agent\", tostring(AdditionalDetails[0].value), tostring(AdditionalDetails[1].value))\n  | where isnotempty(TargetResources)\n  | extend AppName = tostring(TargetResources[0].displayName)\n  | mv-expand TargetResources[0].modifiedProperties\n  | extend TargetResources_0_modifiedProperties = columnifexists(\"TargetResources_0_modifiedProperties\", '')\n  | where isnotempty(TargetResources_0_modifiedProperties)\n  | where TargetResources_0_modifiedProperties.displayName =~ \"MethodExecutionResult.\"\n  | extend FailureReason = tostring(parse_json(tostring(TargetResources_0_modifiedProperties.newValue)))\n  | where FailureReason contains \"Risky\"\n  | project-reorder TimeGenerated, OperationName, Result, AppName, FailureReason, userPrincipalName, userAgent, ipAddress\n", "attributes": {"description": "'Detects a user's consent to an OAuth application being blocked due to it being too risky.\n  These events should be investigated to understand why the user attempted to consent to the applicaiton and what other applicaitons they may have consented to.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-applications#end-user-stopped-due-to-risk-based-consent'\n", "techniques": ["T1078.004"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/GuestUsersInvitedtoTenantbyNewInviters.yaml", "query_name": "Guest Users Invited to Tenant by New Inviters", "query": "let inviting_users = (AuditLogs\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where OperationName =~ \"Invite external user\"\n  | where Result =~ \"success\"\n  | extend invitingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | where isnotempty(invitingUser)\n  | summarize by invitingUser);\n  AuditLogs\n  | where TimeGenerated > ago(1d)\n  | where OperationName =~ \"Invite external user\"\n  | where Result =~ \"success\"\n  | extend invitingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | where isnotempty(invitingUser) and invitingUser !in (inviting_users)\n  | extend invitedUserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n  | extend ipAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n", "attributes": {"description": "'Detects when a Guest User is added by a user account that has not been seen adding a guest in the previous 14 days.\n  Monitoring guest accounts and the access they are provided is important to detect potential account abuse.\n  Accounts added should be investigated to ensure the activity was legitimate.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/NewExtUserGrantedAdmin.yaml", "query_name": "New External User Granted Admin", "query": "// Administrative roles to look for, default is all admin roles\nlet roles = dynamic([\"Administrator\", \"Admin\"]);\n// The maximum distances between and invite and acceptance\nlet maxTimeBetweenInviteAccept = 30min;\n// The delta (minutes) between the invite being sent and the account being escalated\nlet deltaBetweenInviteEscalation = 60;\n// Collect external user invitations\nlet invite = AuditLogs\n| where Category =~ \"UserManagement\"\n| where OperationName =~ \"Invite external user\"\n| extend Target = tostring(TargetResources[0].[\"userPrincipalName\"])\n| extend InviteInitiator = tostring(InitiatedBy.[\"user\"].[\"userPrincipalName\"])\n| where isnotempty(InviteInitiator);\n// Collect redeem events\nlet redeem = AuditLogs\n| where Category =~ \"UserManagement\"\n| where OperationName =~ \"Redeem external user invite\"\n| where Result =~ \"success\"\n| extend Target = tostring(TargetResources[0].[\"displayName\"]) | extend Target = tostring(extract(@\"UPN\\:\\s(.+)\\,\\sEmail\",1,Target))\n| where isnotempty(Target);\n// Union the inivtation and redeem data then run the sequence_detect kusto plugin\ninvite\n| union redeem\n| order by TimeGenerated\n| project TimeGenerated, Target, InviteInitiator, OperationName, TenantId\n| evaluate sequence_detect(TimeGenerated, maxTimeBetweenInviteAccept, maxTimeBetweenInviteAccept, invite=(OperationName has \"Invite external user\"), redeem=(OperationName has \"Redeem external user invite\"), Target)\n| join (\nAuditLogs\n| where Category =~ \"RoleManagement\"\n| where AADOperationType in (\"Assign\", \"AssignEligibleRole\")\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-expand TargetResources\n// Limit to external accounts\n| where TargetResources.userPrincipalName has \"EXT\"\n| mv-expand TargetResources.modifiedProperties\n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n| where displayName_ =~ \"Role.DisplayName\"\n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n// Perform check for admin roles\n| where RoleName has_any(roles)\n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n| where Initiator != \"MS-PIM\"\n| extend Target = tostring(TargetResources.userPrincipalName)\n| summarize by TimeGenerated, OperationName,  RoleName, Target, Initiator, Result\n) on Target\n// Calculate delta between the invite and the account escalation\n| extend delta = datetime_diff(\"minute\", TimeGenerated, invite_TimeGenerated)\n| where delta <= deltaBetweenInviteEscalation\n| project InvitationTime=invite_TimeGenerated, RedeemTime=redeem_TimeGenerated, GrantTime=TimeGenerated, ExternalUser=Target, RoleGranted=RoleName, AdminInitiator=Initiator, MinsBetweenInviteAndEscalation=delta\n", "attributes": {"description": "'This query will detect instances where a newly invited external user is granted an administrative role. By default this query\nwill alert on any granted administrative role, however this can be modified using the roles variable if false positives occur\nin your environment. The maximum delta between invite and escalation to admin is 60 minues, this can be configured using the \ndeltaBetweenInviteEscalation variable.'\n", "techniques": ["T1098.001"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/nrt_FirstAppOrServicePrincipalCredential.yaml", "query_name": "NRT First access credential added to Application or Service Principal where no credential was present", "query": "AuditLogs\n| where OperationName has_any (\"Add service principal\", \"Certificates and secrets management\") // captures \"Add service principal\", \"Add service principal credentials\", and \"Update application - Certificates and secrets management\" events\n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| extend targetDisplayName = tostring(TargetResources[0].displayName)\n| extend targetId = tostring(TargetResources[0].id)\n| extend targetType = tostring(TargetResources[0].type)\n| extend keyEvents = TargetResources[0].modifiedProperties\n| mv-expand keyEvents\n| where keyEvents.displayName =~ \"KeyDescription\"\n| extend new_value_set = parse_json(tostring(keyEvents.newValue))\n| extend old_value_set = parse_json(tostring(keyEvents.oldValue))\n| where old_value_set == \"[]\"\n| mv-expand new_value_set\n| parse new_value_set with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| where keyUsage == \"Verify\"  or keyUsage == \"\"\n| extend UserAgent = iff(AdditionalDetails[0].key == \"User-Agent\",tostring(AdditionalDetails[0].value),\"\")\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n// The below line is currently commented out but Microsoft Sentinel users can modify this query to show only Application or only Service Principal events in their environment\n//| where targetType =~ \"Application\" // or targetType =~ \"ServicePrincipal\"\n| project-away new_value_set, old_value_set\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUserOrApp, IPCustomEntity = InitiatingIpAddress\n", "attributes": {"description": "'This will alert when an admin or app owner account adds a new credential to an Application or Service Principal where there was no previous verify KeyCredential associated.\nIf a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": ["T1550.001"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/PrivilegedAccountPermissionsChanged.yaml", "query_name": "Privileged Account Permissions Changed", "query": "let admin_users = (IdentityInfo\n  | where TimeGenerated > ago(2d)\n  | summarize arg_max(TimeGenerated, *) by AccountUPN\n  | where AssignedRoles contains \"admin\"\n  | summarize by tolower(AccountUPN));\n  AuditLogs\n  | where Category =~ \"RoleManagement\"\n  | where OperationName has \"Add eligible member\"\n  | extend userPrincipalName = tostring(TargetResources[0].userPrincipalName)\n  | where tolower(userPrincipalName) in (admin_users)\n  | extend Group = tostring(TargetResources[0].displayName)\n  | extend AddedTo = iif(isnotempty(userPrincipalName), userPrincipalName, Group)\n  | extend mod_props = TargetResources[0].modifiedProperties\n  | extend appName = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n  | extend UPN = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend AddedBy = iif(isnotempty(appName), appName, UPN)\n  | mv-expand mod_props\n  | where mod_props.displayName == \"Role.DisplayName\"\n  | extend RoleAdded = tostring(parse_json(tostring(mod_props.newValue)))\n  | project-reorder TimeGenerated, OperationName, AddedTo, RoleAdded, AddedBy\n", "attributes": {"description": "'Detects changes to permissions assigned to admin users. Threat actors may try and increase permission scope by adding additional roles to already privileged accounts.\nReview any modifications to ensure they were made legitimately.\nRef: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#changes-to-privileged-accounts'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/ServicePrincipalAssignedAppRoleWithSensitiveAccess.yaml", "query_name": "Service Principal Assigned App Role With Sensitive Access", "query": "// Add other permissions to this list as needed\n  let permissions = dynamic([\"Mail.Read\", \"offline_access\", \"Files.Read\", \"Notes.Read\", \"ChannelMessage.Read\", \"Chat.Read\", \"TeamsActivity.Read\",\n  \"Group.Read\", \"EWS.AccessAsUser.All\", \"EAS.AccessAsUser.All\"]);\n  AuditLogs\n  | where OperationName =~ \"Add app role assignment to service principal\"\n  | mv-expand TargetResources[0].modifiedProperties\n  | extend TargetResources_0_modifiedProperties = columnifexists(\"TargetResources_0_modifiedProperties\", '')\n  | where isnotempty(TargetResources_0_modifiedProperties)\n  | where TargetResources_0_modifiedProperties.displayName =~ \"AppRole.Value\" or TargetResources_0_modifiedProperties.displayName =~ \"DelegatedPermissionGrant.Scope\"\n  | extend Permissions = split((parse_json(tostring(TargetResources_0_modifiedProperties.newValue))), \" \")\n  | where Permissions has_any (permissions)\n  | summarize AddedPermissions=make_set(Permissions) by CorrelationId\n  | join kind=inner (AuditLogs\n  | where OperationName =~ \"Add app role assignment to service principal\") on CorrelationId\n  | extend InitiatedBy = tostring(iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName))\n  | extend ServicePrincipal = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[4].newValue)))\n  | extend SPID = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[6].newValue)))\n  | extend InitiatedBy = pack(\"User\", InitiatedBy, \"UA\", UserAgent, \"IPAddress\", IpAddress)\n  | mv-expand kind=array AddedPermissions\n  | summarize FirstSeen = min(TimeGenerated), LastSeen = max(TimeGenerated), make_set(InitiatedBy), make_set(AddedPermissions) by SPID, ServicePrincipal\n", "attributes": {"description": "'Detects a Service Principal being assigned an app role that has sensitive access such as Mail.Read.\n  A threat actor who compromises a Service Principal may assign it an app role to allow it to access sensitive data, or to perform other actions.\n  Ensure that any assignment to a Service Principal is valid and appropriate.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-applications#application-granted-highly-privileged-permissions'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/ServicePrincipalAssignedPrivilegedRole.yaml", "query_name": "Service Principal Assigned Privileged Role", "query": "AuditLogs\n  | where OperationName has_all (\"member to role\", \"add\")\n  | where Result =~ \"Success\"\n  | extend type_ = tostring(TargetResources[0].type)\n  | where type_ =~ \"ServicePrincipal\"\n  | where isnotempty(TargetResources)\n  | extend ServicePrincipal = tostring(TargetResources[0].displayName)\n  | extend SPID = tostring(TargetResources[0].id)\n  | mv-expand TargetResources[0].modifiedProperties\n  | extend TargetResources_0_modifiedProperties = columnifexists(\"TargetResources_0_modifiedProperties\", '')\n  | where isnotempty(TargetResources_0_modifiedProperties)\n  | where TargetResources_0_modifiedProperties.displayName =~ \"Role.DisplayName\"\n  | extend TargetRole = parse_json(tostring(TargetResources_0_modifiedProperties.newValue))\n  | where TargetRole contains \"admin\"\n  | extend AddedByApp = iif(\n  isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalName)),\n  tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalName),\n  tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n  )\n  | extend AddedByUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend AddedBy = iif(isnotempty(AddedByApp), AddedByApp, AddedByUser)\n  | extend IpAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n  | project-reorder TimeGenerated, ServicePrincipal, SPID, TargetRole, AddedBy, IpAddress\n  | project-away AddedByApp, AddedByUser\n", "attributes": {"description": "'Detects a privileged role being added to a Service Principal.\n  Ensure that any assignment to a Service Principal is valid and appropriate - Service Principals should not be assigned to very highly privileged roles such as Global Admin.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#changes-to-privileged-accounts'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/SuspiciousLinkingofExternalIdtoExistingUsers.yaml", "query_name": "Suspicious linking of existing user to external User", "query": "let lookback = 1d;\nAuditLogs \n| where TimeGenerated > ago(lookback)\n| where OperationName=~ \"Update user\" \n| where Result =~ \"success\" \n| mv-expand TargetResources \n| mv-expand TargetResources.modifiedProperties \n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName) , oldValue_ = tostring(TargetResources_modifiedProperties.oldValue), newValue_ = tostring(TargetResources_modifiedProperties.newValue)\n| where displayName_ == \"UserPrincipalName\" and oldValue_ !has \"#EXT\" and newValue_ has \"#EXT\"\n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName) \n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) , IPAddress = tostring(InitiatedBy.[\"user\"].[\"ipAddress\"])\n| project TimeGenerated, AADTenantId, IPAddress, Initiator, displayName_, oldValue_, newValue_\n", "attributes": {"description": "' This query will detect when an attempt is made to update an existing user and link it to an guest or external identity. These activities are unusual and such linking of external \nidentities should be investigated. In some cases you may see internal AAD sync accounts (Sync_) do this which may be benign'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/URLAddedtoApplicationfromUnknownDomain.yaml", "query_name": "URL Added to Application from Unknown Domain", "query": "let domains =\n  SigninLogs\n  | where ResultType == 0\n  | extend domain = split(UserPrincipalName, \"@\")[1]\n  | extend domain = tostring(split(UserPrincipalName, \"@\")[1])\n  | summarize by tolower(tostring(domain));\n  AuditLogs\n  | where Category =~ \"ApplicationManagement\"\n  | where Result =~ \"success\"\n  | where OperationName =~ 'Update Application'\n  | mv-expand TargetResources\n  | mv-expand TargetResources.modifiedProperties\n  | where TargetResources_modifiedProperties.displayName =~ \"AppAddress\"\n  | extend Key = tostring(TargetResources_modifiedProperties.displayName)\n  | extend NewValue = TargetResources_modifiedProperties.newValue\n  | extend OldValue = TargetResources_modifiedProperties.oldValue\n  | where isnotempty(Key) and isnotempty(NewValue)\n  | project-reorder Key, NewValue, OldValue\n  | extend NewUrls = extract_all('\"Address\":([^,]*)', tostring(NewValue))\n  | extend OldUrls = extract_all('\"Address\":([^,]*)', tostring(OldValue))\n  | extend AddedUrls = set_difference(NewUrls, OldUrls)\n  | where array_length(AddedUrls) > 0\n  | extend UserAgent = iif(tostring(AdditionalDetails[0].key) == \"User-Agent\", tostring(AdditionalDetails[0].value), \"\")\n  | extend AddingUser = iif(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) , tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), \"\")\n  | extend AddingApp = iif(isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalName)) , tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalName), \"\")\n  | extend AddedBy = iif(isnotempty(AddingUser), AddingUser, AddingApp)\n  | project-away AddingApp, AddingUser\n  | extend AppDisplayName = tostring(TargetResources.displayName)\n  | extend ipAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n  | where isnotempty(AddedUrls)\n  | mv-expand AddedUrls\n  | extend Domain = extract(\"^(?:https?:\\\\/\\\\/)?(?:[^@\\\\/\\\\n]+@)?(?:www\\\\.)?([^:\\\\/?\\\\n]+)/\", 1, replace_string(tolower(tostring(AddedUrls)), '\"', \"\"))\n  | where isnotempty(Domain)\n  | extend Domain = strcat(split(Domain, \".\")[-2], \".\", split(Domain, \".\")[-1])\n  | where Domain !in (domains)\n  | project-reorder TimeGenerated, AppDisplayName, AddedUrls, AddedBy, UserAgent, ipAddress\n", "attributes": {"description": "'Detects a URL being added to an application where the domain is not one that is associated with the tenant.\n  The query uses domains seen in sign in logs to determine if the domain is associated with the tenant.\n  Applications associated with URLs not controlled by the organization can pose a security risk.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-applications#application-configuration-changes'\n", "techniques": ["T1078.004"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/UserAccountCreatedUsingIncorrectNamingFormat.yaml", "query_name": "User Account Created Using Incorrect Naming Format", "query": "// Add the environments expected username format regex below before deploying\n  let user_regex = \"\";\n  AuditLogs\n  | where OperationName =~ \"Add user\"\n  | where Result =~ \"success\"\n  | extend userAgent = tostring(AdditionalDetails[0].value)\n  | extend addingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend addingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n  | extend AddedBy = iif(isnotempty(addingUser), addingUser, addingApp)\n  | extend ipAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n  | extend AddedUser = tostring(TargetResources[0].userPrincipalName)\n  | where AddedUser matches regex user_regex\n", "attributes": {"description": "'This query looks for accounts being created where the name does not match a defined pattern.\n  Attackers may attempt to add accounts as a means of establishing persistant access to an environment, looking for anomalies in created accounts may help identify illegitimately created accounts.\n  Created accounts should be investigated to ensure they were legitimated created.\n  The user_regex field in the query needs to be populated with the expected pattern for the environment before deployment.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#accounts-not-following-naming-policies'\n", "techniques": ["T1136.003"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/Useraccountcreatedwithoutexpectedattributesdefined.yaml", "query_name": "User account created without expected attributes defined", "query": "let threshold = 10;\n  let default_ad_attributes = dynamic([\"LastDirSyncTime\", \"StsRefreshTokensValidFrom\", \"Included Updated Properties\", \"AccountEnabled\", \"Action Client Name\", \"SourceAnchor\"]);\n  AuditLogs\n  | where OperationName =~ \"Add user\"\n  | where Result =~ \"success\"\n  | extend properties = TargetResources[0].modifiedProperties\n  | mv-expand properties\n  | evaluate bag_unpack(properties)\n  | extend displayName = column_ifexists(\"displayName\", \"Unknown Value\")\n  | summarize count() by displayName, TenantId\n  | where displayName !in (default_ad_attributes)\n  | top threshold by count_ desc\n  | summarize make_set(displayName) by TenantId\n  | join kind=inner (AuditLogs\n  | where Result =~ \"success\"\n  | where OperationName =~ \"Add user\"\n  | extend CreatingUserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend CreatedUserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n  | extend AccountProperties = TargetResources[0].modifiedProperties\n  | mv-expand AccountProperties\n  | extend PropName = tostring(AccountProperties.displayName)) on TenantId\n  | summarize makeset(PropName) by TimeGenerated, CorrelationId, CreatedUserPrincipalName, CreatingUserPrincipalName, tostring(set_displayName)\n  | extend missing_props = set_difference(todynamic(set_displayName), set_PropName)\n  | where array_length(missing_props) > 0\n  | join kind=innerunique (AuditLogs\n  | where Result =~ \"success\"\n  | where OperationName =~ \"Add user\"\n  | extend CreatedUserPrincipalName = tostring(TargetResources[0].userPrincipalName)) on CorrelationId, CreatedUserPrincipalName\n  | extend ExpectedProperties = set_displayName\n  | project-away set_displayName, set_PropName\n", "attributes": {"description": "'This query looks for accounts being created that do not have attributes populated that are commonly populated in the tenant.\n  Attackers may attempt to add accounts as a means of establishing persistant access to an environment, looking for anomalies in created accounts may help identify illegitimately created accounts.\n  Created accounts should be investigated to ensure they were legitimated created.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#accounts-not-following-naming-policies'\n", "techniques": ["T1136.003"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/UserAddedtoAdminRole.yaml", "query_name": "User Added to Admin Role", "query": "AuditLogs\n  | where OperationName in (\"Add eligible member (permanent)\", \"Add eligible member (eligible)\")\n  | extend Role = tostring(TargetResources[0].displayName)\n  | where Role contains \"admin\"\n  | extend AddedBy = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend AddedUser = tostring(TargetResources[2].userPrincipalName)\n  | project-reorder TimeGenerated, AddedUser, Role, AddedBy\n", "attributes": {"description": "'Detects a user being added to a new privileged role. Monitor these additions to ensure the users are made eligible for these roles are intended to have these levels of access.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#changes-to-privileged-accounts'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/UserStatechangedfromGuesttoMember.yaml", "query_name": "User State changed from Guest to Member", "query": "AuditLogs\n  | where OperationName =~ \"Update user\"\n  | where Result =~ \"success\"\n  | mv-expand TargetResources\n  | mv-expand TargetResources.modifiedProperties\n  | where TargetResources_modifiedProperties.displayName =~ \"TargetId.UserType\"\n  | extend UpdatingServicePrincipal = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n  | extend UpdatingUserPrincipal = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend UpdatingUser = iif(isnotempty(UpdatingServicePrincipal), UpdatingServicePrincipal, UpdatingUserPrincipal)\n  | extend UpdatedUserPrincipalName = tostring(TargetResources.userPrincipalName)\n  | project-reorder TimeGenerated, UpdatedUserPrincipalName, UpdatingUser\n  | where parse_json(tostring(TargetResources_modifiedProperties.newValue)) =~ \"\\\"Member\\\"\" and parse_json(tostring(TargetResources_modifiedProperties.oldValue)) =~ \"\\\"Guest\\\"\"\n", "attributes": {"description": "'Detects when a guest account in a tenant is converted to a member of the tenant.\n  Monitoring guest accounts and the access they are provided is important to detect potential account abuse.\n  Accounts converted to members should be investigated to ensure the activity was legitimate.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_ChangeToRDSDatabase.yaml", "query_name": "Changes to internet facing AWS RDS Database instances", "query": "\nlet EventNameList = dynamic([\"AuthorizeDBSecurityGroupIngress\",\"CreateDBSecurityGroup\",\"DeleteDBSecurityGroup\",\"RevokeDBSecurityGroupIngress\"]);\nAWSCloudTrail\n| where EventName in~ (EventNameList)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, UserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress\n", "attributes": {"description": "'Amazon Relational Database Service (RDS) is scalable relational database in the cloud. \nIf your organization have one or more AWS RDS Databases running, monitoring changes to especially internet facing AWS RDS (Relational Database Service) \nOnce alerts triggered, validate if changes observed are authorized and adhere to change control policy. \nMore information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255\nand RDS API Reference Docs: https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Operations.html'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_ChangeToVPC.yaml", "query_name": "Changes to Amazon VPC settings", "query": "\nlet EventNameList = dynamic([\"CreateNetworkAclEntry\",\"CreateRoute\",\"CreateRouteTable\",\"CreateInternetGateway\",\"CreateNatGateway\"]);\nAWSCloudTrail\n| where EventName in~ (EventNameList)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, \nUserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress\n", "attributes": {"description": "'Amazon Virtual Private Cloud (Amazon VPC) lets you provision a logically isolated section of the AWS Cloud where you can launch AWS resources\nin a virtual network that you define.\nThis identifies changes to Amazon VPC (Virtual Private Cloud) settings such as new ACL entries,routes, routetable or Gateways.\nMore information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255 \nand AWS VPC API Docs: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/OperationList-query-vpc.html'\n", "techniques": ["T1078", "T1563"], "tactics": ["PrivilegeEscalation", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_ClearStopChangeTrailLogs.yaml", "query_name": "Changes made to AWS CloudTrail logs", "query": "\nlet EventNameList = dynamic([\"UpdateTrail\",\"DeleteTrail\",\"StopLogging\",\"DeleteFlowLogs\",\"DeleteEventBus\"]);\nAWSCloudTrail\n| where EventName in~ (EventNameList)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, \nUserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress\n", "attributes": {"description": "'Attackers often try to hide their steps by deleting or stopping the collection of logs that could show their activity. \nThis alert identifies any manipulation of AWS CloudTrail, Cloudwatch/EventBridge or VPC Flow logs.\nMore Information: AWS CloudTrail API: https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_Operations.html\nAWS Cloudwatch/Eventbridge API: https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_Operations.html\nAWS DelteteFlowLogs API : https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteFlowLogs.html '\n", "techniques": NaN, "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_ConsoleLogonWithoutMFA.yaml", "query_name": "Login to AWS Management Console without MFA", "query": "\nAWSCloudTrail\n| where EventName =~ \"ConsoleLogin\" \n| extend MFAUsed = tostring(parse_json(AdditionalEventData).MFAUsed), LoginResult = tostring(parse_json(ResponseElements).ConsoleLogin)\n| where MFAUsed !~ \"Yes\" and LoginResult !~ \"Failure\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, LoginResult, MFAUsed, UserIdentityAccountId,  UserIdentityPrincipalid, UserAgent, \nUserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress\n", "attributes": {"description": "'Multi-Factor Authentication (MFA) helps you to prevent credential compromise. This alert identifies logins to the AWS Management Console without MFA.\nYou can limit this detection to trigger for adminsitrative accounts if you do not have MFA enabled on all accounts.\nThis is done by looking at the eventName ConsoleLogin and if the AdditionalEventData field indicates MFA was NOT used \nand the ResponseElements field indicates NOT a Failure. Thereby indicating that a non-MFA login was successful.'\n", "techniques": ["T1078"], "tactics": ["DefenseEvasion", "PrivilegeEscalation", "Persistence", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_CredentialHijack.yaml", "query_name": "Monitor AWS Credential abuse or hijacking", "query": "\nAWSCloudTrail\n| where EventName =~ \"GetCallerIdentity\" and UserIdentityType =~ \"AssumedRole\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by SourceIpAddress, EventName, EventTypeName, UserIdentityType, UserIdentityAccountId, UserIdentityPrincipalid, \nUserAgent, UserIdentityUserName, SessionMfaAuthenticated,AWSRegion, EventSource, AdditionalEventData, ResponseElements\n| extend timestamp = StartTime, AccountCustomEntity = UserIdentityUserName, IPCustomEntity = SourceIpAddress\n| sort by EndTime desc nulls last \n", "attributes": {"description": "'Looking for GetCallerIdentity Events where the UserID Type is AssumedRole \nAn attacker who has assumed the role of a legitimate account can call the GetCallerIdentity function to determine what account they are using.\nA legitimate user using legitimate credentials would not need to call GetCallerIdentity since they should already know what account they are using.\nMore Information: https://duo.com/decipher/trailblazer-hunts-compromised-credentials-in-aws\nAWS STS GetCallerIdentity API: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html '\n", "techniques": ["T1087"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_FullAdminPolicyAttachedToRolesUsersGroups.yaml", "query_name": "Full Admin policy created and then attached to Roles, Users or Groups", "query": "let EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);\nlet createPolicy = \"CreatePolicy\";\nlet timeframe = 1d;\nlet lookback = 14d;\n// Creating Master table with all the events to use with materialize for better performance\nlet EventInfo = AWSCloudTrail\n| where TimeGenerated >= ago(lookback)\n| where EventName in (EventNameList) or EventName == createPolicy;\n//Checking for Policy creation event with Full Admin Privileges since lookback period.\nlet FullAdminPolicyEvents =  materialize(  EventInfo\n| where TimeGenerated >= ago(lookback)\n| where EventName == createPolicy\n| extend PolicyName = tostring(parse_json(RequestParameters).policyName)\n| extend Statement = parse_json(tostring((parse_json(RequestParameters).policyDocument))).Statement\n| mvexpand Statement\n| extend Action = parse_json(Statement).Action , Effect = tostring(parse_json(Statement).Effect), Resource = tostring(parse_json(Statement).Resource)\n| mvexpand Action\n| extend Action = tostring(Action)\n| where Effect =~ \"Allow\" and Action == \"*\" and Resource == \"*\"\n| distinct TimeGenerated, EventName, PolicyName, SourceIpAddress, UserIdentityArn, UserIdentityUserName\n| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))\n| project-rename StartTime = TimeGenerated  );\nlet PolicyAttach = materialize(  EventInfo\n| where TimeGenerated >= ago(timeframe)\n| where EventName in (EventNameList)\n| extend PolicyName = tostring(split(tostring(parse_json(RequestParameters).policyArn),\"/\")[1])\n| summarize AttachEventCount=count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventSource, EventName,   UserIdentityType , UserIdentityArn, SourceIpAddress, UserIdentityUserName = iff(isnotempty(UserIdentityUserName),   UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1])), PolicyName\n| extend AttachEvent = pack(\"StartTime\", StartTime, \"EndTime\", EndTime, \"EventName\", EventName, \"UserIdentityType\",   UserIdentityType, \"UserIdentityArn\", UserIdentityArn, \"SourceIpAddress\", SourceIpAddress, \"UserIdentityUserName\", UserIdentityUserName)\n| project EventSource, PolicyName, AttachEvent, AttachEventCount\n);\n// Joining the list of PolicyNames and checking if it has been attached to any Roles/Users/Groups.\n// These Roles/Users/Groups will be Privileged and can be used by adversaries as pivot point for privilege escalation via multiple ways.\nFullAdminPolicyEvents\n| join kind=leftouter\n(\n    PolicyAttach\n)\non PolicyName\n| project-away PolicyName1\n| extend timestamp = StartTime, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName\n", "attributes": {"description": "'Identity and Access Management (IAM) securely manages access to AWS services and resources. \nIdentifies when a policy is created with Full Administrators Access (Allow-Action:*,Resource:*). \nThis policy can be attached to role,user or group and may be used by an adversary to escalate a normal user privileges to an adminsitrative level.\nAWS IAM Policy Grammar: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_grammar.html\nand AWS IAM API at https://docs.aws.amazon.com/IAM/latest/APIReference/API_Operations.html'\n", "techniques": NaN, "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_IngressEgressSecurityGroupChange.yaml", "query_name": "Changes to AWS Security Group ingress and egress settings", "query": "\nlet EventNameList = dynamic([ \"AuthorizeSecurityGroupEgress\", \"AuthorizeSecurityGroupIngress\", \"RevokeSecurityGroupEgress\", \"RevokeSecurityGroupIngress\"]);\nAWSCloudTrail\n| where EventName in~ (EventNameList)\n| extend User = iif(isnotempty(UserIdentityUserName), UserIdentityUserName, SessionIssuerUserName)\n| summarize EventCount=count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) \nby EventSource, EventName, UserIdentityType, User, SourceIpAddress, UserAgent, SessionMfaAuthenticated, AWSRegion, \nAdditionalEventData, UserIdentityAccountId, UserIdentityPrincipalid, ResponseElements\n| extend timestamp = StartTimeUtc, AccountCustomEntity = User , IPCustomEntity = SourceIpAddress\n", "attributes": {"description": "'A Security Group acts as a virtual firewall of an instance to control inbound and outbound traffic. \n Hence, ingress and egress settings changes to AWS Security Group should be monitored as these can expose the enviornment to new attack vectors.\nMore information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/AWS_LoadBalancerSecGroupChange.yaml", "query_name": "Changes to AWS Elastic Load Balancer security groups", "query": "\nlet EventNameList = dynamic([\"ApplySecurityGroupsToLoadBalancer\", \"SetSecurityGroups\"]);\nAWSCloudTrail\n| where EventName in~ (EventNameList)\n| extend User = iif(isnotempty(UserIdentityUserName), UserIdentityUserName, SessionIssuerUserName)\n| summarize EventCount=count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) \nby EventSource, EventName, UserIdentityType, User, SourceIpAddress, UserAgent, SessionMfaAuthenticated, AWSRegion,\nAdditionalEventData, UserIdentityAccountId, UserIdentityPrincipalid, ResponseElements\n| extend timestamp = StartTimeUtc, AccountCustomEntity = User , IPCustomEntity = SourceIpAddress\n", "attributes": {"description": "'Elastic Load Balancer distributes incoming traffic across multiple instances in multiple availability Zones. This increases the fault tolerance of your applications. \n Unwanted changes to Elastic Load Balancer specific security groups could open your environment to attack and  hence needs monitoring.\n More information: https://medium.com/@GorillaStack/the-most-important-aws-cloudtrail-security-events-to-track-a5b9873f8255 \n and https://aws.amazon.com/elasticloadbalancing/.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSCloudTrail/NRT_AWS_ConsoleLogonWithoutMFA.yaml", "query_name": "NRT Login to AWS Management Console without MFA", "query": "AWSCloudTrail\n| where EventName =~ \"ConsoleLogin\"\n| extend MFAUsed = tostring(parse_json(AdditionalEventData).MFAUsed), LoginResult = tostring(parse_json(ResponseElements).ConsoleLogin)\n| where MFAUsed !~ \"Yes\" and LoginResult !~ \"Failure\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventName, EventTypeName, LoginResult, MFAUsed, UserIdentityAccountId,  UserIdentityPrincipalid, UserAgent,\nUserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion\n", "attributes": {"description": "'Multi-Factor Authentication (MFA) helps you to prevent credential compromise. This alert identifies logins to the AWS Management Console without MFA.\nYou can limit this detection to trigger for administrative accounts if you do not have MFA enabled on all accounts.\nThis is done by looking at the eventName ConsoleLogin and if the AdditionalEventData field indicates MFA was NOT used\nand the ResponseElements field indicates NOT a Failure. Thereby indicating that a non-MFA login was successful.'\n", "techniques": ["T1078"], "tactics": ["DefenseEvasion", "PrivilegeEscalation", "Persistence", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AWSGuardDuty/AWS_GuardDuty_template.yaml", "query_name": "AWS Guard Duty Alert", "query": "AWSGuardDuty | extend tokens = split(ActivityType,\":\") | extend ThreatPurpose = tokens[0], tokens= split(tokens[1],\"/\") | extend ResourceTypeAffected = tokens[0], ThreatFamilyName= tokens[1] | extend UniqueFindingId = Id | extend AWSAcoundId = AccountId | project-away tokens,ActivityType, Id, AccountId | project-away TimeGenerated, TenantId, SchemaVersion, Region, Partition | extend Severity= iff(Severity between (7.0..8.9),\"High\",iff(Severity between (4.0..6.9), \"Medium\", iff(Severity between (1.0..3.9),\"Low\",\"Unknown\")))", "attributes": {"description": "Amazon GuardDuty is a threat detection service that continuously monitors your AWS accounts and workloads for malicious activity and delivers detailed security findings for visibility and remediation. This templates create an alert for each Amazon GuardDuty finding.", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/AADHybridHealthADFSNewServer.yaml", "query_name": "Azure Active Directory Hybrid Health AD FS New Server", "query": "AzureActivity\n| where CategoryValue == 'Administrative'\n| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'\n| where _ResourceId contains 'AdFederationService'\n| where OperationNameValue =~ 'Microsoft.ADHybridHealthService/services/servicemembers/action'\n| extend claimsJson = parse_json(Claims)\n| extend AppId = tostring(claimsJson.appid)\n| extend AccountName = tostring(claimsJson.name)\n| project-away claimsJson\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'This detection uses AzureActivity logs (Administrative category) to identify the creation or update of a server instance in an Azure AD Hybrid health AD FS service.\nA threat actor can create a new AD Health ADFS service and create a fake server instance to spoof AD FS signing logs. There is no need to compromise an on-prem AD FS server.\nThis can be done programmatically via HTTP requests to Azure. More information in this blog: https://o365blog.com/post/hybridhealthagent/'\n", "techniques": ["T1578"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/AADHybridHealthADFSServiceDelete.yaml", "query_name": "Azure Active Directory Hybrid Health AD FS Service Delete", "query": "AzureActivity\n| where CategoryValue == 'Administrative'\n| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'\n| where _ResourceId contains 'AdFederationService'\n| where OperationNameValue =~ 'Microsoft.ADHybridHealthService/services/delete'\n| extend claimsJson = parse_json(Claims)\n| extend AppId = tostring(claimsJson.appid)\n| extend AccountName = tostring(claimsJson.name)\n| project-away claimsJson\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'This detection uses AzureActivity logs (Administrative category) to identify the deletion of an Azure AD Hybrid health AD FS service instance in a tenant.\nA threat actor can create a new AD Health ADFS service and create a fake server to spoof AD FS signing logs.\nThe health AD FS service can then be deleted after it is not longer needed via HTTP requests to Azure.\nMore information in this blog https://o365blog.com/post/hybridhealthagent/'\n", "techniques": ["T1578.003"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/AADHybridHealthADFSSuspApp.yaml", "query_name": "Azure Active Directory Hybrid Health AD FS Suspicious Application", "query": "// Azure AD Connect Health Agent - cf6d7e68-f018-4e0a-a7b3-126e053fb88d\n// Azure Active Directory Connect - cb1056e2-e479-49de-ae31-7812af012ed8\nlet appList = dynamic(['cf6d7e68-f018-4e0a-a7b3-126e053fb88d','cb1056e2-e479-49de-ae31-7812af012ed8']);\nlet operationNamesList = dynamic(['Microsoft.ADHybridHealthService/services/servicemembers/action','Microsoft.ADHybridHealthService/services/delete']);\nAzureActivity\n| where CategoryValue == 'Administrative'\n| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'\n| where _ResourceId contains 'AdFederationService'\n| where OperationNameValue in~ (operationNamesList)\n| extend claimsJson = parse_json(Claims)\n| extend AppId = tostring(claimsJson.appid)\n| extend AccountName = tostring(claimsJson.name)\n| where AppId !in (appList)\n| project-away claimsJson\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'This detection uses AzureActivity logs (Administrative category) to a suspicious application adding a server instance to an Azure AD Hybrid health AD FS service or deleting the AD FS service instance.\nUsually the Azure AD Connect Health Agent application with ID cf6d7e68-f018-4e0a-a7b3-126e053fb88d is used to perform those operations.'\n", "techniques": ["T1528", "T1550"], "tactics": ["CredentialAccess", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/AzDiagSettingsDeleted.yaml", "query_name": "Azure Diagnostic settings removed from a resource", "query": "AzureActivity\n  | where OperationNameValue == 'MICROSOFT.INSIGHTS/DIAGNOSTICSETTINGS/DELETE' and ActivityStatusValue == \"Start\"\n  | extend ParentResource_a = split(_ResourceId,\"/\")\n  | extend ParentResourceLength = array_length(ParentResource_a)-4\n  | extend ParentResourceSplit = array_split(ParentResource_a,ParentResourceLength)\n  | extend resource = strcat_array(ParentResourceSplit[0],\"/\")\n  | project Diagdelete = TimeGenerated, Caller, ResourceProviderValue, _ResourceId, SubscriptionId, ResourceGroup, OperationNameValue, ActivityStatusValue, ActivitySubstatusValue, Start=TimeGenerated, resource, CallerIpAddress\n  | join kind=leftanti  ( AzureActivity\n  | where OperationNameValue != 'MICROSOFT.INSIGHTS/DIAGNOSTICSETTINGS/DELETE' and OperationNameValue endswith \"/DELETE\"\n  | where ActivityStatusValue == 'Start'\n  | project Caller, ResourceProviderValue, resource = tostring(parse_json(Properties).resource), SubscriptionId, ResourceGroup, OperationNameValue, ActivityStatusValue, ActivitySubstatusValue, Start=TimeGenerated) on $left.resource == $right.resource\n  | project Caller, ResourceProviderValue, resource, SubscriptionId, ResourceGroup, OperationNameValue, ActivityStatusValue, ActivitySubstatusValue, Start, CallerIpAddress\n", "attributes": {"description": "'This query looks for diagnostic settings that are removed from a resource.\nThis could indicate an attacker or malicious internal trying to evade detection before malicious act is performed.\nIf the diagnostic settings are being deleted as part of a parent resource deletion, the event is ignores.'\n", "techniques": ["T1562.008"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/Creating_Anomalous_Number_Of_Resources_detection.yaml", "query_name": "Suspicious number of resource creation or deployment activities", "query": "\nlet szOperationNames = dynamic([\"microsoft.compute/virtualMachines/write\", \"microsoft.resources/deployments/write\"]);\nlet starttime = 7d;\nlet endtime = 1d;\nAzureActivity\n| where TimeGenerated between (startofday(ago(starttime)) .. startofday(ago(endtime)))\n| where OperationNameValue  in~ (szOperationNames)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatusValue = makelist(ActivityStatusValue), \nOperationIds = makelist(OperationId), CallerIpAddress = makelist(CallerIpAddress), CorrelationId = makelist(CorrelationId) \nby ResourceId, Caller, OperationNameValue, Resource, ResourceGroup\n| mvexpand CallerIpAddress\n| where isnotempty(CallerIpAddress)\n| make-series dResourceCount=dcount(ResourceId)  default=0 on StartTimeUtc in range(startofday(ago(7d)), now(), 1d) \nby Caller, tostring(ActivityTimeStamp), tostring(ActivityStatusValue), tostring(OperationIds), tostring(CallerIpAddress), tostring(CorrelationId), ResourceId, OperationNameValue , Resource, ResourceGroup\n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)\n| where Slope > 0.2\n| join kind=leftsemi (\n// Last day's activity is anomalous\nAzureActivity\n| where TimeGenerated >= startofday(ago(endtime))\n| where OperationNameValue in~ (szOperationNames)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatusValue = makelist(ActivityStatusValue), \nOperationIds = makelist(OperationId), CallerIpAddress = makelist(CallerIpAddress), CorrelationId = makelist(CorrelationId) \nby ResourceId, Caller, OperationNameValue, Resource, ResourceGroup\n| mvexpand CallerIpAddress\n| where isnotempty(CallerIpAddress)\n| make-series dResourceCount=dcount(ResourceId)  default=0 on StartTimeUtc in range(startofday(ago(1d)), now(), 1d) \nby Caller, tostring(ActivityTimeStamp), tostring(ActivityStatusValue), tostring(OperationIds), tostring(CallerIpAddress), tostring(CorrelationId), ResourceId, OperationNameValue , Resource, ResourceGroup\n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)\n| where Slope > 0.2    \n) on Caller, CallerIpAddress        \n| mvexpand todynamic(ActivityTimeStamp), todynamic(ActivityStatusValue), todynamic(OperationIds), todynamic(CorrelationId)\n| extend timestamp = ActivityTimeStamp, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Indicates when an anomalous number of VM creations or deployment activities occur in Azure via the AzureActivity log.\nThe anomaly detection identifies activities that have occurred both since the start of the day 1 day ago and the start of the day 7 days ago.\nThe start of the day is considered 12am UTC time.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/Creation_of_Expensive_Computes_in_Azure.yaml", "query_name": "Creation of expensive computes in Azure", "query": "let tokens = dynamic([\"416\",\"208\",\"128\",\"120\",\"96\",\"80\",\"72\",\"64\",\"48\",\"44\",\"40\",\"g5\",\"gs5\",\"g4\",\"gs4\",\"nc12\",\"nc24\",\"nv12\"]);\nlet operationList = dynamic([\"microsoft.compute/virtualmachines/write\", \"microsoft.resources/deployments/write\"]);\nAzureActivity\n| where tolower(OperationNameValue) in (operationList)\n| where ActivityStatusValue == \"Accepted\" \n| where isnotempty(Properties)\n| extend vmSize = tolower(tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).hardwareProfile)).vmSize))\n| where isnotempty(vmSize)\n| where vmSize has_any (tokens) \n| extend ComputerName = tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).osProfile)).computerName)\n| extend clientIpAddress = tostring(parse_json(HTTPRequest).clientIpAddress)\n| project TimeGenerated, OperationNameValue, ActivityStatusValue, Caller, CallerIpAddress, ComputerName, vmSize\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Identifies the creation of large size/expensive VMs (GPU or with large no of virtual CPUs) in Azure.\nAdversary may create new or update existing virtual machines sizes to evade defenses \nor use it for cryptomining purposes.\nFor Windows/Linux Vm Sizes - https://docs.microsoft.com/azure/virtual-machines/windows/sizes \nAzure VM Naming Conventions - https://docs.microsoft.com/azure/virtual-machines/vm-naming-conventions'\n", "techniques": ["T1578"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/Granting_Permissions_To_Account_detection.yaml", "query_name": "Suspicious granting of permissions to an account", "query": "let starttime = 14d;\nlet endtime = 1d;\n// The number of operations below which an IP address is considered an unusual source of role assignment operations\nlet alertOperationThreshold = 5;\nlet AzureBuiltInRole = externaldata(Role:string,RoleDescription:string,ID:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/AzureBuiltInRole.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet createRoleAssignmentActivity = AzureActivity\n| where OperationNameValue =~ \"microsoft.authorization/roleassignments/write\";\nlet RoleAssignedActivity = createRoleAssignmentActivity \n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| summarize count() by CallerIpAddress, Caller\n| where count_ >= alertOperationThreshold\n| join kind = rightanti ( \ncreateRoleAssignmentActivity\n| where TimeGenerated > ago(endtime)\n| extend PrincipalId = tostring(parse_json(tostring(parse_json(tostring(Properties_d.requestbody)).Properties)).PrincipalId)\n| extend PrincipalType = tostring(parse_json(tostring(parse_json(tostring(Properties_d.requestbody)).Properties)).PrincipalType)\n| extend Scope = tostring(parse_json(tostring(parse_json(tostring(Properties_d.requestbody)).Properties)).Scope)\n| extend RoleAddedDetails = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).requestbody)).Properties)).RoleDefinitionId) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = make_set(TimeGenerated), ActivityStatusValue = make_set(ActivityStatusValue), \nOperationIds = make_set(OperationId), CorrelationId = make_set(CorrelationId), ActivityCountByCallerIPAddress = count()  \nby ResourceId, CallerIpAddress, Caller, OperationNameValue, Resource, ResourceGroup, PrincipalId, PrincipalType, Scope, RoleAddedDetails\n) on CallerIpAddress, Caller\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress;\nlet RoleAssignedActivitywithRoleDetails = RoleAssignedActivity\n| extend RoleAssignedID = tostring(split(RoleAddedDetails, \"/\")[-1])\n| join kind = inner (AzureBuiltInRole \n) on $left.RoleAssignedID == $right.ID;\nRoleAssignedActivitywithRoleDetails\n| summarize arg_max(StartTimeUtc, *) by PrincipalId, RoleAssignedID\n| join kind = leftouter( IdentityInfo\n| summarize arg_max(TimeGenerated, *) by AccountObjectId\n) on $left.PrincipalId == $right.AccountObjectId\n| project ActivityTimeStamp, OperationNameValue, Caller, CallerIpAddress, PrincipalId, RoleAssignedID, RoleAddedDetails, Role, RoleDescription, AccountUPN, AccountCreationTime, GroupMembership, UserType, ActivityStatusValue, \nResourceGroup, PrincipalType, Scope, CorrelationId, timestamp, AccountCustomEntity, IPCustomEntity\n", "attributes": {"description": "'Identifies IPs from which users grant access to other users on azure resources and alerts when a previously unseen source IP address is used.'\n", "techniques": ["T1098", "T1548"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/New-CloudShell-User.yaml", "query_name": "New CloudShell User", "query": "\nlet match_window = 3m;\nAzureActivity\n| where ResourceGroup has \"cloud-shell\"\n| where (OperationNameValue =~ \"Microsoft.Storage/storageAccounts/listKeys/action\") \n| where ActivityStatusValue == \"Success\"\n| extend TimeKey = bin(TimeGenerated, match_window), AzureIP = CallerIpAddress\n| join kind = inner\n(AzureActivity\n| where ResourceGroup has \"cloud-shell\"\n| where (OperationNameValue =~ \"Microsoft.Storage/storageAccounts/write\") \n| extend TimeKey = bin(TimeGenerated, match_window), UserIP = CallerIpAddress\n) on Caller, TimeKey\n| summarize count() by TimeKey, Caller, ResourceGroup, SubscriptionId, TenantId, AzureIP, UserIP, HTTPRequest, Type, Properties, CategoryValue, OperationList = strcat(OperationNameValue, ' , ', OperationNameValue1)\n", "attributes": {"description": "'Identifies when a user creates an Azure CloudShell for the first time.\nMonitor this activity to ensure only expected user are using CloudShell'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/NewResourceGroupsDeployedTo.yaml", "query_name": "Suspicious Resource deployment", "query": "\nlet szOperationNames = dynamic([\"Microsoft.Compute/virtualMachines/write\", \"Microsoft.Resources/deployments/write\"]);\nlet starttime = 14d;\nlet endtime = 1d;\nlet RareCaller = AzureActivity\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where OperationNameValue in~ (szOperationNames)\n| project ResourceGroup, Caller, OperationNameValue, CallerIpAddress\n| join kind=rightantisemi (\nAzureActivity\n| where TimeGenerated > ago(endtime)\n| where OperationNameValue in~ (szOperationNames)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityStatusValue = makeset(ActivityStatusValue), OperationIds = makeset(OperationId), CallerIpAddress = makeset(CallerIpAddress) \nby ResourceId, Caller, OperationNameValue, Resource, ResourceGroup\n) on Caller, ResourceGroup \n| mvexpand CallerIpAddress\n| where isnotempty(CallerIpAddress);\nlet Counts = RareCaller | summarize ActivityCountByCaller = count() by Caller;\nRareCaller | join kind= inner (Counts) on Caller | project-away Caller1\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = tostring(CallerIpAddress)\n| sort by ActivityCountByCaller desc nulls last \n", "attributes": {"description": "'Identifies when a rare Resource and ResourceGroup deployment occurs by a previously unseen Caller.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/NRT-AADHybridHealthADFSNewServer.yaml", "query_name": "NRT Azure Active Directory Hybrid Health AD FS New Server", "query": "AzureActivity\n| where CategoryValue == 'Administrative'\n| where ResourceProviderValue =~ 'Microsoft.ADHybridHealthService'\n| where _ResourceId contains 'AdFederationService'\n| where OperationNameValue =~ 'Microsoft.ADHybridHealthService/services/servicemembers/action'\n| extend claimsJson = parse_json(Claims)\n| extend AppId = tostring(claimsJson.appid)\n| extend AccountName = tostring(claimsJson.name)\n| project-away claimsJson\n", "attributes": {"description": "'This detection uses AzureActivity logs (Administrative category) to identify the creation or update of a server instance in an Azure AD Hybrid health AD FS service.\nA threat actor can create a new AD Health ADFS service and create a fake server instance to spoof AD FS signing logs. There is no need to compromise an on-prem AD FS server.\nThis can be done programmatically via HTTP requests to Azure. More information in this blog: https://o365blog.com/post/hybridhealthagent/'\n", "techniques": ["T1578"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/NRT_Creation_of_Expensive_Computes_in_Azure.yaml", "query_name": "NRT Creation of expensive computes in Azure", "query": "let tokens = dynamic([\"416\",\"208\",\"128\",\"120\",\"96\",\"80\",\"72\",\"64\",\"48\",\"44\",\"40\",\"g5\",\"gs5\",\"g4\",\"gs4\",\"nc12\",\"nc24\",\"nv12\"]);\nlet operationList = dynamic([\"microsoft.compute/virtualmachines/write\", \"microsoft.resources/deployments/write\"]);\nAzureActivity\n| where tolower(OperationNameValue) in (operationList)\n| where ActivityStatusValue == \"Accepted\" \n| where isnotempty(Properties)\n| extend vmSize = tolower(tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).hardwareProfile)).vmSize))\n| where isnotempty(vmSize)\n| where vmSize has_any (tokens) \n| extend ComputerName = tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).osProfile)).computerName)\n| extend clientIpAddress = tostring(parse_json(HTTPRequest).clientIpAddress)\n| project TimeGenerated, OperationNameValue, ActivityStatusValue, Caller, CallerIpAddress, ComputerName, vmSize\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Identifies the creation of large size/expensive VMs (GPU or with large no of virtual CPUs) in Azure.\nAdversary may create new or update existing virtual machines sizes to evade defenses \nor use it for cryptomining purposes.\nFor Windows/Linux Vm Sizes - https://docs.microsoft.com/azure/virtual-machines/windows/sizes \nAzure VM Naming Conventions - https://docs.microsoft.com/azure/virtual-machines/vm-naming-conventions'\n", "techniques": ["T1578"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/RareOperations.yaml", "query_name": "Rare subscription-level operations in Azure", "query": "\nlet starttime = 14d;\nlet endtime = 1d;\n// The number of operations below which an IP address is considered an unusual source of role assignment operations\nlet alertOperationThreshold = 5;\nlet SensitiveOperationList =  dynamic([\"microsoft.compute/snapshots/write\", \"microsoft.network/networksecuritygroups/write\", \"microsoft.storage/storageaccounts/listkeys/action\"]);\nlet SensitiveActivity = AzureActivity\n| where OperationNameValue in~ (SensitiveOperationList) or OperationNameValue hassuffix \"listkeys/action\"\n| where ActivityStatusValue =~ \"Success\";\nSensitiveActivity\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| summarize count() by CallerIpAddress, Caller, OperationNameValue\n| where count_ >= alertOperationThreshold\n| join kind = rightanti ( \nSensitiveActivity\n| where TimeGenerated >= ago(endtime)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatusValue = makelist(ActivityStatusValue), \nOperationIds = makelist(OperationId), CorrelationIds = makelist(CorrelationId), Resources = makelist(Resource), ResourceGroups = makelist(ResourceGroup), ResourceIds = makelist(ResourceId), ActivityCountByCallerIPAddress = count()  \nby CallerIpAddress, Caller, OperationNameValue\n) on CallerIpAddress, Caller, OperationNameValue\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'This query looks for a few sensitive subscription-level events based on Azure Activity Logs. \n For example this monitors for the operation name 'Create or Update Snapshot' which is used for creating backups but could be misused by attackers \n to dump hashes or extract sensitive information from the disk.'\n", "techniques": ["T1003", "T1098"], "tactics": ["CredentialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/RareRunCommandPowerShellScript.yaml", "query_name": "Azure VM Run Command operations executing a unique PowerShell script", "query": "let RunCommandData = materialize ( AzureActivity\n// Isolate run command actions\n| where OperationNameValue == \"MICROSOFT.COMPUTE/VIRTUALMACHINES/RUNCOMMAND/ACTION\"\n// Confirm that the operation impacted a virtual machine\n| where Authorization has \"virtualMachines\"\n// Each runcommand operation consists of three events when successful, StartTimeed, Accepted (or Rejected), Successful (or Failed).\n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), max(CallerIpAddress), make_list(ActivityStatusValue) by CorrelationId, Authorization, Caller\n// Limit to Run Command executions that Succeeded\n| where list_ActivityStatusValue has \"Success\"\n// Extract data from the Authorization field, allowing us to later extract the Caller (UPN) and CallerIpAddress\n| extend Authorization_d = parse_json(Authorization)\n| extend Scope = Authorization_d.scope\n| extend Scope_s = split(Scope, \"/\")\n| extend Subscription = tostring(Scope_s[2])\n| extend VirtualMachineName = tostring(Scope_s[-1])\n| project StartTime, EndTime, Subscription, VirtualMachineName, CorrelationId, Caller, CallerIpAddress=max_CallerIpAddress\n| join kind=leftouter (\n    DeviceFileEvents\n    | where InitiatingProcessFileName == \"RunCommandExtension.exe\"\n    | extend VirtualMachineName = tostring(split(DeviceName, \".\")[0])\n    | project VirtualMachineName, PowershellFileCreatedTimestamp=TimeGenerated, FileName, FileSize, InitiatingProcessAccountName, InitiatingProcessAccountDomain, InitiatingProcessFolderPath, InitiatingProcessId\n) on VirtualMachineName\n// We need to filter by time sadly, this is the only way to link events\n| where PowershellFileCreatedTimestamp between (StartTime .. EndTime)\n| project StartTime, EndTime, PowershellFileCreatedTimestamp, VirtualMachineName, Caller, CallerIpAddress, FileName, FileSize, InitiatingProcessId, InitiatingProcessAccountDomain, InitiatingProcessFolderPath\n| join kind=inner(\n    DeviceEvents\n    | extend VirtualMachineName = tostring(split(DeviceName, \".\")[0])\n    | where InitiatingProcessCommandLine has \"-File\"\n    // Extract the script name based on the structure used by the RunCommand extension\n    | extend PowershellFileName = extract(@\"\\-File\\s(script[0-9]{1,9}\\.ps1)\", 1, InitiatingProcessCommandLine)\n    // Discard results that didn't successfully extract, these are not run command related\n    | where isnotempty(PowershellFileName)\n    | extend PSCommand = tostring(parse_json(AdditionalFields).Command)\n    // The first execution of PowerShell will be the RunCommand script itself, we can discard this as it will break our hash later\n    | where PSCommand != PowershellFileName \n    // Now we normalise the cmdlets, we're aiming to hash them to find scripts using rare combinations\n    | extend PSCommand = toupper(PSCommand)\n    | order by PSCommand asc\n    | summarize PowershellExecStartTime=min(TimeGenerated), PowershellExecEnd=max(TimeGenerated), make_list(PSCommand) by PowershellFileName, InitiatingProcessCommandLine\n) on $left.FileName == $right.PowershellFileName\n| project StartTime, EndTime, PowershellFileCreatedTimestamp, PowershellExecStartTime, PowershellExecEnd, PowershellFileName, PowershellScriptCommands=list_PSCommand, Caller, CallerIpAddress, InitiatingProcessCommandLine, PowershellFileSize=FileSize, VirtualMachineName\n| order by StartTime asc \n// We generate the hash based on the cmdlets called and the size of the powershell script\n| extend TempFingerprintString = strcat(PowershellScriptCommands, PowershellFileSize)\n| extend ScriptFingerprintHash = hash_sha256(tostring(PowershellScriptCommands)));\nlet totals = toscalar (RunCommandData\n| summarize count());\nlet hashTotals = RunCommandData\n| summarize HashCount=count() by ScriptFingerprintHash;\nRunCommandData\n| join kind=leftouter (\nhashTotals\n) on ScriptFingerprintHash\n// Calculate prevalence, while we don't need this, it may be useful for responders to know how rare this script is in relation to normal activity\n| extend Prevalence = toreal(HashCount) / toreal(totals) * 100\n// Where the hash was only ever seen once.\n| where HashCount == 1\n| extend timestamp = StartTime, IPCustomEntity=CallerIpAddress, AccountCustomEntity=Caller, HostCustomEntity=VirtualMachineName\n| project timestamp, StartTime, EndTime, PowershellFileName, VirtualMachineName, Caller, CallerIpAddress, PowershellScriptCommands, PowershellFileSize, ScriptFingerprintHash, Prevalence, IPCustomEntity, AccountCustomEntity, HostCustomEntity\n", "attributes": {"description": "'Identifies when Azure Run command is used to execute a PowerShell script on a VM that is unique.\nThe uniqueness of the PowerShell script is determined by taking a combined hash of the cmdLets it imports\nand the file size of the PowerShell script. Alerts from this detection indicate a unique PowerShell was executed\nin your environment.'\n", "techniques": ["T1570", "T1059.001"], "tactics": ["LateralMovement", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureActivity/TimeSeriesAnomaly_Mass_Cloud_Resource_Deletions.yaml", "query_name": "Mass Cloud resource deletions Time Series Anomaly", "query": "let starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet TotalEventsThreshold = 25; \nlet TimeSeriesData = \nAzureActivity \n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where OperationNameValue endswith \"delete\" \n| project TimeGenerated, Caller \n| make-series Total = count() on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by Caller; \nlet TimeSeriesAlerts = materialize(TimeSeriesData \n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 3, -1, 'linefit') \n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long) \n| where anomalies > 0 \n| project Caller, TimeGenerated, Total, baseline, anomalies, score \n| where Total > TotalEventsThreshold and baseline > 0 ); \nTimeSeriesAlerts \n| where TimeGenerated > (ago(endtime)) \n| project TimeGenerated, Caller \n| join (AzureActivity \n| where TimeGenerated > (ago(endtime)) \n| where OperationNameValue endswith \"delete\" \n| summarize count(), make_set(OperationNameValue), make_set(Resource) by bin(TimeGenerated, 1h), Caller) on TimeGenerated, Caller \n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller\n", "attributes": {"description": "'This query generates baseline pattern of cloud resource deletions by an user and generated anomaly \nwhen any unusual spike is detected.\nThese anomalies from unusual or privileged users could be an indication of cloud infrastructure \ntake-down by an adversary '\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureAppServices/AVScan_Failure.yaml", "query_name": "AppServices AV Scan Failure", "query": "\nlet timeframe = ago(1d);\nAppServiceAntivirusScanAuditLogs\n| where ScanStatus == \"Failed\"\n| extend HostCustomEntity = _ResourceId, timestamp = TimeGenerated\n", "attributes": {"description": "'Identifies if an AV scan fails in Azure App Services.'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureAppServices/AVScan_Infected_Files_Found.yaml", "query_name": "AppServices AV Scan with Infected Files", "query": "\nlet timeframe = ago(1d);\nAppServiceAntivirusScanAuditLogs\n| where NumberOfInfectedFiles > 0\n| extend HostCustomEntity = _ResourceId, timestamp = TimeGenerated\n", "attributes": {"description": "'Identifies if an AV scan finds infected files in Azure App Services.'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/ADOAgentPoolCreatedDeleted.yaml", "query_name": "Azure DevOps Agent Pool Created Then Deleted", "query": "let lookback = 14d;\nlet timewindow = 7d;\nAzureDevOpsAuditing\n| where TimeGenerated > ago(lookback)\n| where OperationName =~ \"Library.AgentPoolCreated\"\n| extend AgentCloudId = tostring(Data.AgentCloudId)\n| extend PoolType = iif(isnotempty(AgentCloudId), \"Azure VMs\", \"Self Hosted\")\n// Comment this line out to include cloud pools as well\n| where PoolType == \"Self Hosted\"\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n| extend AgentPoolId = tostring(Data.AgentPoolId)\n| extend IsHosted = tostring(Data.IsHosted)\n| extend IsLegacy = tostring(Data.IsLegacy)\n| extend timekey = bin(TimeGenerated, timewindow)\n// Join only with pools deleted in the same window\n| join (AzureDevOpsAuditing\n| where TimeGenerated > ago(lookback)\n| where OperationName =~ \"Library.AgentPoolDeleted\"\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n| extend AgentPoolId = tostring(Data.AgentPoolId)\n| extend timekey = bin(TimeGenerated, timewindow)) on AgentPoolId, timekey\n| project-reorder TimeGenerated, ActorUPN, UserAgent, IpAddress, AuthenticationMechanism, OperationName, AgentPoolName, IsHosted, IsLegacy, Data\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'As well as adding build agents to an existing pool to execute malicious activity within a pipeline, an attacker could create a complete new agent pool and use this for execution.\nAzure DevOps allows for the creation of agent pools with Azure hosted infrastructure or self-hosted infrastructure. Given the additional customizability of self-hosted agents this \ndetection focuses on the creation of new self-hosted pools. To further reduce false positive rates the detection looks for pools created and deleted relatively quickly (within 7 days by default), \nas an attacker is likely to remove a malicious pool once used in order to reduce/remove evidence of their activity.'\n", "techniques": ["T1578.002"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/ADOAuditStreamDisabled.yaml", "query_name": "Azure DevOps Audit Stream Disabled", "query": "AzureDevOpsAuditing\n| where OperationName =~ \"AuditLog.StreamDisabledByUser\"\n| extend StreamType = tostring(Data.ConsumerType)\n| project-reorder TimeGenerated, Details, ActorUPN, IpAddress, UserAgent, StreamType\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Azure DevOps allow for audit logs to be streamed to external storage solutions such as SIEM solutions. An attacker looking to hide malicious Azure DevOps activity from defenders may look to disable data streams \nbefore conducting activity and then re-enabling the stream after (so as not to raise data threshold-based alarms). Looking for disabled audit streams can identify this activity, and due to the nature of the action \nits unlikely to have a high false positive rate.'\n", "techniques": ["T1562.008"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/ADONewExtensionAdded.yaml", "query_name": "Azure DevOps New Extension Added", "query": "let allowed_publishers = dynamic([]);\nAzureDevOpsAuditing\n| where OperationName =~ \"Extension.Installed\"\n| extend ExtensionName = tostring(Data.ExtensionName)\n| extend PublisherName = tostring(Data.PublisherName)\n| where PublisherName !in (allowed_publishers)\n| project-reorder TimeGenerated, OperationName, ExtensionName, PublisherName, ActorUPN, IpAddress, UserAgent, ScopeDisplayName, Data\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Extensions add additional features to Azure DevOps. An attacker could use a malicious extension to conduct malicious activity. \nThis query looks for new extensions that are not from a configurable list of approved publishers.'\n", "techniques": ["T1505"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/ADOPATUsedWithBrowser.yaml", "query_name": "Azure DevOps PAT used with Browser.", "query": "AzureDevOpsAuditing\n| where AuthenticationMechanism startswith \"PAT\"\n// Look for useragents that include a redenring engine\n| where UserAgent has_any (\"Gecko\", \"WebKit\", \"Presto\", \"Trident\", \"EdgeHTML\", \"Blink\")\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Personal Access Tokens (PATs) are used as an alternate password to authenticate into Azure DevOps. PATs are intended for programmatic access use in code or applications. \nThis can be prone to attacker theft if not adequately secured. This query looks for the use of a PAT in authentication but from a User Agent indicating a browser. \nThis should not be normal activity and could be an indicator of an attacker using a stolen PAT.'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/ADOPipelineModifiedbyNewUser.yaml", "query_name": "Azure DevOps Pipeline modified by a new user.", "query": "// Set the lookback to determine if user has created pipelines before\nlet timeback = 14d;\n// Set the period for detections\nlet timeframe = 1d;\n// Get a list of previous Release Pipeline creators to exclude\nlet releaseusers = AzureDevOpsAuditing\n| where TimeGenerated > ago(timeback) and TimeGenerated < ago(timeframe)\n| where OperationName in (\"Release.ReleasePipelineCreated\", \"Release.ReleasePipelineModified\")\n// We want to look for users performing actions in specific projects so we create this userscope object to match on\n| extend UserScope = strcat(ActorUserId, \"-\", ProjectName)\n| summarize by UserScope;\n// Get Release Pipeline creations by new users\nAzureDevOpsAuditing\n| where TimeGenerated > ago(timeframe)\n| where OperationName =~ \"Release.ReleasePipelineModified\"\n| extend UserScope = strcat(ActorUserId, \"-\", ProjectName)\n| where UserScope !in (releaseusers)\n| extend ActorUPN = tolower(ActorUPN)\n| project-away Id, ActivityId, ActorCUID, ScopeId, ProjectId, TenantId, SourceSystem, UserScope\n// See if any of these users have Azure AD alerts associated with them in the same timeframe\n| join kind = leftouter (\nSecurityAlert\n| where TimeGenerated > ago(timeframe)\n| where ProviderName == \"IPC\"\n| extend AadUserId = tostring(parse_json(Entities)[0].AadUserId)\n| summarize Alerts=count() by AadUserId) on $left.ActorUserId == $right.AadUserId\n| extend Alerts = iif(isnotempty(Alerts), Alerts, 0)\n// Uncomment the line below to only show results where the user as AADIdP alerts\n//| where Alerts > 0\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'There are several potential pipeline steps that could be modified by an attacker to inject malicious code into the build cycle. A likely attacker path is the modification to an existing pipeline that they have access to. \nThis detection looks for users modifying a pipeline when they have not previously been observed modifying or creating that pipeline before. This query also joins events with data to Azure AD Identity Protection (AAD IdP) \nin order to show if the user conducting the action has any associated AAD IdP alerts. You can also choose to filter this detection to only alert when the user also has AAD IdP alerts associated with them.'\n", "techniques": ["T1578", "T1569"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/ADORetentionReduced.yaml", "query_name": "Azure DevOps Retention Reduced", "query": "AzureDevOpsAuditing\n| where OperationName =~ \"Pipelines.PipelineRetentionSettingChanged\"\n| where Data.SettingName in (\"PurgeArtifacts\", \"PurgeRuns\")\n| where Data.NewValue == 1 or Data.NewValue < Data.OldValue/2\n| project-reorder TimeGenerated, OperationName, ActorUPN, IpAddress, UserAgent, Data\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'AzureDevOps retains items such as run records and produced artifacts for a configurable amount of time. An attacker looking to reduce the footprint left by their malicious activity may look to reduce the retention time for artifacts and runs.\nThis query will look for where retention has been reduced to the minimum level - 1, or reduced by more than half.'\n", "techniques": ["T1564"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/ADOSecretNotSecured.yaml", "query_name": "Azure DevOps Variable Secret Not Secured", "query": "let keywords = dynamic([\"secret\", \"secrets\", \"password\", \"PAT\", \"passwd\", \"pswd\", \"pwd\", \"cred\", \"creds\", \"credentials\", \"credential\", \"key\"]);\nAzureDevOpsAuditing\n| where OperationName =~ \"Library.VariableGroupModified\"\n| extend Type = tostring(Data.Type)\n| extend VariableGroupId = tostring(Data.VariableGroupId)\n| extend VariableGroupName = tostring(Data.VariableGroupName)\n| mv-expand Data.Variables\n| where VariableGroupName has_any (keywords) or Data_Variables has_any (keywords)\n| where Type != \"AzureKeyVault\"\n| where Data_Variables !has \"IsSecret\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Credentials used in the build process may be stored as Azure DevOps variables. To secure these variables they should be stored in KeyVault or marked as Secrets. \nThis detection looks for new variables added with names that suggest they are credentials but where they are not set as Secrets or stored in KeyVault.'\n", "techniques": ["T1552"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/ADOVariableModifiedByNewUser.yaml", "query_name": "Azure DevOps Build Variable Modified by New User.", "query": "let lookback = 14d;\nlet timeframe = 1d;\nlet historical_data =\nAzureDevOpsAuditing\n| where TimeGenerated > ago(lookback) and TimeGenerated < ago(timeframe)\n| where OperationName =~ \"Library.VariableGroupModified\"\n| extend variables = Data.Variables\n| extend VariableGroupId = tostring(Data.VariableGroupId)\n| extend UserKey = strcat(VariableGroupId, \"-\", ActorUserId)\n| project UserKey;\nAzureDevOpsAuditing\n| where TimeGenerated > ago(timeframe)\n| where OperationName =~ \"Library.VariableGroupModified\"\n| extend VariableGroupName = tostring(Data.VariableGroupName)\n| extend VariableGroupId = tostring(Data.VariableGroupId)\n| extend UserKey = strcat(VariableGroupId, \"-\", ActorUserId)\n| where UserKey !in (historical_data)\n| project-away UserKey\n| project-reorder TimeGenerated, VariableGroupName, ActorUPN, IpAddress, UserAgent\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Variables can be configured and used at any stage of the build process in Azure DevOps to inject values. An attacker with the required permissions could modify \nor add to these variables to conduct malicious activity such as changing paths or remote endpoints called during the build. As variables are often changed by users, \njust detecting these changes would have a high false positive rate. This detection looks for modifications to variable groups where that user has not been observed \nmodifying them before.'\n", "techniques": ["T1578"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOAdminGroupAdditions.yaml", "query_name": "Azure DevOps Administrator Group Monitoring", "query": "\n// Change to true to monitor for Project Administrator adds to *any* project\nlet MonitorAllProjects = false;\n// If MonitorAllProjects is false, trigger only on Project Administrator add for the following projects\nlet ProjectsToMonitor = dynamic(['<project_X>','<project_Y>']);\nAzureDevOpsAuditing\n| where Area == \"Group\" and OperationName == \"Group.UpdateGroupMembership.Add\"\n| where Details has 'Administrators'\n| where Details has \"was added as a member of group\" and (Details endswith '\\\\Project Administrators' or Details endswith '\\\\Project Collection Administrators')\n| parse Details with AddedIdentity ' was added as a member of group [' EntityName ']\\\\' GroupName\n| extend Level = iif(GroupName == 'Project Collection Administrators', 'Organization', 'Project'), AddedIdentityId = Data.MemberId\n| extend Severity = iif(Level == 'Organization', 'High', 'Medium'), AlertDetails = strcat('At ', TimeGenerated, ' UTC ', ActorUPN, '/', ActorDisplayName, ' added ', AddedIdentity, ' to the ', EntityName, ' ', Level)\n| where MonitorAllProjects == true or EntityName in (ProjectsToMonitor) or Level == 'Organization'\n| project TimeGenerated, Severity, Adder = ActorUPN, AddedIdentity, AddedIdentityId, AlertDetails, Level, EntityName, GroupName, ActorAuthType = AuthenticationMechanism, \n  ActorIpAddress = IpAddress, ActorUserAgent = UserAgent, RawDetails = Details\n| extend timestamp = TimeGenerated, AccountCustomEntity = Adder, IPCustomEntity = ActorIpAddress\n", "attributes": {"description": "'This detection monitors for additions to projects or project collection administration groups in an Azure DevOps Organization.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOHistoricPrPolicyBypassing.yaml", "query_name": "Azure DevOps Pull Request Policy Bypassing - Historic allow list", "query": "\nlet starttime = 14d;\nlet endtime = 3h;\n// Add full UPN (user@domain.com) to Authorized Bypassers to ignore policy bypasses by certain authorized users\nlet AuthorizedBypassers = dynamic(['foo@baz.com', 'test@foo.com']);\nlet historicBypassers = AzureDevOpsAuditing\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where OperationName == 'Git.RefUpdatePoliciesBypassed'\n| distinct ActorUPN;\nAzureDevOpsAuditing\n| where TimeGenerated >= ago(endtime)\n| where OperationName == 'Git.RefUpdatePoliciesBypassed'\n| where ActorUPN !in (historicBypassers) and ActorUPN !in (AuthorizedBypassers)\n| parse ScopeDisplayName with OrganizationName '(Organization)'\n| project TimeGenerated, ActorUPN, IpAddress, UserAgent, OrganizationName, ProjectName, RepoName = Data.RepoName, AlertDetails = Details, Branch = Data.Name, \n  BypassReason = Data.BypassReason, PRLink = strcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_git/', Data.RepoName, '/pullrequest/', Data.PullRequestId)\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This detection builds an allow list of historic PR policy bypasses and compares to recent history, flagging pull request bypasses that are not manually in the allow list and not historically included in the allow list.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOHistoricServiceConnectionAdds.yaml", "query_name": "Azure DevOps Service Connection Addition/Abuse - Historic allow list", "query": "\nlet starttime = 14d;\nlet endtime = 6h;\n// Ignore Build/Releases with less/equal this number\nlet ServiceConnectionThreshold = 3;\n// New Connections need to exhibit execution of more \"new\" connections than this number.\nlet NewConnectionThreshold = 1;\n// List of Builds/Releases to ignore in your space\nlet BypassDefIds = datatable(DefId:string, Type:string, ProjectName:string)\n[\n//\"103\", \"Release\", \"ProjectA\",\n//\"42\", \"Release\", \"ProjectB\",\n//\"122\", \"Build\", \"ProjectB\"\n];\nlet HistoricDefs = AzureDevOpsAuditing\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where OperationName == \"Library.ServiceConnectionExecuted\" \n| extend DefId = tostring(Data.DefinitionId), Type = tostring(Data.PlanType), ConnectionId = tostring(Data.ConnectionId)\n| summarize HistoricCount = dcount(tostring(ConnectionId)), ConnectionNames = make_set(tostring(Data.ConnectionName)) \n  by DefId = tostring(DefId), Type = tostring(Type), ProjectId, ProjectName, ActorUPN;\nAzureDevOpsAuditing\n| where TimeGenerated >= ago(endtime)\n| where OperationName == \"Library.ServiceConnectionExecuted\" \n| extend DefId = tostring(Data.DefinitionId), Type = tostring(Data.PlanType), ConnectionId = tostring(Data.ConnectionId)\n| parse ScopeDisplayName with OrganizationName ' (Organization)'\n| summarize CurrentCount = dcount(tostring(ConnectionId)), ConnectionNames = make_set(tostring(Data.ConnectionName)), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) \n  by OrganizationName, DefId = tostring(DefId), Type = tostring(Type), ProjectId, ProjectName, ActorUPN\n| where CurrentCount > ServiceConnectionThreshold\n| join (HistoricDefs) on ProjectId, DefId, Type, ActorUPN\n| join kind=anti BypassDefIds on $left.DefId==$right.DefId and $left.Type == $right.Type and $left.ProjectName == $right.ProjectName\n| extend link = iff(\nType == \"Build\", strcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_build?definitionId=', DefId),\nstrcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_release?_a=releases&view=mine&definitionId=', DefId))\n| where CurrentCount >= HistoricCount + NewConnectionThreshold\n| project StartTime, OrganizationName, ProjectName, DefId, link, RecentDistinctServiceConnections = CurrentCount, HistoricDistinctServiceConnections = HistoricCount, \n  RecentConnections = ConnectionNames, HistoricConnections = ConnectionNames1, ActorUPN\n| extend timestamp = StartTime, AccountCustomEntity = ActorUPN\n", "attributes": {"description": "'This detection builds an allow list of historic service connection use by Builds and Releases and compares to recent history, flagging growth of service connection use which are not manually included in the allow list and \nnot historically included in the allow list Build/Release runs.  This is to determine if someone is hijacking a build/release and adding many service connections in order to abuse or dump credentials from service connections.'\n", "techniques": ["T1098", "T1496"], "tactics": ["Persistence", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOPatSessionMisuse.yaml", "query_name": "Azure DevOps Personal Access Token (PAT) misuse", "query": "\n// Allowlisted UPNs should likely stay empty\nlet AllowlistedUpns = datatable(UPN:string)['foo@bar.com', 'test@foo.com'];\n// Operation Name parts that will alert\nlet HasAnyBlocklist = datatable(OperationNamePart:string)['Security.','Project.','AuditLog.','Extension.'];\n// Distinct Operation Names that will flag\nlet HasExactBlocklist = datatable(OperationName:string)['Group.UpdateGroupMembership.Add','Library.ServiceConnectionExecuted','Pipelines.PipelineModified',\n'Release.ReleasePipelineModified', 'Git.RefUpdatePoliciesBypassed'];\nAzureDevOpsAuditing\n| where AuthenticationMechanism startswith \"PAT\" and (OperationName has_any (HasAnyBlocklist) or OperationName in (HasExactBlocklist))\n  and ActorUPN !in (AllowlistedUpns)\n| project TimeGenerated, AuthenticationMechanism, ProjectName, ActorUPN, ActorDisplayName, IpAddress, UserAgent, OperationName, Details, Data\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This Alert detects whenever a PAT is used in ways that PATs are not normally used. May require an allow list and baselining.\nReference - https://docs.microsoft.com/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops&tabs=preview-page\nUse this query for baselining:\nAzureDevOpsAuditing\n| distinct OperationName'\n", "techniques": ["T1496", "T1559"], "tactics": ["Execution", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOPipelineCreatedDeletedOneDay.yaml", "query_name": "Azure DevOps Pipeline Created and Deleted on the Same Day", "query": "let timeframe = 3d;\n// Get Release Pipeline Creation Events and group by day\nAzureDevOpsAuditing\n| where TimeGenerated > ago(timeframe)\n| where OperationName =~ \"Release.ReleasePipelineCreated\"\n// Group by day\n| extend timekey = bin(TimeGenerated, 1d)\n| extend PipelineId = tostring(Data.PipelineId)\n| extend PipelineName = tostring(Data.PipelineName)\n// Rename some columns to make output clearer\n| project-rename TimeCreated = TimeGenerated, CreatingUser = ActorUPN, CreatingUserAgent = UserAgent, CreatingIP = IpAddress\n// Join with Release Pipeline Deletions where Pipeline ID is the same and deletion occurred on same day as creation\n| join (AzureDevOpsAuditing\n| where TimeGenerated > ago(timeframe)\n| where OperationName =~ \"Release.ReleasePipelineDeleted\"\n// Group by day\n| extend timekey = bin(TimeGenerated, 1d)\n| extend PipelineId = tostring(Data.PipelineId)\n| extend PipelineName = tostring(Data.PipelineName)\n// Rename some things to make the output clearer\n| project-rename TimeDeleted = TimeGenerated, DeletingUser = ActorUPN, DeletingUserAgent = UserAgent, DeletingIP = IpAddress) on PipelineId, timekey\n| project TimeCreated, TimeDeleted, PipelineName, PipelineId, CreatingUser, CreatingIP, CreatingUserAgent, DeletingUser, DeletingIP, DeletingUserAgent, ScopeDisplayName, ProjectName, Data, OperationName, OperationName1\n| extend timestamp = TimeCreated, AccountCustomEntity = CreatingUser, IPCustomEntity = CreatingIP\n", "attributes": {"description": "'An attacker with access to Azure DevOps could create a pipeline to inject artifacts used by other pipelines, \nor to create a malicious software build that looks legitimate by using a pipeline that incorporates legitimate elements. \nAn attacker would also likely want to cover their tracks once conducting such activity. This query looks for Pipelines \ncreated and deleted within the same day, this is unlikely to be legitimate user activity in the majority of cases.'\n", "techniques": ["T1072"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/AzDOServiceConnectionUsage.yaml", "query_name": "Azure DevOps Service Connection Abuse", "query": "\n// How many greater than Service Connections you want to view per build/release\nlet ServiceConnectionThreshold = 4;\nlet BypassDefIds = datatable(DefId:string, Type:string, ProjectName:string)\n[\n//\"103\", \"Release\", \"ProjectA\",\n//\"42\", \"Release\", \"ProjectB\",\n//\"122\", \"Build\", \"ProjectB\"\n];\nAzureDevOpsAuditing\n| where OperationName == \"Library.ServiceConnectionExecuted\" \n| extend DefId = tostring(Data.DefinitionId), Type = tostring(Data.PlanType), ConnectionId = tostring(Data.ConnectionId)\n| parse ScopeDisplayName with OrganizationName ' (Organization)'\n| summarize CurrentCount = dcount(tostring(ConnectionId)), ConnectionNames = make_set(tostring(Data.ConnectionName)), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) \n  by OrganizationName, tostring(DefId), tostring(Type), ProjectId, ProjectName\n| where CurrentCount > ServiceConnectionThreshold\n| join kind=anti BypassDefIds on $left.DefId==$right.DefId and $left.Type == $right.Type and $left.ProjectName == $right.ProjectName\n| extend link = iif(\n  Type == \"Build\", strcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_build?definitionId=', DefId),\n  strcat('https://dev.azure.com/', OrganizationName, '/', ProjectName, '/_release?_a=releases&view=mine&definitionId=', DefId))\n| extend timestamp = StartTime\n", "attributes": {"description": "'Flags builds/releases that use a large number of service connections if they aren't manually in the allow list.\nThis is to determine if someone is hijacking a build/release and adding many service connections in order to abuse \nor dump credentials from service connections.'\n", "techniques": ["T1098", "T1496"], "tactics": ["Persistence", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/ExternalUpstreamSourceAddedtoAzureDevOpsFeed.yaml", "query_name": "External Upstream Source Added to Azure DevOps Feed", "query": "// Add any known allowed sources and source locations to the filter below (the NuGet Gallery has been added here as an example).\nlet allowed_sources = dynamic([\"NuGet Gallery\"]);\nlet allowed_locations = dynamic([\"https://api.nuget.org/v3/index.json\"]);\nAzureDevOpsAuditing\n// Look for feeds created or modified at either the organization or project level\n| where OperationName matches regex \"Artifacts.Feed.(Org|Project).Modify\"\n| where Details has \"UpstreamSources, added\"\n| extend FeedName = tostring(Data.FeedName)\n| extend FeedId = tostring(Data.FeedId)\n| extend UpstreamsAdded = Data.UpstreamsAdded\n// As multiple feeds may be added expand these out\n| mv-expand UpstreamsAdded\n// Only focus on external feeds\n| where UpstreamsAdded.UpstreamSourceType !~ \"internal\"\n| extend SourceLocation = tostring(UpstreamsAdded.Location)\n| extend SourceName = tostring(UpstreamsAdded.Name)\n// Exclude sources and locations in the allow list\n| where SourceLocation !in (allowed_locations) and SourceName !in (allowed_sources)\n| extend SourceProtocol = tostring(UpstreamsAdded.Protocol)\n| extend SourceStatus = tostring(UpstreamsAdded.Status)\n| project-reorder TimeGenerated, OperationName, ScopeDisplayName, ProjectName, FeedName, SourceName, SourceLocation, SourceProtocol, ActorUPN, UserAgent, IpAddress\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity =  IpAddress\n", "attributes": {"description": "'The detection looks for new external sources added to an Azure DevOps feed. An allow list can be customized to explicitly allow known good sources. \nAn attacker could look to add a malicious feed in order to inject malicious packages into a build pipeline.'\n", "techniques": ["T1199"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/NewAgentAddedToPoolbyNewUserorofNewOS.yaml", "query_name": "New Agent Added to Pool by New User or Added to a New OS Type.", "query": "let lookback = 14d;\nlet timeframe = 1d;\n// exclude allowed users from query such as the ADO service\nlet allowed_users = dynamic([\"Azure DevOps Service\"]);\nunion\n// Look for agents being added to a pool of a OS type not seen with that pool before\n(AzureDevOpsAuditing\n| where TimeGenerated > ago(lookback) and TimeGenerated < ago(timeframe)\n| where OperationName =~ \"Library.AgentAdded\"\n| where ActorUPN !in (allowed_users)\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n| extend OsDescription = tostring(Data.OsDescription)\n| where isnotempty(OsDescription)\n| extend OsDescription = tostring(split(OsDescription, \"#\", 0)[0])\n| project AgentPoolName, OsDescription\n| join kind=rightanti (AzureDevOpsAuditing\n| where TimeGenerated > ago(timeframe)\n| where OperationName == \"Library.AgentAdded\"\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n| extend OsDescription = tostring(Data.OsDescription)\n| where isnotempty(OsDescription)\n| extend OsDescription = tostring(split(OsDescription, \"#\", 0)[0])) on AgentPoolName, OsDescription),\n// Look for users addeing agents to a pool that they have not added agents to before.\n(AzureDevOpsAuditing\n| where TimeGenerated > ago(lookback) and TimeGenerated < ago(timeframe)\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n| where ActorUPN !in (allowed_users)\n| project AgentPoolName, ActorUPN\n| join kind=rightanti (AzureDevOpsAuditing\n| where TimeGenerated > ago(timeframe)\n| where OperationName == \"Library.AgentAdded\"\n| where ActorUPN !in (allowed_users)\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n) on AgentPoolName, ActorUPN)\n| extend AgentName = tostring(Data.AgentName)\n| extend OsDescription = tostring(Data.OsDescription)\n| extend SystemDetails = Data.SystemCapabilities\n| project-reorder TimeGenerated, OperationName, ScopeDisplayName, AgentPoolName, AgentName, ActorUPN, IpAddress, UserAgent, OsDescription, SystemDetails, Data\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'As seen in attacks such as SolarWinds attackers can look to subvert a build process by controlling build servers. Azure DevOps uses agent pools to execute pipeline tasks. \nAn attacker could insert compromised agents that they control into the pools in order to execute malicious code. This query looks for users adding agents to pools they have \nnot added agents to before, or adding agents to a pool of an OS that has not been added to that pool before. This detection has potential for false positives so has a \nconfigurable allow list to allow for certain users to be excluded from the logic.'\n", "techniques": ["T1053"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/NewPAPCAPCASaddedtoADO.yaml", "query_name": "New PA, PCA, or PCAS added to Azure DevOps", "query": "AzureDevOpsAuditing\n| where OperationName =~ \"Group.UpdateGroupMembership.Add\"\n| where Details has_any (\"Project Administrators\", \"Project Collection Administrators\", \"Project Collection Service Accounts\", \"Build Administrator\")\n| project-reorder TimeGenerated, Details, ActorUPN, IpAddress, UserAgent, AuthenticationMechanism, ScopeDisplayName\n| extend timekey = bin(TimeGenerated, 1h)\n| extend ActorUserId = tostring(Data.MemberId)\n| project timekey, ActorUserId, AddingUser=ActorUPN, TimeAdded=TimeGenerated, PermissionGrantDetails = Details\n// Get details of operations conducted by user soon after elevation of permissions\n| join (AzureDevOpsAuditing\n| extend ActorUserId = tostring(Data.MemberId)\n| extend timekey = bin(TimeGenerated, 1h)) on timekey, ActorUserId\n| summarize ActionsWhenAdded = make_set(OperationName) by ActorUPN, AddingUser, TimeAdded, PermissionGrantDetails, IpAddress, UserAgent\n| extend timestamp = TimeAdded, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'In order for an attacker to be able to conduct many potential attacks against Azure DevOps they will need to gain elevated permissions. \nThis detection looks for users being granted key administrative permissions. If the principal of least privilege is applied, the number of \nusers granted these permissions should be small. Note that permissions can also be granted via Azure AD groups and monitoring of these \nshould also be conducted.'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDevOpsAuditing/NRT_ADOAuditStreamDisabled.yaml", "query_name": "NRT Azure DevOps Audit Stream Disabled", "query": "AzureDevOpsAuditing\n| where OperationName =~ \"AuditLog.StreamDisabledByUser\"\n| extend StreamType = tostring(Data.ConsumerType)\n| project-reorder TimeGenerated, Details, ActorUPN, IpAddress, UserAgent, StreamType\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Azure DevOps allow for audit logs to be streamed to external storage solutions such as SIEM solutions. An attacker looking to hide malicious Azure DevOps activity from defenders may look to disable data streams \n before conducting activity and then re-enabling the stream after (so as not to raise data threshold-based alarms). Looking for disabled audit streams can identify this activity, and due to the nature of the action \n its unlikely to have a high false positive rate.'\n", "techniques": ["T1562.008"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureDiagnostics/MaliciousWAFSessions.yaml", "query_name": "A potentially malicious web request was executed against a web server", "query": "let queryperiod = 1d;\nlet mode = 'Blocked';\nlet successCode = dynamic(['200', '101','204', '400','504','304','401','500']);\nlet sessionBin = 30m;\nAzureDiagnostics\n| where TimeGenerated > ago(queryperiod)\n| where Category == 'ApplicationGatewayFirewallLog' and action_s == mode\n| sort by hostname_s asc, clientIp_s asc, TimeGenerated asc\n| extend SessionBlockedStarted = row_window_session(TimeGenerated, queryperiod, 10m, ((clientIp_s != prev(clientIp_s)) or (hostname_s != prev(hostname_s))))\n| summarize SessionBlockedEnded = max(TimeGenerated), SessionBlockedCount = count() by hostname_s, clientIp_s, SessionBlockedStarted\n| extend TimeKey = range(bin(SessionBlockedStarted, sessionBin), bin(SessionBlockedEnded, sessionBin), sessionBin)\n| mv-expand TimeKey to typeof(datetime)\n| join kind = inner(\n    AzureDiagnostics\n    | where TimeGenerated > ago(queryperiod)\n    | where Category == 'ApplicationGatewayAccessLog' and (isempty(httpStatus_d) or httpStatus_d in (successCode))\n    | extend TimeKey = bin(TimeGenerated, sessionBin)\n) on TimeKey, $left.hostname_s == $right.host_s, $left.clientIp_s == $right.clientIP_s\n| where TimeGenerated between (SessionBlockedStarted..SessionBlockedEnded)\n| extend\n    originalRequestUriWithArgs_s = column_ifexists(\"originalRequestUriWithArgs_s\", \"\"),\n    serverStatus_s = column_ifexists(\"serverStatus_s\", \"\")\n| summarize\n    SuccessfulAccessCount = count(),\n    UserAgents = make_set(userAgent_s, 250),\n    RequestURIs = make_set(requestUri_s, 250),\n    OriginalRequestURIs = make_set(originalRequestUriWithArgs_s, 250),\n    SuccessCodes = make_set(httpStatus_d, 250),\n    SuccessCodes_BackendServer = make_set(serverStatus_s, 250),\n    take_any(SessionBlockedEnded, SessionBlockedCount)\n    by hostname_s, clientIp_s, SessionBlockedStarted\n| where SessionBlockedCount > SuccessfulAccessCount\n| extend timestamp = SessionBlockedStarted, IPCustomEntity = clientIp_s\n| extend BlockvsSuccessRatio = SessionBlockedCount/toreal(SuccessfulAccessCount)\n| sort by BlockvsSuccessRatio desc, timestamp asc\n| project-reorder SessionBlockedStarted, SessionBlockedEnded, hostname_s, clientIp_s, SessionBlockedCount, SuccessfulAccessCount, BlockvsSuccessRatio, SuccessCodes, RequestURIs, OriginalRequestURIs, UserAgents\n", "attributes": {"description": "'Detects unobstructed Web Application Firewall (WAF) activity in sessions where the WAF blocked incoming requests by computing the \nratio between blocked requests and unobstructed WAF requests in these sessions (BlockvsSuccessRatio metric). A high ratio value for \na given client IP and hostname calls for further investigation of the WAF data in that session, due to the significantly high number \nof blocked requests and a few unobstructed logs which may be malicious but have passed undetected through the WAF. The successCode \nvariable defines what the detection thinks is a successful status code, and should be altered to fit the environment.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureWAF/AppGwWAF-SQLiDetection.yaml", "query_name": "Application Gateway WAF - SQLi Detection", "query": "let Threshold = 3;\nAzureDiagnostics\n| where Category == \"ApplicationGatewayFirewallLog\"\n| where action_s == \"Matched\"\n| project transactionId_g, hostname_s, requestUri_s, TimeGenerated, clientIp_s, Message, details_message_s, details_data_s\n| join kind = inner(\nAzureDiagnostics\n| where Category == \"ApplicationGatewayFirewallLog\"\n| where action_s == \"Blocked\"\n| parse Message with MessageText 'Total Inbound Score: ' TotalInboundScore ' - SQLI=' SQLI_Score ',XSS=' XSS_Score ',RFI=' RFI_Score ',LFI=' LFI_Score ',RCE=' RCE_Score ',PHPI=' PHPI_Score ',HTTP=' HTTP_Score ',SESS=' SESS_Score '): ' Blocked_Reason '; individual paranoia level scores:' Paranoia_Score\n| where Blocked_Reason contains \"SQL Injection Attack\" and toint(SQLI_Score) >=10 and toint(TotalInboundScore) >= 15) on transactionId_g\n| extend Uri = strcat(hostname_s,requestUri_s)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), TransactionID = make_set(transactionId_g), Message = make_set(Message), Detail_Message = make_set(details_message_s), Detail_Data = make_set(details_data_s), Total_TransactionId = dcount(transactionId_g) by clientIp_s, Uri, action_s, SQLI_Score, TotalInboundScore\n| where Total_TransactionId >= Threshold\n", "attributes": {"description": "'Identifies a match for SQL Injection attack in the Application gateway WAF logs. The Threshold value in the query can be changed as per your infrastructure's requirement.\n References: https://owasp.org/Top10/A03_2021-Injection/'\n", "techniques": ["T1211", "T1059", "T1190", "T0890"], "tactics": ["DefenseEvasion", "Execution", "InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AzureWAF/AppGwWAF-XSSDetection.yaml", "query_name": "Application Gateway WAF - XSS Detection", "query": "let Threshold = 1;  \n AzureDiagnostics\n | where Category == \"ApplicationGatewayFirewallLog\"\n | where action_s == \"Matched\"\n | project transactionId_g, hostname_s, requestUri_s, TimeGenerated, clientIp_s, Message, details_message_s, details_data_s\n | join kind = inner(\n AzureDiagnostics\n | where Category == \"ApplicationGatewayFirewallLog\"\n | where action_s == \"Blocked\"\n | parse Message with MessageText 'Total Inbound Score: ' TotalInboundScore ' - SQLI=' SQLI_Score ',XSS=' XSS_Score ',RFI=' RFI_Score ',LFI=' LFI_Score ',RCE=' RCE_Score ',PHPI=' PHPI_Score ',HTTP=' HTTP_Score ',SESS=' SESS_Score '): ' Blocked_Reason '; individual paranoia level scores:' Paranoia_Score\n | where Blocked_Reason contains \"XSS\" and toint(TotalInboundScore) >=15 and toint(XSS_Score) >= 10 and toint(SQLI_Score) <= 5) on transactionId_g\n | extend Uri = strcat(hostname_s,requestUri_s)\n | summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), TransactionID = make_set(transactionId_g), Message = make_set(Message), Detail_Message = make_set(details_message_s), Detail_Data = make_set(details_data_s), Total_TransactionId = dcount(transactionId_g) by clientIp_s, Uri, action_s, SQLI_Score, XSS_Score, TotalInboundScore\n | where Total_TransactionId >= Threshold\n", "attributes": {"description": "'Identifies a match for XSS attack in the Application gateway WAF logs. The Threshold value in the query can be changed as per your infrastructure's requirement.\n References: https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)'\n", "techniques": ["T1189", "T1203", "T0853"], "tactics": ["InitialAccess", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaConnectionNon-CorporatePrivateNetwork.yaml", "query_name": "Cisco Umbrella - Connection to non-corporate private network", "query": "let lbtime = 10m;\nCisco_Umbrella\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'proxylogs'\n| where DvcAction =~ 'Allowed'\n| where UrlCategory has_any ('Dynamic and Residential', 'Personal VPN')\n| project TimeGenerated, SrcIpAddr, Identities\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = Identities\n", "attributes": {"description": "'IP addresses of broadband links that usually indicates users attempting to access their home network, for example for a remote session to a home computer.'\n", "techniques": NaN, "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaConnectionToUnpopularWebsiteDetected.yaml", "query_name": "Cisco Umbrella - Connection to Unpopular Website Detected", "query": "let domain_lookBack= 14d;\nlet timeframe = 1d;\nlet top_million_list = Cisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(domain_lookBack) and TimeGenerated < ago(timeframe)\n| extend Hostname = parse_url(UrlOriginal)[\"Host\"]\n| summarize count() by tostring(Hostname)\n| top 1000000 by count_\n| summarize make_list(Hostname);\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| extend Hostname = parse_url(UrlOriginal)[\"Host\"]\n| where Hostname !in (top_million_list)\n| extend Message = \"Connect to unpopular website (possible malicious payload delivery)\"\n| project Message, SrcIpAddr, DstIpAddr,UrlOriginal, TimeGenerated\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects first connection to an unpopular website (possible malicious payload delivery).'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaCryptoMinerUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Crypto Miner User-Agent Detected", "query": "let timeframe = 15m;\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal contains \"XMRig\" or HttpUserAgentOriginal contains \"ccminer\"\n| extend Message = \"Crypto Miner User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated,HttpUserAgentOriginal\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects suspicious user agent strings used by crypto miners in proxy logs.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaEmptyUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Empty User Agent Detected", "query": "let timeframe = 15m;\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal == ''\n| extend Message = \"Empty User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Rule helps to detect empty and unusual user agent indicating web browsing activity by an unusual process other than a web browser.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaHackToolUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Hack Tool User-Agent Detected", "query": "let timeframe = 15m;\nlet user_agents=dynamic([\n                          '(hydra)',\n                          ' arachni/',\n                          ' BFAC ',\n                          ' brutus ',\n                          ' cgichk ',\n                          'core-project/1.0',\n                          ' crimscanner/',\n                          'datacha0s',\n                          'dirbuster',\n                          'domino hunter',\n                          'dotdotpwn',\n                          'FHScan Core',\n                          'floodgate',\n                          'get-minimal',\n                          'gootkit auto-rooter scanner',\n                          'grendel-scan',\n                          ' inspath ',\n                          'internet ninja',\n                          'jaascois',\n                          ' zmeu ',\n                          'masscan',\n                          ' metis ',\n                          'morfeus fucking scanner',\n                          'n-stealth',\n                          'nsauditor',\n                          'pmafind',\n                          'security scan',\n                          'springenwerk',\n                          'teh forest lobster',\n                          'toata dragostea',\n                          ' vega/',\n                          'voideye',\n                          'webshag',\n                          'webvulnscan',\n                          ' whcc/',\n                          ' Havij',\n                          'absinthe',\n                          'bsqlbf',\n                          'mysqloit',\n                          'pangolin',\n                          'sql power injector',\n                          'sqlmap',\n                          'sqlninja',\n                          'uil2pn',\n                          'ruler',\n                          'Mozilla/5.0 (Windows; U; Windows NT 5.1; pt-PT; rv:1.9.1.2) Gecko/20090729 Firefox/3.5.2 (.NET CLR 3.5.30729)'\n                          ]);\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal has_any (user_agents)\n| extend Message = \"Hack Tool User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated, HttpUserAgentOriginal\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects suspicious user agent strings used by known hack tools'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaPowershellUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Windows PowerShell User-Agent Detected", "query": "let timeframe = 15m;\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal contains \"WindowsPowerShell\"\n| extend Message = \"Windows PowerShell User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated,HttpUserAgentOriginal\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Rule helps to detect Powershell user-agent activity by an unusual process other than a web browser.'\n", "techniques": NaN, "tactics": ["CommandAndControl", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaRareUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Rare User Agent Detected", "query": "let lookBack = 14d;\nlet timeframe = 1d;\nlet user_agents_list = Cisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(lookBack) and TimeGenerated < ago(timeframe)\n| summarize count() by HttpUserAgentOriginal\n| summarize make_list(HttpUserAgentOriginal);\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal !in (user_agents_list)\n| extend Message = \"Rare User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated, HttpUserAgentOriginal\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Rule helps to detect a rare user-agents indicating web browsing activity by an unusual process other than a web browser.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaRequestAllowedHarmfulMaliciousURICategory.yaml", "query_name": "Cisco Umbrella - Request Allowed to harmful/malicious URI category", "query": "let lbtime = 10m;\nCisco_Umbrella\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'proxylogs'\n| where DvcAction =~ 'Allowed'\n| where UrlCategory contains 'Adult Themes' or\n      UrlCategory contains 'Adware' or\n      UrlCategory contains 'Alcohol' or\n      UrlCategory contains 'Illegal Downloads' or\n      UrlCategory contains 'Drugs' or\n      UrlCategory contains 'Child Abuse Content' or\n      UrlCategory contains 'Hate/Discrimination' or\n      UrlCategory contains 'Nudity' or\n      UrlCategory contains 'Pornography' or\n      UrlCategory contains 'Proxy/Anonymizer' or\n      UrlCategory contains 'Sexuality' or\n      UrlCategory contains 'Tasteless' or\n      UrlCategory contains 'Terrorism' or\n      UrlCategory contains 'Web Spam' or\n      UrlCategory contains 'German Youth Protection' or\n      UrlCategory contains 'Illegal Activities' or\n      UrlCategory contains 'Lingerie/Bikini' or\n      UrlCategory contains 'Weapons'\n| project TimeGenerated, SrcIpAddr, Identities\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = Identities\n", "attributes": {"description": "'It is reccomended that these Categories shoud be blocked by policies because they provide harmful/malicious content..'\n", "techniques": NaN, "tactics": ["CommandAndControl", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaRequestBlocklistedFileType.yaml", "query_name": "Cisco Umbrella - Request to blocklisted file type", "query": "let file_ext_blocklist = dynamic(['.ps1', '.vbs', '.bat', '.scr']);\nlet lbtime = 10m;\nCisco_Umbrella\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'proxylogs'\n| where DvcAction =~ 'Allowed'\n| extend file_ext = extract(@'.*(\\.\\w+)$', 1, UrlOriginal)\n| extend Filename = extract(@'.*\\/*\\/(.*\\.\\w+)$', 1, UrlOriginal)\n| where file_ext in (file_ext_blocklist)\n| project TimeGenerated, SrcIpAddr, Identities, Filename\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = Identities\n", "attributes": {"description": "'Detects request to potentially harmful file types (.ps1, .bat, .vbs, etc.).'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CiscoUmbrella/CiscoUmbrellaURIContainsIPAddress.yaml", "query_name": "Cisco Umbrella - URI contains IP address", "query": "let lbtime = 10m;\nCisco_Umbrella\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'proxylogs'\n| where DvcAction =~ 'Allowed'\n| where UrlOriginal matches regex @'\\Ahttp:\\/\\/\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}.*'\n| project TimeGenerated, SrcIpAddr, Identities\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = Identities\n", "attributes": {"description": "'Malware can use IP address to communicate with C2.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/CreepyDriveRequestSequence.yaml", "query_name": "CreepyDrive request URL sequence", "query": "let eventsThreshold = 20;\nCommonSecurityLog\n| where isnotempty(RequestURL)\n| project TimeGenerated, RequestURL, RequestMethod, SourceIP, SourceHostName\n| evaluate sequence_detect(TimeGenerated, 5s, 8s, login=(RequestURL has \"login.microsoftonline.com/consumers/oauth2/v2.0/token\"), graph=(RequestURL has \"graph.microsoft.com/v1.0/me/drive/\"), SourceIP, SourceHostName)\n| summarize Events=count() by SourceIP, SourceHostName\n| where Events >= eventsThreshold\n", "attributes": {"description": "'CreepyDrive uses OneDrive for command and control, however, it makes regular requests to predicatable paths.\nThis detecton will alert when over 20 sequences are observed in a single day.'\n", "techniques": ["T1567.002", "T1102.002"], "tactics": ["Exfiltration", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/CreepyDriveURLs.yaml", "query_name": "CreepyDrive URLs", "query": "let oneDriveCalls = dynamic(['graph.microsoft.com/v1.0/me/drive/root:/Documents/data.txt:/content','graph.microsoft.com/v1.0/me/drive/root:/Documents/response.json:/content']);\nlet oneDriveCallsRegex = dynamic([@'graph\\.microsoft\\.com\\/v1\\.0\\/me\\/drive\\/root\\:\\/Uploaded\\/.*\\:\\/content',@'graph\\.microsoft\\.com\\/v1\\.0\\/me\\/drive\\/root\\:\\/Downloaded\\/.*\\:\\/content']);\nCommonSecurityLog\n| where RequestURL has_any (oneDriveCalls) or RequestURL matches regex tostring(oneDriveCallsRegex[0]) or RequestURL matches regex tostring(oneDriveCallsRegex[1])\n| project TimeGenerated, DeviceVendor, DeviceProduct, DeviceAction, DestinationDnsDomain, DestinationIP, RequestURL, SourceIP, SourceHostName, RequestClientApplication\n", "attributes": {"description": "'CreepyDrive uses OneDrive for command and control. This detection identifies URLs specific to CreepyDrive.'\n", "techniques": ["T1567.002", "T1102.002"], "tactics": ["Exfiltration", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/CreepySnailURLParameters.yaml", "query_name": "RunningRAT request parameters", "query": "let runningRAT_parameters = dynamic(['/ui/chk', 'mactok=', 'UsRnMe=', 'IlocalP=', 'kMnD=']);\nCommonSecurityLog\n| where RequestMethod == \"GET\"\n| project TimeGenerated, DeviceVendor, DeviceProduct, DeviceAction, DestinationDnsDomain, DestinationIP, RequestURL, SourceIP, SourceHostName, RequestClientApplication\n| where RequestURL has_any (runningRAT_parameters)\n", "attributes": {"description": "'This detection will alert when RunningRAT URI parameters or paths are detect in an HTTP request. Id the device blocked this communication\npresence of this alert means the RunningRAT implant is likely still executing on the source host.'\n", "techniques": ["T1041", "T1071.001"], "tactics": ["Exfiltration", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/Fortinet-NetworkBeaconPattern.yaml", "query_name": "Fortinet - Beacon pattern detected", "query": "\nlet starttime = 1d;\nlet TimeDeltaThresholdInSeconds = 60; // we ignore beacons diffs that fall below this threshold \nlet TotalBeaconsThreshold = 4; // minimum number of beacons required in a session to surface a row\nlet JitterTolerance = 0.2; // tolerance to jitter, e.g. - 0.2 = 20% jitter is tolerated either side of the periodicity\nCommonSecurityLog\n| where DeviceVendor == \"Fortinet\"\n| where TimeGenerated > ago(starttime)\n// eliminate bad data\n| where isnotempty(SourceIP) and isnotempty(DestinationIP) and SourceIP != \"0.0.0.0\"\n// filter out deny, close, rst and SNMP to reduce data volume\n| where DeviceAction !in (\"close\", \"client-rst\", \"server-rst\", \"deny\") and DestinationPort != 161\n// map input fields\n| project TimeGenerated , SourceIP, DestinationIP, DestinationPort, ReceivedBytes, SentBytes, DeviceAction \n// where destination IPs are public\n| where ipv4_is_private(DestinationIP) == false\n// sort into source->destination 'sessions'\n| sort by SourceIP asc, DestinationIP asc, DestinationPort asc, TimeGenerated asc\n| serialize\n// time diff the contact times between source and destination to get a list of deltas\n| extend nextTimeGenerated = next(TimeGenerated, 1), nextSourceIP = next(SourceIP, 1), nextDestIP = next(DestinationIP, 1), nextDestPort = next(DestinationPort, 1)\n| extend TimeDeltainSeconds = datetime_diff(\"second\",nextTimeGenerated,TimeGenerated)\n| where SourceIP == nextSourceIP and DestinationIP == nextDestIP and DestinationPort == nextDestPort\n// remove small time deltas below the set threshold\n| where TimeDeltainSeconds > TimeDeltaThresholdInSeconds\n// summarize the deltas by source->destination\n| summarize count(), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), sum(ReceivedBytes), sum(SentBytes), makelist(TimeDeltainSeconds), makeset(DeviceAction) by SourceIP, DestinationIP, DestinationPort\n// get some statistical properties of the delta distribution and smooth any outliers (e.g. laptop shut overnight, working hours)\n| extend series_stats(list_TimeDeltainSeconds), outliers=series_outliers(list_TimeDeltainSeconds)\n// expand the deltas and the outliers\n| mvexpand list_TimeDeltainSeconds to typeof(double), outliers to typeof(double)\n// replace outliers with the average of the distribution\n| extend list_TimeDeltainSeconds_normalized=iff(outliers > 1.5 or outliers < -1.5, series_stats_list_TimeDeltainSeconds_avg , list_TimeDeltainSeconds)\n// summarize with the smoothed distribution\n| summarize BeaconCount=count(), makelist(list_TimeDeltainSeconds), list_TimeDeltainSeconds_normalized=makelist(list_TimeDeltainSeconds_normalized), makeset(set_DeviceAction) by StartTime, EndTime, SourceIP, DestinationIP, DestinationPort, sum_ReceivedBytes, sum_SentBytes\n// get stats on the smoothed distribution\n| extend series_stats(list_TimeDeltainSeconds_normalized)\n// match jitter tolerance on smoothed distrib\n| extend MaxJitter = (series_stats_list_TimeDeltainSeconds_normalized_avg*JitterTolerance)\n| where series_stats_list_TimeDeltainSeconds_normalized_stdev < MaxJitter\n// where the minimum beacon threshold is satisfied and there was some data transfer\n| where BeaconCount > TotalBeaconsThreshold and (sum_SentBytes > 0 or sum_ReceivedBytes > 0)\n// final projection\n| project StartTime, EndTime, SourceIP, DestinationIP, DestinationPort, BeaconCount, TimeDeltasInSeconds=list_list_TimeDeltainSeconds, Periodicity=series_stats_list_TimeDeltainSeconds_normalized_avg, ReceivedBytes=sum_ReceivedBytes, SentBytes=sum_SentBytes, Actions=set_set_DeviceAction\n// where periodicity is order of magnitude larger than time delta threshold (eliminates FPs whose periodicity is close to the values we ignored)\n| where Periodicity >= (10*TimeDeltaThresholdInSeconds)\n| extend timestamp = StartTime, IPCustomEntity = DestinationIP\n", "attributes": {"description": "'Identifies patterns in the time deltas of contacts between internal and external IPs in Fortinet network data that are consistent with beaconing.\n Accounts for randomness (jitter) and seasonality such as working hours that may have been introduced into the beacon pattern.\n The lookback is set to 1d, the minimum granularity in time deltas is set to 60 seconds and the minimum number of beacons required to emit a\n detection is set to 4.\n Increase the lookback period to capture beacons with larger periodicities.\n The jitter tolerance is set to 0.2 - This means we account for an overall 20% deviation from the infered beacon periodicity. Seasonality is dealt with\n automatically using series_outliers.\n Note: In large environments it may be necessary to reduce the lookback period to get fast query times.'\n", "techniques": ["T1071", "T1571"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/MultiVendor-PossibleDGAContacts.yaml", "query_name": "Possible contact with a domain generated by a DGA", "query": "\nlet triThreshold = 500;\nlet startTime = 6h;\nlet dgaLengthThreshold = 8;\n// fetch the alexa top 1M domains\nlet top1M =  (externaldata (Position:int, Domain:string)   [@\"http://s3-us-west-1.amazonaws.com/umbrella-static/top-1m.csv.zip\"]  with (format=\"csv\", zipPattern=\"*.csv\"));\n// extract tri grams that are above our threshold - i.e. are common\nlet triBaseline =   top1M\n| extend Domain = tolower(extract(\"([^.]*).{0,7}$\", 1, Domain))\n| extend AllTriGrams = array_concat(extract_all(\"(...)\", Domain), extract_all(\"(...)\", substring(Domain, 1)), extract_all(\"(...)\", substring(Domain, 2)))\n| mvexpand Trigram=AllTriGrams\n| summarize triCount=count() by tostring(Trigram)\n| sort by triCount desc\n| where triCount > triThreshold\n| distinct Trigram;\n// collect domain information from common security log, filter and extract the DGA candidate and its trigrams\nlet allDataSummarized =   CommonSecurityLog\n| where TimeGenerated > ago(startTime)\n| where isnotempty(DestinationHostName)\n| extend Name = tolower(DestinationHostName)\n| distinct Name\n| where Name has \".\"\n| where Name !endswith \".home\" and Name !endswith \".lan\"\n// extract DGA candidate\n| extend DGADomain = extract(\"([^.]*).{0,7}$\", 1, Name)\n| where strlen(DGADomain) > dgaLengthThreshold\n// throw out domains with number in them\n| where DGADomain matches regex \"^[A-Za-z]{0,}$\"\n// extract the tri grams from summarized data\n| extend AllTriGrams = array_concat(extract_all(\"(...)\", DGADomain), extract_all(\"(...)\", substring(DGADomain, 1)), extract_all(\"(...)\", substring(DGADomain, 2)));\n// throw out domains that have repeating tri's and/or >=3 repeating letters\nlet nonRepeatingTris =  allDataSummarized\n| join kind=leftanti\n(\n    allDataSummarized\n    | mvexpand AllTriGrams\n    | summarize count() by tostring(AllTriGrams), DGADomain\n    | where count_ > 1\n    | distinct DGADomain\n)\non DGADomain;\n// find domains that do not have a common tri in the baseline\nlet dataWithRareTris =  nonRepeatingTris\n| join kind=leftanti\n(\n    nonRepeatingTris\n    | mvexpand AllTriGrams\n    | extend Trigram = tostring(AllTriGrams)\n    | distinct Trigram, DGADomain\n    | join kind=inner\n    (\n        triBaseline\n    )\n    on Trigram\n    | distinct DGADomain\n)\non DGADomain;\ndataWithRareTris\n// join DGAs back on connection data\n| join kind=inner\n(\n    CommonSecurityLog\n    | where TimeGenerated > ago(startTime)\n    | where isnotempty(DestinationHostName)\n    | extend DestinationHostName = tolower(DestinationHostName)\n    | project-rename Name=DestinationHostName, DataSource=DeviceVendor\n    | summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Name, SourceIP, DestinationIP, DataSource\n)\non Name\n| project StartTime, EndTime, Name, DGADomain, SourceIP, DestinationIP, DataSource\n| extend timestamp=StartTime, IPCustomEntity=SourceIP\n", "attributes": {"description": "'Identifies contacts with domains names in CommonSecurityLog that might have been generated by a Domain Generation Algorithm (DGA). DGAs can be used\nby malware to generate rendezvous points that are difficult to predict in advance. This detection uses the Alexa Top 1 million domain names to build a model\nof what normal domains look like. It uses this to identify domains that may have been randomly generated by an algorithm.\nThe triThreshold is set to 500 - increase this to report on domains that are less likely to have been randomly generated, decrease it for more likely.\nThe start time and end time look back over 6 hours of data and the dgaLengthThreshold is set to 8 - meaning domains whose length is 8 or more are reported.'\n", "techniques": ["T1568"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/TimeSeriesAnomaly-MultiVendor_NetworkTraffic.yaml", "query_name": "Time series anomaly detection for total volume of traffic", "query": "\nlet starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet scorethreshold = 5;\nlet percentotalthreshold = 50;\nlet TimeSeriesData = CommonSecurityLog\n| where isnotempty(DestinationIP) and isnotempty(SourceIP)\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| project TimeGenerated,SourceIP, DestinationIP, DeviceVendor\n| make-series Total=count() on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by DeviceVendor;\n// Filtering specific records associated with spikes as outliers\nlet TimeSeriesAlerts=materialize(TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, scorethreshold, -1, 'linefit')\n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)\n| where anomalies > 0 | extend score = round(score,2), AnomalyHour = TimeGenerated\n| project DeviceVendor,AnomalyHour, TimeGenerated, Total, baseline, anomalies, score);\nlet AnomalyHours = materialize(TimeSeriesAlerts  | where TimeGenerated > ago(2d) | project TimeGenerated);\n// Join anomalies with Base Data to popalate associated records for investigation - Results sorted by score in descending order\nTimeSeriesAlerts\n| where TimeGenerated > ago(2d)\n| join (\n    CommonSecurityLog\n| where isnotempty(DestinationIP) and isnotempty(SourceIP)\n| where TimeGenerated > ago(2d)\n| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour\n| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours\n| summarize HourlyCount = count(), TimeGeneratedMax = arg_max(TimeGenerated, *), DestinationIPlist = make_set(DestinationIP, 100), DestinationPortlist = make_set(DestinationPort, 100) by DeviceVendor, SourceIP, TimeGeneratedHour= bin(TimeGenerated, 1h)\n| extend AnomalyHour = TimeGeneratedHour\n) on AnomalyHour, DeviceVendor\n| extend PercentTotal = round((HourlyCount / Total) * 100, 3)\n| where PercentTotal > percentotalthreshold\n| project DeviceVendor , AnomalyHour, TimeGeneratedMax, SourceIP, DestinationIPlist, DestinationPortlist, HourlyCount, PercentTotal, Total, baseline, score, anomalies\n| summarize HourlyCount=sum(HourlyCount), StartTimeUtc=min(TimeGeneratedMax), EndTimeUtc=max(TimeGeneratedMax), SourceIPlist = make_set(SourceIP, 100), SourceIPMax= arg_max(SourceIP, *), DestinationIPlist = make_set(DestinationIPlist, 100), DestinationPortlist = make_set(DestinationPortlist, 100) by DeviceVendor , AnomalyHour, Total, baseline, score, anomalies\n| project DeviceVendor , AnomalyHour, EndTimeUtc, SourceIPMax ,SourceIPlist, DestinationIPlist, DestinationPortlist, HourlyCount, Total, baseline, score, anomalies\n| extend timestamp= EndTimeUtc , IPCustomEntity = SourceIPMax\n", "attributes": {"description": "'Identifies anamalous spikes in network traffic logs as compared to baseline or normal historical patterns.\nThe query leverages a KQL built-in anomaly detection algorithm to find large deviations from baseline patterns.\nSudden increases in network traffic volume may be an indication of data exfiltration attempts and should be investigated.\nThe higher the score, the further it is from the baseline value.\nThe output is aggregated to provide summary view of unique source IP to destination IP address and port traffic observed in the flagged anomaly hour.\nThe source IP addresses which were sending less than percentotalthreshold of the total traffic have been exluded whose value can be adjusted as needed .\nYou may have to run queries for individual source IP addresses from SourceIPlist to determine if anything looks suspicious'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/CommonSecurityLog/Wazuh-Large%20Number%20of%20Web%20errors%20from%20an%20IP.yaml", "query_name": "Wazuh - Large Number of Web errors from an IP", "query": "\nCommonSecurityLog\n| where DeviceProduct =~ \"Wazuh\"\n| where Activity has \"Web server 400 error code.\"\n| where Message has \"403\"\n| extend HostName=substring(split(DeviceCustomString1,\")\")[0],1)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), NumberOfErrors = dcount(SourceIP) by HostName, SourceIP\n| where NumberOfErrors > 400\n| sort by NumberOfErrors desc\n| extend timestamp = StartTime, HostCustomEntity = HostName, IPCustomEntity = SourceIP\n", "attributes": {"description": "'Identifies instances where Wazuh logged over 400 '403' Web Errors from one IP Address. To onboard Wazuh data into Sentinel please view: https://github.com/wazuh/wazuh-documentation/blob/master/source/azure/monitoring%20activity.rst'\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/DeviceFileEvents/PEfiledroppedinColorDriversFolder.yaml", "query_name": "PE file dropped in Color Profile Folder", "query": "DeviceFileEvents\n  | where ActionType =~ \"FileCreated\"\n  | where FolderPath has \"C:\\\\Windows\\\\System32\\\\spool\\\\drivers\\\\color\\\\\" \n  | where FileName endswith \".exe\" or FileName endswith \".dll\"\n", "attributes": {"description": "'This query looks for writes of PE files to C:\\Windows\\System32\\spool\\drivers\\color\\.\n  This is a common directory used by malware, as well as some legitimate programs, and writes of PE files to the folder should be monitored.\n  Ref: https://www.microsoft.com/security/blog/2022/07/27/untangling-knotweed-european-private-sector-offensive-actor-using-0-day-exploits/'\n", "techniques": ["T1203"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/DeviceProcessEvents/AdFind_Usage.yaml", "query_name": "Probable AdFind Recon Tool Usage", "query": "\nlet args = dynamic([\"objectcategory\",\"domainlist\",\"dcmodes\",\"adinfo\",\"trustdmp\",\"computers_pwdnotreqd\",\"Domain Admins\", \"objectcategory=person\", \"objectcategory=computer\", \"objectcategory=*\",\"dclist\"]);\nlet parentProcesses = dynamic([\"pwsh.exe\",\"powershell.exe\",\"cmd.exe\"]);\nDeviceProcessEvents\n//looks for execution from a shell\n| where InitiatingProcessFileName in (parentProcesses)\n// main filter\n| where FileName =~ \"AdFind.exe\" or SHA256 == \"c92c158d7c37fea795114fa6491fe5f145ad2f8c08776b18ae79db811e8e36a3\"\n   // AdFind common Flags to check for from various threat actor TTPs\n    or ProcessCommandLine has_any (args)\n| extend AccountCustomEntity = AccountName, HostCustomEntity = DeviceName, ProcessCustomEntity = InitiatingProcessFileName, CommandLineCustomEntity = ProcessCommandLine, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = SHA256\n", "attributes": {"description": "'Identifies the host and account that executed AdFind by hash and filename in addition to common and unique flags that are used by many threat actors in discovery.'\n", "techniques": ["T1018"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/DeviceProcessEvents/SolarWinds_SUNBURST_Process-IOCs.yaml", "query_name": "SUNBURST suspicious SolarWinds child processes", "query": "\nlet excludeProcs = dynamic([@\"\\SolarWinds\\Orion\\APM\\APMServiceControl.exe\", @\"\\SolarWinds\\Orion\\ExportToPDFCmd.Exe\", @\"\\SolarWinds.Credentials\\SolarWinds.Credentials.Orion.WebApi.exe\", @\"\\SolarWinds\\Orion\\Topology\\SolarWinds.Orion.Topology.Calculator.exe\", @\"\\SolarWinds\\Orion\\Database-Maint.exe\", @\"\\SolarWinds.Orion.ApiPoller.Service\\SolarWinds.Orion.ApiPoller.Service.exe\", @\"\\Windows\\SysWOW64\\WerFault.exe\"]);\nDeviceProcessEvents\n| where InitiatingProcessFileName =~ \"solarwinds.businesslayerhost.exe\"\n| where not(FolderPath has_any (excludeProcs))\n| extend\n    timestamp = TimeGenerated,\n    AccountCustomEntity = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName),\n    HostCustomEntity = DeviceName,\n    AlgorithmCustomEntity = \"MD5\",\n    FileHashCustomEntity = MD5\n", "attributes": {"description": "Identifies suspicious child processes of SolarWinds.Orion.Core.BusinessLayer.dll that may be evidence of the SUNBURST backdoor\nReferences:\n- https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n- https://gist.github.com/olafhartong/71ffdd4cab4b6acd5cbcd1a0691ff82f\n", "techniques": NaN, "tactics": ["Execution", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Duo%20Security/IPEntity_DuoSecurity.yaml", "query_name": "TI map IP entity to Duo Security", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n| join (\n    DuoSecurityAuthentication_CL\n    | where TimeGenerated >= ago(dt_lookBack)\n    | where isnotempty(access_device_ip_s)\n    // renaming time column so it is clear the log this came from\n    | extend Duo_TimeGenerated = isotimestamp_t\n)\non $left.TI_ipEntity == $right.access_device_ip_s\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, Duo_TimeGenerated,\nTI_ipEntity, user_name_s, factor_s, result_s, application_name_s, event_type_s, txid_g, user_key_s, access_device_ip_s, access_device_location_city_s, access_device_location_state_s, access_device_location_country_s\n| extend timestamp = Duo_TimeGenerated, IPCustomEntity = access_device_ip_s, AccountCustomEntity = user_name_s\n", "attributes": {"description": "'Identifies a match in DuoSecurity from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Duo%20Security/TrustMonitorEvent.yaml", "query_name": "Trust Monitor Event", "query": "\nlet timeframe = ago(5m);\nDuoSecurityTrustMonitor_CL\n| where TimeGenerated >= timeframe\n| extend AccountCustomEntity = surfaced_auth_user_name_s, IPCustomEntity = surfaced_auth_access_device_ip_s\n", "attributes": {"description": "'This query identifies when a new trust monitor event is detected.'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/GitHub/NRT%20Two%20Factor%20Authentication%20Disabled.yaml", "query_name": "NRT GitHub Two Factor Auth Disable", "query": "\nGitHubAudit\n| where Action == \"org.disable_two_factor_requirement\"\n| project TimeGenerated, Action, Actor, Country, IPaddress, Repository\n| extend AccountCustomEntity = Actor, IPCustomEntity = IPaddress\n", "attributes": {"description": "'Two-factor authentication is a process where a user is prompted during the sign-in process for an additional form of identification, such as to enter a code on their cellphone or to provide a fingerprint scan. Two factor authentication reduces the risk of account takeover. Attacker will want to disable such security tools in order to go undetected. '\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/GitHub/Security%20Vulnerability%20in%20Repo.yaml", "query_name": "GitHub Security Vulnerability in Repository", "query": "\nGitHubRepo\n| where Action == \"vulnerabilityAlert\"\n| project TimeGenerated, DismmisedAt, Reason, vulnerableManifestFilename, Description, Link, PublishedAt, Severity, Summary\n", "attributes": {"description": "'This alerts when there is a new security vulnerability in a GitHub repository.'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/GitHub/Threat%20Intel%20Matches%20to%20GitHub%20Audit%20Logs.yaml", "query_name": "TI map IP entity to GitHub_CL", "query": "\nThreatIntelligenceIndicator\n| where Action == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n| join (\n  GitHubAudit\n  | extend GitHubAudit_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.IPaddress\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, GitHubAudit_TimeGenerated, TI_ipEntity, IPaddress, Actor, Action, Country, OperationType, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = GitHubAudit_TimeGenerated, IPCustomEntity = IPaddress, AccountCustomEntity = Actor\n", "attributes": {"description": "'Identifies a match in GitHub_CL table from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Heartbeat/MissingDCHearbeat.yaml", "query_name": "Missing Domain Controller Heartbeat", "query": "\nlet query_frequency = 15m;\nlet missing_period = 1h;\n//Enter a reference list of hostnames for your DC servers\nlet DCServersList = dynamic ([\"DC01.simulandlabs.com\",\"DC02.simulandlabs.com\"]);\n//Alternatively, a Watchlist can be used\n//let DCServersList = _GetWatchlist('HostName-DomainControllers') | project HostName;\nHeartbeat\n| summarize arg_max(TimeGenerated, *) by Computer\n| where Computer in (DCServersList)\n//You may specify the OS type of your Domain Controllers\n//| where OSType == 'Windows'\n| where TimeGenerated between (ago(query_frequency + missing_period) .. ago(missing_period))\n| project TimeGenerated, Computer, OSType, Version, ComputerEnvironment, Type, Solutions\n| sort by TimeGenerated asc\n", "attributes": {"description": "'This detection will go over the heartbeats received from the agents of Domain Controllers over the last hour, and will create alerts if the last heartbeats were received an hour ago.'\n", "techniques": NaN, "tactics": ["Impact", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Heartbeat/OMI_vulnerability_detection.yaml", "query_name": "OMI Vulnerability Exploitation", "query": "let OMIVulnerabilityPatchVersion = \"OMIVulnerabilityPatchVersion:1.13.40-0\";\nHeartbeat\n| where Category == \"Direct Agent\"\n| summarize arg_max(TimeGenerated,*) by Computer\n| parse strcat(\"Version:\" , Version) with * \"Version:\" Major:long \".\"\nMinor:long \".\" Patch:long \"-\" *\n| parse OMIVulnerabilityPatchVersion with * \"OMIVulnerabilityPatchVersion:\"\nOMIVersionMajor:long \".\" OMIVersionMinor:long \".\" OMIVersionPatch:long \"-\" *\n| where Major <OMIVersionMajor or (Major==OMIVersionMajor and Minor\n<OMIVersionMinor) or (Major==OMIVersionMajor and Minor==OMIVersionMinor and\nPatch<OMIVersionPatch) \n| project Version, Major,Minor,Patch,\nComputer,ComputerIP,OSType,OSName,ResourceId\n", "attributes": {"description": "Following the September 14th, 2021 release of three Elevation of Privilege\n(EoP) vulnerabilities (CVE-2021-38645, CVE-2021-38649, CVE-2021-38648) and one\nunauthenticated Remote Code Execution (RCE) vulnerability (CVE-2021-38647) in\nthe Open Management Infrastructure (OMI) Framework.\nThis detection validates that any OMS-agent that is reporting to the Microsoft\nSentinel workspace is updated with the patch. The detection will go over the\nheartbeats received from all agents over the last day and will create alert\nfor those agents who are not updated.\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/http_proxy_oab_CL/HAFNIUMSuspiciousFileDownloads.yaml", "query_name": "HAFNIUM Suspicious File Downloads.", "query": "let scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\", \".cfm\", \".shtml\"]);\nhttp_proxy_oab_CL\n| where RawData contains \"Download failed and temporary file\"\n| extend File = extract(\"([^\\\\\\\\]*)(\\\\\\\\[^']*)\",2,RawData)\n| extend Extension = strcat(\".\",split(File, \".\")[-1])\n| extend InteractiveFile = iif(Extension in (scriptExtensions), \"Yes\", \"No\")\n// Uncomment the following line to alert only on interactive file download type\n//| where InteractiveFile =~ \"Yes\"\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer\n", "attributes": {"description": "'This query looks for messages related to file downloads of suspicious file types. This query uses the Exchange HttpProxy AOBGeneratorLog, you will need to onboard this log as a custom log under the table http_proxy_oab_CL before using this query. \nReference: https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/LAQueryLogs/UserSearchingForVIPUserActivity.yaml", "query_name": "Users searching for VIP user activity", "query": "// Replace these with the username or emails of your VIP users you wish to monitor for.\nlet vips = dynamic(['vip1@email.com','vip2@email.com']);\n// Add users who are allowed to conduct these searches - this could be specific SOC team members\nlet allowed_users = dynamic([]);\nLAQueryLogs\n| where QueryText has_any (vips) or QueryText has_any ('_GetWatchlist(\"VIPUsers\")', \"_GetWatchlist('VIPUsers')\")\n| where AADEmail !in (allowed_users)\n| project TimeGenerated, AADEmail, RequestClientApp, QueryText, ResponseRowCount, RequestTarget\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail\n", "attributes": {"description": "This query monitors for users running Log Analytics queries that contain filters\nfor specific, defined VIP user accounts or the VIPUser watchlist template.\nUse this detection to alert for users specifically searching for activity of sensitive users.\n", "techniques": ["T1530", "T1213", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AADAWSConsoleCorrelation.yaml", "query_name": "Failed AzureAD logons but success logon to AWS Console", "query": "\n//Adjust this threshold to fit your environment\nlet signin_threshold = 5; \n//Make a list of IPs with AAD signin failures above our threshold\nlet aadFunc = (tableName:string){\nlet Suspicious_signins = \ntable(tableName)\n| where ResultType !in (\"0\", \"50125\", \"50140\")\n| where IPAddress !in (\"127.0.0.1\", \"::1\")\n| summarize count() by IPAddress\n| where count_ >  signin_threshold\n| summarize make_set(IPAddress);\nSuspicious_signins\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nlet Suspicious_signins = \nunion isfuzzy=true aadSignin, aadNonInt\n| summarize make_set(set_IPAddress);\n//See if any of those IPs have sucessfully logged into the AWS console\nAWSCloudTrail\n| where EventName =~ \"ConsoleLogin\"\n| extend LoginResult = tostring(parse_json(ResponseElements).ConsoleLogin) \n| where LoginResult =~ \"Success\"\n| where SourceIpAddress in (Suspicious_signins)\n| extend Reason = \"Multiple failed AAD logins from IP address\"\n| extend MFAUsed = tostring(parse_json(AdditionalEventData).MFAUsed)\n| extend User = iif(isempty(UserIdentityUserName), UserIdentityType, UserIdentityUserName) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by Reason, LoginResult, EventTypeName, UserIdentityType, User, AWSRegion, SourceIpAddress, UserAgent, MFAUsed\n| extend timestamp = StartTimeUtc, AccountCustomEntity = User, IPCustomEntity = SourceIpAddress\n", "attributes": {"description": "'Identifies a list of IP addresses with a minimum number(defualt of 5) of failed logon attempts to Azure Active Directory.\nUses that list to identify any successful AWS Console logons from these IPs within the same timeframe.'\n", "techniques": ["T1078", "T1110"], "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AADHostLoginCorrelation.yaml", "query_name": "Failed AzureAD logons but success logon to host", "query": "\n//Adjust this threshold to fit the environment\nlet signin_threshold = 5;\n//Make a list of all IPs with failed signins to AAD above our threshold\nlet aadFunc = (tableName:string){\nlet suspicious_signins =\ntable(tableName)\n| where ResultType !in (\"0\", \"50125\", \"50140\")\n| where IPAddress !in ('127.0.0.1', '::1')\n| summarize count() by IPAddress\n| where count_ > signin_threshold\n| summarize make_set(IPAddress);\n//See if any of these IPs have sucessfully logged into *nix hosts\nlet linux_logons =\nSyslog\n| where Facility contains \"auth\" and ProcessName != \"sudo\"\n| where SyslogMessage has \"Accepted\"\n| extend SourceIP = extract(\"(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.(([0-9]{1,3})))\",1,SyslogMessage)\n| where SourceIP in (suspicious_signins)\n| extend Reason = \"Multiple failed AAD logins from IP address\"\n| project TimeGenerated, Computer, HostIP, IpAddress = SourceIP, SyslogMessage, Facility, ProcessName, Reason;\n//See if any of these IPs have sucessfully logged into Windows hosts\nlet win_logons = (union isfuzzy=true\n(SecurityEvent\n| where EventID == 4624\n| where LogonType in (10, 7, 3)\n| where IpAddress != \"-\"\n| where IpAddress in (suspicious_signins)\n| extend Reason = \"Multiple failed AAD logins from IP address\"\n| project TimeGenerated, Account, AccountType, Computer, Activity, EventID, LogonProcessName, IpAddress, LogonTypeName, TargetUserSid, Reason\n),\n(WindowsEvent\n| where EventID == 4624 and has_any_ipv4(EventData, toscalar(suspicious_signins))\n| extend LogonType = tostring(EventData.LogonType)\n| where LogonType in (10, 7, 3)\n| extend  IpAddress = tostring(EventData.IpAddress)\n| where IpAddress != \"-\"\n| where IpAddress in (suspicious_signins)\n| extend Reason = \"Multiple failed AAD logins from IP address\"\n| extend Activity = \"4624 - An account was successfully logged on.\"\n| extend Account =  strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend TargetUserSid = tostring(EventData.TargetUserSid)\n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend AccountType =case(Account endswith \"$\" or TargetUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(TargetUserSid), \"\", \"User\")\n| extend LogonProcessName = tostring(EventData.LogonProcessName)\n| project TimeGenerated, Account, AccountType, Computer, Activity, EventID, LogonProcessName, IpAddress, TargetUserSid, Reason\n)\n);\nunion isfuzzy=true linux_logons,win_logons\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, IPCustomEntity = IpAddress, HostCustomEntity = Computer\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies a list of IP addresses with a minimum number (default of 5) of failed logon attempts to Azure Active Directory.\nUses that list to identify any successful remote logons to hosts from these IPs within the same timeframe.'\n", "techniques": ["T1078", "T1110"], "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AAD_PAVPN_Correlation.yaml", "query_name": "IP with multiple failed Azure AD logins successfully logs in to Palo Alto VPN", "query": "//Set a threshold of failed AAD signins from an IP address within 1 day above which we want to deem those logins suspicious.\nlet signin_threshold = 5; \n//Make a list of IPs with AAD signin failures above our threshold.\nlet aadFunc = (tableName:string){\nlet suspicious_signins = \n    table(tableName)\n    //Looking for logon failure results\n    | where ResultType !in (\"0\", \"50125\", \"50140\")\n    //Exclude localhost addresses to reduce the chance of FPs\n    | where IPAddress !in (\"127.0.0.1\", \"::1\")\n    | summarize count() by IPAddress\n    | where count_ >  signin_threshold\n    | summarize make_set(IPAddress);\n    suspicious_signins\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nlet suspicious_signins = \nunion isfuzzy=true aadSignin, aadNonInt\n| summarize make_set(set_IPAddress);\n//See if any of those IPs have sucessfully logged into PA VPNs during the same timeperiod\nCommonSecurityLog\n    //Select only PA VPN sucessful logons\n    | where DeviceVendor == \"Palo Alto Networks\" and DeviceEventClassID == \"globalprotect\"\n    | where Message has \"GlobalProtect gateway user authentication succeeded\"\n    //Parse out the logon source IP from the Message field to match on\n    | extend SourceIP = extract(\"Login from: ([^,]+)\", 1, Message) \n    | where SourceIP in (suspicious_signins)\n    | extend Reason = \"Multiple failed AAD logins from SourceIP\"\n    //Parse out other useful information from Message field\n    | extend User = extract('User name: ([^,]+)', 1, Message) \n    | extend ClientOS = extract('Client OS version: ([^,\\\"]+)', 1, Message)\n    | extend Location = extract('Source region: ([^,]{2})',1, Message)\n    | project TimeGenerated, Reason, SourceIP, User, ClientOS, Location, Message, DeviceName, ReceiptTime, DeviceVendor, DeviceEventClassID, Computer, FileName\n    | extend AccountCustomEntity = User, IPCustomEntity = SourceIP, timestamp = TimeGenerated, HostCustomEntity = DeviceName \n", "attributes": {"description": "This query creates a list of IP addresses with a number failed login attempts to AAD \nabove a set threshold.  It then looks for any successful Palo Alto VPN logins from any\nof these IPs within the same timeframe.\n", "techniques": ["T1078", "T1110"], "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Accountcreatedfromnon-approvedsources.yaml", "query_name": "Account created from non-approved sources", "query": "let core_domains = (SigninLogs\n  | where TimeGenerated > ago(7d)\n  | where ResultType == 0\n  | extend domain = tolower(split(UserPrincipalName, \"@\")[1])\n  | summarize by tostring(domain));\n  let alternative_domains = (SigninLogs\n  | where TimeGenerated > ago(7d)\n  | where isnotempty(AlternateSignInName)\n  | where ResultType == 0\n  | extend domain = tolower(split(AlternateSignInName, \"@\")[1])\n  | summarize by tostring(domain));\n  AuditLogs\n  | where TimeGenerated > ago(1d)\n  | where OperationName =~ \"Add User\"\n  | extend AddingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend AddingSPN = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalName)\n  | extend AddedBy = iif(isnotempty(AddingUser), AddingUser, AddingSPN)\n  | extend UserAdded = tostring(TargetResources[0].userPrincipalName)\n  | extend Domain = tolower(split(UserAdded, \"@\")[1])\n  | where Domain !in (core_domains) and Domain !in (alternative_domains)\n  | project-away AddingUser\n  | project-reorder TimeGenerated, UserAdded, Domain, AddedBy\n", "attributes": {"description": "'This query looks for account being created from a domain that is not regularly seen in a tenant.\n  Attackers may attempt to add accounts from these sources as a means of establishing persistant access to an environment.\n  Created accounts should be investigated to ensure they were legitimated created.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#short-lived-accounts'\n", "techniques": ["T1136.003"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ActiniumFeb2022.yaml", "query_name": "ACTINIUM Actor IOCs - Feb 2022", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/ActiniumIOC.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet domains = (iocs | where Type =~ \"domainname\"| project IoC);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\n(union isfuzzy=true\n(DeviceProcessEvents\n| where InitiatingProcessSHA256 in (sha256Hashes) or SHA256 in (sha256Hashes) or  (ProcessCommandLine has ('schtasks.exe /CREATE /sc minute /mo 12 /tn')  and ProcessCommandLine has ('/tr \"wscript.exe') and ProcessCommandLine has ('\"%PUBLIC%\\\\Pictures\\\\') and ProcessCommandLine has ('//e:VBScript //b\" /F')) or (ProcessCommandLine has ('wscript.exe C:\\\\Users\\\\') and ProcessCommandLine has ('.wav') and  ProcessCommandLine has ('//e:VBScript //b') \nor (ProcessCommandLine has_all (\"schtasks.exe\", \"create\", \"wscript\", \"e:vbscript\", \".wav\")))\n| project TimeGenerated, ActionType, DeviceId, DeviceName, ProcessCommandLine, InitiatingProcessAccountName, InitiatingProcessCommandLine, FolderPath, InitiatingProcessFolderPath, ProcessId, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName,  InitiatingProcessSHA256, Type, AccountName, SHA256, FileName\n| extend Account = AccountName, Computer = DeviceName,  FileHash = case(InitiatingProcessSHA256 in (sha256Hashes), \"InitiatingProcessSHA256\", SHA256 in (sha256Hashes), \"SHA256\", \"No Match\")\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = FileName, FileHashCustomEntity = case(FileHash == \"InitiatingProcessSHA256\", InitiatingProcessSHA256, FileHash == \"SHA256\", SHA256, \"No Match\")\n),\n( SecurityEvent\n| where EventID == 4688\n| where (CommandLine has ('schtasks.exe /CREATE /sc minute /mo 12 /tn')  and CommandLine has ('/tr \"wscript.exe') and CommandLine has ('\"%PUBLIC%\\\\Pictures\\\\') and CommandLine has ('//e:VBScript //b\" /F')) or (CommandLine has ('wscript.exe C:\\\\Users\\\\') and CommandLine has ('.wav') and  CommandLine has ('//e:VBScript //b'))\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, EventID\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n),\n( CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated, Message, SourceUserID, FileHash, Type\n| extend timestamp = TimeGenerated, FileHashCustomEntity = 'SHA256', Account = SourceUserID\n),\n( imFileEvent\n| where Hash in~ (sha256Hashes) or  (ActingProcessCommandLine  has ('schtasks.exe /CREATE /sc minute /mo 12 /tn')  and ActingProcessCommandLine  has ('/tr \"wscript.exe') and ActingProcessCommandLine  has ('\"%PUBLIC%\\\\Pictures\\\\') and ActingProcessCommandLine  has ('//e:VBScript //b\" /F')) or (ActingProcessCommandLine  has ('wscript.exe C:\\\\Users\\\\') and ActingProcessCommandLine  has ('.wav') and  ActingProcessCommandLine  has ('//e:VBScript //b') \n or (ActingProcessCommandLine has_all (\"schtasks.exe\", \"create\", \"wscript\", \"e:vbscript\", \".wav\")))\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = Hash\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"], Hashes = tostring(EventDetail.[17].[\"#text\"])\n| extend Hashes = extract_all(@\"(?P<key>\\w+)=(?P<value>[a-zA-Z0-9]+)\", dynamic([\"key\",\"value\"]), Hashes)\n| extend Hashes = column_ifexists(\"Hashes\", \"\"), CommandLine = column_ifexists(\"CommandLine\", \"\")\n| where (Hashes has_any (sha256Hashes) ) or (CommandLine has ('schtasks.exe /CREATE /sc minute /mo 12 /tn')  and CommandLine has ('/tr \"wscript.exe') and CommandLine has ('\"%PUBLIC%\\\\Pictures\\\\') and CommandLine has ('//e:VBScript //b\" /F')) or (CommandLine has ('wscript.exe C:\\\\Users\\\\') and CommandLine has ('.wav') and  CommandLine has ('//e:VBScript //b') or (CommandLine has_all (\"schtasks.exe\", \"create\", \"wscript\", \"e:vbscript\", \".wav\")))\n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, Hashes, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), FileHashCustomEntity = Hashes\n),\n(DnsEvents\n| where Name in~ (domains)  \n| project TimeGenerated, Computer, IPAddresses, Name, ClientIP, Type\n| extend DestinationIPAddress = IPAddresses, DNSName = Name, Computer \n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress\n),\n(VMConnection\n| where RemoteDnsCanonicalNames has_any (domains)\n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, RemoteDnsQuestions, DNSName,BytesSent, BytesReceived, RemoteCountry, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIp, File = ProcessName\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| project TimeGenerated,Resource, msg_s, Type\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (domains)  \n| extend timestamp = TimeGenerated, DNSName = DestinationHost, IPCustomEntity = SourceHost\n),\n(DeviceNetworkEvents \n| where isnotempty(RemoteUrl) \n| where RemoteUrl  in~ (domains)  \n| project Type, TimeGenerated, DeviceName, RemoteIP, RemoteUrl, InitiatingProcessAccountName\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, DNSName = RemoteUrl, IPCustomEntity = RemoteIP\n)\n)\n", "attributes": {"description": "'Identifies a match across various data feeds for domains, hashes and commands related to an actor tracked by Microsoft as Actinium.'\n", "techniques": ["T1137"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ADFS-DKM-MasterKey-Export.yaml", "query_name": "ADFS DKM Master Key Export", "query": "(union isfuzzy=true \n(SecurityEvent \n| where EventID == 4662 // You need to create a SACL on the ADFS Policy Store DKM group for this event to be created. \n| where ObjectServer == 'DS'\n| where OperationType == 'Object Access'\n//| where ObjectName contains '<GUID of ADFS Policy Store DKM Group object' This is unique to the domain. Check description for more details.\n| where ObjectType contains '5cb41ed0-0e4c-11d0-a286-00aa003049e2' // Contact Class\n| where Properties contains '8d3bca50-1d7e-11d0-a081-00aa006c33ed' // Picture Attribute - Ldap-Display-Name: thumbnailPhoto\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = SubjectAccount\n),\n( WindowsEvent \n| where EventID == 4662 // You need to create a SACL on the ADFS Policy Store DKM group for this event to be created. \n| where EventData has_all('Object Access', '5cb41ed0-0e4c-11d0-a286-00aa003049e2','8d3bca50-1d7e-11d0-a081-00aa006c33ed') \n| extend ObjectServer = tostring(EventData.ObjectServer)\n| where ObjectServer == 'DS'\n| extend OperationType = tostring(EventData.OperationType)\n| where OperationType == 'Object Access'\n//| where ObjectName contains '<GUID of ADFS Policy Store DKM Group object' This is unique to the domain. Check description for more details.\n| extend ObjectType = tostring(EventData.ObjectType)\n| where ObjectType contains '5cb41ed0-0e4c-11d0-a286-00aa003049e2' // Contact Class\n| extend Properties = tostring(EventData.Properties)\n| where Properties contains '8d3bca50-1d7e-11d0-a081-00aa006c33ed' // Picture Attribute - Ldap-Display-Name: thumbnailPhoto\n| extend SubjectAccount = strcat(tostring(EventData.SubjectDomainName), \"\\\\\", tostring(EventData.SubjectUserName))\n| extend \n    timestamp = TimeGenerated,\n    HostCustomEntity = Computer,\n    AccountCustomEntity = SubjectAccount\n),\n(DeviceEvents\n| where ActionType =~ \"LdapSearch\"\n| where AdditionalFields.AttributeList contains \"thumbnailPhoto\"\n| where AdditionalFields.DistinguishedName contains \"CN=ADFS,CN=Microsoft,CN=Program Data\" // Filter results to show only hits related to the ADFS AD container\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName, AccountCustomEntity = InitiatingProcessAccountName\n)\n)\n", "attributes": {"description": "'Identifies an export of the ADFS DKM Master Key from Active Directory.\nReferences: https://blogs.microsoft.com/on-the-issues/2020/12/13/customers-protect-nation-state-cyberattacks/, \nhttps://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html?1\nTo understand further the details behind this detection, please review the details in the original PR and subequent PR update to this:\nhttps://github.com/Azure/Azure-Sentinel/pull/1562#issue-551542469\nhttps://github.com/Azure/Azure-Sentinel/pull/1512#issue-543053339\n'\n", "techniques": ["T1005"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AnomalousIPUsageFollowedByTeamsAction.yaml", "query_name": "Anomalous login followed by Teams action", "query": "\n//The bigger the window the better the data sample size, as we use IP prevalence, more sample data is better.\n//The minimum number of countries that the account has been accessed from [default: 2]\nlet minimumCountries = 2;\n//The delta (%) between the largest in-use IP and the smallest [default: 95]\nlet deltaThreshold = 95;\n//The maximum (%) threshold that the country appears in login data [default: 10]\nlet countryPrevalenceThreshold = 10;\n//The time to project forward after the last login activity [default: 60min]\nlet projectedEndTime = 60m;\nlet queryfrequency = 1d;\nlet queryperiod = 14d;\nlet aadFunc = (tableName: string) {\n    // Get successful signins to Teams\n    let signinData =\n        table(tableName)\n        | where TimeGenerated > ago(queryperiod)\n        | where AppDisplayName has \"Teams\" and ConditionalAccessStatus =~ \"success\"\n        | extend Country = tostring(todynamic(LocationDetails)['countryOrRegion'])\n        | where isnotempty(Country) and isnotempty(IPAddress);\n    // Calculate prevalence of countries\n    let countryPrevalence =\n        signinData\n        | summarize CountCountrySignin = count() by Country\n        | extend TotalSignin = toscalar(signinData | summarize count())\n        | extend CountryPrevalence = toreal(CountCountrySignin) / toreal(TotalSignin) * 100;\n    // Count signins by user and IP address\n    let userIpSignin =\n        signinData\n        | summarize CountIPSignin = count(), Country = any(Country), ListSigninTimeGenerated = make_list(TimeGenerated) by IPAddress, UserPrincipalName;\n    // Calculate delta between the IP addresses with the most and minimum activity by user\n    let userIpDelta =\n        userIpSignin\n        | summarize MaxIPSignin = max(CountIPSignin), MinIPSignin = min(CountIPSignin), DistinctCountries = dcount(Country), make_set(Country) by UserPrincipalName\n        | extend UserIPDelta = toreal(MaxIPSignin - MinIPSignin) / toreal(MaxIPSignin) * 100;\n    // Collect Team operations the user account has performed within a time range of the suspicious signins\n    OfficeActivity\n    | where TimeGenerated > ago(queryfrequency)\n    | where Operation in~ (\"TeamsAdminAction\", \"MemberAdded\", \"MemberRemoved\", \"MemberRoleChanged\", \"AppInstalled\", \"BotAddedToTeam\")\n    | project OperationTimeGenerated = TimeGenerated, UserId = tolower(UserId), Operation\n    | join kind = inner(\n        userIpDelta\n        // Check users with activity from distinct countries\n        | where DistinctCountries >= minimumCountries\n        // Check users with high IP delta\n        | where UserIPDelta >= deltaThreshold\n        // Add information about signins and countries\n        | join kind = leftouter userIpSignin on UserPrincipalName\n        | join kind = leftouter countryPrevalence on Country\n        // Check activity that comes from nonprevalent countries\n        | where CountryPrevalence < countryPrevalenceThreshold\n        | project\n            UserPrincipalName,\n            SuspiciousIP = IPAddress,\n            UserIPDelta,\n            SuspiciousSigninCountry = Country,\n            SuspiciousCountryPrevalence = CountryPrevalence,\n            EventTimes = ListSigninTimeGenerated\n    ) on $left.UserId == $right.UserPrincipalName\n    // Check the signins occured 60 min before the Teams operations\n    | mv-expand SigninTimeGenerated = EventTimes\n    | extend SigninTimeGenerated = todatetime(SigninTimeGenerated)\n    | where OperationTimeGenerated between (SigninTimeGenerated .. (SigninTimeGenerated + projectedEndTime))\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n| summarize arg_max(SigninTimeGenerated, *) by UserPrincipalName, SuspiciousIP, OperationTimeGenerated\n| summarize\n    ActivitySummary = make_bag(pack(tostring(SigninTimeGenerated), pack(\"Operation\", tostring(Operation), \"OperationTime\", OperationTimeGenerated)))\n    by UserPrincipalName, SuspiciousIP, SuspiciousSigninCountry, SuspiciousCountryPrevalence\n| extend IPCustomEntity = SuspiciousIP, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'Detects anomalous IP address usage by user accounts and then checks to see if a suspicious Teams action is performed.\nQuery calculates IP usage Delta for each user account and selects accounts where a delta >= 90% is observed between the most and least used IP.\nTo further reduce results the query performs a prevalence check on the lowest used IP's country, only keeping IP's where the country is unusual for the tenant (dynamic ranges)\nFinally the user accounts activity within Teams logs is checked for suspicious commands (modifying user privileges or admin actions) during the period the suspicious IP was active.'\n", "techniques": ["T1199", "T1136", "T1078", "T1098"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AuditPolicyManipulation_using_auditpol.yaml", "query_name": "Audit policy manipulation using auditpol utility", "query": "let timeframe = 1d;\nlet AccountAllowList = dynamic(['SYSTEM']);\nlet SubCategoryList = dynamic([\"Logoff\", \"Account Lockout\", \"User Account Management\", \"Authorization Policy Change\"]); // Add any Category in the list to be allowed or disallowed\nlet tokens = dynamic([\"clear\", \"remove\", \"success:disable\",\"failure:disable\"]); \n(union isfuzzy=true\n(\nSecurityEvent\n| where TimeGenerated >= ago(timeframe)\n//| where Process =~ \"auditpol.exe\" \n| where CommandLine has_any (tokens)\n| where AccountType !~ \"Machine\" and Account !in~ (AccountAllowList)\n| parse CommandLine with * \"/subcategory:\" subcategorytoken\n| extend SubCategory = tostring(split(subcategorytoken, \"\\\"\")[1]) , Toggle =  tostring(split(subcategorytoken, \"\\\"\")[2])\n| where SubCategory in~ (SubCategoryList) //use in~ for inclusion or !in~ for exclusion\n| where Toggle !in~ (\"/failure:disable\", \" /success:enable /failure:disable\") // use this filter if required to exclude certain toggles\n| project TimeGenerated, Computer, Account, SubjectDomainName,  SubjectUserName, Process, ParentProcessName,  CommandLine, SubCategory, Toggle\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(\nDeviceProcessEvents\n| where TimeGenerated >= ago(timeframe)\n// | where InitiatingProcessFileName =~ \"auditpol.exe\" \n| where InitiatingProcessCommandLine has_any (tokens)\n| where AccountName !in~ (AccountAllowList)\n| parse InitiatingProcessCommandLine with * \"/subcategory:\" subcategorytoken\n| extend SubCategory = tostring(split(subcategorytoken, \"\\\"\")[1]) , Toggle =  tostring(split(subcategorytoken, \"\\\"\")[2])\n| where SubCategory in~ (SubCategoryList) //use in~ for inclusion or !in~ for exclusion\n| where Toggle !in~ (\"/failure:disable\", \" /success:enable /failure:disable\") // use this filter if required to exclude certain toggles\n| project TimeGenerated, DeviceName, AccountName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessFileName, InitiatingProcessParentFileName,  InitiatingProcessCommandLine, SubCategory, Toggle\n| extend timestamp = TimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = DeviceName\n),\n(\nEvent\n| where TimeGenerated > ago(timeframe)\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n// | where OriginalFileName =~ \"auditpol.exe\"\n| where CommandLine has_any (tokens)\n| where User !in~ (AccountAllowList)\n| parse CommandLine with * \"/subcategory:\" subcategorytoken\n| extend SubCategory = tostring(split(subcategorytoken, \"\\\"\")[1]) , Toggle =  tostring(split(subcategorytoken, \"\\\"\")[2])\n| where SubCategory in~ (SubCategoryList) //use in~ for inclusion or !in~ for exclusion\n| where Toggle !in~ (\"/failure:disable\", \" /success:enable /failure:disable\") // use this filter if required to exclude certain toggles\n| project TimeGenerated, Computer, User, Process, ParentImage,  CommandLine, SubCategory, Toggle\n| extend timestamp = TimeGenerated, AccountCustomEntity = User, HostCustomEntity = Computer\n)\n)\n", "attributes": {"description": "This detects attempt to manipulate audit policies using auditpol command.\nThis technique was seen in relation to Solorigate attack but the results can indicate potential  malicious activity used in different attacks.\nThe process name in each data source is commented out as an adversary could rename it. It is advisable to keep process name commented but \nif the results show unrelated false positives, users may want to uncomment it.\nRefer to auditpol syntax: https://docs.microsoft.com/windows-server/administration/windows-commands/auditpol  \nRefer to our M365 blog for details on use during the Solorigate attack:\nhttps://www.microsoft.com/security/blog/2021/01/20/deep-dive-into-the-solorigate-second-stage-activation-from-sunburst-to-teardrop-and-raindrop/\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/AWSConsoleAADCorrelation.yaml", "query_name": "Failed AWS Console logons but success logon to AzureAD", "query": "\n//Adjust this threshold to fit environment\nlet  signin_threshold = 5; \n//Make a list of IPs with failed AWS console logins\nlet aws_fails = AWSCloudTrail\n| where EventName == \"ConsoleLogin\"\n| extend LoginResult = tostring(parse_json(ResponseElements).ConsoleLogin) \n| where LoginResult != \"Success\"\n| where SourceIpAddress != \"127.0.0.1\"\n| summarize count() by SourceIpAddress\n| where count_ >  signin_threshold\n| summarize make_set(SourceIpAddress);\n//See if any of those IPs have sucessfully logged into Azure AD.\nSigninLogs\n| where ResultType in (\"0\", \"50125\", \"50140\")\n| where IPAddress in (aws_fails) \n| extend Reason = \"Multiple failed AWS Console logins from IP address\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Identifies a list of IP addresses with a minimum numbe(default of 5) of failed logon attempts to AWS Console.\nUses that list to identify any successful Azure Active Directory logons from these IPs within the same timeframe.'\n", "techniques": ["T1078", "T1110"], "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/B64IPInURLFromMDE.yaml", "query_name": "IP address of Windows host encoded in web request", "query": "// Extracts plaintext IPv4 addresses\nlet ipv4_plaintext_extraction_regex = @\"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})\";\n// Identified base64 encoded IPv4 addresses\nlet ipv4_encoded_identification_regex = @\"\\=([a-zA-Z0-9\\/\\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\\/\\+]{2,4}){3}[a-zA-Z0-9\\/\\+\\=]*)\";\n// Extractes IPv4 addresses as hex values\nlet ipv4_decoded_hex_extract = @\"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})\";\nCommonSecurityLog\n| where isnotempty(RequestURL)\n// Identify requests with encoded IPv4 addresses\n| where RequestURL matches regex ipv4_encoded_identification_regex\n| project TimeGenerated, RequestURL\n// Extract IP candidates in their base64 encoded format, significantly reducing the dataset\n| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)\n// We could have more than one candidate, expand them out\n| mv-expand extracted_encoded_ip_candidate to typeof(string)\n| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate\n// Pad if we need to\n| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, \"=\"))\n// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first\n| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))\n// Extract the IP candidates from the array\n| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)\n// Expand, it's still possible that we might have more than 1 IP\n| mv-expand hex_extracted\n// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.\n| extend hex_extracted = trim_end(\",\", tostring(hex_extracted))\n| extend hex_extracted = strcat(\"[\",hex_extracted,\"]\")\n| extend hex_extracted = todynamic(hex_extracted)\n| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)\n// Convert the array back into a string\n| extend decoded_ip_candidate = make_string(hex_extracted)\n| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End\n// Now the IP candidates will be in plaintext, extract the IPs using a regex\n| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)\n// If it's not an IP, throw it out\n| where isnotnull(ipmatch)\n| mv-expand ipmatch to typeof(string)\n// Join with DeviceNetworkEvents to find instances where an IP of a machine in our MDE estate sent it's IP in a base64 encoded string\n| join (\n    DeviceNetworkEvents\n    | summarize make_set(DeviceId), make_set(DeviceName) by RemoteIP\n) on $left.ipmatch == $right.RemoteIP\n| project Start, End, IPmatch=ipmatch, RequestURL=set_RequestURL, DeviceNames=set_DeviceName, DeviceIds=set_DeviceId, RemoteIP\n", "attributes": {"description": "'This detection will identify network requests in HTTP proxy data that contains Base64 encoded IP addresses. After identifying candidates the query\njoins with DeviceNetworkEvents to idnetify any machine within the network using that IP address. Alerts indicate that the IP address of a machine\nwithin your network was seen with it's IP address base64 encoded in an outbounf web request. This method of egressing the IP was seen used in POLONIUM's\nRunningRAT tool, however the detection is generic.'\n", "techniques": ["T1041", "T1071.001"], "tactics": ["Exfiltration", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/B64UserInWebURIFromMDE.yaml", "query_name": "Windows host username encoded in base64 web request", "query": "let accountLookback = 3d;\nlet requestLookback = 3d;\nlet extraction_regex = @\"(?:\\?|&)[a-zA-Z0-9\\%]*=([a-zA-Z0-9\\/\\+\\=]*)\";\n// Collect account names and base64 encode them\nDeviceEvents\n| where TimeGenerated > ago(accountLookback)\n| summarize make_set(DeviceId), make_set(DeviceName) by InitiatingProcessAccountName\n| where isnotempty(InitiatingProcessAccountName)\n| extend base64_user = base64_encode_tostring(InitiatingProcessAccountName)\n| join (\n    // Collect requests and extract base64 parameters\n    CommonSecurityLog\n    | where TimeGenerated > ago(requestLookback)\n    | where isnotempty(RequestURL)\n    // Summarize early on the RequestURL\n    | summarize FirstRequest=min(TimeGenerated), LastRequest=max(TimeGenerated), NumberOfRequests=count() by RequestURL\n    | extend base64_candidate = extract_all(extraction_regex, RequestURL)\n    | mv-expand base64_candidate  to typeof(string)\n) on $left.base64_user == $right.base64_candidate\n| project FirstRequest, LastRequest, NumberOfRequests, RequestURL, DeviceIds=set_DeviceId, DeviceNames=set_DeviceName, UserName=InitiatingProcessAccountName\n", "attributes": {"description": "'This detection will identify network requests in HTTP proxy data that contains Base64 encoded usernames from machines in the DeviceEvents table.\nThis technique was seen usee by POLONIUM in their RunningRAT tool.'\n", "techniques": ["T1041", "T1071.001"], "tactics": ["Exfiltration", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/BariumDomainIOC112020.yaml", "query_name": "Known Barium domains", "query": "\nlet DomainNames = dynamic([\"0.ns1.dns-info.gq\", \"1.ns1.dns-info.gq\", \"10.ns1.dns-info.gq\", \"102.ns1.dns-info.gq\", \n   \"104.ns1.dns-info.gq\", \"11.ns1.dns-info.gq\", \"110.ns1.dns-info.gq\", \"115.ns1.dns-info.gq\", \"116.ns1.dns-info.gq\", \n   \"117.ns1.dns-info.gq\", \"118.ns1.dns-info.gq\", \"12.ns1.dns-info.gq\", \"120.ns1.dns-info.gq\", \"122.ns1.dns-info.gq\", \n   \"123.ns1.dns-info.gq\", \"128.ns1.dns-info.gq\", \"13.ns1.dns-info.gq\", \"134.ns1.dns-info.gq\", \"135.ns1.dns-info.gq\", \n   \"138.ns1.dns-info.gq\", \"14.ns1.dns-info.gq\", \"144.ns1.dns-info.gq\", \"15.ns1.dns-info.gq\", \"153.ns1.dns-info.gq\", \n   \"157.ns1.dns-info.gq\", \"16.ns1.dns-info.gq\", \"17.ns1.dns-info.gq\", \"18.ns1.dns-info.gq\", \"19.ns1.dns-info.gq\", \n   \"1a9604fa.ns1.feedsdns.com\", \"1c7606b6.ns1.steamappstore.com\", \"2.ns1.dns-info.gq\", \"20.ns1.dns-info.gq\", \n   \"201.ns1.dns-info.gq\", \"202.ns1.dns-info.gq\", \"204.ns1.dns-info.gq\", \"207.ns1.dns-info.gq\", \"21.ns1.dns-info.gq\", \n   \"210.ns1.dns-info.gq\", \"211.ns1.dns-info.gq\", \"216.ns1.dns-info.gq\", \"22.ns1.dns-info.gq\", \"220.ns1.dns-info.gq\", \n   \"223.ns1.dns-info.gq\", \"23.ns1.dns-info.gq\", \"24.ns1.dns-info.gq\", \"25.ns1.dns-info.gq\", \"26.ns1.dns-info.gq\", \n   \"27.ns1.dns-info.gq\", \"28.ns1.dns-info.gq\", \"29.ns1.dns-info.gq\", \"3.ns1.dns-info.gq\", \"30.ns1.dns-info.gq\", \n   \"31.ns1.dns-info.gq\", \"32.ns1.dns-info.gq\", \"33.ns1.dns-info.gq\", \"34.ns1.dns-info.gq\", \"35.ns1.dns-info.gq\", \n   \"36.ns1.dns-info.gq\", \"37.ns1.dns-info.gq\", \"39.ns1.dns-info.gq\", \"3d6fe4b2.ns1.steamappstore.com\", \n   \"4.ns1.dns-info.gq\", \"40.ns1.dns-info.gq\", \"42.ns1.dns-info.gq\", \"43.ns1.dns-info.gq\", \"44.ns1.dns-info.gq\", \n   \"45.ns1.dns-info.gq\", \"46.ns1.dns-info.gq\", \"48.ns1.dns-info.gq\", \"5.ns1.dns-info.gq\", \"50.ns1.dns-info.gq\", \n   \"50417.service.gstatic.dnset.com\", \"51.ns1.dns-info.gq\", \"52.ns1.dns-info.gq\", \"53.ns1.dns-info.gq\",\n   \"54.ns1.dns-info.gq\", \"55.ns1.dns-info.gq\", \"56.ns1.dns-info.gq\", \"57.ns1.dns-info.gq\", \"58.ns1.dns-info.gq\", \n   \"6.ns1.dns-info.gq\", \"60.ns1.dns-info.gq\", \"62.ns1.dns-info.gq\", \"63.ns1.dns-info.gq\", \"64.ns1.dns-info.gq\", \n   \"65.ns1.dns-info.gq\", \"67.ns1.dns-info.gq\", \"7.ns1.dns-info.gq\", \"70.ns1.dns-info.gq\", \"71.ns1.dns-info.gq\",\n   \"73.ns1.dns-info.gq\", \"77.ns1.dns-info.gq\", \"77075.service.gstatic.dnset.com\", \"7c1947fa.ns1.steamappstore.com\",\n   \"8.ns1.dns-info.gq\", \"81.ns1.dns-info.gq\", \"86.ns1.dns-info.gq\", \"87.ns1.dns-info.gq\", \"9.ns1.dns-info.gq\", \n   \"94343.service.gstatic.dnset.com\", \"9939.service.gstatic.dnset.com\", \"aa.ns.mircosoftdoc.com\", \n   \"aaa.feeds.api.ns1.feedsdns.com\", \"aaa.googlepublic.feeds.ns1.dns-info.gq\", \n   \"aaa.resolution.174547._get.cache.up.sourcedns.tk\", \"acc.microsoftonetravel.com\", \n   \"accounts.longmusic.com\", \"admin.dnstemplog.com\", \"agent.updatenai.com\", \n   \"alibaba.zzux.com\", \"api.feedsdns.com\", \"app.portomnail.com\", \"asia.updatenai.com\", \n   \"battllestategames.com\", \"bguha.serveuser.com\", \"binann-ce.com\", \"bing.dsmtp.com\", \n   \"blog.cdsend.xyz\", \"brives.minivineyapp.com\", \"bsbana.dynamic-dns.net\", \n   \"californiaforce.000webhostapp.com\", \"californiafroce.000webhostapp.com\", \n   \"cdn.freetcp.com\", \"cdsend.xyz\", \"cipla.zzux.com\", \"cloudfeeddns.com\", \"comcleanner.info\",\n   \"cs.microsoftsonline.net\", \"dns-info.gq\", \"dns05.cf\", \"dns22.ml\", \"dns224.com\", \n   \"dnsdist.org\", \"dnstemplog.com\", \"doc.mircosoftdoc.com\", \"dropdns.com\", \n   \"eshop.cdn.freetcp.com\", \"exchange.dumb1.com\", \"exchange.misecure.com\", \"exchange.mrbasic.com\",\n   \"facebookdocs.com\", \"facebookint.com\", \"facebookvi.com\", \"feed.ns1.dns-info.gq\", \"feedsdns.com\", \n   \"firejun.freeddns.com\", \"ftp.dns-info.dyndns.pro\", \"goallbandungtravel.com\", \"goodhk.azurewebsites.net\", \n   \"googlepublic.feed.ns1.dns-info.gq\", \"gp.spotifylite.cloud\", \"gskytop.com\", \"gstatic.dnset.com\", \n   \"gxxservice.com\", \"helpdesk.cdn.freetcp.com\", \"id.serveuser.com\", \"infestexe.com\", \"item.itemdb.com\",\n   \"m.mircosoftdoc.com\", \"mail.transferdkim.xyz\", \"mcafee.updatenai.com\", \"mecgjm.mircosoftdoc.com\",\n   \"microdocs.ga\", \"microsock.website\", \"microsocks.net\", \"microsoft.sendsmtp.com\", \n   \"microsoftbook.dns05.com\", \"microsoftcontactcenter.com\", \"microsoftdocs.dns05.com\", \"microsoftdocs.ml\", \n   \"microsoftonetravel.com\", \"microsoftonlines.net\", \"microsoftprod.com\", \"microsofts.dns1.us\", \"microsoftsonline.net\",\n    \"minivineyapp.com\", \"mircosoftdoc.com\", \"mircosoftdocs.com\", \"mlcrosoft.ninth.biz\", \"mlcrosoft.site\", \n   \"mm.portomnail.com\", \"msdnupdate.com\", \"msecdn.cloud\", \"mtnl1.dynamic-dns.net\", \"ns.gstatic.dnset.com\", \n   \"ns.microsoftprod.com\", \"ns.steamappstore.com\", \"ns1.cdn.freetcp.com\", \"ns1.comcleanner.info\", \"ns1.dns-info.gq\", \n   \"ns1.dns05.cf\", \"ns1.dnstemplog.com\", \"ns1.dropdns.com\", \"ns1.microsoftonetravel.com\", \n   \"ns1.microsoftonlines.net\", \"ns1.microsoftprod.com\", \"ns1.microsoftsonline.net\", \"ns1.mlcrosoft.site\", \n   \"ns1.teams.wikaba.com\", \"ns1.windowsdefende.com\", \"ns2.comcleanner.info\", \"ns2.dnstemplog.com\", \n   \"ns2.microsoftonetravel.com\", \"ns2.microsoftprod.com\", \"ns2.microsoftsonline.net\", \"ns2.mlcrosoft.site\", \n   \"ns2.windowsdefende.com\", \"ns3.microsoftprod.com\", \"ns3.mlcrosoft.site\", \"nutrition.mrbasic.com\", \n   \"nutrition.youdontcare.com\", \"online.mlcrosoft.site\", \"online.msdnupdate.com\", \"outlookservce.site\", \n   \"owa.jetos.com\", \"owa.otzo.com\", \"pornotime.co\", \"portomnail.com\", \n   \"post.1a0.066e063ac.7c1947fa.ns1.steamappstore.com\", \"pricingdmdk.com\", \"prod.microsoftprod.com\", \n   \"product.microsoftprod.com\", \"ptcl.yourtrap.com\", \"query.api.sourcedns.tk\", \"rb.itemdb.com\", \"redditcdn.com\", \n   \"rss.otzo.com\", \"secure.msdnupdate.com\", \"service.dns22.ml\", \"service.gstatic.dnset.com\", \"service04.dns04.com\", \n   \"settings.teams.wikaba.com\", \"sip.outlookservce.site\", \"sixindent.epizy.com\", \"soft.msdnupdate.com\", \"sourcedns.ml\", \n   \"sourcedns.tk\", \"sport.msdnupdate.com\", \"spotifylite.cloud\", \"static.misecure.com\", \"steamappstore.com\", \n   \"store.otzo.com\", \"survey.outlookservce.site\", \"team.itemdb.com\", \"temp221.com\", \"test.microsoftprod.com\", \n   \"thisisaaa.000webhostapp.com\", \"token.dns04.com\", \"token.dns05.com\", \"transferdkim.xyz\", \n   \"travelsanignacio.com\", \"update08.com\", \"updated08.com\", \"updatenai.com\", \"wantforspeed.com\",\n    \"web.mircosoftdoc.com\", \"webmail.pornotime.co\", \"webwhois.team.itemdb.com\", \"windowsdefende.com\", \"wnswindows.com\",\n    \"ashcrack.freetcp.com\", \"battllestategames.com\", \"binannce.com\", \"cdsend.xyz\", \"comcleanner.info\", \"microsock.website\", \n   \"microsocks.net\", \"microsoftsonline.net\", \"mlcrosoft.site\", \"notify.serveuser.com\", \"ns1.microsoftprod.com\", \n   \"ns2.microsoftprod.com\", \"pricingdmdk.com\", \"steamappstore.com\", \"update08.com\", \"wnswindows.com\", \n   \"youtube.dns05.com\", \"z1.zalofilescdn.com\", \"z2.zalofilescdn.com\", \"zalofilescdn.com\"]); \n(union isfuzzy=true \n (CommonSecurityLog  \n | parse Message with * '(' DNSName ')' *  \n | where DNSName in~ (DomainNames) \n | extend Account = SourceUserID, Computer = DeviceName, IPAddress =  DestinationIP \n ), \n (_Im_Dns (domain_has_any=DomainNames)\n | extend DNSName = DnsQuery \n | extend IPAddress =  SrcIpAddr, Computer = Dvc\n ), \n (_Im_WebSession (url_has_any=DomainNames)\n | extend DNSName = tostring(parse_url(Url)[\"Host\"])\n | extend IPAddress =  SrcIpAddr, Computer = Dvc\n ), \n (VMConnection  \n | parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' * \n | where isnotempty(DNSName) \n | where DNSName  in~ (DomainNames) \n | extend IPAddress = RemoteIp \n ), \n ( \n  DeviceNetworkEvents \n | where isnotempty(RemoteUrl) \n | where RemoteUrl  in~ (DomainNames)  \n | extend IPAddress = RemoteIP \n | extend Computer = DeviceName \n ),\n (AzureDiagnostics \n | where ResourceType == \"AZUREFIREWALLS\"\n | where Category == \"AzureFirewallApplicationRule\"\n | parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n | where isnotempty(DestinationHost)\n | where DestinationHost has_any (DomainNames)  \n | extend DNSName = DestinationHost \n | extend IPAddress = SourceHost\n ) \n ) \n | extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress \n", "attributes": {"description": "'Identifies a match across various data feeds for domains IOCs related to the Barium activity group.\n References: https://www.justice.gov/opa/pr/seven-international-cyber-defendants-including-apt41-actors-charged-connection-computer'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/BariumIPIOC112020.yaml", "query_name": "Known Barium IP", "query": "let IPList = dynamic([\"216.24.185.74\", \"107.175.189.159\", \"192.210.132.102\", \"67.230.163.214\", \n  \"199.19.110.240\", \"107.148.130.176\", \"154.212.129.218\", \"172.86.75.54\", \"45.61.136.199\", \n  \"149.28.150.195\", \"108.61.214.194\", \"144.202.98.198\", \"149.28.84.98\", \"103.99.209.78\", \n  \"45.61.136.2\", \"176.122.162.149\", \"192.3.80.245\", \"149.28.23.32\", \"107.182.18.149\", \"107.174.45.134\", \n  \"149.248.18.104\", \"65.49.192.74\", \"156.255.2.154\", \"45.76.6.149\", \"8.9.11.130\", \"140.238.27.255\", \n  \"107.182.24.70\", \"176.122.188.254\", \"192.161.161.108\", \"64.64.234.24\", \"104.224.185.36\", \n  \"104.233.224.227\", \"104.36.69.105\", \"119.28.139.120\", \"161.117.39.130\", \"66.42.100.42\", \"45.76.31.159\", \n  \"149.248.8.134\", \"216.24.182.48\", \"66.42.103.222\", \"218.89.236.11\", \"180.150.227.249\", \"47.75.80.23\",\n  \"124.156.164.19\", \"149.248.62.83\", \"150.109.76.174\", \"222.209.187.207\", \"218.38.191.38\", \n  \"119.28.226.59\", \"66.42.98.220\", \"74.82.201.8\", \"173.242.122.198\", \"45.32.130.72\", \"89.35.178.10\", \n  \"89.43.60.113\"]); \n(union isfuzzy=true \n(CommonSecurityLog \n| where isnotempty(SourceIP) or isnotempty(DestinationIP) \n| where SourceIP in (IPList) or DestinationIP in (IPList) or Message has_any (IPList) \n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"Message\")  \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP, DestinationIP, DeviceProduct, DeviceAction, Message, Protocol, SourcePort, DestinationPort, DeviceAddress, DeviceName, IPMatch \n| extend timestamp = StartTimeUtc, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"IP in Message Field\")  \n), \n(OfficeActivity \n|extend SourceIPAddress = ClientIP, Account = UserId \n| where  SourceIPAddress in (IPList) \n| extend timestamp = TimeGenerated , IPCustomEntity = SourceIPAddress , AccountCustomEntity = Account \n),\n(_Im_Dns (response_has_any_prefix=IPList)\n| extend DestinationIPAddress = ResponseName,  Host = SrcIpAddr \n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host \n), \n(_Im_NetworkSession (srcipaddr_has_any_prefix=IPList)\n | extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Hostname, AccountCustomEntity=User\n), \n(_Im_NetworkSession (dstipaddr_has_any_prefix=IPList)\n| extend timestamp = TimeGenerated, IPCustomEntity = DstIpAddr, HostCustomEntity = Hostname , AccountCustomEntity = User\n), \n(WireData  \n| where isnotempty(RemoteIP) \n| where RemoteIP in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = Computer \n), \n(SigninLogs \n| where isnotempty(IPAddress) \n| where IPAddress in (IPList) \n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress \n),\n(AADNonInteractiveUserSignInLogs \n| where isnotempty(IPAddress) \n| where IPAddress in (IPList) \n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress \n), \n(W3CIISLog  \n| where isnotempty(cIP) \n| where cIP in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName \n), \n(AzureActivity  \n| where isnotempty(CallerIpAddress) \n| where CallerIpAddress in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = CallerIpAddress, AccountCustomEntity = Caller \n), \n( \nAWSCloudTrail \n| where isnotempty(SourceIpAddress) \n| where SourceIpAddress in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName \n), \n( \nDeviceNetworkEvents \n| where isnotempty(RemoteIP)  \n| where RemoteIP in (IPList)  \n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = DeviceName  \n),\n(\nAzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (IPList)  \n| extend DestinationIP = DestinationHost \n| extend IPCustomEntity = SourceHost\n),\n(\nAzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallNetworkRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (IPList)  \n| extend DestinationIP = DestinationHost \n| extend IPCustomEntity = SourceHost\n)\n) \n", "attributes": {"description": "'Identifies a match across various data feeds for IP IOCs related to the Barium activity group.  \n References: https://www.justice.gov/opa/pr/seven-international-cyber-defendants-including-apt41-actors-charged-connection-computer' \n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/CERIUMOct292020IOCs.yaml", "query_name": "Known CERIUM domains and hashes", "query": "let DomainNames = \"miniodaum.ml\";\nlet SHA256Hash = dynamic ([\"53f5773bbfbfbee660989d135c042c9f6f69024b9a4b65bdc0dfd44771762257\", \"0897c80df8b80b4c49bf1ccf876f5f782849608b830c3b5cb3ad212dc3e19eff\"]);\n(union isfuzzy=true\n(CommonSecurityLog \n| parse Message with * '(' DNSName ')' * \n| where isnotempty(FileHash)\n| where FileHash in (SHA256Hash) or DNSName =~ DomainNames\n| extend Account = SourceUserID, Computer = DeviceName, IPAddress = SourceIP\n),\n (_Im_Dns (domain_has_any=DomainNames)\n| extend DNSName = DnsQuery \n| extend IPAddress =  SrcIpAddr, Computer = Dvc\n), \n(_Im_WebSession(url_has_any=DomainNames) \n| extend DNSName = tostring(parse_url(Url)[\"Host\"])\n| extend IPAddress = SrcIpAddr, Account=User\n),\n(VMConnection \n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| where isnotempty(DNSName)\n| where DNSName =~ DomainNames\n| extend IPAddress = RemoteIp\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (DomainNames)  \n| extend DNSName = DestinationHost \n| extend IPAddress = SourceHost\n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress\n", "attributes": {"description": "'CERIUM malicious webserver and hash values for maldocs and malware. \n Matches domain name IOCs related to the CERIUM activity group with CommonSecurityLog, DnsEvents, and VMConnection dataTypes.'\n", "techniques": NaN, "tactics": ["CommandAndControl", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ChiaCryptoMining.yaml", "query_name": "Chia_Crypto_Mining - Domain, Process, Hash and IP IOCs - June 2021", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/ChiaCryptoIOC.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet process = (iocs | where Type =~ \"process\" | project IoC);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\nlet IPList = (iocs | where Type =~ \"ip\"| project IoC);\nlet domains = (iocs | where Type =~ \"domainname\"| project IoC);\nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\n//This query uses sysmon data, sections that have - | where Source == \"Microsoft-Windows-Sysmon\" - may need to be updated with latest\n(union isfuzzy=true\n(CommonSecurityLog\n| where SourceIP in (IPList) or DestinationIP in (IPList) or DestinationHostName has_any (domains) or RequestURL has_any (domains) or Message has_any (IPList)\n| parse Message with * '(' DNSName ')' * \n| project TimeGenerated, SourceIP, DestinationIP, Message, SourceUserID, RequestURL, DNSName, Type\n| extend MessageIP = extract(IPRegex, 0, Message), RequestIP = extract(IPRegex, 0, RequestURL)\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", MessageIP in (IPList), \"Message\", RequestURL has_any (domains), \"RequestUrl\", \"NoMatch\"),  AlertDetail = 'Chia crypto IOC detected'\n| extend timestamp = TimeGenerated, IPEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, IPMatch == \"Message\", MessageIP, \"NoMatch\"), Account = SourceUserID\n),\n(DnsEvents\n| where IPAddresses in (IPList) or Name in~ (domains)  \n| project TimeGenerated, Computer, IPAddresses, Name, ClientIP, Type\n| extend DestinationIPAddress = IPAddresses, DNSName = Name, Computer , AlertDetail = 'Chia crypto IOC detected'\n| extend timestamp = TimeGenerated, IPEntity = DestinationIPAddress\n),\n(VMConnection\n| where SourceIp in (IPList) or DestinationIp in (IPList) or RemoteDnsCanonicalNames has_any (domains)\n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, RemoteDnsQuestions, DNSName,BytesSent, BytesReceived, RemoteCountry, Type\n| extend IPMatch = case( SourceIp in (IPList), \"SourceIP\", DestinationIp in (IPList), \"DestinationIP\", \"None\") , AlertDetail = 'Chia crypto IOC detected'\n| extend timestamp = TimeGenerated, IPEntity = case(IPMatch == \"SourceIP\", SourceIp, IPMatch == \"DestinationIP\", DestinationIp, \"NoMatch\"), File = ProcessName\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 3\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend SourceIP = tostring(EventDetail.[9].[\"#text\"]), DestinationIP = tostring(EventDetail.[14].[\"#text\"]), Image = tostring(EventDetail.[4].[\"#text\"])\n| where SourceIP in (IPList) or DestinationIP in (IPList) or Image has_any (process)\n| project TimeGenerated, SourceIP, DestinationIP, Image, Account = UserName, Computer, Type\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\") , AlertDetail = 'Chia crypto IOC detected'\n| extend timestamp = TimeGenerated, File = tostring(split(Image, '\\\\', -1)[-1]), IPEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n| extend FilePath = replace_string(Image, File, '')\n),  \n(OfficeActivity\n| where ClientIP in (IPList) \n| project TimeGenerated, UserAgent, Operation, RecordType, UserId, ClientIP, AlertDetail = 'Chia crypto IOC detected', Type\n| extend timestamp = TimeGenerated, IPEntity = ClientIP, Account = UserId\n),\n(DeviceNetworkEvents\n| where RemoteUrl has_any (domains) or RemoteIP in (IPList) or InitiatingProcessSHA256 in (sha256Hashes) or InitiatingProcessFileName has_any (process)\n| project TimeGenerated, ActionType, DeviceId, Computer = DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RemoteIP, RemoteUrl, RemotePort, LocalIP, Type\n| extend timestamp = TimeGenerated, IPEntity = RemoteIP,  AlertDetail = 'Chia crypto IOC detected'\n),\n(WindowsFirewall\n| where SourceIP in (IPList) or DestinationIP in (IPList) \n| project TimeGenerated, Computer, CommunicationDirection, SourceIP, DestinationIP, SourcePort, DestinationPort, Type\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\"), AlertDetail = 'Chia crypto IOC detected'\n| extend timestamp = TimeGenerated, Computer, IPEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n),\n(AzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallDnsProxy\"\n| project TimeGenerated,Resource, msg_s, Type\n| parse msg_s with \"DNS Request: \" ClientIP \":\" ClientPort \" - \" QueryID \" \" Request_Type \" \" Request_Class \" \" Request_Name \". \" Request_Protocol \" \" Request_Size \" \" EDNSO_DO \" \" EDNS0_Buffersize \" \" Responce_Code \" \" Responce_Flags \" \" Responce_Size \" \" Response_Duration\n| where Request_Name has_any (domains)  or ClientIP in (IPList)\n| extend timestamp = TimeGenerated, DNSName = Request_Name, IPEntity = ClientIP, AlertDetail = 'Chia crypto IOC detected'\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| project TimeGenerated,Resource, msg_s, Type\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (domains)  \n| extend timestamp = TimeGenerated, DNSName = DestinationHost, IPEntity = SourceHost, AlertDetail = 'Chia crypto IOC detected'\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| where EventDetail has_any (sha256Hashes) \n| parse EventDetail with * 'SHA256=' SHA256 '\",' *\n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, SHA256\n| extend Type = strcat(Type, \": \", Source), Account = UserName, FileHash = SHA256, Image = tostring(EventDetail.[4].[\"#text\"]), AlertDetail = 'Chia crypto IOC detected'\n| extend timestamp = TimeGenerated, Computer, Account, File = tostring(split(Image, '\\\\', -1)[-1]), FileHashAlgo = 'SHA256'\n| extend FilePath = replace_string(Image, File, '')\n),\n(DeviceFileEvents\n| where  InitiatingProcessFolderPath has_any (process)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RequestAccountName, RequestSourceIP, InitiatingProcessSHA256, Type\n| extend Account = RequestAccountName, Computer = DeviceName, IPAddress = RequestSourceIP, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256, AlertDetail = 'Chia crypto IOC detected'\n| extend timestamp = TimeGenerated, Computer, Account, File = InitiatingProcessFileName, FileHashAlgo = 'SHA256'\n| extend FilePath = replace_string(InitiatingProcessFolderPath, File, '')\n),\n(CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated, Message, SourceUserID, FileHash, Type\n| extend timestamp = TimeGenerated, AlertDetail = 'Chia crypto IOC detected', FileHashAlgo = 'SHA256', Account = SourceUserID\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| project TimeGenerated, EventDetail, UserName, Computer, Type\n| extend Image = tostring(EventDetail.[4].[\"#text\"]), CommandLine = tostring(EventDetail.[10].[\"#text\"]), Account = UserName, FileHash = tostring(EventDetail.[17].[\"#text\"]), AlertDetail = 'Chia crypto IOC detected'\n| where Image has_any (process)\n| extend timestamp = TimeGenerated, Computer, Account, File = tostring(split(Image, '\\\\', -1)[-1]), FileHashAlgo = 'SHA256'\n| extend FilePath= replace_string(Image, File, '')\n),\n(DeviceEvents\n| where  InitiatingProcessFileName has_any (process) or InitiatingProcessSHA256 in~ (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend Account = InitiatingProcessAccountName, Computer = DeviceName, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256, Image = InitiatingProcessFolderPath, AlertDetail = 'Chia crypto IOC detected'\n| extend timestamp = TimeGenerated, Computer, Account, File = InitiatingProcessFileName, FileHashAlgo = 'SHA256'\n| extend FilePath = replace_string(InitiatingProcessFolderPath, File, '')\n),\n(SecurityEvent\n| where EventID == '4688'\n| where NewProcessName  has_any (process)\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type\n| extend timestamp = TimeGenerated, Computer, Account, File = tostring(split(NewProcessName, '\\\\', -1)[-1]), AlertDetail = 'Chia crypto IOC detected'\n| extend FilePath = replace_string(NewProcessName, File, '')\n)\n)\n| extend AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPEntity, FileCustomEntity = File, FilePathCustomEntity = FilePath, FileHashCustomEntity = FileHash\n", "attributes": {"description": "'Identifies a match across various data feeds for domains, process, hashes and IP IOC related to Chia cryptocurrency farming/plotting activity.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/COMRegistryKeyModifiedtoPointtoFileinColorDrivers.yaml", "query_name": "COM Registry Key Modified to Point to File in Color Profile Folder", "query": "let guids = dynamic([\"{ddc05a5a-351a-4e06-8eaf-54ec1bc2dcea}\",\"{1f486a52-3cb1-48fd-8f50-b8dc300d9f9d}\",\"{4590f811-1d3a-11d0-891f-00aa004b2e24}\", \"{4de225bf-cf59-4cfc-85f7-68b90f185355}\", \"{F56F6FDD-AA9D-4618-A949-C1B91AF43B1A}\"]);\n  let mde_data = DeviceRegistryEvents\n  | where ActionType =~ \"RegistryValueSet\"\n  | where RegistryKey contains \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Classes\\\\CLSID\"\n  | where RegistryKey has_any (guids)\n  | where RegistryValueData has \"System32\\\\spool\\\\drivers\\\\color\";\n  let event_data = SecurityEvent\n  | where EventID == 4657\n  | where ObjectName contains \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Classes\\\\CLSID\"\n  | where ObjectName has_any (guids)\n  | where NewValue has \"System32\\\\spool\\\\drivers\\\\color\"\n  | extend RegistryKey = ObjectName, RegistryValueData = NewValue, DeviceName=Computer, InitiatingProcessFileName = Process, InitiatingProcessAccountName=SubjectAccount;\n  union mde_data, event_data\n", "attributes": {"description": "'This query looks for changes to COM registry keys to point to files in C:\\Windows\\System32\\spool\\drivers\\color\\.\n  This can be used to enable COM hijacking for persistence.\n  Ref: https://www.microsoft.com/security/blog/2022/07/27/untangling-knotweed-european-private-sector-offensive-actor-using-0-day-exploits/'\n", "techniques": ["T1574"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0228FilePathHashesNovember2021.yaml", "query_name": "Dev-0228 File Path Hashes November 2021", "query": "let files1 = dynamic([\"C:\\\\Windows\\\\TAPI\\\\lsa.exe\", \"C:\\\\Windows\\\\TAPI\\\\pa.exe\", \"C:\\\\Windows\\\\TAPI\\\\pc.exe\", \"C:\\\\Windows\\\\TAPI\\\\Rar.exe\"]);\nlet files2 = dynamic([\"svchost.exe\",\"wdmsvc.exe\"]);\nlet FileHash1 = dynamic([\"43109fbe8b752f7a9076eaafa417d9ae5c6e827cd5374b866672263fdebd5ec3\", \"ab50d8d707b97712178a92bbac74ccc2a5699eb41c17aa77f713ff3e568dcedb\", \"010e32be0f86545e116a8bc3381a8428933eb8789f32c261c81fd5e7857d4a77\",         \"56cd102b9fc7f3523dad01d632525ff673259dbc9a091be0feff333c931574f7\"]);\nlet FileHash2 = dynamic([\"2a1044e9e6e87a032f80c6d9ea6ae61bbbb053c0a21b186ecb3b812b49eb03b7\", \"9ab7e99ed84f94a7b6409b87e56dc6e1143b05034a5e4455e8c555dbbcd0d2dd\", \"18a072ccfab239e140d8f682e2874e8ff19d94311fc8bb9564043d3e0deda54b\"]);\nDeviceProcessEvents\n| where ( FolderPath has_any (files1) and SHA256 has_any (FileHash1)) or (FolderPath has_any (files2) and SHA256 has_any (FileHash2))\n| extend DvcId = DeviceId\n| join kind=leftouter (SecurityAlert\n| where ProviderName =~ \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| mv-expand todynamic(Entities)\n| extend DvcId = tostring(parse_json(Entities).MdatpDeviceId)\n| where isnotempty(DvcId)\n// Higher risk score are for Defender alerts related to threat actor\n| extend AlertRiskScore = iif(ThreatName has_any (\"Backdoor:MSIL/ShellClient.A\", \"Backdoor:MSIL/ShellClient.A!dll\", \"Trojan:MSIL/Mimikatz.BA!MTB\"), 1.0, 0.5)\n| project DvcId, AlertRiskScore) on DvcId\n| extend AlertRiskScore = iif(isempty(AlertRiskScore), 0.0, AlertRiskScore)\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName, AccountCustomEntity = AccountName\n", "attributes": {"description": "'This hunting query looks for file paths/hashes related to observed activity by Dev-0228. The actor is known to use custom version of popular tool like PsExec, Procdump etc. to carry its activity.\n The risk score associated with each result is based on a number of factors, hosts with higher risk events should be investigated first.'\n", "techniques": ["T1569", "T1003"], "tactics": ["CredentialAccess", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0270NewUserSep2022.yaml", "query_name": "DEV-0270 New User Creation", "query": "(union isfuzzy=true\n(SecurityEvent\n| where EventID == 4688\n| where CommandLine has_all ('net user', '/add') \n| parse CommandLine with * \"user \" username \" \"*\n| extend password = extract(@\"\\buser\\s+[^\\s]+\\s+([^\\s]+)\", 1, CommandLine) \n| where username in('DefaultAccount') or password in('P@ssw0rd1234', '_AS_@1394') \n| project TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(DeviceProcessEvents \n| where InitiatingProcessCommandLine has_all('net user', '/add') \n| parse InitiatingProcessCommandLine with * \"user \" username \" \"* \n| extend password = extract(@\"\\buser\\s+[^\\s]+\\s+([^\\s]+)\", 1, InitiatingProcessCommandLine) \n| where username in('DefaultAccount') or password in('P@ssw0rd1234', '_AS_@1394') \n| extend timestamp = TimeGenerated, AccountCustomEntity =  InitiatingProcessAccountName, HostCustomEntity = DeviceName\n)\n)\n", "attributes": {"description": "'The following query tries to detect creation of a new user using a known DEV-0270 username/password schema'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0270PowershellSep2022.yaml", "query_name": "Dev-0270 Malicious Powershell usage", "query": "(union isfuzzy=true\n(SecurityEvent\n| where EventID==4688\n| extend FileName=tostring(split(NewProcessName, @'')[(-1)]),  ProcessCommandLine = CommandLine, InitiatingProcessFileName=ParentProcessName\n| where (FileName =~ \"powershell.exe\" and ProcessCommandLine has_all(\"try\", \"Add-MpPreference\", \"-ExclusionPath\", \"ProgramData\", \"catch\")) or (FileName =~ 'powershell.exe' and ProcessCommandLine has_all('Add-PSSnapin', 'Get-Recipient', '-ExpandProperty', 'EmailAddresses', 'SmtpAddress', '-hidetableheaders') )\n| project TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(DeviceProcessEvents \n| where (FileName =~ \"powershell.exe\" and ((ProcessCommandLine has_all(\"try\", \"Add-MpPreference\", \"-ExclusionPath\", \"ProgramData\", \"catch\"))  or (ProcessCommandLine has_all('Add-PSSnapin', 'Get-Recipient', '-ExpandProperty', 'EmailAddresses', 'SmtpAddress', '-hidetableheaders'))))\nor ( InitiatingProcessFileName =~ 'powershell.exe' and (((InitiatingProcessCommandLine has_all('$file=', 'dllhost.exe', 'Invoke-WebRequest', '-OutFile')) or ((InitiatingProcessCommandLine has_all('$admins=', 'System.Security.Principal.SecurityIdentifier', 'Translate', '-split', 'localgroup', '/add', '$rdp='))))))\n| extend timestamp = TimeGenerated, AccountCustomEntity =  InitiatingProcessAccountName, HostCustomEntity = DeviceName\n)\n)\n", "attributes": {"description": "'DEV-0270 heavily uses powershell to achieve their objective at various stages of their attack. To locate powershell related activity tied to the actor, Microsoft Sentinel customers can run the following query.'\n", "techniques": ["T1048", "T1562"], "tactics": ["Exfiltration", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0270RegistryIOCSep2022.yaml", "query_name": "Dev-0270 Registry IOC - September 2022", "query": "(union isfuzzy=true\n(SecurityEvent\n| where EventID == 4688\n| where (CommandLine has_all  ('reg', 'add', 'HKLM\\\\SOFTWARE\\\\Policies\\\\', '/v','/t', 'REG_DWORD', '/d', '/f') and CommandLine has_any('DisableRealtimeMonitoring', 'UseTPMKey', 'UseTPMKeyPIN', 'UseAdvancedStartup', 'EnableBDEWithNoTPM', 'RecoveryKeyMessageSource'))\n  or CommandLine has_all ('reg', 'add', 'HKLM\\\\SOFTWARE\\\\Policies\\\\', '/v','/t', 'REG_DWORD', '/d', '/f', 'RecoveryKeyMessage', 'Your drives are Encrypted!', '@')\n| project TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(DeviceProcessEvents \n| where (InitiatingProcessCommandLine has_all(@'\"reg\"', 'add', @'\"HKLM\\SOFTWARE\\Policies\\', '/v','/t', 'REG_DWORD', '/d', '/f') \n   and InitiatingProcessCommandLine has_any('DisableRealtimeMonitoring', 'UseTPMKey', 'UseTPMKeyPIN', 'UseAdvancedStartup', 'EnableBDEWithNoTPM', 'RecoveryKeyMessageSource') ) \n   or InitiatingProcessCommandLine has_all('\"reg\"', 'add', @'\"HKLM\\SOFTWARE\\Policies\\', '/v','/t', 'REG_DWORD', '/d', '/f', 'RecoveryKeyMessage', 'Your drives are Encrypted!', '@')\n| extend timestamp = TimeGenerated, AccountCustomEntity =  InitiatingProcessAccountName, HostCustomEntity = DeviceName\n )\n )\n", "attributes": {"description": "'The query below identifies modification of registry by Dev-0270 actor to disable security feature as well as to add ransom notes'\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0270WMICDiscoverySep2022.yaml", "query_name": "Dev-0270 WMIC  Discovery", "query": "(union isfuzzy=true\n(SecurityEvent\n| where EventID==4688\n| where CommandLine has \"wmic computersystem get domain\" and ParentProcessName =~ \"dllhost.exe\"\n| project TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(DeviceProcessEvents \n| where InitiatingProcessFileName =~ \"dllhost.exe\" and InitiatingProcessCommandLine == \"dllhost.exe\" \n| where ProcessCommandLine has \"wmic computersystem get domain\" \n| extend timestamp = TimeGenerated, AccountCustomEntity =  InitiatingProcessAccountName, HostCustomEntity = DeviceName\n)\n)\n", "attributes": {"description": "'The query below identifies dllhost.exe using WMIC to discover additional hosts and associated domains in the environment.'\n", "techniques": ["T1482"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/DEV-0322_SolarWinds_Serv-U_IOC.yaml", "query_name": "DEV-0322 Serv-U related IOCs - July 2021", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/DEV-0322_SolarWinds_Serv-U_IoC.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet process = (iocs | where Type =~ \"process\" | project IoC);\nlet parentprocess = (iocs | where Type =~ \"parentprocess\" | project IoC);\nlet IPList = (iocs | where Type =~ \"ip\"| project IoC);\nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\n(union isfuzzy=true\n(CommonSecurityLog\n| where SourceIP in (IPList) or DestinationIP in (IPList) or RequestURL has_any (IPList) or Message has_any (IPList)\n| project TimeGenerated, SourceIP, DestinationIP, Message, SourceUserID, RequestURL, Type\n| extend MessageIP = extract(IPRegex, 0, Message)\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", MessageIP in (IPList), \"Message\", RequestURL in (IPList), \"RequestUrl\",\"NoMatch\"), AlertDetail = 'Dev-0322 IOC match'\n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, IPMatch == \"Message\", MessageIP, IPMatch == \"RequestUrl\", RequestURL, \"NoMatch\"), AccountCustomEntity = SourceUserID\n),\n(DnsEvents\n| where IPAddresses in (IPList)  \n| project TimeGenerated, Computer, IPAddresses, Name, ClientIP, Type\n| extend DestinationIPAddress = IPAddresses, DNSName = Name, Host = Computer , AlertDetail = 'Dev-0322 IOC match'\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host\n),\n(VMConnection\n| where SourceIp in (IPList) or DestinationIp in (IPList)\n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, RemoteDnsQuestions, DNSName,BytesSent, BytesReceived, RemoteCountry, Type\n| extend IPMatch = case( SourceIp in (IPList), \"SourceIP\", DestinationIp in (IPList), \"DestinationIP\", \"None\") , AlertDetail = 'Dev-0322 IOC match'\n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIp, IPMatch == \"DestinationIP\", DestinationIp, \"NoMatch\"), HostCustomEntity = Computer, ProcessCustomEntity = ProcessName\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 3\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend SourceIP = EventDetail.[9].[\"#text\"], DestinationIP = EventDetail.[14].[\"#text\"], Image = EventDetail.[4].[\"#text\"]\n| where SourceIP in (IPList) or DestinationIP in (IPList) \n| project TimeGenerated, SourceIP, DestinationIP, Image, UserName, Computer, Type\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\") , AlertDetail = 'Dev-0322 IOC match'\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), HostCustomEntity = Computer , IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n),  \n(OfficeActivity\n| where ClientIP in (IPList) \n| project TimeGenerated, UserAgent, Operation, RecordType, UserId, ClientIP, AlertDetail = 'Dev-0322 IOC match', Type\n| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, AccountCustomEntity = UserId\n),\n(DeviceNetworkEvents\n| where  RemoteIP in (IPList)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RemoteIP, RemoteUrl, RemotePort, LocalIP, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = DeviceName,  AlertDetail = 'Dev-0322 IOC match', UrlCustomEntity =RemoteUrl, ProcessCustomEntity = InitiatingProcessFileName\n),\n(WindowsFirewall\n| where SourceIP in (IPList) or DestinationIP in (IPList) \n| project TimeGenerated, Computer, CommunicationDirection, SourceIP, DestinationIP, SourcePort, DestinationPort, Type\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\"), AlertDetail = 'Dev-0322 IOC match'\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n),\n(AzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallDnsProxy\"\n| project TimeGenerated,Resource, msg_s, Type\n| parse msg_s with \"DNS Request: \" ClientIP \":\" ClientPort \" - \" QueryID \" \" Request_Type \" \" Request_Class \" \" Request_Name \". \" Request_Protocol \" \" Request_Size \" \" EDNSO_DO \" \" EDNS0_Buffersize \" \" Responce_Code \" \" Responce_Flags \" \" Responce_Size \" \" Response_Duration\n| where  ClientIP in (IPList)\n| extend timestamp = TimeGenerated, DNSName = Request_Name, IPCustomEntity = ClientIP, AlertDetail = 'Dev-0322 IOC match'\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| project TimeGenerated,Resource, msg_s\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where SourceHost in (IPList)\n| extend timestamp = TimeGenerated, DNSName = DestinationHost, IPCustomEntity = SourceHost, AlertDetail = 'Dev-0322 IOC match'\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend ParentImage = EventDetail.[20].[\"#text\"], Image = EventDetail.[4].[\"#text\"]\n| where ( ParentImage has_any (parentprocess) and Image has_any (process))\n| parse EventDetail with * 'SHA256=' SHA256 '\",' *\n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, SHA256,Image, ParentImage \n| extend Type = strcat(Type, \": \", Source), Account = UserName, FileHash = SHA256, AlertDetail = 'Dev-0322 IOC match'\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(DeviceFileEvents\n| extend CommandLineIP = extract(IPRegex, 0,InitiatingProcessCommandLine)\n| where (InitiatingProcessFileName in (process) and InitiatingProcessParentFileName in (parentprocess))  or CommandLineIP in (IPList)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RequestAccountName, RequestSourceIP, InitiatingProcessSHA256, Type, CommandLineIP\n| extend Account = RequestAccountName, Computer = DeviceName, IPAddress = RequestSourceIP, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256, AlertDetail = 'Dev-0322 IOC match'\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash, IPCustomEntity = CommandLineIP\n),\n(DeviceEvents\n| extend CommandLineIP = extract(IPRegex, 0,InitiatingProcessCommandLine)\n| where (InitiatingProcessFileName in (process) and InitiatingProcessParentFileName in (parentprocess)) or CommandLineIP in (IPList)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type, CommandLineIP\n| extend Account = InitiatingProcessAccountName, Computer = DeviceName, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256, Image = InitiatingProcessFolderPath, AlertDetail = 'Dev-0322 IOC match'\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash, IPCustomEntity = CommandLineIP\n),\n(DeviceProcessEvents\n| extend CommandLineIP = extract(IPRegex, 0,InitiatingProcessCommandLine)\n| where (InitiatingProcessFileName in (process) and InitiatingProcessParentFileName in (parentprocess))  or CommandLineIP in (IPList)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName,  InitiatingProcessSHA256, Type, CommandLineIP, AccountName\n| extend Account = AccountName, Computer = DeviceName, IPAddress = CommandLineIP, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256, AlertDetail = 'Dev-0322 IOC match'\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash, IPCustomEntity = IPAddress\n),\n(  SecurityEvent\n| where EventID == 4688\n| extend CommandLineIP = extract(IPRegex, 0, CommandLine)\n| where CommandLineIP in (IPList) or (NewProcessName  has_any (process) and ParentProcessName has_any (parentprocess))\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, CommandLine, CommandLineIP\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName, AlertDetail = 'Dev-0322 IOC match', IPCustomEntity = CommandLineIP\n)\n)\n", "attributes": {"description": "'Identifies a match across IOC's related to DEV-0322 targeting SolarWinds Serv-U software.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0530_FileExtRename.yaml", "query_name": "Dev-0530 File Extension Rename", "query": "(union isfuzzy=true\n(DeviceFileEvents\n| where ActionType == \"FileCreated\"\n| where FileName endswith \".h0lyenc\" or FolderPath == \"C:\\\\FOR_DECRYPT.html\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by AccountCustomEntity = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName), HostCustomEntity = DeviceName, Type, InitiatingProcessId, FileName, FolderPath, EventType = ActionType, Commandline = InitiatingProcessCommandLine, InitiatingProcessFileName, InitiatingProcessSHA256, FileHashCustomEntity = SHA256\n),\n(imFileEvent\n| where EventType == \"FileCreated\" \n| where TargetFilePath endswith \".h0lyenc\" or TargetFilePath == \"C:\\\\FOR_DECRYPT.html\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by AccountCustomEntity = ActorUsername, HostCustomEntity = DvcHostname, DvcId, Type, EventType,  FileHashCustomEntity = TargetFileSHA256, Hash, TargetFilePath, Commandline = ActingProcessCommandLine\n)\n)\n", "attributes": {"description": "'Dev-0530 actors are known to encrypt the contents of the victims device as well as renaming the file extensions. This query looks for the creation of files with .h0lyenc extension or presence of ransom note.'\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0530_July2022.yaml", "query_name": "Dev-0530 IOC - July 2022", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Dev-0530_July2022.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\nlet IPList = (iocs | where Type =~ \"ip\"| project IoC);\n(union isfuzzy=true \n(DeviceProcessEvents\n| where InitiatingProcessSHA256 in (sha256Hashes) or SHA256 in (sha256Hashes) or ( InitiatingProcessCommandLine has ('cmd.exe /Q /c schtasks /create /tn lockertask /tr') \nand InitiatingProcessCommandLine has ('sc minute /mo 1 /F /ru system'))\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName,  InitiatingProcessSHA256, Type, AccountName, SHA256\n| extend Account = AccountName, Computer = DeviceName,  CommandLine = InitiatingProcessCommandLine, FileHash = case(InitiatingProcessSHA256 in (sha256Hashes), \"InitiatingProcessSHA256\", SHA256 in (sha256Hashes), \"SHA256\", \"No Match\")\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, FileHashCustomEntity = case(FileHash == \"InitiatingProcessSHA256\", InitiatingProcessSHA256, FileHash == \"SHA256\", SHA256, \"No Match\")\n),\n( SecurityEvent\n| where EventID == 4688\n| where ( CommandLine has ('cmd.exe /Q /c schtasks /create /tn lockertask /tr') and CommandLine has ('/sc minute /mo 1 /F /ru system'))\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, EventID, CommandLine\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n),\n( imFileEvent\n| where Hash in~ (sha256Hashes) or  ( ActingProcessCommandLine has ('cmd.exe /Q /c schtasks /create /tn lockertask /tr') and ActingProcessCommandLine has ('/sc minute /mo 1 /F /ru system'))\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, FileHashCustomEntity = FileHash\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"], Hashes = tostring(EventDetail.[17].[\"#text\"])\n| extend Hashes = extract_all(@\"(?P<key>\\w+)=(?P<value>[a-zA-Z0-9]+)\", dynamic([\"key\",\"value\"]), Hashes)\n| extend Hashes = column_ifexists(\"Hashes\", \"\"), CommandLine = column_ifexists(\"CommandLine\", \"\")\n| where (Hashes has_any (sha256Hashes) ) or ( CommandLine has ('cmd.exe /Q /c schtasks /create /tn lockertask /tr') and CommandLine has ('/sc minute /mo 1 /F /ru system')) \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, Hashes, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), FileHashCustomEntity = Hashes\n),\n(DeviceFileEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(EmailEvents\n| where SenderFromAddress == 'H0lyGh0st@mail2tor.com'\n| extend timestamp = TimeGenerated, IPCustomEntity = SenderIPv4, AccountCustomEntity = SenderFromAddress \n),\n(CommonSecurityLog \n| where isnotempty(SourceIP) or isnotempty(DestinationIP) \n| where SourceIP in (IPList) or DestinationIP in (IPList) or Message has_any (IPList) or FileHash in (sha256Hashes)\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"Message\")  \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP, DestinationIP, DeviceProduct, DeviceAction, Message, Protocol, SourcePort, DestinationPort, DeviceAddress, DeviceName, IPMatch , FileHash\n| extend timestamp = StartTimeUtc, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"IP in Message Field\")  \n), \n(OfficeActivity \n|extend SourceIPAddress = ClientIP, Account = UserId \n| where  SourceIPAddress in (IPList) \n| extend timestamp = TimeGenerated , IPCustomEntity = SourceIPAddress , AccountCustomEntity = Account \n),\n(SigninLogs \n| where isnotempty(IPAddress) \n| where IPAddress in (IPList) \n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress \n),\n(AADNonInteractiveUserSignInLogs \n| where isnotempty(IPAddress) \n| where IPAddress in (IPList) \n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress \n), \n(W3CIISLog  \n| where isnotempty(cIP) \n| where cIP in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName \n), \n(AzureActivity  \n| where isnotempty(CallerIpAddress) \n| where CallerIpAddress in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = CallerIpAddress, AccountCustomEntity = Caller \n), \n( \nAWSCloudTrail \n| where isnotempty(SourceIpAddress) \n| where SourceIpAddress in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName \n), \n( \nDeviceNetworkEvents \n| where isnotempty(RemoteIP)  \n| where RemoteIP in (IPList)  \n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = DeviceName  \n),\n(\nAzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (IPList)  \n| extend DestinationIP = DestinationHost \n| extend IPCustomEntity = SourceHost\n),\n(\nAzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallNetworkRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (IPList)  \n| extend DestinationIP = DestinationHost \n| extend IPCustomEntity = SourceHost\n)\n)\n", "attributes": {"description": "'Identifies a IOC match related to Dev-0530 actor across various data sources.'\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Dev-0586_Jan2022_IOC.yaml", "query_name": "DEV-0586 Actor IOC - January 2022", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/DEV-0586.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\nlet Command_Line = (iocs | where Type =~ \"CommandLine\" | project IoC);\n(union isfuzzy=true\n(DeviceProcessEvents\n| where InitiatingProcessSHA256 in (sha256Hashes) or SHA256 in (sha256Hashes) or ( InitiatingProcessCommandLine has ('127.0.0.1\\\\ADMIN$') and InitiatingProcessCommandLine has_any (Command_Line))\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName,  InitiatingProcessSHA256, Type, AccountName, SHA256\n| extend Account = AccountName, Computer = DeviceName,  CommandLine = InitiatingProcessCommandLine, FileHash = case(InitiatingProcessSHA256 in (sha256Hashes), \"InitiatingProcessSHA256\", SHA256 in (sha256Hashes), \"SHA256\", \"No Match\")\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, FileHashCustomEntity = case(FileHash == \"InitiatingProcessSHA256\", InitiatingProcessSHA256, FileHash == \"SHA256\", SHA256, \"No Match\")\n),\n( SecurityEvent\n| where EventID == 4688\n| where ( CommandLine has (@'127.0.0.1\\\\ADMIN$') and CommandLine has_any (Command_Line))\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, EventID\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n),\n( CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated, Message, SourceUserID, FileHash, Type\n| extend timestamp = TimeGenerated, FileHashCustomEntity = 'SHA256', Account = SourceUserID\n),\n( imFileEvent\n| where Hash in~ (sha256Hashes) or  ( ActingProcessCommandLine has ('127.0.0.1\\\\ADMIN$') and ActingProcessCommandLine has_any (Command_Line))\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"], Hashes = tostring(EventDetail.[17].[\"#text\"])\n| extend Hashes = extract_all(@\"(?P<key>\\w+)=(?P<value>[a-zA-Z0-9]+)\", dynamic([\"key\",\"value\"]), Hashes)\n| extend Hashes = column_ifexists(\"Hashes\", \"\"), CommandLine = column_ifexists(\"CommandLine\", \"\")\n| where (Hashes has_any (sha256Hashes) ) or ( CommandLine has ('127.0.0.1\\\\ADMIN$') and CommandLine has_any (Command_Line)) \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, Hashes, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), FileHashCustomEntity = Hashes\n)\n)\n", "attributes": {"description": "'Identifies a match across IOC's related to an actor tracked by Microsoft as DEV-0586\n Refrence: https://www.microsoft.com/security/blog/2022/01/15/destructive-malware-targeting-ukrainian-organizations/'\n", "techniques": ["T1561"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/EmailAccessviaActiveSync.yaml", "query_name": "Email access via active sync", "query": "let timeframe = 1d;\nlet cmdList = dynamic([\"Set-CASMailbox\",\"ActiveSyncAllowedDeviceIDs\",\"add\"]);\n(union isfuzzy=true\n(\nSecurityEvent\n| where TimeGenerated >= ago(timeframe)\n| where EventID == 4688\n| where CommandLine has_all (cmdList)\n| project Type, TimeGenerated, Computer, Account, SubjectDomainName, SubjectUserName, Process, ParentProcessName, CommandLine\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n( WindowsEvent\n| where TimeGenerated >= ago(timeframe)\n| where EventID == 4688\n| where EventData has_all (cmdList)\n| extend CommandLine = tostring(EventData.CommandLine) \n| where CommandLine has_all (cmdList)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| project Type, TimeGenerated, Computer, Account, SubjectDomainName, SubjectUserName, Process, ParentProcessName, CommandLine\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(\nDeviceProcessEvents\n| where TimeGenerated >= ago(timeframe)\n| where InitiatingProcessCommandLine has_all (cmdList)\n| project Type, TimeGenerated, DeviceName, AccountName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessFileName, InitiatingProcessParentFileName,  InitiatingProcessCommandLine\n| extend timestamp = TimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = DeviceName\n),\n(\nEvent\n| where TimeGenerated > ago(timeframe)\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| where TimeGenerated >= ago(timeframe)\n| where CommandLine has_all (cmdList)\n| extend Type = strcat(Type, \": \", Source)\n| project Type, TimeGenerated, Computer, User, Process, ParentImage, CommandLine\n| extend timestamp = TimeGenerated, AccountCustomEntity = User, HostCustomEntity = Computer\n)\n)\n", "attributes": {"description": "This query detects attempts to add attacker devices as allowed IDs for active sync using the Set-CASMailbox command.\nThis technique was seen in relation to Solorigate attack but the results can indicate potential malicious activity used in different attacks.\n- Note that this query can be changed to use the KQL \"has_all\" operator, which hasn't yet been documented officially, but will be soon.\n  In short, \"has_all\" will only match when the referenced field has all strings in the list.\n- Refer to Set-CASMailbox syntax: https://docs.microsoft.com/powershell/module/exchange/set-casmailbox?view=exchange-ps  \n", "techniques": ["T1068", "T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/EUROPIUM%20_September2022.yaml", "query_name": "Europium - Hash and IP IOCs - September 2022", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Europium_September2022.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\nlet IPList = (iocs | where Type =~ \"ip\"| project IoC);\nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\n(union isfuzzy=true\n(CommonSecurityLog\n| where SourceIP in (IPList) or DestinationIP in (IPList) or Message has_any (IPList)\n| parse Message with * '(' DNSName ')' * \n| project TimeGenerated, SourceIP, DestinationIP, Message, SourceUserID, RequestURL, DNSName, Type\n| extend MessageIP = extract(IPRegex, 0, Message), RequestIP = extract(IPRegex, 0, RequestURL)\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", MessageIP in (IPList), \"Message\",  \"NoMatch\")\n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, IPMatch == \"Message\", MessageIP, \"NoMatch\"), AccountCustomEntity = SourceUserID\n),\n(DnsEvents\n| where IPAddresses in (IPList)  \n| project TimeGenerated, Computer, IPAddresses, Name, ClientIP, Type\n| extend DestinationIPAddress = IPAddresses, DNSName = Name, Computer \n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Computer\n),\n(VMConnection\n| where SourceIp in (IPList) or DestinationIp in (IPList)\n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, RemoteDnsQuestions, DNSName,BytesSent, BytesReceived, RemoteCountry, Type\n| extend IPMatch = case( SourceIp in (IPList), \"SourceIP\", DestinationIp in (IPList), \"DestinationIP\", \"None\") \n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIp, IPMatch == \"DestinationIP\", DestinationIp, \"NoMatch\"), File = ProcessName, HostCustomEntity = Computer\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 3\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend SourceIP = tostring(EventDetail.[9].[\"#text\"]), DestinationIP = tostring(EventDetail.[14].[\"#text\"]), Image = tostring(EventDetail.[4].[\"#text\"])\n| where SourceIP in (IPList) or DestinationIP in (IPList)\n| project TimeGenerated, SourceIP, DestinationIP, Image, UserName, Computer, Type\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\")\n| extend timestamp = TimeGenerated, File = tostring(split(Image, '\\\\', -1)[-1]), IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\"), HostCustomEntity = Computer, AccountCustomEntity = UserName\n), \n(OfficeActivity\n| where ClientIP in (IPList) \n| project TimeGenerated, UserAgent, Operation, RecordType, UserId, ClientIP, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, AccountCustomEntity = UserId\n),\n(DeviceNetworkEvents\n| where RemoteIP in (IPList) or InitiatingProcessSHA256 in (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, Computer = DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RemoteIP, RemoteUrl, RemotePort, LocalIP, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP,  HostCustomEntity = Computer, AccountCustomEntity = InitiatingProcessAccountName\n),\n(WindowsFirewall\n| where SourceIP in (IPList) or DestinationIP in (IPList) \n| project TimeGenerated, Computer, CommunicationDirection, SourceIP, DestinationIP, SourcePort, DestinationPort, Type\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\")\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n), \n(imFileEvent\n| where TargetFileSHA256 has_any (sha256Hashes)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n| extend timestamp = TimeGenerated, IPCustomEntity = IPAddress,  HostCustomEntity = Computer, AccountCustomEntity = Account, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(DeviceFileEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName,  AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceImageLoadEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName,  AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(Event\n| where Source =~ \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"], Hashes = tostring(EventDetail.[17].[\"#text\"])\n| extend Hashes = extract_all(@\"(?P<key>\\w+)=(?P<value>[a-zA-Z0-9]+)\", dynamic([\"key\",\"value\"]), Hashes)\n| extend Hashes = column_ifexists(\"Hashes\", \"\"), CommandLine = column_ifexists(\"CommandLine\", \"\")\n| where (Hashes has_any (sha256Hashes) )  \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, Hashes, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, FileHashCustomEntity = Hashes\n)\n)\n", "attributes": {"description": "'Identifies a match across various data feeds for  hashes and IP IOC related to Europium\n Reference: https://www.microsoft.com/security/blog/2022/09/08/microsoft-investigates-iranian-attacks-against-the-albanian-government'\n", "techniques": ["T1071", "T1003"], "tactics": ["CommandAndControl", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/EuropiumUnusualIdentity.yaml", "query_name": "Unusual identity creation using exchange powershell", "query": "(union isfuzzy=true\n(SecurityEvent\n| where EventID==4688\n| where CommandLine has_any (\"New-Mailbox\",\"Update-RoleGroupMember\") and CommandLine has \"HealthMailbox55x2yq\"\n| project TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(DeviceProcessEvents\n| where ProcessCommandLine has_any (\"New-Mailbox\",\"Update-RoleGroupMember\") and ProcessCommandLine has \"HealthMailbox55x2yq\"\n| extend timestamp = TimeGenerated, AccountCustomEntity =  InitiatingProcessAccountName, HostCustomEntity = DeviceName\n)\n)\n", "attributes": {"description": "' The query below identifies creation of unusual identity by the Europium actor to mimic Microsoft Exchange Health Manager Service account using Exchange PowerShell commands\n  Reference: https://www.microsoft.com/security/blog/2022/09/08/microsoft-investigates-iranian-attacks-against-the-albanian-government/'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ExchangeServerVulnerabilitiesMarch2021IoCs.yaml", "query_name": "Exchange Server Vulnerabilities Disclosed March 2021 IoC Match", "query": "let iocs = externaldata(DateAdded:string,FirstSeen:string,IoC:string,Type:string,TLP:string)\n[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/MSTICIoCs-ExchangeServerVulnerabilitiesDisclosedMarch2021.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet file_paths = (iocs | where Type =~ \"filepath\" | project IoC);\nlet sha256s = (iocs | where Type =~ \"sha256\" | project IoC);\nlet ips = (iocs | where Type =~ \"ip\" | project IoC);\nlet domains = (iocs | where Type =~ \"domainname\" | project IoC);\nlet dyndomains = todynamic(toscalar((domains | summarize make_set(IoC))));\nunion isfuzzy=true\n(SecurityEvent\n| where EventID == 4663\n| where ObjectName in (file_paths)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(WindowsEvent\n| where EventID == 4663 and EventData has_any (file_paths)\n| extend ObjectName = tostring(EventData.ObjectName) \n| where ObjectName in (file_paths)\n| extend Account = strcat(tostring(EventData.SubjectDomainName), \"\\\\\", tostring(EventData.SubjectUserName))\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(imFileEvent\n| where TargetFileName in (file_paths)\n  or\n  TargetFileSHA256 in (sha256s)\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUsername, HostCustomEntity = DvcHostname\n),\n(DeviceFileEvents\n| where FolderPath in (file_paths)\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingProcessAccountName, HostCustomEntity = DeviceName\n),\n(DeviceEvents\n| where InitiatingProcessSHA256 in (sha256s)\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingProcessAccountName, HostCustomEntity = DeviceName\n),\n  (CommonSecurityLog\n| where FileHash in (sha256s)\n| extend timestamp = TimeGenerated\n),\n(Event // File iocs\n//This query uses sysmon data depending on table name used this may need updating\n| where Source == \"Microsoft-Windows-Sysmon\"\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Hashes = EventDetail.[16].[\"#text\"]\n| where isnotempty(Hashes)\n| parse Hashes with * 'SHA256=' SHA256 ',' *\n| where SHA256 in~ (sha256s)\n| extend Type = strcat(Type, \": \", Source), Account = UserName, FileHash = Hashes\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(CommonSecurityLog\n| where isnotempty(SourceIP) or isnotempty(DestinationIP)\n| where (SourceIP in (ips) or DestinationIP in (ips) or Message has_any (ips)) or (RequestURL has_any (domains))\n| extend IPMatch = case(SourceIP in (ips), \"SourceIP\", DestinationIP in (ips), \"DestinationIP\", \"Message\")\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP, DestinationIP, DeviceProduct, DeviceAction, Message, Protocol, SourcePort, DestinationPort, DeviceAddress, DeviceName, IPMatch\n| extend timestamp = StartTimeUtc, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"IP in Message Field\")\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 3\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend SourceIP = EventDetail.[9].[\"#text\"], DestinationIP = EventDetail.[14].[\"#text\"]\n| where SourceIP in (ips) or DestinationIP in (ips)\n| extend IPMatch = case( SourceIP in (ips), \"SourceIP\", DestinationIP in (ips), \"DestinationIP\", \"None\")\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserName, HostCustomEntity = Computer , IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n),\n(WireData\n| where isnotempty(RemoteIP)\n| where RemoteIP in (ips)\n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = Computer\n),\n(W3CIISLog\n| where isnotempty(cIP)\n| where cIP in (ips)\n| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName\n),\n(\nWindowsFirewall\n| where SourceIP in (ips) or DestinationIP in (ips)\n| extend IPMatch = case( SourceIP in (ips), \"SourceIP\", DestinationIP in (ips), \"DestinationIP\", \"None\")\n),\n(\n  _Im_NetworkSession(srcipaddr_has_any_prefix=ips) \n  | extend IPCustomEntity = SrcIpAddr, AccountCustomEntity= User, HostCustomEntity=Hostname\n),\n  (\n  _Im_NetworkSession(dstipaddr_has_any_prefix=ips) \n  | extend IPCustomEntity = DstIpAddr, AccountCustomEntity= User, HostCustomEntity=Hostname\n),\n(_Im_Dns(domain_has_any=dyndomains)\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Dvc\n)\n", "attributes": {"description": "'This detection look for IoCs shared by Microsoft relating to attacks exploiting the Exchange Server vulnerabilities disclosed in March 2021. It looks for SHA256 file hashes, IP addresses and file paths in a number of data sources. This query can also be customized with additional data sources that may include these elements.\nRef: https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/GainCodeExecutionADFSviaWMI.yaml", "query_name": "Gain Code Execution on ADFS Server via Remote WMI Execution", "query": "let timeframe = 1d;\n// Adjust for a longer timeframe for identifying ADFS Servers\nlet lookback = 6d;\n// Identify ADFS Servers\nlet ADFS_Servers = ( union isfuzzy=true\n( Event\n| where TimeGenerated > ago(timeframe+lookback)\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| extend process = split(Image, '\\\\', -1)[-1]\n| where process =~ \"Microsoft.IdentityServer.ServiceHost.exe\"\n| distinct Computer\n),\n( SecurityEvent\n| where TimeGenerated > ago(timeframe+lookback)\n| where EventID == 4688 and SubjectLogonId != \"0x3e4\"\n| where ProcessName has \"Microsoft.IdentityServer.ServiceHost.exe\"\n| distinct Computer\n),\n(WindowsEvent\n| where TimeGenerated > ago(timeframe+lookback)\n| where EventID == 4688 and EventData has \"0x3e4\" and EventData has \"Microsoft.IdentityServer.ServiceHost.exe\"\n| extend SubjectLogonId  = tostring(EventData.SubjectLogonId)\n| where SubjectLogonId != \"0x3e4\"\n| extend ProcessName  = tostring(EventData.ProcessName)\n| where ProcessName has \"Microsoft.IdentityServer.ServiceHost.exe\"\n| distinct Computer\n)\n| distinct Computer);\n(union isfuzzy=true\n(\nSecurityEvent\n| where EventID == 4688\n| where TimeGenerated > ago(timeframe)\n| where Computer in~ (ADFS_Servers)\n| where ParentProcessName has 'wmiprvse.exe'\n// Looking for rundll32.exe is based on intel from the blog linked in the description\n// This can be commented out or altered to filter out known internal uses\n| where CommandLine has_any ('rundll32') \n| project TimeGenerated, TargetAccount, CommandLine, Computer, Account, TargetLogonId\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n// Search for recent logons to identify lateral movement\n| join kind= inner\n(SecurityEvent\n| where TimeGenerated > ago(timeframe)\n| where EventID == 4624 and LogonType == 3\n| where Account !endswith \"$\"\n| project TargetLogonId\n) on TargetLogonId\n),\n(\nWindowsEvent\n| where EventID == 4688\n| where TimeGenerated > ago(timeframe)\n| where Computer in~ (ADFS_Servers)\n| where EventData has 'wmiprvse.exe' and EventData has_any ('rundll32') \n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| where ParentProcessName has 'wmiprvse.exe'\n// Looking for rundll32.exe is based on intel from the blog linked in the description\n// This can be commented out or altered to filter out known internal uses\n| extend CommandLine = tostring(EventData.CommandLine)\n| where CommandLine has_any ('rundll32') \n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend Account = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend TargetLogonId = tostring(EventData.TargetLogonId)\n| project TimeGenerated, TargetAccount, CommandLine, Computer, Account, TargetLogonId\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n// Search for recent logons to identify lateral movement\n| join kind= inner\n(WindowsEvent\n| where TimeGenerated > ago(timeframe)\n| where EventID == 4624 \n| extend  LogonType = tostring(EventData.LogonType)\n| where LogonType == 3\n| extend Account = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| where Account !endswith \"$\"\n| extend TargetLogonId = tostring(EventData.TargetLogonId)\n| project TargetLogonId\n) on TargetLogonId\n),\n(\nEvent\n| where TimeGenerated > ago(timeframe)\n| where Source == \"Microsoft-Windows-Sysmon\"\n// Check for WMI Events\n| where Computer in~ (ADFS_Servers) and EventID in (19, 20, 21)\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| project TimeGenerated, EventType, Image, Computer, UserName\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = UserName\n)\n)\n", "attributes": {"description": "'This query detects instances where an attacker has gained the ability to execute code on an ADFS Server through remote WMI Execution.\nIn order to use this query you need to be collecting Sysmon EventIDs 19, 20, and 21.\nIf you do not have Sysmon data in your workspace this query will raise an error stating:\n     Failed to resolve scalar expression named \"[@Name]\"\nFor more on how WMI was used in Solorigate see https://www.microsoft.com/security/blog/2021/01/20/deep-dive-into-the-solorigate-second-stage-activation-from-sunburst-to-teardrop-and-raindrop/.\nThe query contains some features from the following detections to look for potentially malicious ADFS activity. See them for more details.\n- ADFS Key Export (Sysmon): https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ADFSKeyExportSysmon.yaml\n- ADFS DKM Master Key Export: https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ADFS-DKM-MasterKey-Export.yaml'\n", "techniques": ["T1210"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/GalliumIOCs.yaml", "query_name": "Known GALLIUM domains and hashes", "query": "let DomainNames = dynamic([\"asyspy256.ddns.net\",\"hotkillmail9sddcc.ddns.net\",\"rosaf112.ddns.net\",\"cvdfhjh1231.myftp.biz\",\"sz2016rose.ddns.net\",\"dffwescwer4325.myftp.biz\",\"cvdfhjh1231.ddns.net\"]);\nlet SHA1Hash = dynamic ([\"53a44c2396d15c3a03723fa5e5db54cafd527635\", \"9c5e496921e3bc882dc40694f1dcc3746a75db19\", \"aeb573accfd95758550cf30bf04f389a92922844\", \"79ef78a797403a4ed1a616c68e07fff868a8650a\", \"4f6f38b4cec35e895d91c052b1f5a83d665c2196\", \"1e8c2cac2e4ce7cbd33c3858eb2e24531cb8a84d\", \"e841a63e47361a572db9a7334af459ddca11347a\", \"c28f606df28a9bc8df75a4d5e5837fc5522dd34d\", \"2e94b305d6812a9f96e6781c888e48c7fb157b6b\", \"dd44133716b8a241957b912fa6a02efde3ce3025\", \"8793bf166cb89eb55f0593404e4e933ab605e803\", \"a39b57032dbb2335499a51e13470a7cd5d86b138\", \"41cc2b15c662bc001c0eb92f6cc222934f0beeea\", \"d209430d6af54792371174e70e27dd11d3def7a7\", \"1c6452026c56efd2c94cea7e0f671eb55515edb0\", \"c6b41d3afdcdcaf9f442bbe772f5da871801fd5a\", \"4923d460e22fbbf165bbbaba168e5a46b8157d9f\", \"f201504bd96e81d0d350c3a8332593ee1c9e09de\", \"ddd2db1127632a2a52943a2fe516a2e7d05d70d2\"]);\nlet SHA256Hash = dynamic ([\"9ae7c4a4e1cfe9b505c3a47e66551eb1357affee65bfefb0109d02f4e97c06dd\", \"7772d624e1aed327abcd24ce2068063da0e31bb1d5d3bf2841fc977e198c6c5b\", \"657fc7e6447e0065d488a7db2caab13071e44741875044f9024ca843fe4e86b5\", \"2ef157a97e28574356e1d871abf75deca7d7a1ea662f38b577a06dd039dbae29\", \"52fd7b90d7144ac448af4008be639d4d45c252e51823f4311011af3207a5fc77\", \"a370e47cb97b35f1ae6590d14ada7561d22b4a73be0cb6df7e851d85054b1ac3\", \"5bf80b871278a29f356bd42af1e35428aead20cd90b0c7642247afcaaa95b022\", \"6f690ccfd54c2b02f0c3cb89c938162c10cbeee693286e809579c540b07ed883\", \"3c884f776fbd16597c072afd81029e8764dd57ee79d798829ca111f5e170bd8e\", \"1922a419f57afb351b58330ed456143cc8de8b3ebcbd236d26a219b03b3464d7\", \"fe0e4ef832b62d49b43433e10c47dc51072959af93963c790892efc20ec422f1\", \"7ce9e1c5562c8a5c93878629a47fe6071a35d604ed57a8f918f3eadf82c11a9c\", \"178d5ee8c04401d332af331087a80fb4e5e2937edfba7266f9be34a5029b6945\", \"51f70956fa8c487784fd21ab795f6ba2199b5c2d346acdeef1de0318a4c729d9\", \"889bca95f1a69e94aaade1e959ed0d3620531dc0fc563be9a8decf41899b4d79\", \"332ddaa00e2eb862742cb8d7e24ce52a5d38ffb22f6c8bd51162bd35e84d7ddf\", \"44bcf82fa536318622798504e8369e9dcdb32686b95fcb44579f0b4efa79df08\", \"63552772fdd8c947712a2cff00dfe25c7a34133716784b6d486227384f8cf3ef\", \"056744a3c371b5938d63c396fe094afce8fb153796a65afa5103e1bffd7ca070\"]);\nlet SigNames = dynamic([\"TrojanDropper:Win32/BlackMould.A!dha\", \"Trojan:Win32/BlackMould.B!dha\", \"Trojan:Win32/QuarkBandit.A!dha\", \"Trojan:Win32/Sidelod.A!dha\"]);\n(union isfuzzy=true\n(CommonSecurityLog \n| parse Message with * '(' DNSName ')' * \n| where isnotempty(FileHash)\n| where FileHash in (SHA256Hash) or DNSName in~ (DomainNames)\n| extend Account = SourceUserID, Computer = DeviceName, IPAddress = SourceIP\n),\n( _Im_Dns(domain_has_any=DomainNames)\n| extend DNSName = DnsQuery\n| extend IPAddress = SrcIpAddr\n),\n(VMConnection \n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| where isnotempty(DNSName)\n| where DNSName  in~ (DomainNames)\n| extend IPAddress = RemoteIp\n),\n(Event\n//This query uses sysmon data depending on table name used this may need updataing\n| where Source == \"Microsoft-Windows-Sysmon\"\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Hashes = EventDetail.[16].[\"#text\"]\n| parse Hashes with * 'SHA1=' SHA1 ',' * \n| where isnotempty(Hashes)\n| where Hashes in (SHA1Hash) \n| extend Account = UserName\n),\n(SecurityAlert\n| where ProductName == \"Microsoft Defender Advanced Threat Protection\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| where isnotempty(ThreatName)\n| where ThreatName has_any (SigNames)\n| extend Computer = tostring(parse_json(Entities)[0].HostName)\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (DomainNames)  \n| extend DNSName = DestinationHost \n| extend IPAddress = SourceHost\n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress\n", "attributes": {"description": "'GALLIUM command and control domains and hash values for tools and malware used by GALLIUM. \n Matches domain name IOCs related to the GALLIUM activity group with CommonSecurityLog, DnsEvents, VMConnection and SecurityEvents dataTypes.\n References: https://www.microsoft.com/security/blog/2019/12/12/gallium-targeting-global-telecom/ '\n", "techniques": NaN, "tactics": ["CommandAndControl", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/HAFNIUMUmServiceSuspiciousFile.yaml", "query_name": "HAFNIUM UM Service writing suspicious file", "query": "let scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\", \".cfm\", \".shtml\"]);\nunion isfuzzy=true\n(SecurityEvent\n| where EventID == 4663\n| where Process has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n| where ObjectName has_any (scriptExtensions)\n| where AccessMask in ('0x2','0x100', '0x10', '0x4')\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n),\n  (WindowsEvent\n| where EventID == 4663 and EventData has_any (\"umworkerprocess.exe\", \"UMService.exe\") and EventData has_any (scriptExtensions) \n| where EventData has_any ('0x2','0x100', '0x10', '0x4')\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| where Process has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n| extend ObjectName = tostring(EventData.ObjectName)\n| where ObjectName has_any (scriptExtensions)\n| extend AccessMask = tostring(EventData.AccessMask)\n| where AccessMask in ('0x2','0x100', '0x10', '0x4')\n| extend Account = strcat(EventData.SubjectDomainName,\"\\\\\", EventData.SubjectUserName)\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n),\n(imFileEvent\n| where EventType == \"FileCreated\"\n| where ActingProcessName has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n  and\n  TargetFileName has_any (scriptExtensions)\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUsername, HostCustomEntity = DvcHostname\n),\n(DeviceFileEvents\n| where ActionType =~ \"FileCreated\"\n| where InitiatingProcessFileName has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n| where FileName has_any(scriptExtensions)\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingProcessAccountUpn, HostCustomEntity = DeviceName, IPCustomEntity = RequestSourceIP)\n", "attributes": {"description": "'This query looks for the Exchange server UM process writing suspicious files that may be indicative of webshells.\nReference: https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/HiveRansomwareJuly2022.yaml", "query_name": "Hive Ransomware IOC - July 2022", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/HiveRansomwareJuly2022.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\n(union isfuzzy=true\n(CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated, Message, SourceUserID, FileHash, Type\n| extend timestamp = TimeGenerated, FileHashCustomEntity = 'SHA256', Account = SourceUserID\n),\n(imFileEvent\n| where TargetFileSHA256 has_any (sha256Hashes)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"], Hashes = tostring(EventDetail.[17].[\"#text\"])\n| extend Hashes = extract_all(@\"(?P<key>\\w+)=(?P<value>[a-zA-Z0-9]+)\", dynamic([\"key\",\"value\"]), Hashes)\n| extend Hashes = column_ifexists(\"Hashes\", \"\"), CommandLine = column_ifexists(\"CommandLine\", \"\")\n| where (Hashes has_any (sha256Hashes) )  \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, Hashes, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), FileHashCustomEntity = Hashes\n),\n(DeviceEvents\n| where InitiatingProcessSHA256 has_any (sha256Hashes) or SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceFileEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceImageLoadEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n)\n)\n", "attributes": {"description": "'Identifies a hash match related to Hive Ransomware across various data sources.'\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/HostAADCorrelation.yaml", "query_name": "Failed host logons but success logon to AzureAD", "query": "//Adjust this threshold to fit environment\nlet signin_threshold = 5; \n//Make a list of IPs with failed Windows host logins above threshold\nlet win_fails = \nSecurityEvent\n| where EventID == 4625\n| where LogonType in (10, 7, 3)\n| where IpAddress != \"-\"\n| summarize count() by IpAddress\n| where count_ > signin_threshold\n| summarize make_list(IpAddress);\nlet wef_fails =\nWindowsEvent\n| where EventID == 4625\n| extend LogonType = tostring(EventData.LogonType)\n| where LogonType in (10, 7, 3)\n| extend IpAddress = tostring(EventData.IpAddress)\n| where IpAddress != \"-\"\n| summarize count() by IpAddress\n| where count_ > signin_threshold\n| summarize make_list(IpAddress);\n//Make a list of IPs with failed *nix host logins above threshold\nlet nix_fails = \nSyslog\n| where Facility contains 'auth' and ProcessName != 'sudo' and SyslogMessage has 'from' and not(SyslogMessage has_any ('Disconnecting', 'Disconnected', 'Accepted', 'disconnect', @'[preauth]'))\n| extend SourceIP = extract(\"(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.(([0-9]{1,3})))\",1,SyslogMessage)\n| where SourceIP != \"\" and SourceIP != \"127.0.0.1\"\n| summarize count() by SourceIP\n| where count_ > signin_threshold\n| summarize make_list(SourceIP);\n//See if any of the IPs with failed host logins hve had a sucessful Azure AD login\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where ResultType in (\"0\", \"50125\", \"50140\")\n| where IPAddress in (win_fails) or IPAddress in (nix_fails) or IPAddress in (wef_fails)\n| extend Reason=  \"Multiple failed host logins from IP address with successful Azure AD login\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress, Type = Type\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies a list of IP addresses with a minimum number(default of 5) of failed logon attempts to remote hosts.\nUses that list to identify any successful logons to Azure Active Directory from these IPs within the same timeframe.'\n", "techniques": ["T1078", "T1110"], "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/IridiumIOCs.yaml", "query_name": "Known IRIDIUM IP", "query": "let IPList = dynamic([\"154.223.45.38\",\"185.141.207.140\",\"185.234.73.19\",\"216.245.210.106\",\"51.91.48.210\",\"46.255.230.229\"]);\n(union isfuzzy=true\n(CommonSecurityLog\n| where isnotempty(SourceIP) or isnotempty(DestinationIP)\n| where SourceIP in (IPList) or DestinationIP in (IPList) or Message has_any (IPList)\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"Message\") \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP, DestinationIP, DeviceProduct, DeviceAction, Message, Protocol, SourcePort, DestinationPort, DeviceAddress, DeviceName, IPMatch\n| extend timestamp = StartTimeUtc, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"IP in Message Field\") \n),\n(OfficeActivity\n|extend SourceIPAddress = ClientIP, Account = UserId\n| where  SourceIPAddress in (IPList)\n| extend timestamp = TimeGenerated , IPCustomEntity = SourceIPAddress , AccountCustomEntity = Account\n),\n(_Im_Dns (response_has_any_prefix=IPList)\n| extend DestinationIPAddress = DnsResponseName,  Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Host, AccountCustomEntity=User\n),\n(_Im_WebSession (srcipaddr_has_any_prefix=IPList)\n| extend DestinationIPAddress = DstIpAddr,  Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Host\n),\n(_Im_NetworkSession (srcipaddr_has_any_prefix=IPList)\n| extend DestinationIPAddress = DstIpAddr,  Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Host\n),\n(_Im_NetworkSession (dstipaddr_has_any_prefix=IPList)\n| extend DestinationIPAddress = DstIpAddr,  Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Host\n),\n(SigninLogs\n| where isnotempty(IPAddress)\n| where IPAddress in (IPList)\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n),\n(AADNonInteractiveUserSignInLogs\n| where isnotempty(IPAddress)\n| where IPAddress in (IPList)\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n),\n(W3CIISLog \n| where isnotempty(cIP)\n| where cIP in (IPList)\n| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName\n),\n(AzureActivity \n| where isnotempty(CallerIpAddress)\n| where CallerIpAddress in (IPList)\n| extend timestamp = TimeGenerated, IPCustomEntity = CallerIpAddress, AccountCustomEntity = Caller\n),\n(\nAWSCloudTrail\n| where isnotempty(SourceIpAddress)\n| where SourceIpAddress in (IPList)\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName\n),\n(\nAzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (IPList)  \n| extend DestinationIP = DestinationHost \n| extend IPCustomEntity = SourceHost\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 3\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend SourceIP = EventDetail.[9].[\"#text\"], DestinationIP = EventDetail.[14].[\"#text\"]\n| where SourceIP in (IPList) or DestinationIP in (IPList) \n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\") \n| extend timestamp = TimeGenerated, AccountCustomEntity = UserName, HostCustomEntity = Computer , IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n)\n)\n", "attributes": {"description": "'IRIDIUM command and control IP. Identifies a match across various data feeds for IP IOCs related to the IRIDIUM activity group.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/KNOTWEEDAVDetection.yaml", "query_name": "KNOTWEED AV Detection", "query": "let knotweed_sigs = dynamic([\"JumplumpDropper\", \"Jumplump\", \"Corelump\", \"Medcerc\", \"SuspModuleLoad\", \"Mexlib\"]);\n  let mde_data = (DeviceInfo\n    | extend DeviceName = tolower(DeviceName)\n    | join kind=rightouter ( SecurityAlert\n    | where ProviderName =~ \"MDATP\"\n    | extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n    | extend ThreatFamilyName = tostring(parse_json(ExtendedProperties).ThreatFamilyName)\n    | where ThreatFamilyName in~ (knotweed_sigs)\n    | extend CompromisedEntity = tolower(CompromisedEntity)\n    ) on $left.DeviceName == $right.CompromisedEntity);\n  let event_data = ( Event\n    | where EventID in (1006, 1009, 1116, 1119)\n    | extend ThreatData = parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_xml(EventData).DataItem)).EventData)).Data))\n    | mv-expand ThreatData\n    | where tostring(ThreatData.[\"@Name\"]) == \"Threat Name\"\n    | extend EventData = parse_xml(EventData)\n    | where tostring(ThreatData.[\"#text\"]) has_any (knotweed_sigs));\n  union mde_data, event_data\n  | extend ThreatName = iif(isnotempty(ThreatName), ThreatName, tostring(ThreatData.[\"#text\"]))\n  | extend ThreatFamilyName = iif(isnotempty(ThreatFamilyName), ThreatFamilyName, split(tostring(ThreatData.[\"#text\"]), \"/\")[-1])\n  | extend TimeGenerated = iif(isnotempty(TimeGenerated), TimeGenerated, TimeGenerated1)\n  | extend DeviceName = iif(isnotempty(DeviceName), DeviceName, Computer)\n  | project-reorder TimeGenerated, CompromisedEntity, ThreatName, ThreatFamilyName\n", "attributes": {"description": "'This query looks for Microsoft Defender AV detections related to the KNOTWEED threat actor and the Corelump and Jumplump malware.\n  Ref: https://www.microsoft.com/security/blog/2022/07/27/untangling-knotweed-european-private-sector-offensive-actor-using-0-day-exploits/'\n", "techniques": ["T1203"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/KNOTWEEDC2DomainsJuly2022.yaml", "query_name": "KNOTWEED C2 Domains July 2022", "query": "let DomainNames = dynamic([\"acrobatrelay.com\", \"finconsult.cc\", \"realmetaldns.com\"]); \n(union isfuzzy=true \n(CommonSecurityLog  \n| parse Message with * '(' DNSName ')' *  \n| where DNSName in~ (DomainNames) \n| extend Account = SourceUserID, Computer = DeviceName, IPAddress =  DestinationIP \n), \n(_Im_Dns (domain_has_any=DomainNames)\n| extend DNSName = DnsQuery \n| extend IPAddress =  SrcIpAddr, Computer = Dvc\n), \n(_Im_WebSession (url_has_any=DomainNames)\n| extend DNSName = tostring(parse_url(Url)[\"Host\"])\n| extend IPAddress =  SrcIpAddr, Computer = Dvc\n), \n(VMConnection  \n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' * \n| where isnotempty(DNSName) \n| where DNSName  in~ (DomainNames) \n| extend IPAddress = RemoteIp \n), \n( \n DeviceNetworkEvents \n| where isnotempty(RemoteUrl) \n| where RemoteUrl  has_any (DomainNames)  \n| extend IPAddress = RemoteIP \n| extend Computer = DeviceName \n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (DomainNames)  \n| extend DNSName = DestinationHost \n| extend IPAddress = SourceHost\n) \n) \n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress \n", "attributes": {"description": "'This query looks for references to known KNOTWEED Domains in network logs.\n  This query was published July 2022.\n  Ref: https://www.microsoft.com/security/blog/2022/07/27/untangling-knotweed-european-private-sector-offensive-actor-using-0-day-exploits/'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/KNOTWEEDFileHashesJuly2022.yaml", "query_name": "KNOTWEED File Hashes July 2022", "query": "let sha256Hashes = dynamic([\"78c255a98003a101fa5ba3f49c50c6922b52ede601edac5db036ab72efc57629\", \"0588f61dc7e4b24554cffe4ea56d043d8f6139d2569bc180d4a77cf75b68792f\", \"441a3810b9e89bae12eea285a63f92e98181e9fb9efd6c57ef6d265435484964\", \"cbae79f66f724e0fe1705d6b5db3cc8a4e89f6bdf4c37004aa1d45eeab26e84b\", \"fd6515a71530b8329e2c0104d0866c5c6f87546d4b44cc17bbb03e64663b11fc\", \"5d169e083faa73f2920c8593fb95f599dad93d34a6aa2b0f794be978e44c8206\", \"7f29b69eb1af1cc6c1998bad980640bfe779525fd5bb775bc36a0ce3789a8bfc\", \"02a59fe2c94151a08d75a692b550e66a8738eb47f0001234c600b562bf8c227d\", \"7f84bf6a016ca15e654fb5ebc36fd7407cb32c69a0335a32bfc36cb91e36184d\", \"afab2e77dc14831f1719e746042063a8ec107de0e9730249d5681d07f598e5ec\", \"894138dfeee756e366c65a197b4dbef8816406bc32697fac6621601debe17d53\", \"4611340fdade4e36f074f75294194b64dcf2ec0db00f3d958956b4b0d6586431\", \"c96ae21b4cf2e28eec222cfe6ca903c4767a068630a73eca58424f9a975c6b7d\", \"fa30be45c5c5a8f679b42ae85410f6099f66fe2b38eb7aa460bcc022babb41ca\", \"e64bea4032cf2694e85ede1745811e7585d3580821a00ae1b9123bb3d2d442d6\"]);\n(union isfuzzy=true\n(CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated, Message, SourceUserID, FileHash, Type\n| extend timestamp = TimeGenerated, FileHashCustomEntity = 'SHA256', Account = SourceUserID\n),\n(imFileEvent\n| where TargetFileSHA256 has_any (sha256Hashes)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(Event\n| where Source =~ \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"], Hashes = tostring(EventDetail.[17].[\"#text\"])\n| extend Hashes = extract_all(@\"(?P<key>\\w+)=(?P<value>[a-zA-Z0-9]+)\", dynamic([\"key\",\"value\"]), Hashes)\n| extend Hashes = column_ifexists(\"Hashes\", \"\"), CommandLine = column_ifexists(\"CommandLine\", \"\")\n| where (Hashes has_any (sha256Hashes) )  \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, Hashes, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), FileHashCustomEntity = Hashes\n),\n(DeviceEvents\n| where InitiatingProcessSHA256 has_any (sha256Hashes) or SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceFileEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceImageLoadEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n)\n)\n", "attributes": {"description": "'This query looks for references to known KNOTWEED file hashes in various logs.\n  This query was published July 2022.\n  Ref: https://www.microsoft.com/security/blog/2022/07/27/untangling-knotweed-european-private-sector-offensive-actor-using-0-day-exploits/'\n", "techniques": ["T1203"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/KnownPHOSPHORUSDomainsIP-October2020.yaml", "query_name": "Known PHOSPHORUS group domains/IP - October 2020", "query": "\nlet DomainNames = dynamic([\"de-ma.online\", \"g20saudi.000webhostapp.com\", \"ksat20.000webhostapp.com\"]);\nlet EmailAddresses = dynamic([\"munichconference1962@gmail.com\",\"munichconference@outlook.de\", \"munichconference@outlook.com\", \"t20saudiarabia@gmail.com\", \"t20saudiarabia@hotmail.com\", \"t20saudiarabia@outlook.sa\"]);\nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\n(union isfuzzy=true\n(CommonSecurityLog \n| parse Message with * '(' DNSName ')' * \n| extend MessageIP = extract(IPRegex, 0, Message)\n| extend RequestURLIP = extract(IPRegex, 0, Message)\n| where (isnotempty(DNSName) and DNSName has_any (DomainNames)) \n  or (isnotempty(DestinationHostName) and DestinationHostName has_any (DomainNames)) \n  or (isnotempty(RequestURL) and (RequestURL has_any (DomainNames)))\n| extend timestamp = TimeGenerated , AccountCustomEntity = SourceUserID, HostCustomEntity = DeviceName\n),\n(DnsEvents \n| extend DestinationIPAddress = IPAddresses, DNSName = Name, Host = Computer\n| where DNSName has_any (DomainNames) \n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host),\n(VMConnection \n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| where isnotempty(DNSName)\n| where DNSName has_any (DomainNames)\n| extend timestamp = TimeGenerated , HostCustomEntity = Computer),\n(SecurityAlert\n| where ProviderName =~ 'OATP'\n| extend UPN = case(isnotempty(parse_json(Entities)[0].Upn), parse_json(Entities)[0].Upn, \n                    isnotempty(parse_json(Entities)[1].Upn), parse_json(Entities)[1].Upn,\n                    isnotempty(parse_json(Entities)[2].Upn), parse_json(Entities)[2].Upn,\n                    isnotempty(parse_json(Entities)[3].Upn), parse_json(Entities)[3].Upn,\n                    isnotempty(parse_json(Entities)[4].Upn), parse_json(Entities)[4].Upn,\n                    isnotempty(parse_json(Entities)[5].Upn), parse_json(Entities)[5].Upn,\n                    isnotempty(parse_json(Entities)[6].Upn), parse_json(Entities)[6].Upn,\n                    isnotempty(parse_json(Entities)[7].Upn), parse_json(Entities)[7].Upn,\n                    isnotempty(parse_json(Entities)[8].Upn), parse_json(Entities)[8].Upn,\n                    parse_json(Entities)[9].Upn)\n| where Entities has_any (EmailAddresses)\n| extend timestamp = TimeGenerated, AccountCustomEntity = tostring(UPN)),\n(AzureDiagnostics\n| where ResourceType =~ \"AZUREFIREWALLS\"\n| where msg_s has_any (DomainNames)\n| extend timestamp = TimeGenerated))\n", "attributes": {"description": "'Matches IOCs related to PHOSPHORUS group activity published October 2020 with CommonSecurityLog, DnsEvents, OfficeActivity and VMConnection dataTypes.\nReferences: '\n", "techniques": ["T1071", "T1566"], "tactics": ["CommandAndControl", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/MailBoxTampering.yaml", "query_name": "Detecting Impossible travel with mailbox permission tampering & Privilege Escalation attempt", "query": "SecurityAlert \n| where AlertName == \"Impossible travel activity\"\n| extend Extprop = parsejson(Entities)\n| mv-expand Extprop\n| extend Extprop = parsejson(Extprop)\n| extend CmdLine = iff(Extprop['Type']==\"process\", Extprop['CommandLine'], '')\n| extend File = iff(Extprop['Type']==\"file\", Extprop['Name'], '')\n| extend Account = Extprop['Name']\n| extend Domain = Extprop['UPNSuffix']\n| extend Account = iif(isnotempty(Domain) and Extprop['Type']==\"account\", tolower(strcat(Account, \"@\", Domain)), iif(Extprop['Type']==\"account\", tolower(Account), \"\"))\n| extend IpAddress = iff(Extprop[\"Type\"] == \"ip\",Extprop['Address'], '')\n| extend Process = iff(isnotempty(CmdLine), CmdLine, File)\n| project TimeGenerated,Account,IpAddress,CompromisedEntity,Description,ProviderName,ResourceId\n| join kind=inner\n(\nOfficeActivity\n| where Operation =~ \"Add-MailboxPermission\"\n| extend value = tostring(parse_json(Parameters)[3].Value)\n| where value contains \"FullAccess\"\n| where ResultStatus == \"True\"\n| project Parameters,TimeGenerated,value,RecordType,Operation,OrganizationId,UserType,UserKey,OfficeWorkload,ResultStatus,OfficeObjectId,UserId,ClientIP,ExternalAccess,OriginatingServer,OrganizationName,TenantId,ElevationTime,SourceSystem,OfficeId,OfficeTenantId,Type,SourceRecordId\n) on $left.Account == $right.UserId\n| join kind=inner\n(\nAuditLogs\n| where ActivityDisplayName =~ \"Add eligible member to role in PIM requested (timebound)\"\n| where AADOperationType =~ \"CreateRequestEligibleRole\"\n| where TargetResources has_any (\"-PRIV\", \"Administrator\", \"Security\")\n| extend BuiltinRole = tostring(parse_json(TargetResources[0].displayName))\n| extend CustomGroup = tostring(parse_json(TargetResources[3].displayName))\n| extend TargetAccount = tostring(parse_json(TargetResources[2].displayName))\n| extend Initiatedby = Identity\n| project TimeGenerated, ActivityDisplayName, AADOperationType, Initiatedby, TargetAccount, BuiltinRole, CustomGroup, LoggedByService, Result, ResourceId, Id\n| sort by TimeGenerated desc\n) on $left.UserId == $right.Initiatedby\n| project AADOperationType, ActivityDisplayName,AccountCustomEntity=Initiatedby, Id,ResourceId,IPCustomEntity=IpAddress\n", "attributes": {"description": "'This hunting query will alert on any Impossible travel activity in correlation with mailbox permission tampering followed by account being added to a PIM managed privileged group.\nEnsure this impossible travel incident with increase of privileges is legitimate in your environment.'\n", "techniques": ["T1078", "T1548"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/MalformedUserAgents.yaml", "query_name": "Malformed user agent", "query": "\n(union isfuzzy=true\n(OfficeActivity | where UserAgent != \"\"),\n(OfficeActivity\n| where RecordType in (\"AzureActiveDirectory\", \"AzureActiveDirectoryStsLogon\")\n| extend OperationName = Operation\n| parse ExtendedProperties with * 'User-Agent\\\\\":\\\\\"' UserAgent2 '\\\\' *\n| parse ExtendedProperties with * 'UserAgent\",      \"Value\": \"' UserAgent1 '\"' *\n| where isnotempty(UserAgent1) or isnotempty(UserAgent2)\n| extend UserAgent = iff( RecordType == 'AzureActiveDirectoryStsLogon', UserAgent1, UserAgent2)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = ClientIP, Account = UserId, Type, RecordType, Operation\n),\n(AzureDiagnostics\n| where ResourceType =~ \"APPLICATIONGATEWAYS\" \n| where OperationName =~ \"ApplicationGatewayAccess\" \n| extend ClientIP = columnifexists(\"clientIP_s\", \"None\"), UserAgent = columnifexists(\"userAgent_s\", \"None\")\n| where UserAgent != '-'\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = ClientIP,  requestUri_s, httpMethod_s, host_s, requestQuery_s, Type\n),\n(\nW3CIISLog\n| where isnotempty(csUserAgent)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent = csUserAgent, SourceIP = cIP, Account = csUserName, Type, sSiteName, csMethod, csUriStem\n),\n(\nAWSCloudTrail\n| where isnotempty(UserAgent)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = SourceIpAddress, Account = UserIdentityUserName, Type, EventSource, EventName\n),\n(SigninLogs\n| where isnotempty(UserAgent)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = IPAddress, Account = UserPrincipalName, Type, OperationName, tostring(LocationDetails), tostring(DeviceDetail), AppDisplayName, ClientAppUsed\n),\n(AADNonInteractiveUserSignInLogs \n| where isnotempty(UserAgent)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = IPAddress, Account = UserPrincipalName, Type, OperationName, tostring(LocationDetails), tostring(DeviceDetail), AppDisplayName, ClientAppUsed\n)\n)\n// Likely artefact of hardcoding\n| where UserAgent startswith \"User\" or UserAgent startswith '\\\"'\n// Incorrect casing\nor (UserAgent startswith \"Mozilla\" and not(UserAgent containscs \"Mozilla\"))\n// Incorrect casing\nor UserAgent containscs  \"(Compatible;\"\n// Missing MSIE version\nor UserAgent matches regex @\"MSIE\\s?;\"\n// Incorrect spacing around MSIE version\nor UserAgent matches regex  @\"MSIE(?:\\d|.{1,5}?\\d\\s;)\"\n| extend timestamp = StartTime, IPCustomEntity = SourceIP, AccountCustomEntity = Account\n", "attributes": {"description": "'Malware authors will sometimes hardcode user agent string values when writing the network communication component of their malware.\nMalformed user agents can be an indication of such malware.'\n", "techniques": ["T1189", "T1071", "T1203"], "tactics": ["InitialAccess", "CommandAndControl", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Manganese_VPN-IOCs.yaml", "query_name": "Known Manganese IP and UserAgent activity", "query": "\nlet IPList = dynamic([\"45.63.52.41\",\"140.82.17.161\",\"207.148.101.95\",\"45.32.87.51\",\"66.42.98.156\",\"45.76.144.105\",\"217.163.28.35\",\"45.32.141.174\",\"149.28.165.249\",\"209.250.225.247\",\"45.63.100.115\",\"95.179.229.230\",\"209.250.233.247\",\"45.77.121.232\",\"45.76.175.65\",\"104.238.160.237\",\"45.77.181.97\",\"95.179.192.125\",\"149.28.93.184\",\"140.82.16.81\",\"45.76.173.103\",\"45.77.255.22\",\"45.32.11.71\",\"149.28.77.26\",\"45.32.54.50\",\"104.156.233.156\",\"45.32.21.118\",\"45.63.62.109\",\"45.77.244.202\",\"149.248.11.205\",\"104.238.190.244\"]);\nlet IOCTerms = \"\\\\?lang=[/..]*/dev/cmdb/sslvpn_websession|/dana-na/jam/[/..]*home/webserver/htdocs/dana/html5acc/guacamole[/..]*etc/passwd\\\\?\";\n(union isfuzzy=true\n(CommonSecurityLog\n| where isnotempty(SourceIP) or isnotempty(DestinationIP)\n| where SourceIP in (IPList) or DestinationIP in (IPList) or has_any_ipv4 (Message, IPList)\n| extend IPMatch = case(\nSourceIP in (IPList), \"SourceIP\", \nDestinationIP in (IPList), \"DestinationIP\",\n\"Message\") \n| where Message matches regex IOCTerms\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP, DestinationIP, DeviceProduct, DeviceAction, Message, Protocol, SourcePort, DestinationPort, DeviceAddress, DeviceName, IPMatch\n| extend timestamp = StartTimeUtc, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"IP in Message Field\") \n),\n(OfficeActivity\n| where isnotempty(UserAgent) and ClientIP in (IPList)\n| where UserAgent contains \"ExchangeServicesClient/0.0.0.0\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP = ClientIP, Account = UserId, Type, RecordType, OfficeWorkload, UserAgent, OfficeObjectId, IPMatch = \"ClientIP\"\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, IPCustomEntity = SourceIP\n)\n)\n", "attributes": {"description": "'Matches IP plus UserAgent IOCs in OfficeActivity data, along with IP plus Connection string information in the CommonSecurityLog data related to Manganese group activity.\nReferences: \nhttps://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44101/\nhttps://fortiguard.com/psirt/FG-IR-18-384'\n", "techniques": ["T1133", "T1114"], "tactics": ["InitialAccess", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Mercury_Log4j_August2022.yaml", "query_name": "Mercury - Domain, Hash and IP IOCs - August 2022", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Mercury_August2022.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\nlet IPList = (iocs | where Type =~ \"ip\"| project IoC);\nlet domains = (iocs | where Type =~ \"domainname\"| project IoC);\nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\n(union isfuzzy=true\n(CommonSecurityLog\n| where SourceIP in (IPList) or DestinationIP in (IPList) or DestinationHostName has_any (domains) or RequestURL has_any (domains) or Message has_any (IPList)\n| parse Message with * '(' DNSName ')' * \n| project TimeGenerated, SourceIP, DestinationIP, Message, SourceUserID, RequestURL, DNSName, Type\n| extend MessageIP = extract(IPRegex, 0, Message), RequestIP = extract(IPRegex, 0, RequestURL)\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", MessageIP in (IPList), \"Message\", RequestURL has_any (domains), \"RequestUrl\", \"NoMatch\")\n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, IPMatch == \"Message\", MessageIP, \"NoMatch\"), AccountCustomEntity = SourceUserID\n),\n(DnsEvents\n| where IPAddresses in (IPList) or Name in~ (domains)  \n| project TimeGenerated, Computer, IPAddresses, Name, ClientIP, Type\n| extend DestinationIPAddress = IPAddresses, DNSName = Name, Computer \n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Computer\n),\n(VMConnection\n| where SourceIp in (IPList) or DestinationIp in (IPList) or RemoteDnsCanonicalNames has_any (domains)\n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, RemoteDnsQuestions, DNSName,BytesSent, BytesReceived, RemoteCountry, Type\n| extend IPMatch = case( SourceIp in (IPList), \"SourceIP\", DestinationIp in (IPList), \"DestinationIP\", \"None\") \n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIp, IPMatch == \"DestinationIP\", DestinationIp, \"NoMatch\"), File = ProcessName, HostCustomEntity = Computer\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 3\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend SourceIP = tostring(EventDetail.[9].[\"#text\"]), DestinationIP = tostring(EventDetail.[14].[\"#text\"]), Image = tostring(EventDetail.[4].[\"#text\"])\n| where SourceIP in (IPList) or DestinationIP in (IPList)\n| project TimeGenerated, SourceIP, DestinationIP, Image, UserName, Computer, Type\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\")\n| extend timestamp = TimeGenerated, File = tostring(split(Image, '\\\\', -1)[-1]), IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\"), HostCustomEntity = Computer, AccountCustomEntity = UserName\n), \n(OfficeActivity\n| where ClientIP in (IPList) \n| project TimeGenerated, UserAgent, Operation, RecordType, UserId, ClientIP, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, AccountCustomEntity = UserId\n),\n(DeviceNetworkEvents\n| where RemoteUrl has_any (domains) or RemoteIP in (IPList) or InitiatingProcessSHA256 in (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, Computer = DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RemoteIP, RemoteUrl, RemotePort, LocalIP, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP,  HostCustomEntity = Computer, AccountCustomEntity = InitiatingProcessAccountName\n),\n(WindowsFirewall\n| where SourceIP in (IPList) or DestinationIP in (IPList) \n| project TimeGenerated, Computer, CommunicationDirection, SourceIP, DestinationIP, SourcePort, DestinationPort, Type\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\")\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where DestinationHost has_any (domains)  \n| extend DNSName = DestinationHost \n| extend IPCustomEntity = SourceHost\n), \n(CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated, Message, SourceUserID, FileHash, Type\n| extend timestamp = TimeGenerated, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash, AccountCustomEntity = SourceUserID\n),\n(imFileEvent\n| where TargetFileSHA256 has_any (sha256Hashes)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n| extend timestamp = TimeGenerated, IPCustomEntity = IPAddress,  HostCustomEntity = Computer, AccountCustomEntity = Account, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(DeviceFileEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName,  AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceImageLoadEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName,  AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(Event\n| where Source =~ \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"], Hashes = tostring(EventDetail.[17].[\"#text\"])\n| extend Hashes = extract_all(@\"(?P<key>\\w+)=(?P<value>[a-zA-Z0-9]+)\", dynamic([\"key\",\"value\"]), Hashes)\n| extend Hashes = column_ifexists(\"Hashes\", \"\"), CommandLine = column_ifexists(\"CommandLine\", \"\")\n| where (Hashes has_any (sha256Hashes) )  \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, Hashes, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, FileHashCustomEntity = Hashes\n)\n)\n", "attributes": {"description": "'Identifies a match across various data feeds for domains, hashes and IP IOC related to Mercury\n Reference:  https://www.microsoft.com/security/blog/2022/08/25/mercury-leveraging-log4j-2-vulnerabilities-in-unpatched-systems-to-target-israeli-organizations/'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/MFADisable.yaml", "query_name": "MFA disabled for a user", "query": "\n(union isfuzzy=true\n(AuditLogs \n| where OperationName =~ \"Disable Strong Authentication\"\n| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) \n| extend InitiatedByUser = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n| extend Targetprop = todynamic(TargetResources)\n| extend TargetUser = tostring(Targetprop[0].userPrincipalName) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by User = TargetUser, InitiatedByUser , Operation = OperationName , CorrelationId, IPAddress, Category, Source = SourceSystem , AADTenantId, Type\n),\n(AWSCloudTrail\n| where EventName in~ (\"DeactivateMFADevice\", \"DeleteVirtualMFADevice\") \n| extend InstanceProfileName = tostring(parse_json(RequestParameters).InstanceProfileName)\n| extend TargetUser = tostring(parse_json(RequestParameters).userName)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by User = TargetUser, Source = EventSource , Operation = EventName , TenantorInstance_Detail = InstanceProfileName, IPAddress = SourceIpAddress\n)\n)\n| extend timestamp = StartTimeUtc, AccountCustomEntity = User, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Multi-Factor Authentication (MFA) helps prevent credential compromise. This alert identifies when an attempt has been made to disable MFA for a user '\n", "techniques": ["T1098", "T1556"], "tactics": ["CredentialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/MSHTMLVuln.yaml", "query_name": "MSHTML vulnerability CVE-2021-40444 attack", "query": "( union isfuzzy=true\n(SecurityEvent\n| where EventID==4688\n| where isnotempty(CommandLine)\n| extend FileName = Process, ProcessCommandLine = CommandLine\n| where (FileName in~('control.exe','rundll32.exe') and ProcessCommandLine has '.cpl:')\n  or ProcessCommandLine matches regex @'\\\".[a-zA-Z]{2,4}:\\.\\.\\/\\.\\.'\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(DeviceProcessEvents\n| where (FileName in~('control.exe','rundll32.exe') and ProcessCommandLine has '.cpl:')\nor ProcessCommandLine matches regex @'\\\".[a-zA-Z]{2,4}:\\.\\.\\/\\.\\.'\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingProcessAccountUpn, HostCustomEntity = DeviceName\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1 \n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| extend Image = column_ifexists(\"Image\", \"\"), ProcessCommandLine = column_ifexists(\"CommandLine\", \"\")\n| extend FileName = split(Image, '\\\\', -1)[-1]\n| where (FileName in~('control.exe','rundll32.exe') and ProcessCommandLine has '.cpl:')\n  or ProcessCommandLine matches regex @'\\\".[a-zA-Z]{2,4}:\\.\\.\\/\\.\\.'\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserName, HostCustomEntity = Computer\n)\n)\n", "attributes": {"description": "'This query detects attacks that exploit the CVE-2021-40444 MSHTML vulnerability using specially crafted Microsoft Office documents. \n The detection searches for relevant files used in the attack along with regex matches in commnadline to look for pattern similar to : \".cpl:../../msword.inf\"\n Refrence: https://www.microsoft.com/security/blog/2021/09/15/analyzing-attacks-that-exploit-the-mshtml-cve-2021-40444-vulnerability/'\n", "techniques": ["T1203"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/MultiplePasswordresetsbyUser.yaml", "query_name": "Multiple Password Reset by user", "query": "\nlet PerUserThreshold = 5;\nlet TotalThreshold = 100;\nlet action = dynamic([\"change\", \"changed\", \"reset\"]);\nlet pWord = dynamic([\"password\", \"credentials\"]);\nlet PasswordResetMultiDataSource =\n(union isfuzzy=true\n(//Password reset events\n//4723: An attempt was made to change an account's password\n//4724: An attempt was made to reset an accounts password\nSecurityEvent\n| where EventID in (\"4723\",\"4724\")\n| project TimeGenerated, Computer, AccountType, Account, Type, TargetUserName),\n(//Password reset events\n//4723: An attempt was made to change an account's password\n//4724: An attempt was made to reset an accounts password\nWindowsEvent\n| where EventID in (\"4723\",\"4724\")\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend TargetUserName = tostring(EventData.TargetUserName)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend AccountType=case(Account endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n| project TimeGenerated, Computer, AccountType, Account, Type, TargetUserName),\n(//Azure Active Directory Password reset events\nAuditLogs\n| where OperationName has_any (pWord) and OperationName has_any (action) and Result =~ \"success\"\n| extend AccountType = tostring(TargetResources[0].type), Account = tostring(TargetResources[0].userPrincipalName), \nTargetUserName = tolower(tostring(TargetResources[0].displayName))\n| project TimeGenerated, AccountType, Account, Computer = \"\", Type),\n(//OfficeActive ActiveDirectory Password reset events\nOfficeActivity\n| where OfficeWorkload == \"AzureActiveDirectory\" \n| where (ExtendedProperties has_any (pWord) or ModifiedProperties has_any (pWord)) and (ExtendedProperties has_any (action) or ModifiedProperties has_any (action))\n| extend AccountType = UserType, Account = OfficeObjectId \n| project TimeGenerated, AccountType, Account, Type, Computer = \"\"),\n(// Unix syslog password reset events\nSyslog\n| where Facility in (\"auth\",\"authpriv\")\n| where SyslogMessage has_any (pWord) and SyslogMessage has_any (action)\n| extend AccountType = iif(SyslogMessage contains \"root\", \"Root\", \"Non-Root\")\n| where SyslogMessage matches regex \".*password changed for.*\"\n| parse SyslogMessage with * \"password changed for\" Account\n| project TimeGenerated, AccountType, Account, Computer = HostName, Type)\n);\nlet pwrmd = PasswordResetMultiDataSource\n| project TimeGenerated, Computer, AccountType, Account, Type, TargetUserName;\n(union isfuzzy=true  \n(pwrmd\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Computerlist = make_set(Computer, 25), AccountType = make_set(AccountType, 25), Computer = arg_max(Computer , TimeGenerated), TargetUserList = make_set(TargetUserName, 25), TargetUserName = arg_max(TargetUserName, TimeGenerated), Total=count() by Account, Type\n| where Total > PerUserThreshold\n| extend ResetPivot = \"PerUserReset\"),  \n(pwrmd\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ComputerList = make_set(Computer, 25), AccountList = make_set(Account, 25), AccountType = make_set(AccountType, 25), Computer = arg_max(Computer , TimeGenerated), TargetUserList = make_set(TargetUserName, 25), TargetUserName = arg_max(TargetUserName, TimeGenerated), Total=count() by Type\n| where Total > TotalThreshold\n| extend ResetPivot = \"TotalUserReset\")\n)\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'This query will determine multiple password resets by user across multiple data sources. \nAccount manipulation including password reset may aid adversaries in maintaining access to credentials \nand certain permission levels within an environment.'\n", "techniques": ["T1078", "T1110"], "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/NetworkEndpointCorrelation.yaml", "query_name": "Network endpoint to host executable correlation", "query": "let endpointData = \n(union isfuzzy=true\n(SecurityEvent\n  | where EventID == 4688\n  | extend shortFileName = tostring(split(NewProcessName, '\\\\')[-1])\n  ),\n  (WindowsEvent\n  | where EventID == 4688\n  | extend  NewProcessName = tostring(EventData.NewProcessName)\n  | extend shortFileName = tostring(split(NewProcessName, '\\\\')[-1])\n  | extend TargetUserName = tostring(EventData.TargetUserName)\n  ));\n// Correlate suspect executables seen in TrendMicro rule updates with similar activity on endpoints\nCommonSecurityLog\n| where DeviceVendor =~ \"Trend Micro\"\n| where Activity =~ \"Deny List updated\" \n| where RequestURL endswith \".exe\"\n| project TimeGenerated, Activity , RequestURL , SourceIP, DestinationIP\n| extend suspectExeName = tolower(tostring(split(RequestURL, '/')[-1]))\n| join (endpointData) on $left.suspectExeName == $right.shortFileName \n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIP, AccountCustomEntity = TargetUserName, HostCustomEntity = Computer, URLCustomEntity = RequestURL\n", "attributes": {"description": "'Correlates blocked URLs hosting [malicious] executables with host endpoint data\nto identify potential instances of executables of the same name having been recently run.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/NewUserAgentLast24h.yaml", "query_name": "New UserAgent observed in last 24 hours", "query": "\nlet starttime = 14d;\nlet endtime = 1d;\nlet UserAgentAll =\n(union isfuzzy=true\n(OfficeActivity\n| where TimeGenerated >= ago(starttime)\n| where isnotempty(UserAgent)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = ClientIP, Account = UserId, Type, RecordType, Operation\n),\n(\nW3CIISLog\n| where TimeGenerated >= ago(starttime)\n| where isnotempty(csUserAgent)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent = csUserAgent, SourceIP = cIP, Account = csUserName, Type, sSiteName, csMethod, csUriStem\n),\n(\nAWSCloudTrail\n| where TimeGenerated >= ago(starttime)\n| where isnotempty(UserAgent)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = SourceIpAddress, Account = UserIdentityUserName, Type, EventSource, EventName\n))\n// remove wordSize blocks of non-numeric hex characters prior to word extraction\n| extend UserAgentNoHexAlphas = replace(\"([A-Fa-f]{4,})\", \"x\", UserAgent)\n// once blocks of hex chars are removed, extract wordSize blocks of a-z\n| extend Tokens = extract_all(\"([A-Za-z]{4,})\", UserAgentNoHexAlphas)\n// concatenate extracted words to create a summarized user agent for baseline and comparison\n| extend NormalizedUserAgent = strcat_array(Tokens, \"|\")\n| project-away UserAgentNoHexAlphas, Tokens;\nUserAgentAll\n| where StartTime >= ago(endtime)\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), count() by UserAgent, NormalizedUserAgent, SourceIP, Account, Type, RecordType, Operation, EventSource, EventName, sSiteName, csMethod, csUriStem\n| join kind=leftanti\n(\nUserAgentAll\n| where StartTime < ago(endtime)\n| summarize by NormalizedUserAgent, SourceIP, Account, Type, RecordType, Operation, EventSource, EventName, sSiteName, csMethod, csUriStem\n)\non NormalizedUserAgent\n| extend timestamp = StartTime, IPCustomEntity = SourceIP, AccountCustomEntity = Account\n", "attributes": {"description": "'Identifies new UserAgents observed in the last 24 hours versus the previous 14 days. This detection\nextracts words from user agents to build the baseline and determine rareity rather than perform a\ndirect comparison. This avoids FPs caused by version numbers and other high entropy user agent components.\nThese new UserAgents could be benign. However, in normally stable environments,\nthese new UserAgents could provide a starting point for investigating malicious activity.\nNote: W3CIISLog can be noisy depending on the environment, however OfficeActivity and AWSCloudTrail are\nusually stable with low numbers of detections.'\n", "techniques": ["T1189", "T1071", "T1203"], "tactics": ["InitialAccess", "CommandAndControl", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/NICKELIOCsNov2021.yaml", "query_name": "Known NICKEL domains and hashes", "query": "let DomainNames = dynamic([\"beesweiserdog.com\", \n                          \"bluehostfit.com\", \n                          \"business-toys.com\", \n                          \"cleanskycloud.com\", \n                          \"cumberbat.com\", \n                          \"czreadsecurity.com\", \n                          \"dgtresorgouv.com\", \n                          \"dimediamikedask.com\", \n                          \"diresitioscon.com\", \n                          \"elcolectador.com\", \n                          \"elperuanos.org\", \n                          \"eprotectioneu.com\", \n                          \"fheacor.com\", \n                          \"followthewaterdata.com\", \n                          \"francevrteepress.com\", \n                          \"futtuhy.com\", \n                          \"gardienweb.com\", \n                          \"heimflugaustr.com\", \n                          \"ivpsers.com\", \n                          \"jkeducation.org\", \n                          \"micrlmb.com\", \n                          \"muthesck.com\", \n                          \"netscalertech.com\", \n                          \"newgoldbalmap.com\", \n                          \"news-laestrella.com\", \n                          \"noticialif.com\", \n                          \"opentanzanfoundation.com\", \n                          \"optonlinepress.com\", \n                          \"palazzochigi.com\", \n                          \"pandemicacre.com\", \n                          \"papa-ser.com\", \n                          \"pekematclouds.com\", \n                          \"pipcake.com\", \n                          \"popularservicenter.com\", \n                          \"projectsyndic.com\", \n                          \"qsadtv.com\", \n                          \"sankreal.com\", \n                          \"scielope.com\", \n                          \"seoamdcopywriting.com\", \n                          \"slidenshare.com\", \n                          \"somoswake.com\", \n                          \"squarespacenow.com\", \n                          \"subapostilla.com\", \n                          \"suzukicycles.net\", \n                          \"tatanotakeeps.com\", \n                          \"tijuanazxc.com\", \n                          \"transactioninfo.net\", \n                          \"eurolabspro.com\", \n                          \"adelluminate.com\", \n                          \"headhunterblue.com\", \n                          \"primenuesty.com\" \n                          ]);\nlet SHA256Hashes = dynamic ([\"02daf4544bcefb2de865d0b45fc406bee3630704be26a9d6da25c9abe906e7d2\", \n                            \"0a45ec3da31838aa7f56e4cbe70d5b3b3809029f9159ff0235837e5b7a4cb34c\", \n                            \"0d7965489810446ca7acc7a2160795b22e452a164261313c634a6529a0090a0c\", \n                            \"10bb4e056fd19f2debe61d8fc5665434f56064a93ca0ec0bef946a4c3e098b95\", \n                            \"12d914f24fe5501e09f5edf503820cc5fe8b763827a1c6d44cdb705e48651b21\", \n                            \"1899f761123fedfeba0fee6a11f830a29cd3653bcdcf70380b72a05b921b4b49\", \n                            \"22e68e366dd3323e5bb68161b0938da8e1331e4f1c1819c8e84a97e704d93844\", \n                            \"259783405ec2cb37fdd8fd16304328edbb6a0703bc3d551eba252d9b450554ef\", \n                            \"26debed09b1bbf24545e3b4501b799b66a0146d4020f882776465b5071e91822\", \n                            \"35c5f22bb11f7dd7a2bb03808e0337cb7f9c0d96047b94c8afdab63efc0b9bb2\", \n                            \"3ae2d9ffa4e53519e62cc0a75696f9023f9cce09b0a917f25699b48d0f7c4838\", \n                            \"3bac2e459c69fcef8c1c93c18e5f4f3e3102d8d0f54a63e0650072aeb2a5fa65\", \n                            \"3c0bf69f6faf85523d9e60d13218e77122b2adb0136ffebbad0f39f3e3eed4e6\", \n                            \"3dc0001a11d54925d2591aec4ea296e64f1d4fdf17ff3343ddeea82e9bd5e4f1\", \n                            \"3fd73af89e94af180b1fbf442bbfb7d7a6c4cf9043abd22ac0aa2f8149bafc90\", \n                            \"6854df6aa0af46f7c77667c450796d5658b3058219158456e869ebd39a47d54b\", \n                            \"6b79b807a66c786bd2e57d1c761fc7e69dd9f790ffab7ce74086c4115c9305ce\", \n                            \"7944a86fbef6238d2a55c14c660c3a3d361c172f6b8fa490686cc8889b7a51a0\", \n                            \"926904f7c0da13a6b8689c36dab9d20b3a2e6d32f212fca9e5f8cf2c6055333c\", \n                            \"95e98c811ea9d212673d0e84046d6da94cbd9134284275195800278593594b5a\", \n                            \"a142625512e5372a1728595be19dbee23eea50524b4827cb64ed5aaeaaa0270b\", \n                            \"afe5e9145882e0b98a795468a4c0352f5b1ddb7b4a534783c9e8fc366914cf6a\", \n                            \"b9027bad09a9f5c917cf0f811610438e46e42e5e984a8984b6d69206ceb74124\", \n                            \"c132d59a3bf0099e0f9f5667daf7b65dba66780f4addd88f04eecae47d5d99fa\", \n                            \"c9a5765561f52bbe34382ce06f4431f7ac65bafe786db5de89c29748cf371dda\", \n                            \"ce0408f92635e42aadc99da3cc1cbc0044e63441129c597e7aa1d76bf2700c94\", \n                            \"ce47bacc872516f91263f5e59441c54f14e9856cf213ca3128470217655fc5e6\", \n                            \"d0fe4562970676e30a4be8cb4923dc9bfd1fca8178e8e7fea0f3f02e0c7435ce\", \n                            \"d5b36648dc9828e69242b57aca91a0bb73296292bf987720c73fcd3d2becbae6\", \n                            \"e72d142a2bc49572e2d99ed15827fc27c67fc0999e90d4bf1352b075f86a83ba\"\n                            ]);\nlet SigNames = dynamic([\"Backdoor:Win32/Leeson\", \"Trojan:Win32/Kechang\", \"Backdoor:Win32/Nightimp!dha\", \"Trojan:Win32/QuarkBandit.A!dha\", \"TrojanSpy:Win32/KeyLogger\"]);\n(union isfuzzy=true\n(CommonSecurityLog \n| parse Message with * '(' DNSName ')' * \n| where isnotempty(FileHash)\n| where FileHash in (SHA256Hashes) or DNSName in~ (DomainNames)\n| extend Account = SourceUserID, Computer = DeviceName, IPAddress = SourceIP\n),\n(_Im_Dns(domain_has_any = DomainNames)\n| extend DNSName = DnsQuery\n| extend IPAddress = SrcIpAddr\n),\n(_Im_WebSession(url_has_any = DomainNames)\n| extend DNSName = tostring(parse_url(Url)[\"Host\"])\n| extend IPAddress = SrcIpAddr\n),\n(Event\n//This query uses sysmon data depending on table name used this may need updataing\n| where Source == \"Microsoft-Windows-Sysmon\"\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Hashes = EventDetail.[16].[\"#text\"]\n| parse Hashes with * 'SHA256=' SHA256 ',' * \n| where isnotempty(Hashes)\n| where Hashes in (SHA256Hashes) \n| extend Account = UserName\n),\n(DeviceFileEvents\n| where SHA256 in~ (SHA256Hashes)\n| extend Account = RequestAccountName, Computer = DeviceName, IPAddress = RequestSourceIP, CommandLine = InitiatingProcessCommandLine, FileHash = SHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(imFileEvent\n| where TargetFileSHA256 in~ (SHA256Hashes)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(DeviceNetworkEvents\n| where RemoteUrl in~ (DomainNames)\n| extend Computer = DeviceName, IPAddress = LocalIP, Account = InitiatingProcessAccountName\n| project Type, TimeGenerated, Computer, Account, IPAddress, RemoteUrl\n),\n(SecurityAlert\n| where ProductName == \"Microsoft Defender Advanced Threat Protection\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| where isnotempty(ThreatName)\n| where ThreatName has_any (SigNames)\n| extend Computer = tostring(parse_json(Entities)[0].HostName)\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (DomainNames)  \n| extend DNSName = DestinationHost \n| extend IPAddress = SourceHost\n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress\n", "attributes": {"description": "'IOC domains and hash values for tools and malware used by NICKEL. \n Matches domain name, hash IOCs and M365 Defender sigs related to the NICKEL activity group with CommonSecurityLog, DnsEvents, VMConnection and SecurityEvents dataTypes.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/NOBELIUM_DomainIOCsMarch2021.yaml", "query_name": "NOBELIUM - Domain and IP IOCs - March 2021", "query": "let DomainNames = dynamic(['onetechcompany.com', 'reyweb.com', 'srfnetwork.org', 'sense4baby.fr', 'nikeoutletinc.org', 'megatoolkit.com']);\nlet IPList = dynamic(['185.225.69.69']);\nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\n(union isfuzzy=true\n(CommonSecurityLog\n| where SourceIP in (IPList) or DestinationIP in (IPList) or DestinationHostName in~ (DomainNames) or RequestURL has_any (DomainNames) or Message has_any (IPList)\n| parse Message with * '(' DNSName ')' * \n| extend MessageIP = extract(IPRegex, 0, Message)\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", MessageIP in (IPList), \"Message\", RequestURL in (DomainNames), \"RequestUrl\", \"NoMatch\") \n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, IPMatch == \"Message\", MessageIP, \"NoMatch\"), AccountCustomEntity = SourceUserID\n),\n(_Im_Dns (domain_has_any=DomainNames)\n| extend DestinationIPAddress = DnsResponseName, DNSName = DnsQuery, Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host\n),\n(_Im_Dns (response_has_any_prefix=IPList)\n| extend DestinationIPAddress = DnsResponseName, DNSName = DnsQuery, Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host\n),\n(_Im_WebSession(url_has_any=DomainNames)\n| extend DestinationIPAddress = DstIpAddr, DNSName = tostring(parse_url(Url)[\"Host\"]), Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host\n),\n(VMConnection\n| where SourceIp in (IPList) or DestinationIp in (IPList) or RemoteDnsCanonicalNames has_any (DomainNames)\n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| extend IPMatch = case( SourceIp in (IPList), \"SourceIP\", DestinationIp in (IPList), \"DestinationIP\", \"None\") \n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIp, IPMatch == \"DestinationIP\", DestinationIp, \"NoMatch\"), HostCustomEntity = Computer\n),\n(OfficeActivity\n| where ClientIP in (IPList)\n| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, AccountCustomEntity = UserId\n),\n(DeviceNetworkEvents\n| where RemoteUrl has_any (DomainNames) or RemoteIP in (IPList)\n| extend timestamp = TimeGenerated, DNSName = RemoteUrl, IPCustomEntity = RemoteIP, HostCustomEntity = DeviceName\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (DomainNames)  \n| extend timestamp = TimeGenerated, DNSName = DestinationHost, IPCustomEntity = SourceHost\n)\n)\n", "attributes": {"description": "'Identifies a match across various data feeds for domains and IP IOCs related to NOBELIUM.\n References: https://www.microsoft.com/security/blog/2021/03/04/goldmax-goldfinder-sibot-analyzing-nobelium-malware/'\n", "techniques": ["T1102"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Nobelium_FoggyWeb.yaml", "query_name": "NOBELIUM IOCs related to FoggyWeb backdoor", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/FoggyWebIOC.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet sha256Hashes = (iocs | where Type == \"sha256\" | project IoC);\nlet FilePaths = (iocs | where Type =~ \"FilePath\" | project IoC);\nlet POST_URI = (iocs | where Type =~ \"URI1\" | project IoC);\nlet GET_URI = (iocs | where Type =~ \"URI2\" | project IoC);\n//Include in the list below, the ADFS servers you know about in your environment.  In the next part of the query, we will try to identify them for you if you have the telemetry.\nlet ADFS_Servers1 = datatable(Computer:string)\n[ \"<ADFS01>.<DOMAIN>.<COM>\",\n\"<ADFS02>.<DOMAIN>.<COM>\"\n];\n// Automatically identify potential ADFS services in your environment by searching process event telemetry for \"Microsoft.IdentityServer.ServiceHost.exe\".\nlet ADFS_Servers2 = \n(union isfuzzy=true\n(SecurityEvent\n| where EventID == 4688 and SubjectLogonId != \"0x3e4\"\n| where ProcessName has \"Microsoft.IdentityServer.ServiceHost.exe\"\n| distinct Computer\n),\n( WindowsEvent\n| where EventID == 4688 and EventData has \"Microsoft.IdentityServer.ServiceHost.exe\" and EventData has \"0x3e4\"\n| extend ProcessName = tostring(EventData.ProcessName)\n| where ProcessName == \"Microsoft.IdentityServer.ServiceHost.exe\"\n| extend SubjectLogonId = tostring(EventData.SubjectLogonId)\n| where SubjectLogonId != \"0x3e4\"\n| distinct Computer\n),\n(DeviceProcessEvents\n| where InitiatingProcessFileName == 'Microsoft.IdentityServer.ServiceHost.exe'\n| extend Computer = DeviceName\n| distinct Computer\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| extend process = split(Image, '\\\\', -1)[-1]\n| where process =~ \"Microsoft.IdentityServer.ServiceHost.exe\"\n| distinct Computer\n)\n);\nlet ADFS_Servers =\nADFS_Servers1\n| union  (ADFS_Servers2 | distinct Computer);\n(union isfuzzy=true\n(DeviceNetworkEvents\n| where DeviceName in (ADFS_Servers)\n| where isnotempty(InitiatingProcessSHA256) or isnotempty(InitiatingProcessFolderPath)\n| where  InitiatingProcessSHA256 has_any (sha256Hashes) or InitiatingProcessFolderPath has_any (FilePaths)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId,  InitiatingProcessParentFileName, InitiatingProcessFileName, RemoteIP, RemoteUrl, RemotePort, LocalIP, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = DeviceName\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\" and EventID == '7'\n| where Computer in (ADFS_Servers)\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend ImageLoaded = EventDetail.[5].[\"#text\"], Hashes = EventDetail.[11].[\"#text\"]\n| parse Hashes with * 'SHA256=' SHA256 '\",' *\n| where ImageLoaded has_any (FilePaths) or SHA256 has_any (sha256Hashes) \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, SHA256, ImageLoaded, EventID\n| extend Type = strcat(Type,\":\",EventID, \": \", Source), Account = UserName, FileHash = SHA256, Image = EventDetail.[4].[\"#text\"] \n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated,  Message, SourceUserID, FileHash, Type\n| extend timestamp = TimeGenerated, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(DeviceEvents\n| where DeviceName in (ADFS_Servers)\n| extend FilePath = strcat(FolderPath, '\\\\', FileName)\n| where InitiatingProcessSHA256 has_any (sha256Hashes) or FilePath has_any (FilePaths)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend Account = InitiatingProcessAccountName, Computer = DeviceName, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256, Image = InitiatingProcessFolderPath\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(DeviceFileEvents\n| where DeviceName in (ADFS_Servers)\n| where FolderPath has_any (FilePaths) or SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend Account = InitiatingProcessAccountName, Computer = DeviceName, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256, Image = InitiatingProcessFolderPath\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(DeviceImageLoadEvents\n| where DeviceName in (ADFS_Servers)\n| where FolderPath has_any (FilePaths) or SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend Account = InitiatingProcessAccountName, Computer = DeviceName, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256, Image = InitiatingProcessFolderPath\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where Computer in (ADFS_Servers)\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| parse EventDetail with * 'SHA256=' SHA256 '\",' *\n| where EventDetail has_any (sha256Hashes) \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, SHA256\n| extend Type = strcat(Type, \": \", Source), Account = UserName, FileHash = SHA256, Image = EventDetail.[4].[\"#text\"] \n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(W3CIISLog \n| where ( csMethod == 'GET' and csUriStem has_any (GET_URI)) or (csMethod == 'POST' and csUriStem has_any (POST_URI))\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), cIP_MethodCount = count() \nby cIP, cIP_MethodCountType = \"Count of repeated entries, this is to reduce rowsets returned\", csMethod, \ncsHost, scStatus, sIP, csUriStem, csUriQuery, csUserName, csUserAgent, csCookie, csReferer\n| extend timestamp = StartTime, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName\n),\n(imFileEvent\n| where DvcHostname in (ADFS_Servers)\n| where TargetFileSHA256 has_any (sha256Hashes) or FilePath has_any (FilePaths)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n)\n)\n", "attributes": {"description": "'Identifies a match across various data feeds for IOCs related to FoggyWeb backdoor by the threat actor NOBELIUM.\n FoggyWeb is a passive and highly targeted backdoor capable of remotely exfiltrating sensitive information from a compromised AD FS server.\n It can also receive additional malicious components from a command-and-control (C2) server and execute them on the compromised server.\n Reference: https://aka.ms/nobelium-foggy-web'\n", "techniques": ["T1005"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/NOBELIUM_IOCsMay2021.yaml", "query_name": "NOBELIUM - Domain, Hash and IP IOCs - May 2021", "query": "let iocs = externaldata(DateAdded:string,FirstSeen:string,IoC:string,Type:string,TLP:string)\n[@\"https://raw.githubusercontent.com/microsoft/mstic/master/Indicators/May21-NOBELIUM/May21NOBELIUMIoCs.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet sha256s = (iocs | where Type =~ \"SHA256\"| project IoC);\nlet ips = (iocs | where Type =~ \"IP\"| project IoC);\nlet IPList = dynamic([\"192.99.221.77\",\"83.171.237.173\"]);\nlet ips_list=toscalar(ips | summarize makeset(IoC));\nlet full_ip_list= array_concat(ips_list, IPList);\nlet domains = (iocs | where Type =~ \"Domain\"| project IoC);\nlet domain_list=toscalar(domains | summarize make_set(IoC));\nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\nlet sha256Hashes = dynamic([\"2523f94bd4fba4af76f4411fe61084a7e7d80dec163c9ccba9226c80b8b31252\",\n\"d035d394a82ae1e44b25e273f99eae8e2369da828d6b6fdb95076fd3eb5de142\",\n\"94786066a64c0eb260a28a2959fcd31d63d175ade8b05ae682d3f6f9b2a5a916\",\n\"48b5fb3fa3ea67c2bc0086c41ec755c39d748a7100d71b81f618e82bf1c479f0\",\n\"ee44c0692fd2ab2f01d17ca4b58ca6c7f79388cbc681f885bb17ec946514088c\",\n\"ee42ddacbd202008bcc1312e548e1d9ac670dd3d86c999606a3a01d464a2a330\"]);\n(union isfuzzy=true\n(CommonSecurityLog\n| where SourceIP in (IPList) or DestinationIP in (IPList) or DestinationHostName in~ (domains) or RequestURL has_any (domains) or Message has_any (IPList)\n| parse Message with * '(' DNSName ')' * \n| extend MessageIP = extract(IPRegex, 0, Message)\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", MessageIP in (IPList), \"Message\", RequestURL in (domains), \"RequestUrl\", SourceIP in (ips), \"SourceIP\", DestinationIP in (ips), \"DestinationIP\", MessageIP in (IPList), \"Message\", \"NoMatch\") \n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, IPMatch == \"Message\", MessageIP, \"NoMatch\"), AccountCustomEntity = SourceUserID\n),\n(_Im_Dns (domain_has_any=todynamic(domain_list))\n| extend DestinationIPAddress = DnsResponseName, DNSName = DnsQuery, Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Host\n),\n(_Im_Dns (response_has_any_prefix=todynamic(full_ip_list))\n| extend DestinationIPAddress = DnsResponseName, DNSName = DnsQuery, Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Host\n),\n(VMConnection\n| where SourceIp in (IPList) or DestinationIp in (IPList) or SourceIp in (ips) or DestinationIp in (ips) or RemoteDnsCanonicalNames has_any (domains)\n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| extend IPMatch = case( SourceIp in (IPList), \"SourceIP\", DestinationIp in (IPList), \"DestinationIP\",  SourceIp in (ips), \"SourceIP\", DestinationIp in (ips), \"DestinationIP\", \"None\") \n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIp, IPMatch == \"DestinationIP\", DestinationIp, \"NoMatch\"), HostCustomEntity = Computer\n),\n(OfficeActivity\n| where ClientIP in (IPList) or ClientIP in (ips)\n| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, AccountCustomEntity = UserId\n),\n(WindowsFirewall\n| where SourceIP in (IPList) or DestinationIP in (IPList) or SourceIP in (ips) or DestinationIP in (ips)\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", SourceIP in (ips), \"SourceIP\", DestinationIP in (ips), \"DestinationIP\", \"None\")\n),\n(_Im_NetworkSession(srcipaddr_has_any_prefix=full_ip_list)\n  | extend IPMatch =  \"SourceIP\"\n  | extend timestamp = TimeGenerated, HostCustomEntity = Dvc , IPCustomEntity = SrcIpAddr //, AccountCustomEntity =User\n),\n(_Im_NetworkSession(dstipaddr_has_any_prefix=full_ip_list)\n  | extend IPMatch =  \"DestinationIP\"\n  | extend timestamp = TimeGenerated, HostCustomEntity = Dvc , IPCustomEntity =  DstIpAddr //, AccountCustomEntity =User\n),\n(_Im_WebSession(url_has_any=domains)\n  | extend timestamp=TimeGenerated, HostCustomEntity=Dvc , DNSName=tostring(parse_url(Url)[\"Host\"]), AccountCustomEntity=User\n),\n(_Im_WebSession(srcipaddr_has_any_prefix=full_ip_list)\n  | extend timestamp=TimeGenerated, HostCustomEntity=Dvc , DNSName=tostring(parse_url(Url)[\"Host\"]), AccountCustomEntity=User\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (domains)  \n| extend timestamp = TimeGenerated, DNSName = DestinationHost, IPCustomEntity = SourceHost\n),\n(Event\n//This query uses sysmon data depending on table name used this may need updating\n| where Source == \"Microsoft-Windows-Sysmon\"\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| where EventDetail has_any (sha256Hashes) or EventDetail has_any (sha256s)\n| parse EventDetail with * 'SHA256=' SHA256 '\",' *\n| extend Type = strcat(Type, \": \", Source), Account = UserName, FileHash = SHA256\n| project Type, TimeGenerated, Computer, Account, FileHash\n),\n(DeviceFileEvents\n| where SHA256 in~ (sha256Hashes) or SHA256 in~ (sha256s)\n| extend Account = RequestAccountName, Computer = DeviceName, IPAddress = RequestSourceIP, CommandLine = InitiatingProcessCommandLine, FileHash = SHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(imFileEvent\n| where TargetFileSHA256 in~ (sha256Hashes) or TargetFileSHA256 in~ (sha256s)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(CommonSecurityLog\n| where FileHash in (sha256Hashes) or FileHash in (sha256s)\n| extend timestamp = TimeGenerated\n)\n)\n", "attributes": {"description": "'Identifies a match across various data feeds for domains, hashes and IP IOCs related to NOBELIUM.\nRef: https://www.microsoft.com/security/blog/2021/05/27/new-sophisticated-email-based-attack-from-nobelium/'\n", "techniques": ["T1102.002", "T1204.001"], "tactics": ["CommandAndControl", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/PHOSPHORUSMarch2019IOCs.yaml", "query_name": "Known Phosphorus group domains/IP", "query": "\nlet DomainNames = dynamic([\"yahoo-verification.org\",\"support-servics.com\",\"verification-live.com\",\"com-mailbox.com\",\"com-myaccuants.com\",\"notification-accountservice.com\",\n\"accounts-web-mail.com\",\"customer-certificate.com\",\"session-users-activities.com\",\"user-profile-credentials.com\",\"verify-linke.com\",\"support-servics.net\",\"verify-linkedin.net\", \n\"yahoo-verification.net\",\"yahoo-verify.net\",\"outlook-verify.net\",\"com-users.net\",\"verifiy-account.net\",\"te1egram.net\",\"account-verifiy.net\",\"myaccount-services.net\",\n\"com-identifier-servicelog.name\",\"microsoft-update.bid\",\"outlook-livecom.bid\",\"update-microsoft.bid\",\"documentsfilesharing.cloud\",\"com-microsoftonline.club\",\n\"confirm-session-identifier.info\",\"session-management.info\",\"confirmation-service.info\",\"document-share.info\",\"broadcast-news.info\",\"customize-identity.info\",\"webemail.info\",\n\"com-identifier-servicelog.info\",\"documentsharing.info\",\"notification-accountservice.info\",\"identifier-activities.info\",\"documentofficupdate.info\",\"recoveryusercustomer.info\",\n\"serverbroadcast.info\",\"account-profile-users.info\",\"account-service-management.info\",\"accounts-manager.info\",\"activity-confirmation-service.info\",\"com-accountidentifier.info\",\n\"com-privacy-help.info\",\"com-sessionidentifier.info\",\"com-useraccount.info\",\"confirmation-users-service.info\",\"confirm-identity.info\",\"confirm-session-identification.info\",\n\"continue-session-identifier.info\",\"customer-recovery.info\",\"customers-activities.info\",\"elitemaildelivery.info\",\"email-delivery.info\",\"identify-user-session.info\",\n\"message-serviceprovider.info\",\"notificationapp.info\",\"notification-manager.info\",\"recognized-activity.info\",\"recover-customers-service.info\",\"recovery-session-change.info\",\n\"service-recovery-session.info\",\"service-session-continue.info\",\"session-mail-customers.info\",\"session-managment.info\",\"session-verify-user.info\",\"shop-sellwear.info\",\n\"supportmailservice.info\",\"terms-service-notification.info\",\"user-activity-issues.info\",\"useridentity-confirm.info\",\"users-issue-services.info\",\"verify-user-session.info\",\n\"login-gov.info\",\"notification-signal-agnecy.info\",\"notifications-center.info\",\"identifier-services-sessions.info\",\"customers-manager.info\",\"session-manager.info\",\n\"customer-managers.info\",\"confirmation-recovery-options.info\",\"service-session-confirm.info\",\"session-recovery-options.info\",\"services-session-confirmation.info\",\n\"notification-managers.info\",\"activities-services-notification.info\",\"activities-recovery-options.info\",\"activity-session-recovery.info\",\"customers-services.info\",\n\"sessions-notification.info\",\"download-teamspeak.info\",\"services-issue-notification.info\",\"microsoft-upgrade.mobi\",\"broadcastnews.pro\",\"mobile-messengerplus.network\"]);\nlet IPList = dynamic([\"51.91.200.147\"]);\nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\n(union isfuzzy=true\n(CommonSecurityLog \n| parse Message with * '(' DNSName ')' * \n| extend MessageIP = extract(IPRegex, 0, Message)\n| extend RequestURLIP = extract(IPRegex, 0, Message)\n| where (isnotempty(SourceIP) and SourceIP in (IPList)) or (isnotempty(DestinationIP) and DestinationIP in (IPList)) \nor (isnotempty(DNSName) and DNSName in~ (DomainNames)) or (isnotempty(DestinationHostName) and DestinationHostName in~ (DomainNames)) or (isnotempty(RequestURL) and (RequestURL has_any (DomainNames) or RequestURLIP in (IPList))) \nor (isnotempty(Message) and MessageIP in (IPList))\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", MessageIP in (IPList), \"Message\", RequestURLIP in (IPList), \"RequestUrl\", \"NoMatch\") \n| extend timestamp = TimeGenerated , IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP,IPMatch == \"Message\", MessageIP,\nIPMatch == \"RequestUrl\", RequestURLIP,\"NoMatch\"), Account = SourceUserID, Host = DeviceName\n),\n(_Im_Dns (domain_has_any=DomainNames)\n| extend DestinationIPAddress = DnsResponseName, DNSName = DnsQuery, Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Host),\n(_Im_Dns (response_has_any_prefix=IPList)\n| extend DestinationIPAddress = DnsResponseName, DNSName = DnsQuery, Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Host),\n(_Im_WebSession(url_has_any=DomainNames)\n| extend DestinationIPAddress = DstIpAddr, DNSName = tostring(parse_url(Url)[\"Host\"]), Host = Dvc\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Host),\n(VMConnection \n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| where isnotempty(SourceIp) or isnotempty(DestinationIp) or isnotempty(DNSName)\n| where SourceIp in (IPList) or DestinationIp in (IPList) or DNSName in~ (DomainNames)\n| extend IPMatch = case( SourceIp in (IPList), \"SourceIP\", DestinationIp in (IPList), \"DestinationIP\", \"None\") \n| extend timestamp = TimeGenerated , IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIp, IPMatch == \"DestinationIP\", DestinationIp, \"None\"), Host = Computer),\n(OfficeActivity\n| extend SourceIPAddress = ClientIP, Account = UserId\n| where  SourceIPAddress in (IPList)\n| extend timestamp = TimeGenerated , IPCustomEntity = SourceIPAddress , AccountCustomEntity = Account),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (DomainNames)  \n| extend DNSName = DestinationHost \n| extend IPCustomEntity = SourceHost \n)\n)\n", "attributes": {"description": "'Matches domain name IOCs related to Phosphorus group activity with CommonSecurityLog, DnsEvents, OfficeActivity and VMConnection dataTypes.\nReferences: https://blogs.microsoft.com/on-the-issues/2019/03/27/new-steps-to-protect-customers-from-hacking/.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/POLONIUMIPIoC.yaml", "query_name": "Known POLONIUM IP", "query": "let IPList = dynamic([\"135.125.147.170:80\",\"185.244.129.79:63047\",\"185.244.129.79:80\",\"45.80.149.108:63047\",\"45.80.149.108:80\",\"45.80.149.57:63047\",\"45.80.149.68:63047\",\"45.80.149.71:80\",\"185.244.129.109\",\"172.96.188.51\",\"51.83.246.73\"]); \n(union isfuzzy=true \n(CommonSecurityLog \n| where isnotempty(SourceIP) or isnotempty(DestinationIP) \n| where SourceIP in (IPList) or DestinationIP in (IPList) or Message has_any (IPList) \n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"Message\")  \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SourceIP, DestinationIP, DeviceProduct, DeviceAction, Message, Protocol, SourcePort, DestinationPort, DeviceAddress, DeviceName, IPMatch \n| extend timestamp = StartTimeUtc, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"IP in Message Field\")  \n), \n(OfficeActivity \n|extend SourceIPAddress = ClientIP, Account = UserId \n| where  SourceIPAddress in (IPList) \n| extend timestamp = TimeGenerated , IPCustomEntity = SourceIPAddress , AccountCustomEntity = Account \n),\n(_Im_Dns (response_has_any_prefix=IPList)\n| extend DestinationIPAddress = ResponseName,  Host = SrcIpAddr \n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host \n), \n(_Im_NetworkSession (srcipaddr_has_any_prefix=IPList)\n | extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Hostname, AccountCustomEntity=User\n), \n(_Im_NetworkSession (dstipaddr_has_any_prefix=IPList)\n| extend timestamp = TimeGenerated, IPCustomEntity = DstIpAddr, HostCustomEntity = Hostname , AccountCustomEntity = User\n), \n(WireData  \n| where isnotempty(RemoteIP) \n| where RemoteIP in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = Computer \n), \n(SigninLogs \n| where isnotempty(IPAddress) \n| where IPAddress in (IPList) \n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress \n),\n(AADNonInteractiveUserSignInLogs \n| where isnotempty(IPAddress) \n| where IPAddress in (IPList) \n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress \n), \n(W3CIISLog  \n| where isnotempty(cIP) \n| where cIP in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName \n), \n(AzureActivity  \n| where isnotempty(CallerIpAddress) \n| where CallerIpAddress in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = CallerIpAddress, AccountCustomEntity = Caller \n), \n( \nAWSCloudTrail \n| where isnotempty(SourceIpAddress) \n| where SourceIpAddress in (IPList) \n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName \n), \n( \nDeviceNetworkEvents \n| where isnotempty(RemoteIP)  \n| where RemoteIP in (IPList)  \n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = DeviceName  \n),\n(\nAzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (IPList)  \n| extend DestinationIP = DestinationHost \n| extend IPCustomEntity = SourceHost\n),\n(\nAzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallNetworkRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (IPList)  \n| extend DestinationIP = DestinationHost \n| extend IPCustomEntity = SourceHost\n)\n) \n", "attributes": {"description": "'Identifies a match across various data feeds for IP IOCs related to the POLONIUM activity group.  \n References: BLOGURL' \n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/PotentialFodhelperUACBypass%28ASIMVersion%29.yaml", "query_name": "Potential Fodhelper UAC Bypass (ASIM Version)", "query": "imRegistry\n  | where EventType in (\"RegistryValueSet\", \"RegistryKeyCreated\")\n  | where RegistryKey has \"Software\\\\Classes\\\\ms-settings\\\\shell\\\\open\\\\command\"\n  | extend TimeKey = bin(TimeGenerated, 1h)\n  | join (imProcess\n  | where Process endswith \"fodhelper.exe\"\n  | where ParentProcessName endswith \"cmd.exe\" or ParentProcessName endswith \"powershell.exe\" or ParentProcessName endswith \"powershell_ise.exe\"\n  | extend TimeKey = bin(TimeGenerated, 1h)) on TimeKey, Dvc\n", "attributes": {"description": "'This detection looks for the steps required to conduct a UAC bypass using Fodhelper.exe. By default this detection looks for the setting of the required registry keys and the invoking of the process within 1 hour - this can be tweaked as required.'\n", "techniques": ["T1548.002"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/PotentialMercury_Webshell.yaml", "query_name": "Identify SysAid Server web shell creation", "query": "let timeframe = 1d;\nlet time_window = 5m;\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated > ago(timeframe)\n| where EventID == 4688\n| where Process has_any (\"java.exe\", \"javaw.exe\") and CommandLine has \"SysAidServer\" \n| summarize by ParentProcessName,Process, Account, Computer, CommandLine, timekey= bin(TimeGenerated, time_window), TimeGenerated, SubjectLogonId\n| join kind=inner(\nSecurityEvent\n| where TimeGenerated > ago(timeframe)\n| where EventID == 4663\n| where Process has_any (\"java.exe\", \"javaw.exe\")\n| where AccessMask in ('0x2','0x100', '0x10', '0x4')\n| where ObjectName endswith \".jsp\" \n| summarize by ParentProcessName, Account, Computer, ObjectName, ProcessName, timekey= bin(TimeGenerated, time_window), TimeGenerated, SubjectLogonId)\n on timekey, Computer, SubjectLogonId\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(DeviceFileEvents \n| where InitiatingProcessFileName has_any (\"java.exe\", \"javaw.exe\")  \n| where InitiatingProcessCommandLine has \"SysAidServer\"  \n| where FileName endswith \".jsp\" \n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingProcessAccountName, HostCustomEntity = DeviceName\n),\n(imFileEvent\n| where TimeGenerated > ago(timeframe)\n| where EventType == \"FileCreated\"\n| where ActingProcessName has_any (\"java.exe\", \"javaw.exe\") \n| where ActingProcessCommandLine has \"SysAidServer\"  \n| where FilePath endswith \".jsp\" \n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUsername, HostCustomEntity = DvcHostname\n)\n)\n", "attributes": {"description": "'This query looks for potential webshell creation by the threat actor Mercury after the sucessful exploitation of SysAid server. \nReference:  https://www.microsoft.com/security/blog/2022/08/25/mercury-leveraging-log4j-2-vulnerabilities-in-unpatched-systems-to-target-israeli-organizations/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/powershell_mercury.yaml", "query_name": "Identify MERCURY powershell commands", "query": "(union isfuzzy=true\n(SecurityEvent\n| where EventID == 4688\n| where Process has_any (\"powershell.exe\",\"powershell_ise.exe\",\"pwsh.exe\") and CommandLine has_cs \"-exec bypass -w 1 -enc\"\n| where CommandLine  contains_cs \"UwB0AGEAcgB0AC0ASgBvAGIAIAAtAFMAYwByAGkAcAB0AEIAbABvAGMAawAgAHsAKABzAGEAcABzACAAKAAiAHAA\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, ProcessCustomEntity = Process\n),\n(DeviceProcessEvents\n| where FileName =~ \"powershell.exe\" and ProcessCommandLine has_cs \"-exec bypass -w 1 -enc\"  \n| where ProcessCommandLine contains_cs \"UwB0AGEAcgB0AC0ASgBvAGIAIAAtAFMAYwByAGkAcAB0AEIAbABvAGMAawAgAHsAKABzAGEAcABzACAAKAAiAHAA\" \n| extend timestamp = TimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = DeviceName, ProcessCustomEntity = InitiatingProcessFileName\n),\n(imProcessCreate\n| where Process has_any (\"powershell.exe\",\"powershell_ise.exe\",\"pwsh.exe\") and CommandLine has_cs \"-exec bypass -w 1 -enc\"\n| where CommandLine  contains_cs \"UwB0AGEAcgB0AC0ASgBvAGIAIAAtAFMAYwByAGkAcAB0AEIAbABvAGMAawAgAHsAKABzAGEAcABzACAAKAAiAHAA\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUsername, HostCustomEntity = DvcHostname, ProcessCustomEntity = Process\n)\n)\n", "attributes": {"description": "'The query below identifies powershell commands used by the threat actor Mercury.\nReference:  https://www.microsoft.com/security/blog/2022/08/25/mercury-leveraging-log4j-2-vulnerabilities-in-unpatched-systems-to-target-israeli-organizations/'\n", "techniques": ["T1570"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/RunCommandUEBABreach.yaml", "query_name": "Azure VM Run Command operation executed during suspicious login window", "query": "AzureActivity\n// Isolate run command actions\n| where OperationNameValue == \"MICROSOFT.COMPUTE/VIRTUALMACHINES/RUNCOMMAND/ACTION\"\n// Confirm that the operation impacted a virtual machine\n| where Authorization has \"virtualMachines\"\n// Each runcommand operation consists of three events when successful, Started, Accepted (or Rejected), Successful (or Failed).\n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), max(CallerIpAddress), make_list(ActivityStatusValue) by CorrelationId, Authorization, Caller\n// Limit to Run Command executions that Succeeded\n| where list_ActivityStatusValue has \"Success\"\n// Extract data from the Authorization field\n| extend Authorization_d = parse_json(Authorization)\n| extend Scope = Authorization_d.scope\n| extend Scope_s = split(Scope, \"/\")\n| extend Subscription = tostring(Scope_s[2])\n| extend VirtualMachineName = tostring(Scope_s[-1])\n| project StartTime, EndTime, Subscription, VirtualMachineName, CorrelationId, Caller, CallerIpAddress=max_CallerIpAddress\n// Create a join key using  the Caller (UPN)\n| extend joinkey = tolower(Caller)\n// Join the Run Command actions to UEBA data\n| join kind = inner (\n    BehaviorAnalytics\n    // We are specifically interested in unusual logins\n    | where EventSource == \"Azure AD\" and ActivityInsights.ActionUncommonlyPerformedByUser == \"True\"\n    | project UEBAEventTime=TimeGenerated, UEBAActionType=ActionType, UserPrincipalName, UEBASourceIPLocation=SourceIPLocation, UEBAActivityInsights=ActivityInsights, UEBAUsersInsights=UsersInsights\n    | where isnotempty(UserPrincipalName) and isnotempty(UEBASourceIPLocation)\n    | extend joinkey = tolower(UserPrincipalName)\n) on joinkey\n// Create a window around the UEBA event times, check to see if the Run Command action was performed within them\n| extend UEBAWindowStart = UEBAEventTime - 1h, UEBAWindowEnd = UEBAEventTime + 6h\n| where StartTime between (UEBAWindowStart .. UEBAWindowEnd)\n| project StartTime, EndTime, Subscription, VirtualMachineName, Caller, CallerIpAddress, UEBAEventTime, UEBAActionType, UEBASourceIPLocation, UEBAActivityInsights, UEBAUsersInsights\n| extend timestamp = StartTime, AccountCustomEntity=Caller, IPCustomEntity=CallerIpAddress\n", "attributes": {"description": "'Identifies when the Azure Run Command operation is executed by a UserPrincipalName and IP Address  \nthat has resulted in a recent user entity behaviour alert.'\n", "techniques": ["T1570", "T1212"], "tactics": ["LateralMovement", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/SEABORGIUMDomainsAugust2022.yaml", "query_name": "SEABORGIUM C2 Domains August 2022", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/SEABORGIUMIOC.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet DomainNames = (iocs | where Type =~ \"domainname\"| project IoC);\n(union isfuzzy=true \n(CommonSecurityLog  \n| parse Message with * '(' DNSName ')' *  \n| where DNSName in~ (DomainNames) \n| extend Account = SourceUserID, Computer = DeviceName, IPAddress =  DestinationIP \n), \n(_Im_Dns (domain_has_any=DomainNames)\n| extend DNSName = DnsQuery \n| extend IPAddress =  SrcIpAddr, Computer = Dvc\n), \n(_Im_WebSession (url_has_any=DomainNames)\n| extend DNSName = tostring(parse_url(Url)[\"Host\"])\n| extend IPAddress =  SrcIpAddr, Computer = Dvc\n), \n(VMConnection  \n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' * \n| where DNSName  in~ (DomainNames) \n| extend IPAddress = RemoteIp \n), \n(DeviceNetworkEvents \n| where RemoteUrl  has_any (DomainNames)  \n| extend IPAddress = RemoteIP \n| extend Computer = DeviceName \n),\n(EmailUrlInfo\n| where Url has_any (DomainNames) \n| join (EmailEvents \n| where EmailDirection == \"Inbound\" ) on NetworkMessageId \n| extend IPAddress = SenderIPv4 \n| extend Account = RecipientEmailAddress \n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (DomainNames)  \n| extend DNSName = DestinationHost \n| extend IPAddress = SourceHost\n) \n) \n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress \n", "attributes": {"description": "'Identifies a match across various data feeds for domains related to an actor tracked by Microsoft as SEABORGIUM.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/SecurityServiceRegistryACLModification.yaml", "query_name": "Security Service Registry ACL Modification", "query": "\nlet servicelist = dynamic(['Services\\\\HealthService', 'Services\\\\Sense', 'Services\\\\WinDefend', 'Services\\\\MsSecFlt', 'Services\\\\DiagTrack', 'Services\\\\SgrmBroker', 'Services\\\\SgrmAgent', 'Services\\\\AATPSensorUpdater' , 'Services\\\\AATPSensor', 'Services\\\\mpssvc']);\nlet filename = dynamic([\"subinacl.exe\",'SetACL.exe']);\nlet parameters = dynamic (['/deny=SYSTEM', '/deny=S-1-5-18', '/grant=SYSTEM=r', '/grant=S-1-5-18=r', 'n:SYSTEM;p:READ', 'n1:SYSTEM;ta:remtrst;w:dacl']);\nlet FullAccess = dynamic(['A;CI;KA;;;SY', 'A;ID;KA;;;SY', 'A;CIID;KA;;;SY']);\nlet ReadAccess = dynamic(['A;CI;KR;;;SY', 'A;ID;KR;;;SY', 'A;CIID;KR;;;SY']);\nlet DenyAccess = dynamic(['D;CI;KR;;;SY', 'D;ID;KR;;;SY', 'D;CIID;KR;;;SY']);\nlet timeframe = 1d;\n(union isfuzzy=true\n(\nSecurityEvent\n| where TimeGenerated >= ago(timeframe)\n| where EventID == 4670\n| where ObjectType == 'Key'\n| where ObjectName has_any (servicelist)\n| parse EventData with * 'OldSd\">' OldSd \"<\" *\n| parse EventData with * 'NewSd\">' NewSd \"<\" *\n| extend Reason = case( (OldSd has ';;;SY' and NewSd !has ';;;SY'), 'System Account is removed', (OldSd has_any (FullAccess) and NewSd has_any (ReadAccess)) , 'System permission has been changed to read from full access', (OldSd has_any (FullAccess) and NewSd has_any (DenyAccess)), 'System account has been given denied permission', 'None')\n| project TimeGenerated, Computer, Account,  ProcessName, ProcessId, ObjectName, EventData, Activity, HandleId, SubjectLogonId, OldSd, NewSd , Reason\n),\n(\nSecurityEvent\n| where TimeGenerated >= ago(timeframe)\n| where EventID == 4688\n| extend ProcessName = tostring(split(NewProcessName, '\\\\')[-1])\n| where ProcessName in~ (filename) \n| where CommandLine has_any (servicelist) and CommandLine has_any (parameters)\n| project TimeGenerated, Computer, Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(\nWindowsEvent\n| where TimeGenerated >= ago(timeframe)\n| where EventID == 4670 and EventData has_any (servicelist) and EventData has 'Key'\n| extend ObjectType = tostring(EventData.ObjectType)\n| where ObjectType == 'Key'\n| extend ObjectName = tostring(EventData.ObjectName)\n| where ObjectName has_any (servicelist)\n| extend OldSd = tostring(EventData.OldSd)\n| extend NewSd = tostring(EventData.NewSd)\n| extend Reason = case( (OldSd has ';;;SY' and NewSd !has ';;;SY'), 'System Account is removed', (OldSd has_any (FullAccess) and NewSd has_any (ReadAccess)) , 'System permission has been changed to read from full access', (OldSd has_any (FullAccess) and NewSd has_any (DenyAccess)), 'System account has been given denied permission', 'None')\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend ProcessName = tostring(EventData.ProcessName)\n| extend ProcessId = tostring(EventData.ProcessId)\n| extend Activity= \"4670 - Permissions on an object were changed.\"\n| extend HandleId = tostring(EventData.HandleId)\n| extend  SubjectLogonId = tostring(EventData.SubjectLogonId)\n| project TimeGenerated, Computer, Account,  ProcessName, ProcessId, ObjectName, EventData, Activity, HandleId, SubjectLogonId, OldSd, NewSd , Reason\n),\n(\nWindowsEvent\n| where TimeGenerated >= ago(timeframe)\n| where EventID == 4688 and EventData has_any (filename) and EventData has_any (servicelist) and EventData has_any (parameters)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend ProcessName = tostring(split(NewProcessName, '\\\\')[-1])\n| where ProcessName in~ (filename) \n| extend CommandLine = tostring(EventData.CommandLine) \n| where CommandLine has_any (servicelist) and CommandLine has_any (parameters)\n| extend  Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend  AccountDomain = tostring(EventData.AccountDomain)\n| extend  Activity=\"4688 - A new process has been created.\"\n| extend  EventSourceName=Provider\n| project TimeGenerated, Computer, Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(\nDeviceProcessEvents\n| where TimeGenerated >= ago(timeframe)\n| where InitiatingProcessFileName in~ (filename) \n| where InitiatingProcessCommandLine has_any(servicelist) and InitiatingProcessCommandLine has_any (parameters)\n| extend Account = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName), Computer = DeviceName\n| project TimeGenerated, Computer, Account, AccountDomain, ProcessName = InitiatingProcessFileName, ProcessNameFullPath = FolderPath, Activity = ActionType, CommandLine = InitiatingProcessCommandLine, Type, InitiatingProcessParentFileName\n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies attempts to modify registry ACL to evade security solutions. In the Solorigate attack, the attackers were found modifying registry permissions so services.exe cannot access the relevant registry keys to start the service.\n The detection leverages Security Event as well as MDE data to identify when specific security services registry permissions are modified. \n Only some portions of this detection are related to Solorigate, it also includes coverage for some common tools that perform this activity. \n Reference on guidance for enabling registry auditing:\n - https://docs.microsoft.com/windows/security/threat-protection/auditing/advanced-security-auditing-faq\n - https://docs.microsoft.com/windows/security/threat-protection/auditing/appendix-a-security-monitoring-recommendations-for-many-audit-events\n - https://docs.microsoft.com/windows/security/threat-protection/auditing/audit-registry\n - https://docs.microsoft.com/windows/security/threat-protection/auditing/event-4670\n   - For the event 4670 to be created the audit policy for the registry must have auditing enabled for Write DAC and/or Write Owner\n - https://github.com/OTRF/Set-AuditRule \n - https://docs.microsoft.com/dotnet/api/system.security.accesscontrol.registryrights?view=dotnet-plat-ext-5.0'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/SigninFirewallCorrelation.yaml", "query_name": "Cisco - firewall block but success logon to Azure AD", "query": "\nlet aadFunc = (tableName:string){\nCommonSecurityLog\n| where DeviceVendor =~ \"Cisco\"\n| where DeviceAction =~ \"denied\"\n| where ipv4_is_private(SourceIP) == false\n| summarize count() by SourceIP\n| join (\n    // Successful signins from IPs blocked by the firewall solution are suspect\n    // Include fully successful sign-ins, but also ones that failed only at MFA stage\n    // as that supposes the password was sucessfully guessed.\n  table(tableName)\n  | where ResultType in (\"0\", \"50074\", \"50076\") \n) on $left.SourceIP == $right.IPAddress\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, AccountCustomEntity = UserPrincipalName\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Correlate IPs blocked by a Cisco firewall appliance with successful Azure Active Directory signins. \nBecause the IP was blocked by the firewall, that same IP logging on successfully to AAD is potentially suspect\nand could indicate credential compromise for the user account.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Solorigate-Network-Beacon.yaml", "query_name": "Solorigate Network Beacon", "query": "let domains = dynamic([\"incomeupdate.com\",\"zupertech.com\",\"databasegalore.com\",\"panhardware.com\",\"avsvmcloud.com\",\"digitalcollege.org\",\"freescanonline.com\",\"deftsecurity.com\",\"thedoccloud.com\",\"virtualdataserver.com\",\"lcomputers.com\",\"webcodez.com\",\"globalnetworkissues.com\",\"kubecloud.com\",\"seobundlekit.com\",\"solartrackingsystem.net\",\"virtualwebdata.com\"]);\n(union isfuzzy=true\n(CommonSecurityLog \n  | parse Message with * '(' DNSName ')' * \n  | where DNSName in~ (domains) or DestinationHostName has_any (domains) or RequestURL has_any(domains)\n  | extend AccountCustomEntity = SourceUserID, HostCustomEntity = DeviceName, IPCustomEntity = SourceIP\n  ),\n(_Im_Dns (domain_has_any=domains)\n  | extend DNSName = DnsQuery\n  | extend IPCustomEntity = SrcIpAddr\n  ),\n(VMConnection \n  | parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n  | where isnotempty(DNSName)\n  | where DNSName in~ (domains)\n  | extend IPCustomEntity = RemoteIp\n  ),\n(DeviceNetworkEvents \n  | where isnotempty(RemoteUrl) \n  | where RemoteUrl  has_any (domains)  \n  | extend DNSName = RemoteUrl\n  | extend IPCustomEntity = RemoteIP \n  | extend HostCustomEntity = DeviceName \n  ),\n(AzureDiagnostics \n  | where ResourceType == \"AZUREFIREWALLS\"\n  | where Category == \"AzureFirewallApplicationRule\"\n  | parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n  | where isnotempty(DestinationHost)\n  | where DestinationHost has_any (domains)  \n  | extend DNSName = DestinationHost \n  | extend IPCustomEntity = SourceHost\n  ) \n  )\n", "attributes": {"description": "'Identifies a match across various data feeds for domains IOCs related to the Solorigate incident.\n References: https://blogs.microsoft.com/on-the-issues/2020/12/13/customers-protect-nation-state-cyberattacks/, \n https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html?1'\n", "techniques": ["T1102"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/Solorigate-VM-Network.yaml", "query_name": "Solorigate Domains Found in VM Insights", "query": "\nlet domains = dynamic([\"incomeupdate.com\",\"zupertech.com\",\"databasegalore.com\",\"panhardware.com\",\"avsvmcloud.com\",\"digitalcollege.org\",\"freescanonline.com\",\"deftsecurity.com\",\"thedoccloud.com\",\"virtualdataserver.com\",\"lcomputers.com\",\"webcodez.com\",\"globalnetworkissues.com\",\"kubecloud.com\",\"seobundlekit.com\",\"solartrackingsystem.net\",\"virtualwebdata.com\"]);\nlet timeframe = 1h;\nlet connections = VMConnection \n    | where TimeGenerated >= ago(timeframe)\n    | extend DNSName = set_union(todynamic(RemoteDnsCanonicalNames),todynamic(RemoteDnsQuestions))\n    | mv-expand DNSName\n    | where isnotempty(DNSName)\n    | where DNSName has_any (domains)\n    | extend IPCustomEntity = RemoteIp\n    | summarize TimeGenerated = arg_min(TimeGenerated, *), requests = count() by IPCustomEntity, DNSName = tostring(DNSName), AgentId, Machine, Process;\nlet processes = VMProcess\n    | where TimeGenerated >= ago(timeframe)\n    | project AgentId, Machine, Process, UserName, UserDomain, ExecutablePath, CommandLine, FirstPid\n    | extend exePathArr = split(ExecutablePath, \"\\\\\")\n    | extend DirectoryName = array_strcat(array_slice(exePathArr, 0, array_length(exePathArr) - 2), \"\\\\\")\n    | extend Filename = array_strcat(array_slice(exePathArr, array_length(exePathArr) - 1, array_length(exePathArr)), \"\\\\\")\n    | project-away exePathArr;\nlet computers = VMComputer\n    | where TimeGenerated >= ago(timeframe)\n    | project HostCustomEntity = HostName, AzureResourceId = _ResourceId, AgentId, Machine;\nconnections | join kind = inner (processes) on AgentId, Machine, Process\n            | join kind = inner (computers) on AgentId, Machine\n             \n", "attributes": {"description": "'Identifies connections to Solorigate-related DNS records based on VM insights data'\n", "techniques": ["T1102"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/SOURGUM_IOC.yaml", "query_name": "SOURGUM Actor IOC - July 2021", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/SOURGUM.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet domains = (iocs | where Type =~ \"domainname\"| project IoC);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\nlet file_path1 = (iocs | where Type =~ \"filepath1\" | project IoC);\nlet file_path2 = (iocs | where Type =~ \"filepath2\" | project IoC);\nlet file_path3 = (iocs | where Type =~ \"filepath3\" | project IoC);\nlet reg_key = (iocs | where Type =~ \"regkey\" | project IoC);\n(union isfuzzy=true\n(CommonSecurityLog\n| where DestinationHostName has_any (domains) or RequestURL has_any (domains) or Message has_any (domains)\n| parse Message with * '(' DNSName ')' *\n| project TimeGenerated, Message, SourceUserID, RequestURL, DestinationHostName, Type, SourceIP, DestinationIP, DNSName\n| extend  Alert = 'SOURGUM IOC detected'\n| extend timestamp = TimeGenerated, AccountCustomEntity = SourceUserID, UrlCustomEntity = RequestURL , IPCustomEntity = DestinationIP, DNSCustomEntity = DNSName\n),\n(DnsEvents\n| where Name in~ (domains)\n| project TimeGenerated, Computer, IPAddresses, Name, ClientIP, Type\n| extend DNSName = Name, Host = Computer , Alert = 'SOURGUM IOC detected'\n| extend timestamp = TimeGenerated, HostCustomEntity = Host, DNSCustomEntity = DNSName, IPCustomEntity = IPAddresses\n),\n(VMConnection\n| where  RemoteDnsCanonicalNames has_any (domains)\n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| project TimeGenerated, Computer, Direction, RemoteDnsCanonicalNames, ProcessName, SourceIp, DestinationIp, DestinationPort, DNSName,BytesSent, BytesReceived, RemoteCountry, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIp, HostCustomEntity = Computer, ProcessCustomEntity = ProcessName, DNSCustomEntity = DNSName, Alert = 'SOURGUM IOC detected'\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 3\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend SourceIP = tostring(EventDetail.[9].[\"#text\"]), DestinationIP = tostring(EventDetail.[14].[\"#text\"]), Image = EventDetail.[4].[\"#text\"]\n| where Image has_any (file_path1) or Image has_any (file_path3)\n| project TimeGenerated, SourceIP, DestinationIP, Image, UserName, Computer, EventDetail, Type\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), HostCustomEntity = Computer , IPCustomEntity = DestinationIP, Alert = 'SOURGUM IOC detected'\n),  \n(DeviceNetworkEvents\n| where (RemoteUrl has_any (domains))  or (InitiatingProcessSHA256 in (sha256Hashes) and InitiatingProcessFolderPath has_any (file_path1)) or InitiatingProcessFolderPath has_any (file_path3)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RemoteIP, RemoteUrl, LocalIP, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = DeviceName,  Alert = 'SOURGUM IOC detected', UrlCustomEntity =RemoteUrl\n),\n(AzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallDnsProxy\"\n| project TimeGenerated,Resource, msg_s, Type\n| parse msg_s with \"DNS Request: \" ClientIP \":\" ClientPort \" - \" QueryID \" \" Request_Type \" \" Request_Class \" \" Request_Name \". \" Request_Protocol \" \" Request_Size \" \" EDNSO_DO \" \" EDNS0_Buffersize \" \" Responce_Code \" \" Responce_Flags \" \" Responce_Size \" \" Response_Duration\n| where Request_Name has_any (domains)\n| extend timestamp = TimeGenerated, DNSName = Request_Name, IPCustomEntity = ClientIP, Alert = 'SOURGUM IOC detected'\n),\n(AzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| project TimeGenerated,Resource, msg_s\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where DestinationHost has_any (domains)  \n| extend timestamp = TimeGenerated, DNSName = DestinationHost, IPCustomEntity = SourceHost, Alert = 'SOURGUM IOC detected'\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| parse EventDetail with * 'SHA256=' SHA256 '\",' *\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"]\n| where (SHA256 has_any (sha256Hashes) and Image has_any (file_path1)) or (Image has_any (file_path3)) or ( CommandLine has_any (file_path3)) or ( CommandLine has_any (file_path1)) or ( CommandLine has 'reg add' and CommandLine has_any (reg_key) and CommandLine has_any (file_path2)) \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, SHA256, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source), Alert = 'SOURGUM IOC detected'\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = SHA256\n),\n(DeviceRegistryEvents\n| where RegistryKey has_any (reg_key) and RegistryValueData has_any (file_path2)\n|  project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type \n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  Alert = 'SOURGUM IOC detected'\n),\n(DeviceProcessEvents\n| where  ( InitiatingProcessCommandLine has_any (file_path1)) or ( InitiatingProcessCommandLine has_any (file_path3)) or ( InitiatingProcessCommandLine has 'reg add' and InitiatingProcessCommandLine has_any (reg_key) and InitiatingProcessCommandLine has_any (file_path2)) or (InitiatingProcessFolderPath has_any (file_path1)) or (InitiatingProcessFolderPath has_any (file_path3)) or (FolderPath  has_any (file_path1)) or (FolderPath has_any (file_path3))\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, FolderPath, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256, Alert = 'SOURGUM IOC detected'\n),\n(DeviceFileEvents\n| where  (InitiatingProcessSHA256 has_any (sha256Hashes) and InitiatingProcessFolderPath has_any (file_path1)) or (InitiatingProcessFolderPath has_any (file_path3)) or (FolderPath  has_any (file_path1)) or (FolderPath  has_any (file_path3)) or ( InitiatingProcessCommandLine has_any (file_path1)) or ( InitiatingProcessCommandLine has_any (file_path3))\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RequestAccountName, RequestSourceIP, InitiatingProcessSHA256, FolderPath, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = RequestAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  Alert = 'SOURGUM IOC detected'\n),\n(DeviceEvents\n| where  ( InitiatingProcessCommandLine has_any (file_path1)) or ( InitiatingProcessCommandLine has_any (file_path3)) or ( InitiatingProcessCommandLine has 'reg add' and InitiatingProcessCommandLine has_any (reg_key) and InitiatingProcessCommandLine has_any (file_path2)) or (InitiatingProcessFolderPath has_any (file_path1)) or (InitiatingProcessFolderPath has_any (file_path3)) or (FolderPath  has_any (file_path1)) or (FolderPath has_any (file_path3))\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, FolderPath, Type\n| extend CommandLine = InitiatingProcessCommandLine, Alert = 'SOURGUM IOC detected'\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256\n),\n(  SecurityEvent\n| where EventID == 4688\n| where ( CommandLine has_any (file_path1)) or ( CommandLine has_any (file_path3)) or ( CommandLine has 'reg add' and CommandLine has_any (reg_key) and CommandLine has_any (file_path2)) or (NewProcessName has_any (file_path1)) or (NewProcessName has_any (file_path3)) or (ParentProcessName has_any (file_path1)) or (ParentProcessName has_any (file_path3))\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName, Alert = 'SOURGUM IOC detected'\n)\n)\n", "attributes": {"description": "'Identifies a match across IOC's related to an actor tracked by Microsoft as SOURGUM'\n", "techniques": ["T1546"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/STRONTIUMJuly2019IOCs.yaml", "query_name": "Known STRONTIUM group domains - July 2019", "query": "let DomainNames = dynamic([\"irf.services\",\"microsoft-onthehub.com\",\"msofficelab.com\",\"com-mailbox.com\",\"my-sharefile.com\",\"my-sharepoints.com\",\n\"accounts-web-mail.com\",\"customer-certificate.com\",\"session-users-activities.com\",\"user-profile-credentials.com\",\"verify-linke.com\",\"support-servics.net\",\n\"onedrive-sharedfile.com\",\"onedrv-live.com\",\"transparencyinternational-my-sharepoint.com\",\"transparencyinternational-my-sharepoints.com\",\"soros-my-sharepoint.com\"]);\n(union isfuzzy=true\n  (CommonSecurityLog \n  | parse Message with * '(' DNSName ')' * \n  | extend Account = SourceUserID, Host = DeviceName, IPAddress = SourceIP\n  ),\n  (_Im_Dns(domain_has_any=DomainNames)\n  | extend IPAddress = SrcIpAddr, DNSName = DnsQuery, Host = Dvc),\n  (VMConnection \n  | parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n  | extend IPAddress = RemoteIp, Host = Computer\n  ),\n  (AzureDiagnostics \n  | where ResourceType == \"AZUREFIREWALLS\"\n  | where Category == \"AzureFirewallApplicationRule\"\n  | parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n  | extend DNSName = DestinationHost \n  | extend IPAddress = SourceHost\n  ),\n  (\n    _Im_WebSession(url_has_any=DomainNames)\n    | extend IPCustomEntity=IpAddr, HostCustomEntity=Hostname, AccoutCustomEntity=User\n  )\n)\n| where isnotempty(DNSName)\n| where DNSName  has_any (DomainNames)\n| extend timestamp = TimeGenerated, IPCustomEntity = IPAddress, AccountCustomEntity = Account, HostCustomEntity = Host\n", "attributes": {"description": "'Matches domain name IOCs related to Strontium group activity published July 2019 with CommonSecurityLog, DnsEvents and VMConnection dataTypes.\nReferences: https://blogs.microsoft.com/on-the-issues/2019/07/17/new-cyberthreats-require-new-ways-to-protect-democracy/.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/STRONTIUMOct292020IOCs.yaml", "query_name": "Possible STRONTIUM attempted credential harvesting - Oct 2020", "query": "let User_Agents = dynamic ([\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70\", \n\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.1 Safari/605.1.15\", \n\"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0\", \n\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36\", \n\"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36\"]);\nOfficeActivity\n| where RecordType in (\"AzureActiveDirectoryAccountLogon\", \"AzureActiveDirectoryStsLogon\") \n| where Operation != 'UserLoggedIn'\n| extend UserAgent = iff(parse_json(ExtendedProperties)[0].Name =~ \"UserAgent\", extractjson(\"$[0].Value\", ExtendedProperties, typeof(string)),\"\")\n| mv-expand parse_json(ExtendedProperties)\n| where ExtendedProperties.Name =~ \"RequestType\"\n| extend RequestType = todynamic(ExtendedProperties).Value\n| where UserAgent =~ \"ms-office\" or UserAgent has_any (User_Agents)\n| summarize authAttempts=dcount(TimeGenerated), firstAttempt=min(TimeGenerated), lastAttempt=max(TimeGenerated), uniqueIPs=dcount(ClientIP), uniqueAccounts=dcount(UserId), attemptedAccounts=make_set(UserId) by UserAgent\n| where authAttempts > 500\n| extend timestamp = firstAttempt\n| sort by uniqueAccounts\n", "attributes": {"description": "'Surfaces potential STRONTIUM group Office365 credential harvesting attempts within OfficeActivity Logon events.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/SUNSPOTLogFile.yaml", "query_name": "SUNSPOT log file creation", "query": "union isfuzzy=true\n(DeviceFileEvents\n| where FolderPath endswith \"vmware-vmdmp.log\"\n| extend HostCustomEntity = DeviceName, timestamp=TimeGenerated),\n(WindowsEvent\n| where EventID == 4663 and EventData has \"vmware-vmdmp.log\"\n| extend ObjectName = tostring(EventData.ObjectName) \n| where ObjectName endswith \"vmware-vmdmp.log\"\n| extend HostCustomEntity = Computer, timestamp=TimeGenerated),\n(SecurityEvent\n| where EventID == 4663\n| where ObjectName endswith \"vmware-vmdmp.log\"\n| extend HostCustomEntity = Computer, timestamp=TimeGenerated),\n(imFileEvent\n| where TargetFileName endswith \"vmware-vmdmp.log\"\n| extend HostCustomEntity = DvcHostname, timestamp=TimeGenerated\n)\n", "attributes": {"description": "'This query uses Microsoft Defender for Endpoint data and Windows Event Logs to look for IoCs associated with the SUNSPOT malware shared by Crowdstrike.\nMore details: \n  - https://www.crowdstrike.com/blog/sunspot-malware-technical-analysis/ \n  - https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-your-software-build-process-with-azure-sentinel/ba-p/2140807'\n", "techniques": ["T1554"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/SuspiciousLoginfromDeletedExternalIdentities.yaml", "query_name": "Suspicious Login from deleted guest account", "query": "let lookback = 1d;\nlet DeleteExtUsers = AuditLogs\n| where TimeGenerated > ago(lookback)\n| where Category =~ \"UserManagement\"\n| where OperationName =~ \"Delete external user\"\n| where Result =~ \"success\"\n| extend InviteInitiator = tostring(InitiatedBy.[\"user\"].[\"userPrincipalName\"])\n| extend Target = tostring(TargetResources[0].[\"displayName\"])\n| extend TargetUPN = tostring(extract(@\"UPN\\:\\s(.+)\\,\\sEmail\",1,Target)) , DeleteUserTime = TimeGenerated;\nDeleteExtUsers\n| join kind=inner (\nSigninLogs\n| where TimeGenerated > ago(lookback)\n| extend LoginTime = TimeGenerated\n) on $left.TargetUPN == $right.UserPrincipalName\n| where DeleteUserTime > LoginTime\n", "attributes": {"description": "' This query will detect logins from guest account which was recently deleted. \nFor any successful logins from deleted identities should be investigated further if any existing user accounts have been altered or linked to such identity prior deletion'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/SuspiciousModificationofGlobalAdminProperties.yaml", "query_name": "Suspicious modification of Global Administrator user properties", "query": "let lookback = 1d;\nlet GlobalAdmins = IdentityInfo\n| where TimeGenerated > ago(lookback)\n| extend IsGlobalAdmin = set_has_element(AssignedRoles, \"Global Administrator\")\n| where IsGlobalAdmin == true\n| distinct AccountUPN;\nGlobalAdmins\n| join kind=inner ( AuditLogs\n| where TimeGenerated > ago(lookback)\n| where OperationName=~ \"Update user\" \n| where Result =~ \"success\" \n| mv-expand TargetResources \n| mv-expand TargetResources.modifiedProperties \n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName) , oldValue_ = tostring(TargetResources_modifiedProperties.oldValue), newValue_ = tostring(TargetResources_modifiedProperties.newValue)\n| where displayName_ == \"UserPrincipalName\" and oldValue_ !has \"#EXT\" and newValue_ has \"#EXT\"\n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName) \n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) , IPAddress = tostring(InitiatedBy.[\"user\"].[\"ipAddress\"])\n) on $left.AccountUPN == $right.oldValue_\n| project TimeGenerated, AADTenantId, IPAddress, Initiator, displayName_, oldValue_, newValue_\n", "attributes": {"description": "' This query will detect if user properties of Global Administrator are updated by an existing user. Usually only user administrator or other global administrator can update such properties.\nInvestigate if such user change is an attempt to elevate an existing low privileged identity or rogue administrator activity'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/TarraskHashIoC.yaml", "query_name": "Tarrask malware IOC - April 2022", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Tarrask.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\n(union isfuzzy=true\n(CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated, Message, SourceUserID, FileHash, Type\n| extend timestamp = TimeGenerated, FileHashCustomEntity = 'SHA256', Account = SourceUserID\n),\n(imFileEvent\n| where TargetFileSHA256 has_any (sha256Hashes)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"], Hashes = tostring(EventDetail.[17].[\"#text\"])\n| extend Hashes = extract_all(@\"(?P<key>\\w+)=(?P<value>[a-zA-Z0-9]+)\", dynamic([\"key\",\"value\"]), Hashes)\n| extend Hashes = column_ifexists(\"Hashes\", \"\"), CommandLine = column_ifexists(\"CommandLine\", \"\")\n| where (Hashes has_any (sha256Hashes) )  \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, Hashes, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), FileHashCustomEntity = Hashes\n),\n(DeviceEvents\n| where InitiatingProcessSHA256 has_any (sha256Hashes) or SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceFileEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceImageLoadEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = InitiatingProcessSHA256,  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n)\n)\n", "attributes": {"description": "'Identifies a hash match related to Tarrask malware across various data sources.\n Reference: https://www.microsoft.com/security/blog/2022/04/12/tarrask-malware-uses-scheduled-tasks-for-defense-evasion/'\n", "techniques": ["T1053"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ThalliumIOCs.yaml", "query_name": "THALLIUM domains included in DCU takedown", "query": "let DomainNames = dynamic([\"seoulhobi.biz\", \"reader.cash\", \"pieceview.club\", \"app-wallet.com\", \"bigwnet.com\", \"bitwoll.com\", \"cexrout.com\", \"change-pw.com\", \"checkprofie.com\", \"cloudwebappservice.com\", \"ctquast.com\", \"dataviewering.com\", \"day-post.com\", \"dialy-post.com\", \"documentviewingcom.com\", \"dovvn-mail.com\", \"down-error.com\", \"drivecheckingcom.com\", \"drog-service.com\", \"encodingmail.com\", \"filinvestment.com\", \"foldershareing.com\", \"golangapis.com\", \"hotrnall.com\", \"lh-logins.com\", \"login-use.com\", \"mail-down.com\", \"matmiho.com\", \"mihomat.com\", \"natwpersonal-online.com\", \"nidlogin.com\", \"nid-login.com\", \"nidlogon.com\", \"pw-change.com\", \"rnaii.com\", \"rnailm.com\", \"sec-live.com\", \"secrityprocessing.com\", \"securitedmode.com\", \"securytingmail.com\", \"set-login.com\", \"usrchecking.com\", \"com-serviceround.info\", \"mai1.info\", \"reviewer.mobi\", \"files-download.net\", \"fixcool.net\", \"hanrnaii.net\", \"office356-us.org\", \"smtper.org\"]);\n(union isfuzzy=true\n(CommonSecurityLog \n| parse Message with * '(' DNSName ')' * \n| where isnotempty(FileHash)\n| where DNSName in~ (DomainNames)\n| extend Account = SourceUserID, Computer = DeviceName, IPAddress = SourceIP\n),\n(_Im_Dns (domain_has_any=DomainNames)\n| extend DNSName = DnsQuery\n| extend IPAddress = SrcIpAddr\n),\n(VMConnection \n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| where isnotempty(DNSName)\n| where DNSName  in~ (DomainNames)\n| extend IPAddress = RemoteIp\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (DomainNames)  \n| extend DNSName = DestinationHost \n| extend IPAddress = SourceHost \n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress \n", "attributes": {"description": "'THALLIUM spearphishing and command and control domains included in December 2019 DCU/MSTIC takedown. \n Matches domain name IOCs related to the THALLIUM activity group with CommonSecurityLog, DnsEvents, VMConnection and SecurityEvents dataTypes.\n References: https://blogs.microsoft.com/on-the-issues/2019/12/30/microsoft-court-action-against-nation-state-cybercrime/ '\n", "techniques": NaN, "tactics": ["CommandAndControl", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/TimeSeriesAnomaly-MultiVendor_DataExfiltration.yaml", "query_name": "Time series anomaly for data size transferred to public internet", "query": "\nlet starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet scorethreshold = 5;\nlet bytessentperhourthreshold = 10;\nlet TimeSeriesData = (union isfuzzy=true\n(\nVMConnection\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where isnotempty(DestinationIp) and isnotempty(SourceIp)\n| extend SourceIP = SourceIp, DestinationIP = DestinationIp\n| where ipv4_is_private(DestinationIP) == false\n| extend DeviceVendor = \"VMConnection\"\n| project TimeGenerated, BytesSent, DeviceVendor\n| make-series TotalBytesSent=sum(BytesSent) on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by DeviceVendor\n),\n(\nCommonSecurityLog\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where isnotempty(DestinationIP) and isnotempty(SourceIP)\n| where ipv4_is_private(DestinationIP) == false\n| project TimeGenerated, SentBytes, DeviceVendor\n| make-series TotalBytesSent=sum(SentBytes) on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by DeviceVendor\n)\n);\n//Filter anomolies against TimeSeriesData\nlet TimeSeriesAlerts = materialize(TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(TotalBytesSent, scorethreshold, -1, 'linefit')\n| mv-expand TotalBytesSent to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)\n| where anomalies > 0 | extend AnomalyHour = TimeGenerated\n| extend TotalBytesSentinMBperHour = round(((TotalBytesSent / 1024)/1024),2), baselinebytessentperHour = round(((baseline / 1024)/1024),2), score = round(score,2)\n| project DeviceVendor, AnomalyHour, TimeGenerated, TotalBytesSentinMBperHour, baselinebytessentperHour, anomalies, score);\nlet AnomalyHours = materialize(TimeSeriesAlerts  | where TimeGenerated > ago(2d) | project TimeGenerated);\n//Union of all BaseLogs aggregated per hour\nlet BaseLogs = (union isfuzzy=true\n(\nCommonSecurityLog\n| where isnotempty(DestinationIP) and isnotempty(SourceIP)\n| where TimeGenerated > ago(2d)\n| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour\n| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours\n| where ipv4_is_private(DestinationIP) == false\n| extend SentBytesinMB = ((SentBytes / 1024)/1024), ReceivedBytesinMB = ((ReceivedBytes / 1024)/1024)\n| summarize HourlyCount = count(), TimeGeneratedMax=arg_max(TimeGenerated, *), DestinationIPList=make_set(DestinationIP, 100), DestinationPortList = make_set(DestinationPort,100), TotalSentBytesinMB = sum(SentBytesinMB), TotalReceivedBytesinMB = sum(ReceivedBytesinMB) by SourceIP, DeviceVendor, TimeGeneratedHour=bin(TimeGenerated,1h)\n| where TotalSentBytesinMB > bytessentperhourthreshold\n| sort by TimeGeneratedHour asc, TotalSentBytesinMB desc\n| extend Rank=row_number(1, prev(TimeGeneratedHour) != TimeGeneratedHour) // Ranking the dataset per Hourly Partition\n| where Rank < 10  // Selecting Top 10 records with Highest BytesSent in each Hour\n| project DeviceVendor, TimeGeneratedHour, TimeGeneratedMax, SourceIP, DestinationIPList, DestinationPortList, TotalSentBytesinMB, TotalReceivedBytesinMB, Rank\n),\n(\nVMConnection\n| where isnotempty(DestinationIp) and isnotempty(SourceIp)\n| where TimeGenerated > ago(2d)\n| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour\n| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours\n| extend SourceIP = SourceIp, DestinationIP = DestinationIp\n| where ipv4_is_private(DestinationIP) == false | extend DeviceVendor = \"VMConnection\"\n| extend SentBytesinMB = ((BytesSent / 1024)/1024), ReceivedBytesinMB = ((BytesReceived / 1024)/1024)\n| summarize HourlyCount = count(),TimeGeneratedMax=arg_max(TimeGenerated, *), DestinationIPList=make_set(DestinationIP, 100), DestinationPortList = make_set(DestinationPort, 100), TotalSentBytesinMB = sum(SentBytesinMB),TotalReceivedBytesinMB = sum(ReceivedBytesinMB) by SourceIP, DeviceVendor, TimeGeneratedHour=bin(TimeGenerated,1h)\n| where TotalSentBytesinMB > bytessentperhourthreshold\n| sort by TimeGeneratedHour asc, TotalSentBytesinMB desc\n| extend Rank=row_number(1, prev(TimeGeneratedHour) != TimeGeneratedHour) // Ranking the dataset per Hourly Partition\n| where Rank < 10  // Selecting Top 10 records with Highest BytesSent in each Hour\n| project DeviceVendor, TimeGeneratedHour, TimeGeneratedMax, SourceIP, DestinationIPList, DestinationPortList, TotalSentBytesinMB, TotalReceivedBytesinMB, Rank\n)\n);\n// Join against base logs to retrive records associated with the hour of anomoly\nTimeSeriesAlerts\n| where TimeGenerated > ago(2d)\n| join (\n    BaseLogs | extend AnomalyHour = TimeGeneratedHour\n) on DeviceVendor, AnomalyHour | sort by score desc\n| project DeviceVendor, AnomalyHour,TimeGeneratedMax, SourceIP, DestinationIPList, DestinationPortList, TotalSentBytesinMB, TotalReceivedBytesinMB, TotalBytesSentinMBperHour, baselinebytessentperHour, score, anomalies\n| summarize EventCount = count(), StartTimeUtc= min(TimeGeneratedMax), EndTimeUtc= max(TimeGeneratedMax), SourceIPMax= arg_max(SourceIP,*), TotalBytesSentinMB = sum(TotalSentBytesinMB), TotalBytesReceivedinMB = sum(TotalReceivedBytesinMB), SourceIPList = make_set(SourceIP, 100), DestinationIPList = make_set(DestinationIPList, 100) by AnomalyHour,TotalBytesSentinMBperHour, baselinebytessentperHour, score, anomalies\n| project DeviceVendor, AnomalyHour, StartTimeUtc, EndTimeUtc, SourceIPMax, SourceIPList, DestinationIPList, DestinationPortList, TotalBytesSentinMB, TotalBytesReceivedinMB, TotalBytesSentinMBperHour, baselinebytessentperHour, score, anomalies, EventCount\n| extend timestamp =EndTimeUtc, IPCustomEntity = SourceIPMax\n", "attributes": {"description": "'Identifies anomalous data transfer to public networks. The query leverages built-in KQL anomaly detection algorithms that detects large deviations from a baseline pattern.\nA sudden increase in data transferred to unknown public networks is an indication of data exfiltration attempts and should be investigated.\nThe higher the score, the further it is from the baseline value.\nThe output is aggregated to provide summary view of unique source IP to destination IP address and port bytes sent traffic observed in the flagged anomaly hour.\nThe source IP addresses which were sending less than bytessentperhourthreshold have been exluded whose value can be adjusted as needed .\nYou may have to run queries for individual source IP addresses from SourceIPlist to determine if anything looks suspicious'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/WSLMalwareCorrelation.yaml", "query_name": "Alert for  IOCs related to Windows/ELF malware - IP, Hash IOCs - September 2021", "query": "let IPList = dynamic([\"185.63.90.137\"]);  \nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\nlet sha256Hashes = \ndynamic([\"53854c6d163bfd0c56d8b297ac43bd25c21f696de6063031241e792ee65df441\",\n\"c297e545b8f150cc5ff56dbb68dc74fe30a421d9d40f38f4a53083192697c44c\",\n\"17921368901f23e0cad0d2fe4ce5694aebaf4727699ed0358117500701914d1b\",\n\"198a2d42df010d838b4207f478d885ef36e3db13b1744d673e221b828c28bf77\",\n\"71d7b48c2fdc7b57b104a7858a35165bbed21d2fa7e34828d6c1d50b2b33a1d0\",\n\"601227d52c6e367e11b80240183d07d38bc11a88e844e8401fce17eb25e92ba8\",\n\"63ff04bed4fdb120a9cb9b1ea7fd88e83f12fb01ab6a057088f8016e663b48d4\",\n\"a3037c3389b811bc1404f719af5c8b9034c5e24710cf3a0b457d28bf1b922cf7\",\n\"e19b8be1b21c066d60725e550f8455f824065abbf1b43f7b2fe4fb338b241ffc\",\n\"a3037c3389b811bc1404f719af5c8b9034c5e24710cf3a0b457d28bf1b922cf7\"\n]);\n(union isfuzzy=true\n(CommonSecurityLog\n| where SourceIP in (IPList) or DestinationIP in (IPList) or Message has_any (IPList) \n| project TimeGenerated, SourceIP, DestinationIP, Message, SourceUserID, RequestURL\n| extend MessageIP = extract(IPRegex, 0, Message)\n| extend IPMatch = case(SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", MessageIP in (IPList), \"Message\", MessageIP in (IPList), \"Message\", \"NoMatch\")\n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, IPMatch == \"Message\", MessageIP, \"NoMatch\"), AccountCustomEntity = SourceUserID\n),\n(DeviceNetworkEvents\n| where  RemoteIP in (IPList) or InitiatingProcessSHA256 in (sha256Hashes) \n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RemoteIP, RemoteUrl, RemotePort, LocalIP\n| extend timestamp = TimeGenerated, DNSName = RemoteUrl, IPCustomEntity = RemoteIP, HostCustomEntity = DeviceName\n),\n(WindowsFirewall\n| where SourceIP in (IPList) or DestinationIP in (IPList) \n| project TimeGenerated, Computer, CommunicationDirection, SourceIP, DestinationIP, SourcePort, DestinationPort\n| extend IPMatch = case( SourceIP in (IPList), \"SourceIP\", DestinationIP in (IPList), \"DestinationIP\", \"None\")\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| project TimeGenerated,Resource, msg_s\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost) \n| where SourceHost in (IPList) or DestinationHost in (IPList)\n| extend timestamp = TimeGenerated, DNSName = DestinationHost, IPCustomEntity = SourceHost\n),\n(DeviceFileEvents\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, RequestAccountName, RequestSourceIP, InitiatingProcessSHA256\n| extend Account = RequestAccountName, Computer = DeviceName, IPAddress = RequestSourceIP, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n| where FileHash in (sha256Hashes)\n),\n(CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated,  Message, SourceUserID, FileHash\n| extend timestamp = TimeGenerated, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(DeviceEvents\n| where   InitiatingProcessSHA256 in~ (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256\n| extend Account = InitiatingProcessAccountName, Computer = DeviceName, CommandLine = InitiatingProcessCommandLine, FileHash = InitiatingProcessSHA256, Image = InitiatingProcessFolderPath\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = FileHash\n),\n(SecurityEvent\n| where EventID == '4688'\n| where CommandLine has_any (IPList) \n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n),\n(WindowsEvent\n| where EventID == '4688' and  has_any_ipv4(EventData, toscalar(IPList)) \n| extend NewProcessName = tostring(EventData.NewProcessName)\n| where NewProcessName  in (IPList) \n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| extend Account =  strcat(EventData.SubjectDomainName,\"\\\\\", EventData.SubjectUserName)\n| extend NewProcessId = tostring(EventData.NewProcessId)\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n)\n)\n", "attributes": {"description": "'Identifies a match across various data feeds for IP,hashes and IOCs related to Windows/ELF malware published by Black Lotus Labs\nReference: \nhttps://blog.lumen.com/no-longer-just-theory-black-lotus-labs-uncovers-linux-executables-deployed-as-stealth-windows-loaders\nhttps://github.com/ManuelBerrueta/YARA-rules/blob/master/BlackLotusLabs-WSLMalware/BLL_SneakyWSL.yar'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ZincJan272021IOCs.yaml", "query_name": "Known ZINC Comebacker and Klackring malware hashes", "query": "let tokens = dynamic([\"SSL_HandShaking\", \"ASN2_TYPE_new\", \"sql_blob_open\", \"cmsSetLogHandlerTHR\", \"ntSystemInfo\", \"SetWebFilterString\", \"CleanupBrokerString\", \"glInitSampler\", \"deflateSuffix\", \"ntWindowsProc\"]);\nlet DomainNames = dynamic(['codevexillium.org', 'angeldonationblog.com', 'investbooking.de', 'krakenfolio.com']);\nlet SHA256Hash = dynamic(['58a74dceb2022cd8a358b92acd1b48a5e01c524c3b0195d7033e4bd55eff4495','e0e59bfc22876c170af65dcbf19f744ae560cc43b720b23b9d248f4505c02f3e','3d3195697521973efe0097a320cbce0f0f98d29d50e044f4505e1fbc043e8cf9', '0a2d81164d524be7022ba8fd4e1e8e01bfd65407148569d172e2171b5cd76cd4', '96d7a93f6691303d39a9cc270b8814151dfec5683e12094537fd580afdf2e5fe','dc4cf164635db06b2a0b62d313dbd186350bca6fc88438617411a68df13ec83c', '46efd5179e43c9cbf07dcec22ce0d5527e2402655aee3afc016e5c260650284a', '95e42a94d4df1e7e472998f43b9879eb34aaa93f3705d7d3ef9e3b97349d7008', '9d5320e883264a80ea214077f44b1d4b22155446ad5083f4b27d2ab5bd127ef5', '9fd05063ad203581a126232ac68027ca731290d17bd43b5d3311e8153c893fe3', 'ada7e80c9d09f3efb39b729af238fcdf375383caaf0e9e0aed303931dc73b720', 'edb1597789c7ed784b85367a36440bf05267ac786efe5a4044ec23e490864cee', '33665ce1157ddb7cd7e905e3356b39245dfba17b7a658bdbf02b6968656b9998', '3ab770458577eb72bd6239fe97c35e7eb8816bce5a4b47da7bd0382622854f7c', 'b630ad8ffa11003693ce8431d2f1c6b8b126cd32b657a4bfa9c0dbe70b007d6c', '53f3e55c1217dafb8801af7087e7d68b605e2b6dde6368fceea14496c8a9f3e5', '99c95b5272c5b11093eed3ef2272e304b7a9311a22ff78caeb91632211fcb777', 'f21abadef52b4dbd01ad330efb28ef50f8205f57916a26daf5de02249c0f24ef', '2cbdea62e26d06080d114bbd922d6368807d7c6b950b1421d0aa030eca7e85da', '079659fac6bd9a1ce28384e7e3a465be4380acade3b4a4a4f0e67fd0260e9447']);\nlet SigNames = dynamic([\"Backdoor:Script/ComebackerCompile.A!dha\", \"Trojan:Win64/Comebacker.A!dha\", \"Trojan:Win64/Comebacker.A.gen!dha\", \"Trojan:Win64/Comebacker.B.gen!dha\", \"Trojan:Win32/Comebacker.C.gen!dha\", \"Trojan:Win32/Klackring.A!dha\", \"Trojan:Win32/Klackring.B!dha\"]);\n(union isfuzzy=true\n(CommonSecurityLog\n| parse Message with * '(' DNSName ')' * \n| where isnotempty(FileHash)\n| where FileHash in~ (SHA256Hash) or DNSName in~ (DomainNames)\n| extend Account = SourceUserID, Computer = DeviceName, IPAddress = SourceIP\n| project Type, TimeGenerated, Computer, Account, IPAddress, FileHash, DNSName\n),\n(_Im_Dns(domain_has_any=DomainNames)\n| extend DNSName = DnsQuery\n| extend Type = \"imDns\", IPAddress = SrcIpAddr, Computer=Dvc\n| project Type, TimeGenerated, Computer, IPAddress, DNSName\n),\n(VMConnection\n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| where isnotempty(DNSName)\n| where DNSName  in~ (DomainNames)\n| extend IPAddress = RemoteIp\n| project Type, TimeGenerated, Computer, IPAddress, DNSName\n),\n(Event\n//This query uses sysmon data depending on table name used this may need updataing\n| where Source == \"Microsoft-Windows-Sysmon\"\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Hashes = EventDetail.[16].[\"#text\"]\n| where isnotempty(Hashes)\n| parse Hashes with * 'SHA256=' SHA256 ',' * \n| where SHA256 in~ (SHA256Hash) \n| extend Type = strcat(Type, \": \", Source), Account = UserName, FileHash = Hashes\n| project Type, TimeGenerated, Computer, Account, FileHash\n),\n(DeviceFileEvents\n| where SHA256 in~ (SHA256Hash)\n| extend Account = RequestAccountName, Computer = DeviceName, IPAddress = RequestSourceIP, CommandLine = InitiatingProcessCommandLine, FileHash = SHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(imFileEvent\n| where TargetFileSHA256 in~ (SHA256Hash)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(DeviceNetworkEvents\n| where RemoteUrl in~ (DomainNames)\n| extend Computer = DeviceName, IPAddress = LocalIP, Account = InitiatingProcessAccountName\n| project Type, TimeGenerated, Computer, Account, IPAddress, RemoteUrl\n),\n(SecurityAlert\n| where ProductName == \"Microsoft Defender Advanced Threat Protection\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| where isnotempty(ThreatName)\n| where ThreatName has_any (SigNames)\n| extend Computer = tostring(parse_json(Entities)[0].HostName) \n| project Type, TimeGenerated, Computer\n),\n(DeviceProcessEvents\n| where FileName =~ \"powershell.exe\" or FileName =~ \"rundll32.exe\"\n| where (ProcessCommandLine has \"is64bitoperatingsystem\" and ProcessCommandLine has \"Debug\\\\Browse\") or (ProcessCommandLine has_any (tokens))\n| extend Computer = DeviceName, Account = AccountName, CommandLine = ProcessCommandLine\n| project Type, TimeGenerated, Computer, Account, CommandLine, FileName\n),\n(SecurityEvent\n| where EventID == 4688\n| where ProcessName has_any (\"powershell.exe\", \"rundll32.exe\")\n| where (CommandLine has \"is64bitoperatingsystem\" and CommandLine has \"Debug\\\\Browse\") or (CommandLine has_any (tokens))\n| project Type, TimeGenerated, Computer, Account, ProcessName, CommandLine \n),\n( WindowsEvent\n| where EventID == 4688\n| where EventData has_any (\"powershell.exe\", \"rundll32.exe\") and EventData has_any (tokens, \"Debug\\\\Browse\",\"is64bitoperatingsystem\" ) \n| extend  ProcessName = tostring(EventData.ProcessName)\n| where ProcessName has_any (\"powershell.exe\", \"rundll32.exe\")\n| extend CommandLine = tostring(EventData.CommandLine)  \n| where (CommandLine has \"is64bitoperatingsystem\" and CommandLine has \"Debug\\\\Browse\") or (CommandLine has_any (tokens))\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| project Type, TimeGenerated, Computer, Account, ProcessName, CommandLine \n),\n(AzureDiagnostics \n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category == \"AzureFirewallApplicationRule\"\n| parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action\n| where isnotempty(DestinationHost)\n| where DestinationHost has_any (DomainNames)  \n| extend DNSName = DestinationHost \n| extend IPAddress = SourceHost\n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress\n", "attributes": {"description": "'ZINC attacks against security researcher campaign malware hashes.'\n", "techniques": ["T1071.001", "T1204"], "tactics": ["CommandAndControl", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/MultipleDataSources/ZincOct292020IOCs.yaml", "query_name": "Known ZINC related maldoc hash", "query": "let SHA256Hash = \"1174fd03271f80f5e2a6435c72bdd0272a6e3a37049f6190abf125b216a83471\" ;\n(union isfuzzy=true\n(CommonSecurityLog \n| parse Message with * '(' DNSName ')' * \n| where isnotempty(FileHash)\n| where FileHash in (SHA256Hash) \n| extend Account = SourceUserID, Computer = DeviceName, IPAddress = SourceIP\n),\n(Event\n//This query uses sysmon data depending on table name used this may need updataing\n| where Source == \"Microsoft-Windows-Sysmon\"\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Hashes = EventDetail.[16].[\"#text\"]\n| parse Hashes with * 'SHA256=' SHA265 ',' * \n| where isnotempty(Hashes)\n| where Hashes in (SHA256Hash) \n| extend Account = UserName\n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Document hash used by ZINC in highly targeted spear phishing campaign.'\n", "techniques": NaN, "tactics": ["CommandAndControl", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/exchange_auditlogdisabled.yaml", "query_name": "Exchange AuditLog disabled", "query": "\nOfficeActivity\n| where UserType in~ (\"Admin\",\"DcAdmin\") \n// Only admin or global-admin can disable audit logging\n| where Operation =~ \"Set-AdminAuditLogConfig\" \n| extend AdminAuditLogEnabledValue = tostring(parse_json(tostring(parse_json(tostring(array_slice(parse_json(Parameters),3,3)))[0])).Value)\n| where AdminAuditLogEnabledValue =~ \"False\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() by Operation, UserType, UserId, ClientIP, ResultStatus, Parameters, AdminAuditLogEnabledValue\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP \n", "attributes": {"description": "'Identifies when the exchange audit logging has been disabled which may be an adversary attempt\nto evade detection or avoid other defenses.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/External%20User%20added%20to%20Team%20and%20immediately%20uploads%20file.yaml", "query_name": "Accessed files shared by temporary external user", "query": "let fileAccessThrehold = 10;\nOfficeActivity\n | where OfficeWorkload =~ \"MicrosoftTeams\"\n | where Operation =~ \"MemberAdded\"\n | extend UPN = tostring(parse_json(Members)[0].UPN)\n | where UPN contains (\"#EXT#\")\n | project TimeAdded=TimeGenerated, Operation, UPN, UserWhoAdded = UserId, TeamName\n | join kind = inner(\n                       OfficeActivity\n                       | where OfficeWorkload =~ \"MicrosoftTeams\"\n                       | where Operation =~ \"MemberRemoved\"\n                       | extend UPN = tostring(parse_json(Members)[0].UPN)\n                       | where UPN contains (\"#EXT#\")\n                       | project TimeDeleted=TimeGenerated, Operation, UPN, UserWhoDeleted = UserId, TeamName\n                     ) on UPN\n | where TimeDeleted > TimeAdded\n | join kind=inner \n                   (\n                   OfficeActivity\n                   | where RecordType == \"SharePointFileOperation\"\n                   | where SourceRelativeUrl has \"Microsoft Teams Chat Files\"\n                   | where Operation == \"FileUploaded\"\n                   | join kind = inner \n                                       (\n                                       OfficeActivity\n                                       | where RecordType == \"SharePointFileOperation\"\n                                       | where Operation  == \"FileAccessed\"\n                                       | where SourceRelativeUrl has \"Microsoft Teams Chat Files\"\n                                       | summarize FileAccessCount = count() by OfficeObjectId\n                                       | where FileAccessCount > fileAccessThrehold\n                                       ) on $left.OfficeObjectId == $right.OfficeObjectId\n                   )on $left.UPN == $right.UserId\n | extend timestamp=TimeGenerated, AccountCustomEntity = UserWhoAdded \n", "attributes": {"description": "'This detection identifies an external user is added to a Team or Teams chat\nand shares a files which is accessed by many users (>10) and the users is removed within short period of time. This might be\nan indicator of suspicious activity.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/ExternalUserAddedRemovedInTeams.yaml", "query_name": "External user added and removed in short timeframe", "query": "let TeamsAddDel = (Op:string){\nOfficeActivity\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n| where Operation == Op\n| where Members has (\"#EXT#\")\n| mv-expand Members\n| extend UPN = tostring(Members.UPN)\n| where UPN has (\"#EXT#\")\n| project TimeGenerated, Operation, UPN, UserId, TeamName\n};\nlet TeamsAdd = TeamsAddDel(\"MemberAdded\")\n| project TimeAdded=TimeGenerated, Operation, UPN, UserWhoAdded = UserId, TeamName;\nlet TeamsDel = TeamsAddDel(\"MemberRemoved\")\n| project TimeDeleted=TimeGenerated, Operation, UPN, UserWhoDeleted = UserId, TeamName;\nTeamsAdd\n| join kind=inner (TeamsDel) on UPN\n| where TimeDeleted > TimeAdded\n| project TimeAdded, TimeDeleted, UPN, UserWhoAdded, UserWhoDeleted, TeamName\n", "attributes": {"description": "'This detection flags the occurances of external user accounts that are added to a Team and then removed within\none hour.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/MailItemsAccessedTimeSeries.yaml", "query_name": "Exchange workflow MailItemsAccessed operation anomaly", "query": "\nlet starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet scorethreshold = 1.5;\nlet percentthreshold = 50;\n// Preparing the time series data aggregated hourly count of MailItemsAccessd Operation in the form of multi-value array to use with time series anomaly function.\nlet TimeSeriesData =\nOfficeActivity\n| where TimeGenerated  between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where OfficeWorkload=~ \"Exchange\" and Operation =~ \"MailItemsAccessed\" and ResultStatus =~ \"Succeeded\"\n| project TimeGenerated, Operation, MailboxOwnerUPN\n| make-series Total=count() on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe;\nlet TimeSeriesAlerts = TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, scorethreshold, -1, 'linefit')\n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n| where anomalies > 0\n| project TimeGenerated, Total, baseline, anomalies, score;\n// Joining the flagged outlier from the previous step with the original dataset to present contextual information\n// during the anomalyhour to analysts to conduct investigation or informed decisions.\nTimeSeriesAlerts | where TimeGenerated > ago(2d)\n// Join against base logs since specified timeframe to retrive records associated with the hour of anomoly\n| join (\n    OfficeActivity\n    | where TimeGenerated > ago(2d)\n    | extend DateHour = bin(TimeGenerated, 1h)\n    | where OfficeWorkload=~ \"Exchange\" and Operation =~ \"MailItemsAccessed\" and ResultStatus =~ \"Succeeded\"\n    | summarize HourlyCount=count(), TimeGeneratedMax = arg_max(TimeGenerated, *), IPAdressList = make_set(Client_IPAddress), SourceIPMax= arg_max(Client_IPAddress, *), ClientInfoStringList= make_set(ClientInfoString) by MailboxOwnerUPN, Logon_Type, TenantId, UserType, TimeGenerated = bin(TimeGenerated, 1h) \n    | where HourlyCount > 25 // Only considering operations with more than 25 hourly count to reduce False Positivies\n    | order by HourlyCount desc \n) on TimeGenerated\n| extend PercentofTotal = round(HourlyCount/Total, 2) * 100 \n| where PercentofTotal > percentthreshold // Filter Users with count of less than 5 percent of TotalEvents per Hour to remove FPs/ users with very low count of MailItemsAccessed events\n| order by PercentofTotal desc \n| project-reorder TimeGeneratedMax, Type, OfficeWorkload, Operation, UserId,SourceIPMax ,IPAdressList, ClientInfoStringList, HourlyCount, PercentofTotal, Total, baseline, score, anomalies\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId\n", "attributes": {"description": "'Identifies anomalous increases in Exchange mail items accessed operations.\nThe query leverages KQL built-in anomaly detection algorithms to find large deviations from baseline patterns.\nSudden increases in execution frequency of sensitive actions should be further investigated for malicious activity.\nManually change scorethreshold from 1.5 to 3 or higher to reduce the noise based on outliers flagged from the query criteria.\nRead more about MailItemsAccessed- https://docs.microsoft.com/microsoft-365/compliance/advanced-audit?view=o365-worldwide#mailitemsaccessed'\n", "techniques": ["T1114"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/Mail_redirect_via_ExO_transport_rule.yaml", "query_name": "Mail redirect via ExO transport rule", "query": "OfficeActivity\n| where OfficeWorkload == \"Exchange\"\n| where Operation in~ (\"New-TransportRule\", \"Set-TransportRule\")\n| mv-apply DynamicParameters = todynamic(Parameters) on (summarize ParsedParameters = make_bag(pack(tostring(DynamicParameters.Name), DynamicParameters.Value)))\n| extend RuleName = case(\n    Operation =~ \"Set-TransportRule\", OfficeObjectId,\n    Operation =~ \"New-TransportRule\", ParsedParameters.Name,\n    \"Unknown\")\n| mv-expand ExpandedParameters = todynamic(Parameters)\n| where ExpandedParameters.Name in~ (\"BlindCopyTo\", \"RedirectMessageTo\") and isnotempty(ExpandedParameters.Value)\n| extend RedirectTo = ExpandedParameters.Value\n| extend ClientIPValues = extract_all(@'\\[?(::ffff:)?(?P<IPAddress>(\\d+\\.\\d+\\.\\d+\\.\\d+)|[^\\]]+)\\]?([-:](?P<Port>\\d+))?', dynamic([\"IPAddress\", \"Port\"]), ClientIP)[0]\n| project TimeGenerated, RedirectTo, IPAddress = tostring(ClientIPValues[0]), Port = tostring(ClientIPValues[1]), UserId, Operation, RuleName, Parameters\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = IPAddress\n    \n", "attributes": {"description": "'Identifies when Exchange Online transport rule configured to forward emails.\nThis could be an adversary mailbox configured to collect mail from multiple user accounts.'\n", "techniques": ["T1114", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/Malicious_Inbox_Rule.yaml", "query_name": "Malicious Inbox Rule", "query": "\nlet Keywords = dynamic([\"helpdesk\", \" alert\", \" suspicious\", \"fake\", \"malicious\", \"phishing\", \"spam\", \"do not click\", \"do not open\", \"hijacked\", \"Fatal\"]);\nOfficeActivity\n| where Operation =~ \"New-InboxRule\"\n| where Parameters has \"Deleted Items\" or Parameters has \"Junk Email\"  or Parameters has \"DeleteMessage\"\n| extend Events=todynamic(Parameters)\n| parse Events  with * \"SubjectContainsWords\" SubjectContainsWords '}'*\n| parse Events  with * \"BodyContainsWords\" BodyContainsWords '}'*\n| parse Events  with * \"SubjectOrBodyContainsWords\" SubjectOrBodyContainsWords '}'*\n| where SubjectContainsWords has_any (Keywords)\n or BodyContainsWords has_any (Keywords)\n or SubjectOrBodyContainsWords has_any (Keywords)\n| extend ClientIPAddress = case( ClientIP has \".\", tostring(split(ClientIP,\":\")[0]), ClientIP has \"[\", tostring(trim_start(@'[[]',tostring(split(ClientIP,\"]\")[0]))), ClientIP )\n| extend Keyword = iff(isnotempty(SubjectContainsWords), SubjectContainsWords, (iff(isnotempty(BodyContainsWords),BodyContainsWords,SubjectOrBodyContainsWords )))\n| extend RuleDetail = case(OfficeObjectId contains '/' , tostring(split(OfficeObjectId, '/')[-1]) , tostring(split(OfficeObjectId, '\\\\')[-1]))\n| summarize count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by  Operation, UserId, ClientIPAddress, ResultStatus, Keyword, OriginatingServer, OfficeObjectId, RuleDetail\n| extend timestamp = StartTimeUtc,  IPCustomEntity = ClientIPAddress, AccountCustomEntity = UserId , HostCustomEntity =  OriginatingServer\n", "attributes": {"description": "'Often times after the initial compromise the attackers create inbox rules to delete emails that contain certain keywords. \n This is done so as to limit ability to warn compromised users that they've been compromised. Below is a sample query that tries to detect this.\nReference: https://www.reddit.com/r/sysadmin/comments/7kyp0a/recent_phishing_attempts_my_experience_and_what/'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/MultipleTeamsDeletes.yaml", "query_name": "Multiple Teams deleted by a single user", "query": "\n// Adjust this value to change how many Teams should be deleted before including\nlet max_delete_count = 3;\n// Adjust this value to change the timewindow the query runs over\n  OfficeActivity\n| where OfficeWorkload =~ \"MicrosoftTeams\" \n| where Operation =~ \"TeamDeleted\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), DeletedTeams = make_set(TeamName) by UserId\n| where array_length(DeletedTeams) > max_delete_count\n| extend timestamp = StartTime, AccountCustomEntity = UserId\n", "attributes": {"description": "'This detection flags the occurrences of deleting multiple teams within an hour.\nThis data is a part of Office 365 Connector in Microsoft Sentinel.'\n", "techniques": ["T1485", "T1489"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/NRT_Malicious_Inbox_Rule.yaml", "query_name": "NRT Malicious Inbox Rule", "query": "let Keywords = dynamic([\"helpdesk\", \" alert\", \" suspicious\", \"fake\", \"malicious\", \"phishing\", \"spam\", \"do not click\", \"do not open\", \"hijacked\", \"Fatal\"]);\nOfficeActivity\n| where OfficeWorkload =~ \"Exchange\"\n| where Parameters has \"Deleted Items\" or Parameters has \"Junk Email\"  or Parameters has \"DeleteMessage\"\n| extend Events=todynamic(Parameters)\n| parse Events  with * \"SubjectContainsWords\" SubjectContainsWords '}'*\n| parse Events  with * \"BodyContainsWords\" BodyContainsWords '}'*\n| parse Events  with * \"SubjectOrBodyContainsWords\" SubjectOrBodyContainsWords '}'*\n| where SubjectContainsWords has_any (Keywords)\n or BodyContainsWords has_any (Keywords)\n or SubjectOrBodyContainsWords has_any (Keywords)\n| extend ClientIPAddress = case( ClientIP has \".\", tostring(split(ClientIP,\":\")[0]), ClientIP has \"[\", tostring(trim_start(@'[[]',tostring(split(ClientIP,\"]\")[0]))), ClientIP )\n| extend Keyword = iff(isnotempty(SubjectContainsWords), SubjectContainsWords, (iff(isnotempty(BodyContainsWords),BodyContainsWords,SubjectOrBodyContainsWords )))\n| extend RuleDetail = case(OfficeObjectId contains '/' , tostring(split(OfficeObjectId, '/')[-1]) , tostring(split(OfficeObjectId, '\\\\')[-1]))\n| summarize count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by  UserId, ClientIPAddress, ResultStatus, Keyword, OriginatingServer, OfficeObjectId, RuleDetail\n", "attributes": {"description": "'Often times after the initial compromise the attackers create inbox rules to delete emails that contain certain keywords.\n This is done so as to limit ability to warn compromised users that they've been compromised. Below is a sample query that tries to detect this.\nReference: https://www.reddit.com/r/sysadmin/comments/7kyp0a/recent_phishing_attempts_my_experience_and_what/'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/NRT_Office_MailForwarding.yaml", "query_name": "NRT Multiple users email forwarded to same destination", "query": "OfficeActivity\n| where OfficeWorkload =~ \"Exchange\"\n| where Parameters has_any (\"ForwardTo\", \"RedirectTo\", \"ForwardingSmtpAddress\")\n| mv-apply DynamicParameters = todynamic(Parameters) on (summarize ParsedParameters = make_bag(pack(tostring(DynamicParameters.Name), DynamicParameters.Value)))\n| evaluate bag_unpack(ParsedParameters, columnsConflict='replace_source')\n| extend DestinationMailAddress = tolower(case(\n    isnotempty(column_ifexists(\"ForwardTo\", \"\")), column_ifexists(\"ForwardTo\", \"\"),\n    isnotempty(column_ifexists(\"RedirectTo\", \"\")), column_ifexists(\"RedirectTo\", \"\"),\n    isnotempty(column_ifexists(\"ForwardingSmtpAddress\", \"\")), trim_start(@\"smtp:\", column_ifexists(\"ForwardingSmtpAddress\", \"\")),\n    \"\"))\n| where isnotempty(DestinationMailAddress)\n| mv-expand split(DestinationMailAddress, \";\")\n| extend ClientIPValues = extract_all(@'\\[?(::ffff:)?(?P<IPAddress>(\\d+\\.\\d+\\.\\d+\\.\\d+)|[^\\]]+)\\]?([-:](?P<Port>\\d+))?', dynamic([\"IPAddress\", \"Port\"]), ClientIP)[0]\n| extend ClientIP = tostring(ClientIPValues[0]), Port = tostring(ClientIPValues[1])\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), DistinctUserCount = dcount(UserId), UserId = make_set(UserId, 250), Ports = make_set(Port, 250), EventCount = count() by tostring(DestinationMailAddress), ClientIP\n| where DistinctUserCount > 1\n| mv-expand UserId to typeof(string)\n", "attributes": {"description": "'Identifies when multiple (more than one) users mailboxes are configured to forward to the same destination.\nThis could be an attacker-controlled destination mailbox configured to collect mail from multiple compromised user accounts.'\n", "techniques": ["T1114", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/Office_MailForwarding.yaml", "query_name": "Multiple users email forwarded to same destination", "query": "let queryfrequency = 1d;\nlet queryperiod = 7d;\nOfficeActivity\n| where TimeGenerated > ago(queryperiod)\n| where OfficeWorkload =~ \"Exchange\"\n//| where Operation in (\"Set-Mailbox\", \"New-InboxRule\", \"Set-InboxRule\")\n| where Parameters has_any (\"ForwardTo\", \"RedirectTo\", \"ForwardingSmtpAddress\")\n| mv-apply DynamicParameters = todynamic(Parameters) on (summarize ParsedParameters = make_bag(pack(tostring(DynamicParameters.Name), DynamicParameters.Value)))\n| evaluate bag_unpack(ParsedParameters, columnsConflict='replace_source')\n| extend DestinationMailAddress = tolower(case(\n    isnotempty(column_ifexists(\"ForwardTo\", \"\")), column_ifexists(\"ForwardTo\", \"\"),\n    isnotempty(column_ifexists(\"RedirectTo\", \"\")), column_ifexists(\"RedirectTo\", \"\"),\n    isnotempty(column_ifexists(\"ForwardingSmtpAddress\", \"\")), trim_start(@\"smtp:\", column_ifexists(\"ForwardingSmtpAddress\", \"\")),\n    \"\"))\n| where isnotempty(DestinationMailAddress)\n| mv-expand split(DestinationMailAddress, \";\")\n| extend ClientIPValues = extract_all(@'\\[?(::ffff:)?(?P<IPAddress>(\\d+\\.\\d+\\.\\d+\\.\\d+)|[^\\]]+)\\]?([-:](?P<Port>\\d+))?', dynamic([\"IPAddress\", \"Port\"]), ClientIP)[0]\n| extend ClientIP = tostring(ClientIPValues[0]), Port = tostring(ClientIPValues[1])\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), DistinctUserCount = dcount(UserId), UserId = make_set(UserId, 250), Ports = make_set(Port, 250), EventCount = count() by tostring(DestinationMailAddress), ClientIP\n| where DistinctUserCount > 1 and EndTime > ago(queryfrequency)\n| mv-expand UserId to typeof(string)\n| extend timestamp = StartTime, AccountCustomEntity = UserId, IPCustomEntity = ClientIP\n", "attributes": {"description": "'Identifies when multiple (more than one) users mailboxes are configured to forward to the same destination. \nThis could be an attacker-controlled destination mailbox configured to collect mail from multiple compromised user accounts.'\n", "techniques": ["T1114", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/office_policytampering.yaml", "query_name": "Office policy tampering", "query": "let opList = OfficeActivity \n| summarize by Operation\n//| where Operation startswith \"Remove-\" or Operation startswith \"Disable-\"\n| where Operation has_any (\"Remove\", \"Disable\")\n| where Operation contains \"AntiPhish\" or Operation contains \"SafeAttachment\" or Operation contains \"SafeLinks\" or Operation contains \"Dlp\" or Operation contains \"Audit\"\n| summarize make_set(Operation);\nOfficeActivity\n// Only admin or global-admin can disable/remove policy\n| where RecordType =~ \"ExchangeAdmin\"\n| where UserType in~ (\"Admin\",\"DcAdmin\")\n// Pass in interesting Operation list\n| where Operation in~ (opList)\n| extend ClientIPOnly = case( \nClientIP has \".\", tostring(split(ClientIP,\":\")[0]), \nClientIP has \"[\", tostring(trim_start(@'[[]',tostring(split(ClientIP,\"]\")[0]))),\nClientIP\n)  \n| extend Port = case(\nClientIP has \".\", (split(ClientIP,\":\")[1]),\nClientIP has \"[\", tostring(split(ClientIP,\"]:\")[1]),\nClientIP\n)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() by Operation, UserType, UserId, ClientIP = ClientIPOnly, Port, ResultStatus, Parameters\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP\n", "attributes": {"description": "'Identifies if any tampering is done to either auditlog, ATP Safelink, SafeAttachment, AntiPhish or Dlp policy. \nAn adversary may use this technique to evade detection or avoid other policy based defenses.\nReferences: https://docs.microsoft.com/powershell/module/exchange/advanced-threat-protection/remove-antiphishrule?view=exchange-ps.'\n", "techniques": ["T1098", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/Office_Uploaded_Executables.yaml", "query_name": "New executable via Office FileUploaded Operation", "query": "\n// a threshold can be enabled, see commented line below for PrevSeenCount\nlet threshold = 2;\nlet uploadOp = 'FileUploaded';\n// Extensions that are interesting. Add/Remove to this list as you see fit\nlet execExt = dynamic(['exe', 'inf', 'gzip', 'cmd', 'bat']);\nlet starttime = 8d;\nlet endtime = 1d;\nOfficeActivity | where TimeGenerated >= ago(endtime)\n// Limited to File Uploads due to potential noise, comment out the Operation statement below to include any operation type\n// Additional, but potentially noisy operation types that include Uploads and Downloads can be included by adding the following - Operation contains \"upload\" or Operation contains \"download\"\n| where Operation =~ uploadOp\n| where SourceFileExtension has_any (execExt)\n| project TimeGenerated, OfficeId, OfficeWorkload, RecordType, Operation, UserType, UserKey, UserId, ClientIP, UserAgent, Site_Url, SourceRelativeUrl, SourceFileName\n| join kind= leftanti (\nOfficeActivity | where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where Operation =~ uploadOp\n| where SourceFileExtension has_any (execExt)\n| summarize SourceRelativeUrl = make_set(SourceRelativeUrl), UserId = make_set(UserId) , PrevSeenCount = count() by SourceFileName\n// To exclude previous matches when only above a specific count, change threshold above and uncomment the line below\n//| where PrevSeenCount > threshold\n| mvexpand SourceRelativeUrl, UserId\n| extend SourceRelativeUrl = tostring(SourceRelativeUrl), UserId = tostring(UserId)\n) on SourceFileName, SourceRelativeUrl, UserId \n| extend SiteUrlUserFolder = tolower(split(Site_Url, '/')[-2])\n| extend UserIdUserFolderFormat = tolower(replace('@|\\\\.', '_',UserId))\n// identify when UserId is not a match to the specific site url personal folder reference\n| extend UserIdDiffThanUserFolder = iff(Site_Url has '/personal/' and SiteUrlUserFolder != UserIdUserFolderFormat, true , false ) \n| summarize TimeGenerated = make_list(TimeGenerated), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), \nUserAgents = make_list(UserAgent), OfficeIds = make_list(OfficeId), SourceRelativeUrls = make_list(SourceRelativeUrl), FileNames = make_list(SourceFileName)\nby OfficeWorkload, RecordType, Operation, UserType, UserKey, UserId, ClientIP, Site_Url, SiteUrlUserFolder, UserIdUserFolderFormat, UserIdDiffThanUserFolder\n| extend timestamp = StartTime, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Site_Url\n", "attributes": {"description": "'Identifies when executable file types are uploaded to Office services such as SharePoint and OneDrive.\nList currently includes 'exe', 'inf', 'gzip', 'cmd', 'bat' file extensions.\nAdditionally, identifies when a given user is uploading these files to another users workspace.\nThis may be indication of a staging location for malware or other malicious activity.'\n", "techniques": ["T1105"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/RareOfficeOperations.yaml", "query_name": "Rare and potentially high-risk Office operations", "query": "\nOfficeActivity\n| where Operation in~ ( \"Add-MailboxPermission\", \"Add-MailboxFolderPermission\", \"Set-Mailbox\", \"New-ManagementRoleAssignment\", \"New-InboxRule\", \"Set-InboxRule\", \"Set-TransportRule\")\nand not(UserId has_any ('NT AUTHORITY\\\\SYSTEM (Microsoft.Exchange.ServiceHost)', 'NT AUTHORITY\\\\SYSTEM (w3wp)', 'devilfish-applicationaccount') and Operation in~ ( \"Add-MailboxPermission\", \"Set-Mailbox\"))\n| extend ClientIPOnly = tostring(extract_all(@'\\[?(::ffff:)?(?P<IPAddress>(\\d+\\.\\d+\\.\\d+\\.\\d+)|[^\\]]+)\\]?', dynamic([\"IPAddress\"]), ClientIP)[0][0])\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIPOnly\n", "attributes": {"description": "'Identifies Office operations that are typically rare and can provide capabilities useful to attackers.'\n", "techniques": ["T1098", "T1114"], "tactics": ["Persistence", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/SharePoint_Downloads_byNewIP.yaml", "query_name": "SharePointFileOperation via previously unseen IPs", "query": "\nlet threshold = 50;\nlet szSharePointFileOperation = \"SharePointFileOperation\";\nlet szOperations = dynamic([\"FileDownloaded\", \"FileUploaded\"]);\nlet starttime = 14d;\nlet endtime = 1d;\nlet historicalActivity =\nOfficeActivity\n| where TimeGenerated between(ago(starttime)..ago(endtime))\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| summarize historicalCount = count() by ClientIP, RecordType, Operation;\nlet recentActivity = OfficeActivity\n| where TimeGenerated > ago(endtime)\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| summarize min(Start_Time), max(Start_Time), recentCount = count() by ClientIP, RecordType, Operation;\nlet RareIP = recentActivity | join kind= leftanti ( historicalActivity ) on ClientIP, RecordType, Operation\n// More than 50 downloads/uploads from a new IP\n| where recentCount > threshold;\nOfficeActivity \n| where TimeGenerated >= ago(endtime) \n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| join kind= inner (RareIP) on ClientIP, RecordType, Operation\n| where Start_Time between(min_Start_Time .. max_Start_Time)\n| summarize StartTimeUtc = min(min_Start_Time), EndTimeUtc = max(max_Start_Time) by RecordType, Operation, UserType, UserId, ClientIP, OfficeWorkload, Site_Url, OfficeObjectId, UserAgent, IPSeenCount = recentCount\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Site_Url\n| order by IPSeenCount desc, ClientIP asc, Operation asc, UserId asc\n", "attributes": {"description": "'Identifies when the volume of documents uploaded to or downloaded from Sharepoint by new IP addresses\nexceeds a threshold (default is 50).'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/SharePoint_Downloads_byNewUserAgent.yaml", "query_name": "SharePointFileOperation via devices with previously unseen user agents", "query": "\nlet threshold = 5;\nlet szSharePointFileOperation = \"SharePointFileOperation\";\nlet szOperations = dynamic([\"FileDownloaded\", \"FileUploaded\"]);\nlet starttime = 14d;\nlet endtime = 1d;\nlet historicalActivity =\nOfficeActivity\n| where TimeGenerated between(ago(starttime)..ago(endtime))\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| where isnotempty(UserAgent)\n| summarize historicalCount = count() by UserAgent, RecordType, Operation;\nlet recentActivity = OfficeActivity\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| where TimeGenerated > ago(endtime)\n| where isnotempty(UserAgent)\n| summarize min(Start_Time), max(Start_Time), recentCount = count() by UserAgent, RecordType, Operation;\nlet RareUserAgent = recentActivity | join kind = leftanti (historicalActivity) on UserAgent\n| order by recentCount desc, UserAgent\n// More than 5 downloads/uploads from a new user agent today\n| where recentCount > threshold;\nOfficeActivity \n| where TimeGenerated > ago(endtime) \n| where RecordType =~ szSharePointFileOperation \n| where Operation in~ (szOperations)\n| where isnotempty(UserAgent)\n| join kind= inner (RareUserAgent)\non UserAgent, RecordType, Operation    \n| where Start_Time between(min_Start_Time .. max_Start_Time)\n| summarize StartTimeUtc = min(min_Start_Time), EndTimeUtc = max(max_Start_Time) by RecordType, Operation, UserAgent, UserType, UserId, ClientIP, OfficeWorkload, Site_Url, OfficeObjectId, UserAgentSeenCount = recentCount\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Site_Url\n| order by UserAgentSeenCount desc, UserAgent asc, Operation asc, UserId asc\n", "attributes": {"description": "'Identifies if the number of documents uploaded or downloaded from device(s) associated\nwith a previously unseen user agent exceeds a threshold (default is 5).'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/StrontiumCredHarvesting.yaml", "query_name": "Possible STRONTIUM attempted credential harvesting - Sept 2020", "query": "let IPs = dynamic ([\"199.249.230.\",\"185.220.101.\",\"23.129.64.\",\"109.70.100.\",\"185.220.102.\"]);\nOfficeActivity\n| where RecordType in (\"AzureActiveDirectoryAccountLogon\", \"AzureActiveDirectoryStsLogon\") \n| where Operation != 'UserLoggedIn'\n| extend UserAgent = iff(parse_json(ExtendedProperties)[0].Name =~ \"UserAgent\", extractjson(\"$[0].Value\", ExtendedProperties, typeof(string)),\"\")\n| mv-expand parse_json(ExtendedProperties)\n| where ExtendedProperties.Name =~ \"RequestType\"\n| extend RequestType = ExtendedProperties.Value\n| where ClientIP has_any (IPs)\n| summarize authAttempts=dcount(TimeGenerated), firstAttempt=min(TimeGenerated), lastAttempt=max(TimeGenerated), uniqueIPs=dcount(ClientIP), uniqueAccounts=dcount(UserId), attemptedAccounts=make_set(UserId) by UserAgent\n| where authAttempts > 2500\n| extend timestamp = firstAttempt\n| sort by uniqueAccounts\n", "attributes": {"description": "'Surfaces potential STRONTIUM group Office365 credential harvesting attempts within OfficeActivity Logon events.\nReferences: https://www.microsoft.com/security/blog/2020/09/10/strontium-detecting-new-patters-credential-harvesting/.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODBinaryInAttachment.yaml", "query_name": "ProofpointPOD - Binary file in attachment", "query": "let lbtime = 10m;\nProofpointPOD\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| where FilterDisposition !in ('reject', 'discard')\n| extend attachedMimeType = todynamic(MsgParts)[0]['detectedMime']\n| where attachedMimeType == 'application/zip'\n| project SrcUserUpn, DstUserUpn\n| extend AccountCustomEntity = DstUserUpn\n", "attributes": {"description": "'Detects when email received with binary file as attachment.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODDataExfiltrationToPrivateEmail.yaml", "query_name": "ProofpointPOD - Possible data exfiltration to private email", "query": "let lbtime = 10m;\nProofpointPOD\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'message'\n| where NetworkDirection == 'outbound'\n| where array_length(todynamic(DstUserUpn)) == 1\n| extend sender = extract(@'\\A(.*?)@', 1, SrcUserUpn)\n| extend sender_domain = extract(@'@(.*)$', 1, SrcUserUpn)\n| extend recipient = extract(@'\\A(.*?)@', 1, tostring(todynamic(DstUserUpn)[0]))\n| extend recipient_domain = extract(@'@(.*)$', 1, tostring(todynamic(DstUserUpn)[0]))\n| where sender =~ recipient\n| where sender_domain != recipient_domain\n| project SrcUserUpn, DstUserUpn\n| extend AccountCustomEntity = SrcUserUpn\n", "attributes": {"description": "'Detects when sender sent email to the non-corporate domain and recipient's username is the same as sender's username.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODEmailSenderInTIList.yaml", "query_name": "ProofpointPOD - Email sender in TI list", "query": "let dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now() \n| where Active == true\n| where isnotempty(EmailSenderAddress)\n| extend TI_emailEntity = EmailSenderAddress\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n       ProofpointPOD \n       | where TimeGenerated >= ago(dt_lookBack)\n       | where isnotempty(SrcUserUpn)\n       | extend ProofpointPOD_TimeGenerated = TimeGenerated, ClientEmail = SrcUserUpn\n\n)\non $left.TI_emailEntity == $right.ClientEmail\n| where ProofpointPOD_TimeGenerated < ExpirationDateTime\n| summarize ProofpointPOD_TimeGenerated = arg_max(ProofpointPOD_TimeGenerated, *) by IndicatorId, ClientEmail\n| project ProofpointPOD_TimeGenerated, Description, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, ClientEmail\n| extend timestamp = ProofpointPOD_TimeGenerated\n", "attributes": {"description": "'Email sender in TI list.'\n", "techniques": ["T1078", "T1567"], "tactics": ["Exfiltration", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODEmailSenderIPinTIList.yaml", "query_name": "ProofpointPOD - Email sender IP in TI list", "query": "let dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n          ProofpointPOD \n          | where TimeGenerated >= ago(dt_lookBack)\n          | where isnotempty(SrcIpAddr)\n          | extend ProofpointPOD_TimeGenerated = TimeGenerated, ClientIP = SrcIpAddr\n  )\non $left.TI_ipEntity == $right.ClientIP\n| where ProofpointPOD_TimeGenerated < ExpirationDateTime\n| summarize ProofpointPOD_TimeGenerated = arg_max(ProofpointPOD_TimeGenerated, *) by IndicatorId, ClientIP\n| project ProofpointPOD_TimeGenerated, SrcUserUpn, DstUserUpn, SrcIpAddr, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, ClientIP\n| extend timestamp = ProofpointPOD_TimeGenerated\n", "attributes": {"description": "'Email sender IP in TI list.'\n", "techniques": ["T1078", "T1567"], "tactics": ["Exfiltration", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODHighRiskNotDiscarded.yaml", "query_name": "ProofpointPOD - High risk message not discarded", "query": "let lbtime = 10m;\nProofpointPOD\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| where FilterDisposition !in ('reject', 'discard')\n| where FilterModulesSpamScoresOverall == '100'\n| project SrcUserUpn, DstUserUpn\n| extend AccountCustomEntity = SrcUserUpn\n", "attributes": {"description": "'Detects when email with high risk score was not rejected or discarded by filters.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODMultipleArchivedAttachmentsToSameRecipient.yaml", "query_name": "ProofpointPOD - Multiple archived attachments to the same recipient", "query": "let lbtime = 30m;\nlet msgthreshold = 3;\nProofpointPOD\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'message'\n| where NetworkDirection == 'outbound'\n| extend attachedMimeType = todynamic(MsgParts)[0]['detectedMime']\n| where attachedMimeType == 'application/zip'\n| summarize count() by SrcUserUpn, DstUserUpn\n| where count_ > msgthreshold\n| extend AccountCustomEntity = SrcUserUpn\n", "attributes": {"description": "'Detects when multiple emails where sent to the same recipient with large archived attachments.'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODMultipleLargeEmailsToSameRecipient.yaml", "query_name": "ProofpointPOD - Multiple large emails to the same recipient", "query": "let lbtime = 30m;\nlet msgthreshold = 3;\nlet msgszthreshold = 3000000;\nProofpointPOD\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'message'\n| where NetworkDirection == 'outbound'\n| where NetworkBytes > msgszthreshold\n| summarize count() by SrcUserUpn, DstUserUpn\n| where count_ > msgthreshold\n| extend AccountCustomEntity = SrcUserUpn\n", "attributes": {"description": "'Detects when multiple emails with large size where sent to the same recipient.'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODMultipleProtectedEmailsToUnknownRecipient.yaml", "query_name": "ProofpointPOD - Multiple protected emails to unknown recipient", "query": "let lbtime = 30m;\nlet lbperiod = 14d;\nlet knownrecipients = ProofpointPOD\n| where TimeGenerated > ago(lbperiod)\n| where EventType == 'message'\n| where NetworkDirection == 'outbound'\n| where SrcUserUpn != ''\n| where array_length(todynamic(DstUserUpn)) == 1\n| summarize recipients = make_set(tostring(todynamic(DstUserUpn)[0])) by SrcUserUpn\n| extend commcol = SrcUserUpn;\nProofpointPOD\n| where TimeGenerated between (ago(lbtime) .. now())\n| where EventType == 'message'\n| where NetworkDirection == 'outbound'\n| extend isProtected = todynamic(MsgParts)[0]['isProtected']\n| extend mimePgp = todynamic(MsgParts)[0]['detectedMime']\n| where isProtected == 'true' or mimePgp == 'application/pgp-encrypted'\n| extend DstUserMail = tostring(todynamic(DstUserUpn)[0])\n| extend commcol = tostring(todynamic(DstUserUpn)[0])\n| join knownrecipients on commcol\n| where recipients !contains DstUserMail\n| project SrcUserUpn, DstUserMail\n| extend AccountCustomEntity = SrcUserUpn\n", "attributes": {"description": "'Detects when multiple protected messages where sent to early not seen recipient.'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODSuspiciousAttachment.yaml", "query_name": "ProofpointPOD - Suspicious attachment", "query": "let lbtime = 10m;\nlet disallowed_ext = dynamic(['ps1', 'exe', 'vbs', 'js', 'scr']);\nProofpointPOD\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| where FilterDisposition !in ('reject', 'discard')\n| extend attachedExt = todynamic(MsgParts)[0]['detectedExt']\n| where attachedExt in (disallowed_ext)\n| project SrcUserUpn, DstUserUpn\n| extend AccountCustomEntity = DstUserUpn\n", "attributes": {"description": "'Detects when email contains suspicious attachment (file type).'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ProofpointPOD/ProofpointPODWeakCiphers.yaml", "query_name": "ProofpointPOD - Weak ciphers", "query": "let lbtime = 1h;\nlet tls_ciphers = dynamic(['RC4-SHA', 'DES-CBC3-SHA']);\nProofpointPOD\n| where EventType == 'message'\n| where TlsCipher in (tls_ciphers)\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when weak TLS ciphers are used.'\n", "techniques": ["T1573"], "tactics": ["CommandandControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/PulseConnectSecure/PulseConnectSecureVPN-CVE_2021_22893_Exploit.yaml", "query_name": "PulseConnectSecure - CVE-2021-22893 Possible Pulse Connect Secure RCE Vulnerability Attack", "query": "let threshold = 3;\nPulseConnectSecure\n| where Messages contains \"Unauthenticated request url /dana-na/\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by Source_IP\n| where count_ > threshold\n| extend timestamp = StartTime, IPCustomEntity = Source_IP\n", "attributes": {"description": "'This query identifies exploitation attempts using Pulse Connect Secure(PCS) vulnerability (CVE-2021-22893) to the VPN server'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/QualysVM/HighNumberofVulnDetected.yaml", "query_name": "High Number of Urgent Vulnerabilities Detected", "query": "\nlet threshold = 10;\nQualysHostDetection_CL\n| mv-expand todynamic(Detections_s)\n| where Detections_s.Severity == \"5\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by NetBios_s, IPAddress\n| where count_ >= threshold\n| extend timestamp = StartTime, HostCustomEntity = NetBios_s, IPCustomEntity = IPAddress\n", "attributes": {"description": "'This Creates an incident when a host has a high number of Urgent, severity 5, vulnerabilities detected.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/QualysVM/NewHighSeverityVulnDetectedAcrossMulitpleHosts.yaml", "query_name": "New High Severity Vulnerability Detected Across Multiple Hosts", "query": "\nlet threshold = 10;\nQualysHostDetection_CL\n| mv-expand todynamic(Detections_s)\n| extend Status = tostring(Detections_s.Status), Vulnerability = tostring(Detections_s.Results), Severity = tostring(Detections_s.Severity)\n| where Status =~ \"New\" and Severity == \"5\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), dcount(NetBios_s) by tostring(Detections_s.QID)\n| where dcount_NetBios_s >= threshold\n| extend timestamp = StartTime\n", "attributes": {"description": "'This creates an incident when a new high severity vulnerability is detected across multilple hosts'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/CoreBackupDeletionwithSecurityAlert.yaml", "query_name": "CoreBackUp Deletion in correlation with other related security alerts", "query": "SecurityAlert\n| extend Extprop = parse_json(ExtendedProperties)\n| extend Computer = iff(isnotempty(toupper(tostring(Extprop[\"Compromised Host\"]))), toupper(tostring(Extprop[\"Compromised Host\"])), tostring(parse_json(Entities)[0].HostName))\n| extend Account = iff(isnotempty(tolower(tostring(Extprop[\"User Name\"]))), tolower(tostring(Extprop[\"User Name\"])), tolower(tostring(Extprop[\"user name\"])))\n| extend IpAddress = tostring(parse_json(ExtendedProperties).[\"IpAddress\"]) \n| project TimeGenerated, AlertName, Computer, Account, IpAddress, ExtendedProperties\n| extend timestamp = TimeGenerated, Account, MachineName = Computer, IpAddress\n| join kind=inner\n(\nCoreAzureBackup\n| where State =~ \"Deleted\"\n| where OperationName =~ \"BackupItem\"\n| extend data = split(BackupItemUniqueId, \";\")\n| extend AzureLocation = data[0], VaultId=data[1], MachineName=data[2], DrivesBackedUp=data[3]\n| project timestamp = TimeGenerated, AzureLocation, VaultId, tostring(MachineName), DrivesBackedUp, State, BackupItemUniqueId, _ResourceId, OperationName, BackupItemFriendlyName\n)\non MachineName\n| project timestamp, AlertName, HostCustomEntity = MachineName, AccountCustomEntity = Account, ResourceCustomEntity = _ResourceId, IPCustomEntity = IpAddress, VaultId, AzureLocation, DrivesBackedUp, State, BackupItemUniqueId, OperationName, BackupItemFriendlyName\n", "attributes": {"description": "'This query will help detect attackers attempt to delete backup containers in correlation with other alerts that could have triggered to help possibly reveal more details of attacker activity. \nThough such an activity could be legitimate as part of business operation, some ransomware actors may perform such operation to cause interruption to regular business services.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/DetectPIMAlertDisablingActivity.yaml", "query_name": "Detect PIM Alert Disabling activity", "query": "AuditLogs\n| where LoggedByService =~ \"PIM\"\n| where Category =~ \"RoleManagement\"\n| where ActivityDisplayName has \"Disable PIM Alert\"\n| extend IpAddress = case(\n  isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), \n  isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.app)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.app)).ipAddress),\n  'Not Available')\n| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n  tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName)), UserRoles = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| project InitiatedBy, ActivityDateTime, ActivityDisplayName, IpAddress, AADOperationType, AADTenantId, ResourceId, CorrelationId, Identity\n| extend timestamp = ActivityDateTime, IPCustomEntity = IpAddress, AccountCustomEntity = tolower(InitiatedBy), ResourceCustomEntity = ResourceId\n", "attributes": {"description": "'Privileged Identity Management (PIM) generates alerts when there is suspicious or unsafe activity in Azure Active Directory (Azure AD) organization. \nThis query will help detect attackers attempts to disable in product PIM alerts which are associated with Azure MFA requirements and could indicate activation of privileged access'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/Dev-0530AVHits.yaml", "query_name": "AV detections related to Dev-0530 actors", "query": "let Dev0530_threats = dynamic([\"Trojan:Win32/SiennaPurple.A\", \"Ransom:Win32/SiennaBlue.A\", \"Ransom:Win32/SiennaBlue.B\"]);\nDeviceInfo\n| extend DeviceName = tolower(DeviceName)\n| join kind=inner ( SecurityAlert\n| where ProviderName == \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| extend ThreatFamilyName = tostring(parse_json(ExtendedProperties).ThreatFamilyName)\n| where ThreatName in~ (Dev0530_threats) or ThreatFamilyName in~ (Dev0530_threats)\n| extend CompromisedEntity = tolower(CompromisedEntity)\n) on $left.DeviceName == $right.CompromisedEntity\n| summarize by DisplayName, ThreatName, ThreatFamilyName, PublicIP, AlertSeverity, Description, tostring(LoggedOnUsers), DeviceId, TenantId , bin(TimeGenerated, 1d), CompromisedEntity, tostring(LoggedOnUsers), ProductName, Entities\n", "attributes": {"description": "'This query looks for Microsoft Defender AV detections related to  Dev-0530 actors. In Microsoft Sentinel the SecurityAlerts table includes only the Device Name of the affected device, \n this query joins the DeviceInfo table to clearly connect other information such as Device group, ip, logged on users etc. This would allow the Microsoft Sentinel analyst to have more context related to the alert, if available.'\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/EuropiumAVHits.yaml", "query_name": "AV detections related to Europium actors", "query": "let Europium_threats = dynamic([\"TrojanDropper:ASP/WebShell!MSR\", \"Trojan:Win32/BatRunGoXml\", \"DoS:Win64/WprJooblash\", \"Ransom:Win32/Eagle!MSR\", \"Trojan:Win32/Debitom.A\"]);\nDeviceInfo\n| extend DeviceName = tolower(DeviceName)\n| join kind=inner ( SecurityAlert\n| where ProviderName == \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| extend ThreatFamilyName = tostring(parse_json(ExtendedProperties).ThreatFamilyName)\n| where ThreatName in~ (Europium_threats) or ThreatFamilyName in~ (Europium_threats)\n| extend CompromisedEntity = tolower(CompromisedEntity)\n) on $left.DeviceName == $right.CompromisedEntity\n| summarize by DisplayName, ThreatName, ThreatFamilyName, PublicIP, AlertSeverity, Description, tostring(LoggedOnUsers), DeviceId, TenantId , bin(TimeGenerated, 1d), CompromisedEntity, tostring(LoggedOnUsers), ProductName, Entities\n", "attributes": {"description": "'This query looks for Microsoft Defender AV detections related to  Europium actor. In Microsoft Sentinel the SecurityAlerts table includes only the Device Name of the affected device, \n this query joins the DeviceInfo table to clearly connect other information such as Device group, ip, etc. This would allow the Microsoft Sentinel analyst to have more context related to the alert, if available.\n Reference: https://www.microsoft.com/security/blog/2022/09/08/microsoft-investigates-iranian-attacks-against-the-albanian-government '\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/HiveRansomwareAVHits.yaml", "query_name": "AV detections related to Hive Ransomware", "query": "let Hive_threats = dynamic([\"Ransom:Win64/Hive\", \"Ransom:Win32/Hive\"]);\nDeviceInfo\n| extend DeviceName = tolower(DeviceName)\n| join kind=inner ( SecurityAlert\n| where ProviderName == \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| extend ThreatFamilyName = tostring(parse_json(ExtendedProperties).ThreatFamilyName)\n| where ThreatName in~ (Hive_threats) or ThreatFamilyName in~ (Hive_threats)\n| extend CompromisedEntity = tolower(CompromisedEntity)\n) on $left.DeviceName == $right.CompromisedEntity\n| summarize by DisplayName, ThreatName, ThreatFamilyName, PublicIP, AlertSeverity, Description, tostring(LoggedOnUsers), DeviceId, TenantId , bin(TimeGenerated, 1d), CompromisedEntity, tostring(LoggedOnUsers), ProductName, Entities\n", "attributes": {"description": "'This query looks for Microsoft Defender AV detections related to Hive Ransomware . In Microsoft Sentinel the SecurityAlerts table includes only the Device Name of the affected device,\n this query joins the DeviceInfo table to clearly connect other information such as Device group, ip, logged on users etc. This would allow the Microsoft Sentinel analyst to have more context related to the alert, if available.'\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/Massdownload_USBFileCopy.yaml", "query_name": "Mass Download & copy to USB device by single user", "query": "let Alerts = SecurityAlert\n| where AlertName =~ \"mass download by a single user\"\n| where Status != 'Resolved'\n| extend ipEnt = parse_json(Entities), accountEnt = parse_json(Entities)\n| mv-apply tempParams = ipEnt on (\nmv-expand ipEnt\n| where ipEnt.Type == \"ip\" \n| extend IpAddress = tostring(ipEnt.Address)\n)\n| mv-apply tempParams = accountEnt on (\nmv-expand accountEnt\n| where accountEnt.Type == \"account\"\n| extend AADUserId = tostring(accountEnt.AadUserId)\n)\n| extend Alert_TimeGenerated = TimeGenerated\n| distinct Alert_TimeGenerated, IpAddress, AADUserId, DisplayName, Description, ProductName, ExtendedProperties, Entities, Status, CompromisedEntity\n;\nlet CA_Events = CloudAppEvents\n| where ActionType == \"FileDownloaded\"\n| extend parsed = parse_json(RawEventData)\n| extend UserId = tostring(parsed.UserId)\n| extend FileName = tostring(parsed.SourceFileName)\n| extend FileExtension = tostring(parsed.SourceFileExtension)\n| summarize CloudAppEvent_StartTime = min(TimeGenerated), CloudAppEvent_EndTime = max(TimeGenerated), CloudAppEvent_Files = make_set(FileName), FileCount = dcount(FileName) by Application, AccountObjectId, UserId, IPAddress, City, CountryCode\n| extend CloudAppEvents_Details = pack_all();\nlet CA_Alerts_Events = Alerts | join kind=inner (CA_Events)\non $left.AADUserId == $right.AccountObjectId and $left.IpAddress == $right.IPAddress\n// Cloud app event comes before Alert\n| where CloudAppEvent_EndTime <= Alert_TimeGenerated\n| project Alert_TimeGenerated, UserId, AADUserId, IPAddress, CloudAppEvents_Details, CloudAppEvent_Files\n;\n// setup list to filter DeviceFileEvents for only files downloaded as indicated by CloudAppEvents\nlet CA_FileList = CA_Alerts_Events | project CloudAppEvent_Files;\nCA_Alerts_Events\n| join kind=inner ( DeviceFileEvents\n| where ActionType in (\"FileCreated\", \"FileRenamed\")\n| where FileName in~ (CA_FileList)\n| summarize DeviceFileEvent_StartTime = min(TimeGenerated), DeviceFileEvent_EndTime = max(TimeGenerated), DeviceFileEvent_Files = make_set(FolderPath), DeviceFileEvent_FileCount = dcount(FolderPath) by InitiatingProcessAccountUpn, DeviceId, DeviceName, InitiatingProcessFolderPath, InitiatingProcessParentFileName//, InitiatingProcessCommandLine\n| extend DeviceFileEvents_Details = pack_all()\n) on $left.UserId == $right.InitiatingProcessAccountUpn\n| where DeviceFileEvent_StartTime >= Alert_TimeGenerated\n| join kind=inner (\n// get device events where a USB drive was mounted\nDeviceEvents\n| where ActionType == \"UsbDriveMounted\"\n| extend parsed = parse_json(AdditionalFields)\n| extend USB_DriveLetter = tostring(AdditionalFields.DriveLetter), USB_ProductName = tostring(AdditionalFields.ProductName), USB_Volume = tostring(AdditionalFields.Volume)\n| where isnotempty(USB_DriveLetter)\n| project USB_TimeGenerated = TimeGenerated, DeviceId, USB_DriveLetter, USB_ProductName, USB_Volume\n| extend USB_Details = pack_all()\n)  \non DeviceId\n// USB event occurs after the Alert\n| where USB_TimeGenerated >= Alert_TimeGenerated\n| mv-expand DeviceFileEvent_Files\n| extend DeviceFileEvent_Files = tostring(DeviceFileEvent_Files)\n// make sure that we only pickup the files that have the USB drive letter\n| where DeviceFileEvent_Files startswith USB_DriveLetter\n| summarize USB_Drive_MatchedFiles = make_set_if(DeviceFileEvent_Files, DeviceFileEvent_Files startswith USB_DriveLetter) by Alert_TimeGenerated, USB_TimeGenerated, UserId, AADUserId, DeviceId, DeviceName, IPAddress, CloudAppEvents_Details = tostring(CloudAppEvents_Details), DeviceFileEvents_Details = tostring(DeviceFileEvents_Details), USB_Details = tostring(USB_Details)\n| extend InitiatingProcessFileName = tostring(split(todynamic(DeviceFileEvents_Details).InitiatingProcessFolderPath, \"\\\\\")[-1]), InitiatingProcessFolderPath = tostring(todynamic(DeviceFileEvents_Details).InitiatingProcessFolderPath)\n", "attributes": {"description": "'This query looks for any mass download by a single user with possible file copy activity to a new USB drive. Malicious insiders may perform such activities that may cause harm to the organization. \nThis query could also reveal unintentional insider that had no intention of malicious activity but their actions may impact an organizations security posture.\nReference:https://docs.microsoft.com/defender-cloud-apps/policy-template-reference'\n", "techniques": ["T1052"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/MDE_hitsforADFandAzureSynapsePipelines.yaml", "query_name": "Microsoft Defender for Endpoint (MDE) signatures for Azure Synapse pipelines and Azure Data Factory", "query": "let mde_threats = dynamic([\"Behavior:Win32/SuspAzureRequest.A\", \"Behavior:Win32/SuspAzureRequest.B\", \"Behavior:Win32/SuspAzureRequest.C\", \"Behavior:Win32/LaunchingSuspCMD.B\"]);\nDeviceInfo\n| extend DeviceName = tolower(DeviceName)\n| join kind=inner ( SecurityAlert\n| where ProviderName == \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| extend ThreatFamilyName = tostring(parse_json(ExtendedProperties).ThreatFamilyName)\n| where ThreatName in~ (mde_threats) or ThreatFamilyName in~ (mde_threats)\n| extend CompromisedEntity = tolower(CompromisedEntity)\n) on $left.DeviceName == $right.CompromisedEntity\n| summarize by DisplayName, ThreatName, ThreatFamilyName, PublicIP, AlertSeverity, Description, tostring(LoggedOnUsers), DeviceId, TenantId , bin(TimeGenerated, 1d), CompromisedEntity, tostring(LoggedOnUsers), ProductName, Entities\n", "attributes": {"description": "'This query looks for Microsoft Defender for Endpoint detections related to the remote command execution attempts on Azure IR with Managed VNet or SHIR. \nIn Microsoft Sentinel, the SecurityAlerts table includes the name of the impacted device. Additionally, this query joins the DeviceInfo table to connect other information such as device group, \nIP address, signed in users, and others allowing analysts using Microsoft Sentinel to have more context related to the alert. \nReference: https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-29972 , \nhttps://msrc-blog.microsoft.com/2022/05/09/vulnerability-mitigated-in-the-third-party-data-connector-used-in-azure-synapse-pipelines-and-azure-data-factory-cve-2022-29972'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/Solorigate-Defender-Detections.yaml", "query_name": "Solorigate Defender Detections", "query": "\nDeviceInfo\n| extend DeviceName = tolower(DeviceName)\n| join (SecurityAlert\n| where ProviderName =~ \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| where ThreatName has \"Solorigate\"\n| extend HostCustomEntity = tolower(CompromisedEntity)\n) on $left.DeviceName == $right.HostCustomEntity\n| project TimeGenerated, DisplayName, ThreatName, CompromisedEntity, PublicIP, MachineGroup, AlertSeverity, Description, LoggedOnUsers, DeviceId, TenantId, HostCustomEntity\n| extend timestamp = TimeGenerated, IPCustomEntity = PublicIP\n", "attributes": {"description": "'Surfaces any Defender Alert for Solorigate Events. In Microsoft Sentinel the SecurityAlerts table includes only the Device Name of the affected device, this query joins the DeviceInfo table to clearly connect other information such as \n Device group, ip, logged on users etc. This way, the Microsoft Sentinel user can have all the pertinent device info in one view for all the the Solarigate Defender alerts.'\n", "techniques": ["T1195"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityAlert/Suspicious_WorkSpaceDeletion_Attempt.yaml", "query_name": "Workspace deletion attempt from an infected device", "query": "SecurityAlert \n| where AlertName == \"Sign-in from an infected device\"\n| extend Extprop = parsejson(Entities)\n| mv-expand Extprop\n| extend Extprop = parsejson(Extprop)\n| extend CmdLine = iff(Extprop['Type']==\"process\", Extprop['CommandLine'], '')\n| extend File = iff(Extprop['Type']==\"file\", Extprop['Name'], '')\n| extend Account = Extprop['Name']\n| extend Domain = Extprop['UPNSuffix']\n| extend Account = iif(isnotempty(Domain) and Extprop['Type']==\"account\", tolower(strcat(Account, \"@\", Domain)), iif(Extprop['Type']==\"account\", tolower(Account), \"\"))\n| extend IpAddress = iff(Extprop[\"Type\"] == \"ip\",Extprop['Address'], '')\n| extend Process = iff(isnotempty(CmdLine), CmdLine, File)\n| summarize count() by AlertName, AlertSeverity, CompromisedEntity, Account, IpAddress\n| join kind=inner \n(\nAzureActivity\n| where OperationNameValue hassuffix (\"/workspaces/computes/delete\")\n| where ActivityStatusValue =~ \"Succeeded\"\n| summarize  StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ActivityTimeStamp = makelist(TimeGenerated), ActivityStatusValue = makelist(ActivityStatusValue),  OperationIds = makelist(OperationId), CorrelationIds = makelist(CorrelationId), Resources = makelist(Resource), ResourceGroups = makelist(ResourceGroup), ResourceIds = makelist(ResourceId), ActivityCountByCallerIPAddress = count()  \nby CallerIpAddress, Caller, OperationNameValue\n) on $left. IpAddress == $right. CallerIpAddress\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'This hunting query will alert on any sign-ins from devices infected with malware in correlation with potential workspace deletion activity. \nAttackers may attempt to delete  workspaces containing  compute instances  after successful compromise to cause service unavailability to regular business operation.'\n", "techniques": ["T1078", "T1489"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/AADHealthMonAgentRegKeyAccess.yaml", "query_name": "Azure AD Health Monitoring Agent Registry Keys Access", "query": "// ADHealth Monitoring Agent Registry Key\nlet aadHealthMonAgentRegKey = \"\\\\REGISTRY\\\\MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Microsoft Online\\\\Reporting\\\\MonitoringAgent\";\n// Filter out known processes\nlet aadConnectHealthProcs = dynamic ([\n    'Microsoft.Identity.Health.Adfs.DiagnosticsAgent.exe',\n    'Microsoft.Identity.Health.Adfs.InsightsService.exe',\n    'Microsoft.Identity.Health.Adfs.MonitoringAgent.Startup.exe',\n    'Microsoft.Identity.Health.Adfs.PshSurrogate.exe',\n    'Microsoft.Identity.Health.Common.Clients.ResourceMonitor.exe',\n    'Microsoft.Identity.Health.AadSync.MonitoringAgent.Startup.exe',\n    'Microsoft.Identity.AadConnect.Health.AadSync.Host.exe',\n    'Microsoft.Azure.ActiveDirectory.Synchronization.Upgrader.exe',\n    'miiserver.exe'\n]);\n(union isfuzzy=true\n(\nSecurityEvent\n| where EventID == '4656'\n| where EventData has aadHealthMonAgentRegKey\n| extend EventData = parse_xml(EventData).EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Computer, EventID)\n| extend ObjectName = column_ifexists(\"ObjectName\", \"\"),\n    ObjectType = column_ifexists(\"ObjectType\", \"\")\n| where ObjectType == 'Key'\n| where ObjectName == aadHealthMonAgentRegKey\n| extend SubjectUserName = column_ifexists(\"SubjectUserName\", \"\"),\n    SubjectDomainName = column_ifexists(\"SubjectDomainName\", \"\"),\n    ProcessName = column_ifexists(\"ProcessName\", \"\")\n| extend Process = split(ProcessName, '\\\\', -1)[-1],\n    Account = strcat(SubjectDomainName, \"\\\\\", SubjectUserName)\n| where Process !in (aadConnectHealthProcs)\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), count() by EventID, Account, Computer, Process, SubjectUserName, SubjectDomainName, ObjectName, ObjectType, ProcessName\n),\n(\nWindowsEvent\n| where EventID == '4656' and EventData has aadHealthMonAgentRegKey\n| extend ObjectType = tostring(EventData.ObjectType)\n| where ObjectType == 'Key'\n| extend ObjectName = tostring(EventData.ObjectName)\n| where ObjectName == aadHealthMonAgentRegKey\n| extend ProcessName = tostring(EventData.ProcessName)\n| extend Process = tostring(split(ProcessName, '\\\\')[-1])\n| where Process !in (aadConnectHealthProcs)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName)\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), count() by EventID, Account, Computer, Process, SubjectUserName, SubjectDomainName, ObjectName, ObjectType, ProcessName\n),\n(\nSecurityEvent\n| where EventID == '4663'\n| where ObjectType == 'Key'\n| where ObjectName == aadHealthMonAgentRegKey\n| extend Process = tostring(split(ProcessName, '\\\\', -1)[-1])\n| where Process !in (aadConnectHealthProcs)\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), count() by EventID, Account, Computer, Process, SubjectUserName, SubjectDomainName, ObjectName, ObjectType, ProcessName\n),\n  (\nWindowsEvent\n| where EventID == '4663' and EventData has aadHealthMonAgentRegKey\n| extend ObjectType = tostring(EventData.ObjectType)\n| where ObjectType == 'Key'\n| extend ObjectName = tostring(EventData.ObjectName)\n| where ObjectName == aadHealthMonAgentRegKey\n| extend ProcessName = tostring(EventData.ProcessName)\n| extend Process = tostring(split(ProcessName, '\\\\')[-1])\n| where Process !in (aadConnectHealthProcs)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName)\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), count() by EventID, Account, Computer, Process, SubjectUserName, SubjectDomainName, ObjectName, ObjectType, ProcessName\n)\n)\n// You can filter out potential machine accounts\n//| where AccountType != 'Machine'\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'This detection uses Windows security events to detect suspicious access attempts to the registry key of Azure AD Health monitoring agent.\nThis detection requires an access control entry (ACE) on the system access control list (SACL) of the following securable object HKLM\\SOFTWARE\\Microsoft\\Microsoft Online\\Reporting\\MonitoringAgent.\nYou can find more information in here https://github.com/OTRF/Set-AuditRule/blob/master/rules/registry/aad_connect_health_monitoring_agent.yml\n'\n", "techniques": ["T1005"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/AADHealthSvcAgentRegKeyAccess.yaml", "query_name": "Azure AD Health Service Agents Registry Keys Access", "query": "// ADHealth Monitoring Agent Registry Key\nlet aadHealthMonAgentRegKey = \"\\\\REGISTRY\\\\MACHINE\\\\SOFTWARE\\\\Microsoft\\\\MicrosoftOnline\\\\Reporting\\\\MonitoringAgent\";\n// Filter out known processes\nlet aadConnectHealthProcs = dynamic ([\n    'Microsoft.Identity.Health.Adfs.DiagnosticsAgent.exe',\n    'Microsoft.Identity.Health.Adfs.InsightsService.exe',\n    'Microsoft.Identity.Health.Adfs.MonitoringAgent.Startup.exe',\n    'Microsoft.Identity.Health.Adfs.PshSurrogate.exe',\n    'Microsoft.Identity.Health.Common.Clients.ResourceMonitor.exe',\n    'Microsoft.Identity.Health.AadSync.MonitoringAgent.Startup.exe',\n    'Microsoft.Identity.AadConnect.Health.AadSync.Host.exe',\n    'Microsoft.Azure.ActiveDirectory.Synchronization.Upgrader.exe',\n    'miiserver.exe'\n]);\n(union isfuzzy=true\n(\nSecurityEvent\n| where EventID == '4656'\n| where EventData has aadHealthMonAgentRegKey\n| extend EventData = parse_xml(EventData).EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Computer, EventID)\n| extend ObjectName = column_ifexists(\"ObjectName\", \"\"),\n    ObjectType = column_ifexists(\"ObjectType\", \"\")\n| where ObjectType == 'Key'\n| where ObjectName == aadHealthMonAgentRegKey\n| extend SubjectUserName = column_ifexists(\"SubjectUserName\", \"\"),\n    SubjectDomainName = column_ifexists(\"SubjectDomainName\", \"\"),\n    ProcessName = column_ifexists(\"ProcessName\", \"\")\n| extend Process = split(ProcessName, '\\\\', -1)[-1],\n    Account = strcat(SubjectDomainName, \"\\\\\", SubjectUserName)\n| where Process !in (aadConnectHealthProcs)\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), count() by EventID, Account, Computer, Process, SubjectUserName, SubjectDomainName, ObjectName, ObjectType, ProcessName\n),\n  ( WindowsEvent\n| where EventID == '4656' and EventData has aadHealthMonAgentRegKey\n| extend ObjectType = tostring(EventData.ObjectType)\n| where ObjectType == 'Key'\n| extend ObjectName = tostring(EventData.ObjectName)\n| where ObjectName == aadHealthMonAgentRegKey\n| extend ProcessName = tostring(EventData.ProcessName)\n| extend Process = tostring(split(ProcessName, '\\\\')[-1])\n| where Process !in (aadConnectHealthProcs)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName)\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), count() by EventID, Account, Computer, Process, SubjectUserName, SubjectDomainName, ObjectName, ObjectType, ProcessName\n),\n(\nSecurityEvent\n| where EventID == '4663'\n| where ObjectType == 'Key'\n| where ObjectName == aadHealthMonAgentRegKey\n| extend Process = tostring(split(ProcessName, '\\\\', -1)[-1])\n| where Process !in (aadConnectHealthProcs)\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), count() by EventID, Account, Computer, Process, SubjectUserName, SubjectDomainName, ObjectName, ObjectType, ProcessName\n),\n( WindowsEvent\n| where EventID == '4663' and EventData has aadHealthMonAgentRegKey\n| extend ObjectType = tostring(EventData.ObjectType)\n| where ObjectType == 'Key'\n| extend ObjectName = tostring(EventData.ObjectName)\n| where ObjectName == aadHealthMonAgentRegKey\n| extend ProcessName = tostring(EventData.ProcessName)\n| extend Process = tostring(split(ProcessName, '\\\\')[-1])\n| where Process !in (aadConnectHealthProcs)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName)\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), count() by EventID, Account, Computer, Process, SubjectUserName, SubjectDomainName, ObjectName, ObjectType, ProcessName\n)\n)\n// You can filter out potential machine accounts\n//| where AccountType != 'Machine'\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'This detection uses Windows security events to detect suspicious access attempts to the registry key values and sub-keys of Azure AD Health service agents (e.g AD FS).\nInformation from AD Health service agents can be used to potentially abuse some of the features provided by those services in the cloud (e.g. Federation).\nThis detection requires an access control entry (ACE) on the system access control list (SACL) of the following securable object: HKLM:\\SOFTWARE\\Microsoft\\ADHealthAgent.\nMake sure you set the SACL to propagate to its sub-keys. You can find more information in here https://github.com/OTRF/Set-AuditRule/blob/master/rules/registry/aad_connect_health_service_agent.yml\n'\n", "techniques": ["T1005"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/AccessibilityFeaturesModification.yaml", "query_name": "Modification of Accessibility Features", "query": "let ImagesList = dynamic ([\"sethc.exe\",\"utilman.exe\",\"osk.exe\",\"Magnify.exe\",\"Narrator.exe\",\"DisplaySwitch.exe\",\"AtBroker.exe\"]); \nlet OriginalFileNameList = dynamic ([\"sethc.exe\",\"utilman.exe\",\"osk.exe\",\"Magnify.exe\",\"Narrator.exe\",\"DisplaySwitch.exe\",\"AtBroker.exe\",\"SR.exe\",\"utilman2.exe\",\"ScreenMagnifier.exe\"]); \nEvent\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID==1\n| parse EventData with * 'Image\">' Image \"<\" * 'OriginalFileName\">' OriginalFileName \"<\" *\n| where Image has_any (ImagesList) and not (OriginalFileName has_any (OriginalFileNameList))\n| parse EventData with * 'ProcessGuid\">' ProcessGuid \"<\" * 'Description\">' Description \"<\" * 'CommandLine\">' CommandLine \"<\" * 'CurrentDirectory\">' CurrentDirectory \"<\" * 'User\">' User \"<\" * 'LogonGuid\">' LogonGuid \"<\" * 'Hashes\">' Hashes \"<\" * 'ParentProcessGuid\">' ParentProcessGuid \"<\" * 'ParentImage\">' ParentImage \"<\" * 'ParentCommandLine\">' ParentCommandLine \"<\" * 'ParentUser\">' ParentUser \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, User, ParentImage, ParentProcessGuid, ParentCommandLine, ParentUser, Image, ProcessGuid, CommandLine, Description, OriginalFileName, CurrentDirectory, Hashes\n", "attributes": {"description": "'Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by accessibility features. Windows contains accessibility features that may be launched with a key combination before a user has logged in (ex: when the user is on the Windows logon screen). An adversary can modify the way these programs are launched to get a command prompt or backdoor without logging in to the system.\n Two common accessibility programs are C:\\Windows\\System32\\sethc.exe, launched when the shift key is pressed five times and C:\\Windows\\System32\\utilman.exe, launched when the Windows + U key combination is pressed. The sethc.exe program is often referred to as \"sticky keys\", and has been used by adversaries for unauthenticated access through a remote desktop login screen. [1]\nRef: https://attack.mitre.org/techniques/T1546/008/'\n", "techniques": ["T1546.008"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ADFSAbnormalEnhancedKeyUsageAttribute-OID.yaml", "query_name": "AD FS Abnormal EKU object identifier attribute", "query": "// change the starttime value for a longer period of known OIDs\nlet starttime = 1d;\n// change the lookback value for a longer period of lookback for suspicious/abnormal\nlet lookback = 1h;\nlet OIDList = SecurityEvent\n| where TimeGenerated >= ago(starttime)\n| where EventSourceName == 'AD FS Auditing'\n| where EventID == 501\n| where EventData has '/eku'\n| extend OIDs = extract_all(@\"<Data>([\\d+\\.]+)</Data>\", EventData)\n| mv-expand OIDs\n| extend OID = tostring(OIDs)\n| extend OID_Length = strlen(OID)\n| project TimeGenerated, Computer, EventSourceName, EventID, OID, OID_Length, EventData\n;\nOIDList\n| where TimeGenerated >= ago(lookback)\n| join kind=leftanti (\nOIDList\n| where TimeGenerated between (ago(starttime) .. ago(lookback))\n| summarize by OID\n) on OID\n", "attributes": {"description": "'This detection uses Security events from the \"AD FS Auditing\" provider to detect suspicious object identifiers (OIDs) as part EventID 501 and specifically part of the Enhanced Key Usage attributes.\nThis query checks to see if you have any new OIDs in the last hour that have not been seen in the previous day. New OIDs should be validated and OIDs that are very long, as indicated\nby the OID_Length field, could also be an indicator of malicious activity.\nIn order to use this query you need to enable AD FS auditing on the AD FS Server.\nReferences:\nhttps://www.microsoft.com/security/blog/2022/08/24/magicweb-nobeliums-post-compromise-trick-to-authenticate-as-anyone/\nhttps://docs.microsoft.com/windows-server/identity/ad-fs/troubleshooting/ad-fs-tshoot-logging\n'\n", "techniques": ["T1552"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ADFSDBNamedPipeConnection.yaml", "query_name": "ADFS Database Named Pipe Connection", "query": "// Adjust this to use a longer timeframe to identify ADFS servers\n//let lookback = 6d;\n// Adjust this to adjust the key export detection  timeframe\n//let timeframe = 1d;\n// Start be identifying ADFS servers to reduce FP chance\nlet ADFS_Servers = (\nEvent\n//| where TimeGenerated > ago(timeframe+lookback)\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 18\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, MG, ManagementGroupName, _ResourceId)\n| extend Image = column_ifexists(\"Image\", \"\")\n| extend process = split(Image, '\\\\', -1)[-1]\n| where process =~ \"Microsoft.IdentityServer.ServiceHost.exe\"\n| summarize by Computer);\n// Look for ADFS servers where Named Pipes event are present\nEvent\n//| where TimeGenerated > ago(timeframe)\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 18\n| where Computer in~ (ADFS_Servers)\n| extend RenderedDescription = tostring(split(RenderedDescription, \":\")[0])\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| extend RuleName = column_ifexists(\"RuleName\", \"\"),\n    TechniqueId = column_ifexists(\"TechniqueId\", \"\"),\n    TechniqueName = column_ifexists(\"TechniqueName\", \"\"),\n    Image = column_ifexists(\"Image\", \"\"),\n    PipeName = column_ifexists(\"PipeName\", \"\"),\n    EventType = column_ifexists(\"EventType\", \"\")\n| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName\n// Look for Pipe related to querying the WID\n| where PipeName == \"\\\\MICROSOFT##WID\\\\tsql\\\\query\"\n| extend process = split(Image, '\\\\', -1)[-1]\n// Exclude expected processes\n| where process !in (\"Microsoft.IdentityServer.ServiceHost.exe\", \"Microsoft.Identity.Health.Adfs.PshSurrogate.exe\", \"AzureADConnect.exe\", \"Microsoft.Tri.Sensor.exe\", \"wsmprovhost.exe\",\"mmc.exe\", \"sqlservr.exe\")\n| extend Operation = RenderedDescription\n| project-reorder TimeGenerated, EventType, Operation, process, Image, Computer, UserName\n| extend HostCustomEntity = Computer, AccountCustomEntity = UserName\n", "attributes": {"description": "'This detection uses Sysmon telemetry to detect suspicious local connections via a named pipe to the AD FS configuration database (Windows Internal Database).\nIn order to use this query you need to be collecting Sysmon EventIdD 18 (Pipe Connected).\nIf you do not have Sysmon data in your workspace this query will raise an error stating:\nFailed to resolve scalar expression named \"[@Name]\"'\n", "techniques": ["T1005"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ADFSRemoteAuthSyncConnection.yaml", "query_name": "AD FS Remote Auth Sync Connection", "query": "// Adjust this to use a longer timeframe to identify ADFS servers\n//let lookback = 0d;\n// Adjust this to adjust detection timeframe\n//let timeframe = 1d;\n// SamAccountName of AD FS Service Account. Filter on the use of a specific AD FS user account\n//let adfsuser = 'adfsadmin';\n// Identify ADFS Servers\nlet ADFS_Servers = (\n    SecurityEvent\n    //| where TimeGenerated > ago(timeframe+lookback)\n    | where EventSourceName == 'AD FS Auditing'\n    | distinct Computer\n);\nSecurityEvent\n    //| where TimeGenerated > ago(timeframe)\n    | where Computer in~ (ADFS_Servers)\n    // A token of type 'http://schemas.microsoft.com/ws/2006/05/servicemodel/tokens/SecureConversation'\n    // for relying party '-' was successfully authenticated.\n    | where EventID == 412\n    | extend EventData = parse_xml(EventData).EventData.Data\n    | extend InstanceId = tostring(EventData[0])\n| join kind=inner\n(\n    SecurityEvent\n    //| where TimeGenerated > ago(timeframe)\n    | where Computer in~ (ADFS_Servers)\n    // Events to identify caller identity from event 412\n    | where EventID == 501\n    | extend EventData = parse_xml(EventData).EventData.Data\n    | where tostring(EventData[1]) contains 'identity/claims/name'\n    | extend InstanceId = tostring(EventData[0])\n    | extend ClaimsName = tostring(EventData[2])\n    // Filter on the use of a specific AD FS user account\n    //| where ClaimsName contains adfsuser\n)\non $left.InstanceId == $right.InstanceId\n| join kind=inner\n(\n    SecurityEvent\n    | where EventID == 5156\n    | where Computer in~ (ADFS_Servers)\n    | extend EventData = parse_xml(EventData).EventData.Data\n    | mv-expand bagexpansion=array EventData\n    | evaluate bag_unpack(EventData)\n    | extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n    | evaluate pivot(Key, any(Value), TimeGenerated, Computer, EventID)\n    | extend DestPort = column_ifexists(\"DestPort\", \"\"),\n          Direction = column_ifexists(\"Direction\", \"\"),\n          Application = column_ifexists(\"Application\", \"\"),\n          DestAddress = column_ifexists(\"DestAddress\", \"\"),\n          SourceAddress = column_ifexists(\"SourceAddress\", \"\"),\n          SourcePort = column_ifexists(\"SourcePort\", \"\")\n    // Look for inbound connections from endpoints on port 80\n    | where DestPort == 80 and Direction == '%%14592' and Application == 'System'\n    | where DestAddress !in ('::1','0:0:0:0:0:0:0:1') \n)\non $left.Computer == $right.Computer\n| project TimeGenerated, Computer, ClaimsName, SourceAddress, SourcePort\n| extend HostCustomEntity = Computer, AccountCustomEntity = ClaimsName, IPCustomEntity = SourceAddress\n", "attributes": {"description": "'This detection uses Security events from the \"AD FS Auditing\" provider to detect suspicious authentication events on an AD FS server. The results then get\ncorrelated with events from the Windows Filtering Platform (WFP) to detect suspicious incoming network traffic on port 80 on the AD FS server.\nThis could be a sign of a threat actor trying to use replication services on the AD FS server to get its configuration settings and extract\nsensitive information such as AD FS certificates.\nIn order to use this query you need to enable AD FS auditing on the AD FS Server.\nReferences: \nhttps://docs.microsoft.com/windows-server/identity/ad-fs/troubleshooting/ad-fs-tshoot-logging\nhttps://twitter.com/OTR_Community/status/1387038995016732672\n'\n", "techniques": ["T1005"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ADFSRemoteHTTPNetworkConnection.yaml", "query_name": "AD FS Remote HTTP Network Connection", "query": "// Adjust this to use a longer timeframe to identify ADFS servers\n//let lookback = 0d;\n// Adjust this to adjust detection timeframe\n//let timeframe = 1d;\n// Filter out other servers in the AD FS farm\nlet ADFSServersList = dynamic([\"ADFS02.domain.com\",\"ADFS03.domain.com\"]);\n// Start by identifying ADFS servers to reduce FP chance\nlet ADFS_Servers = (\nEvent\n//| where TimeGenerated > ago(timeframe+lookback)\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 18\n| where Computer !in (ADFSServersList)\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, MG, ManagementGroupName, _ResourceId)\n| extend Image = column_ifexists(\"Image\", \"\")\n| extend process = split(Image, '\\\\', -1)[-1]\n| where process =~ \"Microsoft.IdentityServer.ServiceHost.exe\"\n| summarize by Computer\n);\n// Look for ADFS servers receiving connections over port 80\nEvent\n//| where TimeGenerated > ago(timeframe)\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where Computer in~ (ADFS_Servers)\n| extend RenderedDescription = tostring(split(RenderedDescription, \":\")[0])\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, _ResourceId)\n| extend RuleName = column_ifexists(\"RuleName\", \"\"), TechniqueId = column_ifexists(\"TechniqueId\", \"\"),  TechniqueName = column_ifexists(\"TechniqueName\", \"\")\n| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName\n| where EventID == 3\n// Look for endpoints connecting to the AD FS server over port 80\n| extend DestinationPort = column_ifexists(\"DestinationPort\", \"\"), Image = column_ifexists(\"Image\", \"\"), Initiated = column_ifexists(\"Initiated\", \"\"), SourceIp = column_ifexists(\"DestinationIp\", \"\"), DestinationIp = column_ifexists(\"DestinationIp\", \"\")\n| where DestinationPort == 80\n| extend process = split(Image, '\\\\', -1)[-1]\n// Look for the System process receiving connections\n| where process == 'System' and Initiated == 'false'\n| where DestinationIp !in ('::1','0:0:0:0:0:0:0:1')\n| extend Operation = RenderedDescription\n| project-reorder TimeGenerated, Operation, Image, Computer, UserName\n| extend HostCustomEntity = Computer, AccountCustomEntity = UserName, IPCustomEntity = SourceIp\n", "attributes": {"description": "'This detection uses Sysmon events (NetworkConnect events) to detect incoming network traffic on port 80 on AD FS servers. This could be a sign of a threat actor\ntrying to use replication services on the AD FS server to get its configuration settings and extract sensitive information such as AD FS certificates.\nIn order to use this query you need to enable Sysmon telemetry on the AD FS Server.\nReference: https://twitter.com/OTR_Community/status/1387038995016732672\n'\n", "techniques": ["T1005"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/AdminSDHolder_Modifications.yaml", "query_name": "AdminSDHolder Modifications", "query": "SecurityEvent\n| where EventID == 5136 and EventData contains \"<Data Name=\\\"ObjectDN\\\">CN=AdminSDHolder,CN=System\"\n| parse EventData with * 'ObjectDN\">' ObjectDN \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Computer, SubjectAccount, SubjectUserSid, SubjectLogonId, ObjectDN\n", "attributes": {"description": "'This query detects modification in the AdminSDHolder  in the Active Directory which could indicate an attempt for persistence. \nAdminSDHolder Modification is a persistence technique in which an attacker abuses the SDProp process in Active Directory to establish a persistent backdoor to Active Directory.\nThis query searches for the event id 5136 where the Object DN is AdminSDHolder.\nRef: https://attack.stealthbits.com/adminsdholder-modification-ad-persistence'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/base64_encoded_pefile.yaml", "query_name": "Base64 encoded Windows process command-lines", "query": "\n\nlet ProcessCreationEvents=() {\nlet processEvents=(union isfuzzy=true\n(SecurityEvent\n| where EventID==4688\n| where isnotempty(CommandLine)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName,\nFileName = Process, CommandLine, ParentProcessName\n),\n(WindowsEvent\n| where EventID==4688\n| where EventData has \"TVqQAAMAAAAEAAA\"\n| extend CommandLine = tostring(EventData.CommandLine)\n| where isnotempty(CommandLine)\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName,\nFileName = Process, CommandLine, ParentProcessName));\nprocessEvents};\nProcessCreationEvents\n| where CommandLine contains \"TVqQAAMAAAAEAAA\"\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies instances of a base64 encoded PE file header seen in the process command line parameter.'\n", "techniques": ["T1059", "T1027", "T1140"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/CredentialDumpingServiceInstallation.yaml", "query_name": "Credential Dumping Tools - Service Installation", "query": "// Enter a reference list of decoy users (usernames) \"Case Sensitive\"\nlet MaliciousServiceArtifacts = dynamic ([\"fgexec\",\"cachedump\",\"mimikatz\",\"mimidrv\",\"wceservice\",\"pwdump\"]);\nEvent\n| where Source == \"Service Control Manager\" and EventID == 7045\n| parse EventData with * 'ServiceName\">' ServiceName \"<\" * 'ImagePath\">' ImagePath \"<\" *\n| where ServiceName has_any (MaliciousServiceArtifacts) or ImagePath has_any (MaliciousServiceArtifacts)\n| parse EventData with * 'AccountName\">' AccountName \"<\" *\n|summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, ServiceName, ImagePath, AccountName\n", "attributes": {"description": "'This query detects the installation of a Windows service that contains artifacts from credential dumping tools such as Mimikatz.\nRef: https://blueteamblog.com/darkside-ransomware-operations-preventions-and-detections'\n", "techniques": ["T1003.001"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/CredentialDumpingToolsFileArtifacts.yaml", "query_name": "Credential Dumping Tools - File Artifacts", "query": "// Enter a reference list of malicious file artifacts\nlet MaliciousFileArtifacts = dynamic ([\"lsass.dmp\",\"test.pwd\",\"lsremora.dll\",\"lsremora64.dll\",\"fgexec.exe\",\"pwdump\",\"kirbi\",\"wce_ccache\",\"wce_krbtkts\",\"wceaux.dll\",\"PwHashes\",\"SAM.out\",\"SECURITY.out\",\"SYSTEM.out\",\"NTDS.out\" \"DumpExt.dll\",\"DumpSvc.exe\",\"cachedump64.exe\",\"cachedump.exe\",\"pstgdump.exe\",\"servpw64.exe\",\"servpw.exe\",\"pwdump.exe\",\"fgdump-log\"]);\nEvent\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID==11\n| parse EventData with * 'TargetFilename\">' TargetFilename \"<\" *\n| where TargetFilename has_any (MaliciousFileArtifacts)\n| parse EventData with * 'ProcessGuid\">' ProcessGuid \"<\" * 'Image\">' Image \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, Image, ProcessGuid, TargetFilename\n", "attributes": {"description": "'This query detects the creation of credential dumping tools files. Several credential dumping tools export files with hardcoded file names.\nRef: https://jpcertcc.github.io/ToolAnalysisResultSheet/'\n", "techniques": ["T1003.001"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/DSRMAccountAbuse.yaml", "query_name": "DSRM Account Abuse", "query": "Event\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID in (13)\n| parse EventData with * 'TargetObject\">' TargetObject \"<\" * 'Details\">' Details \"<\" * \n| where TargetObject has (\"HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\Lsa\\\\DsrmAdminLogonBehavior\") and Details == \"DWORD (0x00000002)\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventID, Computer,  TargetObject, Details\n", "attributes": {"description": "'This query detects an abuse of the DSRM account in order to maintain persistence and access to the organization's Active Directory.\nRef: https://adsecurity.org/?p=1785'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/DumpingLSASSProcessIntoaFile.yaml", "query_name": "Dumping LSASS Process Into a File", "query": "Event\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID==10\n| parse EventData with * 'TargetImage\">' TargetImage \"<\" * 'GrantedAccess\">' GrantedAccess \"<\" * 'CallTrace\">' CallTrace \"<\" * \n| where GrantedAccess == \"0x1FFFFF\" and TargetImage == \"C:\\\\Windows\\\\System32\\\\lsass.exe\" and CallTrace has_any (\"dbghelp.dll\",\"dbgcore.dll\")\n| parse EventData with * 'SourceProcessGUID\">' SourceProcessGUID \"<\" * 'SourceImage\">' SourceImage \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, SourceProcessGUID, SourceImage, GrantedAccess, TargetImage, CallTrace\n", "attributes": {"description": "'Adversaries may attempt to access credential material stored in the process memory of the Local Security Authority Subsystem Service (LSASS). \nAfter a user logs on, the system generates and stores a variety of credential materials in LSASS process memory. \nThese credential materials can be harvested by an administrative user or SYSTEM and used to conduct Lateral Movement using Use Alternate Authentication Material. \nAs well as in-memory techniques, the LSASS process memory can be dumped from the target host and analyzed on a local system.\nRef: https://attack.mitre.org/techniques/T1003/001/'\n", "techniques": ["T1003.001"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ExcessiveLogonFailures.yaml", "query_name": "Excessive Windows logon failures", "query": "\nlet starttime = 8d;\nlet endtime = 1d;\nlet threshold = 0.333;\nlet countlimit = 50;\nSecurityEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4625 and AccountType =~ \"User\"\n| where IpAddress !in (\"127.0.0.1\", \"::1\")\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), CountToday = count() by EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress, Process\n| join kind=leftouter (\n    SecurityEvent \n    | where TimeGenerated between (ago(starttime) .. ago(endtime))\n    | where EventID == 4625 and AccountType =~ \"User\"\n    | where IpAddress !in (\"127.0.0.1\", \"::1\")\n    | summarize CountPrev7day = count() by EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress\n) on EventID, Account, LogonTypeName, SubStatus, AccountType, Computer, WorkstationName, IpAddress\n| where CountToday >= coalesce(CountPrev7day,0)*threshold and CountToday >= countlimit\n//SubStatus Codes are detailed here - https://docs.microsoft.com/windows/security/threat-protection/auditing/event-4625\n| extend Reason = case(\nSubStatus =~ '0xC000005E', 'There are currently no logon servers available to service the logon request.',\nSubStatus =~ '0xC0000064', 'User logon with misspelled or bad user account',\nSubStatus =~ '0xC000006A', 'User logon with misspelled or bad password',    \nSubStatus =~ '0xC000006D', 'Bad user name or password',\nSubStatus =~ '0xC000006E', 'Unknown user name or bad password',\nSubStatus =~ '0xC000006F', 'User logon outside authorized hours',\nSubStatus =~ '0xC0000070', 'User logon from unauthorized workstation',\nSubStatus =~ '0xC0000071', 'User logon with expired password',\nSubStatus =~ '0xC0000072', 'User logon to account disabled by administrator',\nSubStatus =~ '0xC00000DC', 'Indicates the Sam Server was in the wrong state to perform the desired operation',  \nSubStatus =~ '0xC0000133', 'Clocks between DC and other computer too far out of sync',\nSubStatus =~ '0xC000015B', 'The user has not been granted the requested logon type (aka logon right) at this machine',\nSubStatus =~ '0xC000018C', 'The logon request failed because the trust relationship between the primary domain and the trusted domain failed',\nSubStatus =~ '0xC0000192', 'An attempt was made to logon, but the Netlogon service was not started',\nSubStatus =~ '0xC0000193', 'User logon with expired account',\nSubStatus =~ '0xC0000224', 'User is required to change password at next logon',\nSubStatus =~ '0xC0000225', 'Evidently a bug in Windows and not a risk',\nSubStatus =~ '0xC0000234', 'User logon with account locked',\nSubStatus =~ '0xC00002EE', 'Failure Reason: An Error occurred during Logon',\nSubStatus =~ '0xC0000413', 'Logon Failure: The machine you are logging onto is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine',\nstrcat('Unknown reason substatus: ', SubStatus))\n| extend WorkstationName = iff(WorkstationName == \"-\" or isempty(WorkstationName), Computer , WorkstationName) \n| project StartTime, EndTime, EventID, Account, LogonTypeName, SubStatus, Reason, AccountType, Computer, WorkstationName, IpAddress, CountToday, CountPrev7day, Avg7Day = round(CountPrev7day*1.00/7,2), Process\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), Computer = make_set(Computer,128), IpAddressList = make_set(IpAddress,128), sum(CountToday), sum(CountPrev7day), avg(Avg7Day) \nby EventID, Account, LogonTypeName, SubStatus, Reason, AccountType, WorkstationName, Process\n| order by sum_CountToday desc nulls last \n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = WorkstationName\n", "attributes": {"description": "'User has over 50 Windows logon failures today and at least 33% of the count of logon failures over the previous 7 days.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ExchangeOABVirtualDirectoryAttributeContainingPotentialWebshell.yaml", "query_name": "Exchange OAB Virtual Directory Attribute Containing Potential Webshell", "query": "SecurityEvent\n// Look for specific Directory Service Changes and parse data\n| where EventID == 5136\n| extend EventData = parse_xml(EventData).EventData.Data\n| mv-expand bagexpansion = array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value),TimeGenerated, EventID, Computer, Account, AccountType, EventSourceName, Activity, SubjectAccount)\n// Where changes relate to Exchange OAB\n| extend ObjectClass = column_ifexists(\"ObjectClass\", \"\")\n| where ObjectClass =~ \"msExchOABVirtualDirectory\"\n// Look for InternalHostName or ExternalHostName properties being changed\n| extend AttributeLDAPDisplayName = column_ifexists(\"AttributeLDAPDisplayName\", \"\")\n| where AttributeLDAPDisplayName in (\"msExchExternalHostName\", \"msExchInternalHostName\")\n// Look for suspected webshell activity\n| extend AttributeValue = column_ifexists(\"AttributeValue\", \"\")\n| where AttributeValue has \"script\"\n| project-rename LastSeen = TimeGenerated\n| extend ObjectDN = column_ifexists(\"ObjectDN\", \"\")\n| project-reorder LastSeen, Computer, Account, ObjectDN, AttributeLDAPDisplayName, AttributeValue\n| extend timestamp = LastSeen, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'This query uses Windows Event ID 5136 in order to detect potential webshell deployment by exploitation of CVE-2021-27065.\nThis query looks for changes to the InternalHostName or ExternalHostName properties of Exchange OAB Virtual Directory objects in AD Directory Services\nwhere the new objects contain potential webshell objects. Ref: https://aka.ms/ExchangeVulns'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/execute_base64_decodedpayload.yaml", "query_name": "Process executed from binary hidden in Base64 encoded file", "query": "let ProcessCreationEvents=() {\nlet processEvents=(union isfuzzy=true\n(SecurityEvent\n| where EventID==4688\n| where isnotempty(CommandLine)\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, CommandLine, ParentProcessName\n),\n(WindowsEvent\n| where EventID==4688\n| where EventData has_any (\".decode('base64')\", \"base64 --decode\", \".decode64(\" )\n| extend CommandLine = tostring(EventData.CommandLine)\n| where isnotempty(CommandLine)\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend FileName=tostring(split(NewProcessName, '\\\\')[-1])\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, CommandLine, ParentProcessName\n));\nprocessEvents;\n};\nProcessCreationEvents \n| where CommandLine contains \".decode('base64')\"\n        or CommandLine contains \"base64 --decode\"\n        or CommandLine contains \".decode64(\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), CountToday = count() by Computer, Account, AccountDomain, FileName, CommandLine, ParentProcessName \n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'Encoding malicious software is a technique used to obfuscate files from detection. \nThe first CommandLine component is looking for Python decoding base64. \nThe second CommandLine component is looking for Bash/sh command line base64 decoding.\nThe third one is looking for Ruby decoding base64.'\n", "techniques": ["T1059", "T1027", "T1140"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/FakeComputerAccountCreated.yaml", "query_name": "Fake computer account created", "query": "SecurityEvent\n| where EventID == 4720 and TargetUserName endswith \"$\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Computer, SubjectUserName, SubjectUserSid, SubjectLogonId, TargetUserName, TargetSid\n", "attributes": {"description": "'This query detects domain user accounts creation (event ID 4720) where the username ends with $. \nAccounts that end with $ are normally domain computer accounts and when they are created the event ID 4741 is generated instead.\nRef: https://blog.menasec.net/2019/02/threat-hunting-6-hiding-in-plain-sights.html'\n", "techniques": ["T1564"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/GainCodeExecutionADFSViaSMB.yaml", "query_name": "Gain Code Execution on ADFS Server via SMB + Remote Service or Scheduled Task", "query": "let timeframe = 1d;\n// Adjust for a longer timeframe for identifying ADFS Servers\nlet lookback = 6d;\n// Identify ADFS Servers\nlet ADFS_Servers = (\nSecurityEvent\n| where TimeGenerated > ago(timeframe+lookback)\n| where EventID == 4688 and SubjectLogonId != \"0x3e4\"\n| where NewProcessName has \"Microsoft.IdentityServer.ServiceHost.exe\"\n| distinct Computer\n);\nSecurityEvent\n| where TimeGenerated > ago(timeframe)\n| where Computer in~ (ADFS_Servers)\n| where Account !endswith \"$\"\n// Check for scheduled task events\n| where EventID in (4697, 4698, 4699, 4700, 4701, 4702)\n| extend EventDataParsed = parse_xml(EventData)\n| extend SubjectLogonId = tostring(EventDataParsed.EventData.Data[3][\"#text\"])\n// Check specifically for access to IPC$ share and PIPE\\svcctl and PIPE\\atsvc for Service Control Services and Schedule Control Services\n| union (\n    SecurityEvent\n    | where TimeGenerated > ago(timeframe)\n    | where Computer in~ (ADFS_Servers)\n    | where Account !endswith \"$\"\n    | where EventID == 5145\n    | where RelativeTargetName =~ \"svcctl\" or RelativeTargetName  =~ \"atsvc\"\n)\n// Check for lateral movement\n| join kind=inner\n(SecurityEvent\n| where TimeGenerated > ago(timeframe)\n| where Account !endswith \"$\"\n| where EventID == 4624 and LogonType == 3\n) on $left.SubjectLogonId == $right.TargetLogonId\n| project TimeGenerated, Account, Computer, EventID, RelativeTargetName\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n", "attributes": {"description": "'This query detects instances where an attacker has gained the ability to execute code on an ADFS Server through SMB and Remote Service or Scheduled Task.'\n", "techniques": ["T1210"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/GroupCreatedAddedToPrivlegeGroup_1h.yaml", "query_name": "Group created then added to built in domain local or global group", "query": "let WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$\";\nlet GroupAddition = (union isfuzzy=true   \n(SecurityEvent \n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group  \n| where EventID in (\"4728\", \"4732\", \"4756\") \n| where AccountType =~ \"User\" and MemberName == \"-\"\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| where TargetSid !in (\"S-1-5-32-555\")\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, GroupAddComputer = Computer, GroupAddTargetAccount = TargetAccount, \nGroupAddTargetSid = TargetSid, GroupAddSubjectAccount = SubjectAccount, GroupAddSubjectUserSid = SubjectUserSid, GroupSid = MemberSid\n),\n(\nWindowsEvent \n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group  \n| where EventID in (\"4728\", \"4732\", \"4756\")  and not(EventData has \"S-1-5-32-555\")\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend Account = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend AccountType=case(Account endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n| extend MemberName = tostring(EventData.MemberName)\n| where AccountType =~ \"User\" and MemberName == \"-\"\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| extend TargetSid = tostring(EventData.TargetSid)\n| where TargetSid !in (\"S-1-5-32-555\")\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend MemberSid = tostring(EventData.MemberSid)\n| extend Activity= \"GroupAddActivity\"\n| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, GroupAddComputer = Computer, GroupAddTargetAccount = TargetAccount, \nGroupAddTargetSid = TargetSid, GroupAddSubjectAccount = Account, GroupAddSubjectUserSid = SubjectUserSid, GroupSid = MemberSid\n));\nlet GroupCreated = (union isfuzzy=true  \n(SecurityEvent\n// 4727 - A security-enabled global group was created\n// 4731 - A security-enabled local group was created\n// 4754 - A security-enabled universal group was created\n| where EventID in (\"4727\", \"4731\", \"4754\")\n| where AccountType =~ \"User\"\n| project GroupCreateTime = TimeGenerated, GroupCreateEventID = EventID, GroupCreateActivity = Activity, GroupCreateComputer = Computer, GroupCreateTargetAccount = TargetAccount, \nGroupCreateSubjectAccount = SubjectAccount, GroupCreateSubjectUserSid = SubjectUserSid, GroupSid = TargetSid\n),\n(WindowsEvent\n// 4727 - A security-enabled global group was created\n// 4731 - A security-enabled local group was created\n// 4754 - A security-enabled universal group was created\n| where EventID in (\"4727\", \"4731\", \"4754\")\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend Account = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend AccountType=case(Account endswith \"$\", \"Machine\", iff(SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", iff(isempty(SubjectUserSid), \"\", \"User\")))\n| where AccountType =~ \"User\"\n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend SubjectAccount = strcat(EventData.SubjectDomainName,\"\\\\\", EventData.SubjectUserName)  \n| extend TargetSid = tostring(EventData.TargetSid) \n| extend Activity= \"GroupAddActivity\"\n| project GroupCreateTime = TimeGenerated, GroupCreateEventID = EventID, GroupCreateActivity = Activity, GroupCreateComputer = Computer, GroupCreateTargetAccount = TargetAccount, \nGroupCreateSubjectAccount = SubjectAccount, GroupCreateSubjectUserSid = SubjectUserSid, GroupSid = TargetSid\n));\nGroupCreated\n| join (\nGroupAddition\n) on GroupSid \n| extend timestamp = GroupCreateTime, AccountCustomEntity = GroupCreateSubjectAccount, HostCustomEntity = GroupCreateComputer\n", "attributes": {"description": "'Identifies when a recently created Group was added to a privileged built in domain local group or global group such as the \nEnterprise Admins, Cert Publishers or DnsAdmins.  Be sure to verify this is an expected addition.\nReferences: For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/gte_6_FailedLogons_10m.yaml", "query_name": "Failed logon attempts by valid accounts within 10 mins", "query": "let threshold = 20;\nlet ReasontoSubStatus = datatable(SubStatus:string,Reason:string) [\n\"0xC000005E\", \"There are currently no logon servers available to service the logon request.\",\n\"0xC0000064\", \"User logon with misspelled or bad user account\", \n\"0xC000006A\", \"User logon with misspelled or bad password\",\n\"0xC000006D\", \"Bad user name or password\",\n\"0xC000006E\", \"Unknown user name or bad password\",\n\"0xC000006F\", \"User logon outside authorized hours\",\n\"0xC0000070\", \"User logon from unauthorized workstation\",\n\"0xC0000071\", \"User logon with expired password\",\n\"0xC0000072\", \"User logon to account disabled by administrator\",\n\"0xC00000DC\", \"Indicates the Sam Server was in the wrong state to perform the desired operation\",\n\"0xC0000133\", \"Clocks between DC and other computer too far out of sync\",\n\"0xC000015B\", \"The user has not been granted the requested logon type (aka logon right) at this machine\",\n\"0xC000018C\", \"The logon request failed because the trust relationship between the primary domain and the trusted domain failed\",\n\"0xC0000192\", \"An attempt was made to logon, but the Netlogon service was not started\",\n\"0xC0000193\", \"User logon with expired account\",\n\"0xC0000224\", \"User is required to change password at next logon\",\n\"0xC0000225\", \"Evidently a bug in Windows and not a risk\",\n\"0xC0000234\", \"User logon with account locked\",\n\"0xC00002EE\", \"Failure Reason: An Error occurred during Logon\",\n\"0xC0000413\", \"Logon Failure: The machine you are logging onto is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine\"\n];\n(union isfuzzy=true\n(SecurityEvent \n| where EventID == 4625\n| where AccountType =~ \"User\"\n| where SubStatus !='0xc0000064' and Account !in ('\\\\', '-\\\\-')\n// SubStatus '0xc0000064' signifies 'Account name does not exist'\n| extend ResourceId = column_ifexists(\"_ResourceId\", _ResourceId), SourceComputerId = column_ifexists(\"SourceComputerId\", SourceComputerId)\n| lookup ReasontoSubStatus on SubStatus\n| extend coalesce(Reason, strcat('Unknown reason substatus: ', SubStatus))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), FailedLogonCount = count() by EventID, \nActivity, Computer, Account, TargetAccount, TargetUserName, TargetDomainName, \nLogonType, LogonTypeName, LogonProcessName, Status, SubStatus, Reason, ResourceId, SourceComputerId, WorkstationName, IpAddress\n| where FailedLogonCount >= threshold\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n),\n(\n(WindowsEvent \n| where EventID == 4625 and not(EventData has '0xc0000064')\n| extend TargetAccount = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend TargetUserSid = tostring(EventData.TargetUserSid)\n| extend AccountType=case(EventData.TargetUserName endswith \"$\" or TargetUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(TargetUserSid), \"\", \"User\")\n| where AccountType =~ \"User\"\n| extend SubStatus = tostring(EventData.SubStatus)\n| where SubStatus !='0xc0000064' and TargetAccount !in ('\\\\', '-\\\\-')\n// SubStatus '0xc0000064' signifies 'Account name does not exist'\n| extend ResourceId = column_ifexists(\"_ResourceId\", _ResourceId), SourceComputerId = column_ifexists(\"SourceComputerId\", \"\")\n| lookup ReasontoSubStatus on SubStatus\n| extend coalesce(Reason, strcat('Unknown reason substatus: ', SubStatus))\n| extend Activity=\"4625 - An account failed to log on.\"\n| extend TargetUserName = tostring(EventData.TargetUserName)\n| extend TargetDomainName = tostring(EventData.TargetDomainName)\n| extend LogonType = tostring(EventData.LogonType)\n| extend Status= tostring(EventData.Status)\n| extend LogonProcessName = tostring(EventData.LogonProcessName)\n| extend WorkstationName = tostring(EventData.WorkstationName)\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend LogonTypeName=case(LogonType==2,\"2 - Interactive\", LogonType==3,\"3 - Network\", LogonType==4, \"4 - Batch\",LogonType==5, \"5 - Service\", LogonType==7, \"7 - Unlock\", LogonType==8, \"8 - NetworkCleartext\", LogonType==9, \"9 - NewCredentials\", LogonType==10, \"10 - RemoteInteractive\", LogonType==11, \"11 - CachedInteractive\",tostring(LogonType))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), FailedLogonCount = count() by EventID, \nActivity, Computer,  TargetAccount, TargetUserName, TargetDomainName, \nLogonType, LogonTypeName, LogonProcessName, Status, SubStatus, Reason, ResourceId, SourceComputerId, WorkstationName, IpAddress\n| where FailedLogonCount >= threshold\n| extend timestamp = StartTime, AccountCustomEntity = TargetAccount, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n)))\n", "attributes": {"description": "'Identifies when failed logon attempts are 20 or higher during a 10 minute period (2 failed logons per minute minimum) from valid account.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/HAFNIUMNewUMServiceChildProcess.yaml", "query_name": "HAFNIUM New UM Service Child Process", "query": "let lookback = 14d;\nlet timeframe = 1d;\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated > ago(lookback) and TimeGenerated < ago(timeframe)\n| where EventID == 4688\n| where ParentProcessName has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n| join kind=rightanti (\nSecurityEvent\n| where TimeGenerated > ago(timeframe)\n| where ParentProcessName has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n| where EventID == 4688) on NewProcessName\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n),\n(WindowsEvent\n| where TimeGenerated > ago(lookback) and TimeGenerated < ago(timeframe)\n| where EventID == 4688 and EventData has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| where ParentProcessName has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Account = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend IpAddress = tostring(EventData.IpAddress)\n| join kind=rightanti (\nWindowsEvent\n| where TimeGenerated > ago(timeframe)\n| where EventID == 4688  and EventData has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| where ParentProcessName has_any (\"umworkerprocess.exe\", \"UMService.exe\")\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Account = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend IpAddress = tostring(EventData.IpAddress)) on NewProcessName\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n))  \n", "attributes": {"description": "'This query looks for new processes being spawned by the Exchange UM service where that process has not previously been observed before. \nReference: https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/HAFNIUMSuspiciousUMServiceError.yaml", "query_name": "HAFNIUM Suspicious UM Service Error", "query": "Event\n| where EventLog =~ \"Application\"\n| where Source startswith \"MSExchange\"\n| where EventLevelName =~ \"error\"\n| where (RenderedDescription startswith \"Watson report\" and RenderedDescription contains \"umworkerprocess\" and RenderedDescription contains \"TextFormattingRunProperties\") or RenderedDescription startswith \"An unhandled exception occurred in a UM worker process\" or RenderedDescription startswith \"The Microsoft Exchange Unified Messaging service\" or RenderedDescription contains \"MSExchange Unified Messaging\"\n| where RenderedDescription !contains \"System.OutOfMemoryException\"\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer\n", "attributes": {"description": "'This query looks for errors that may indicate that an attacker is attempting to exploit a vulnerability in the service. \nReference: https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/LateralMovementViaDCOM.yaml", "query_name": "Lateral Movement via DCOM", "query": "Event\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID==1\n| parse EventData with * 'CommandLine\">' CommandLine \"<\" * 'ParentCommandLine\">' ParentCommandLine \"<\" *\n| where ParentCommandLine == \"C:\\\\Windows\\\\System32\\\\svchost.exe -k DcomLaunch\" and CommandLine == \"C:\\\\Windows\\\\System32\\\\mmc.exe -Embedding\"\n| parse EventData with * 'ProcessGuid\">' ProcessGuid \"<\" * 'Image\">' Image \"<\" * 'Description\">' Description \"<\" * 'CurrentDirectory\">' CurrentDirectory \"<\" * 'User\">' User \"<\" * 'LogonGuid\">' LogonGuid \"<\" * 'ParentProcessGuid\">' ParentProcessGuid \"<\" * 'ParentImage\">' ParentImage \"<\" * 'ParentCommandLine\">' ParentCommandLine \"<\" * 'ParentUser\">' ParentUser \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, User, ParentImage, ParentProcessGuid, ParentCommandLine, ParentUser, Image, ProcessGuid, CommandLine, Description\n", "attributes": {"description": "'This query detects a fairly uncommon attack technique using the Windows Distributed Component Object Model (DCOM) to make a remote execution call to another computer system and gain lateral movement throughout the network.\nRef: http://thenegative.zone/incident%20response/2017/02/04/MMC20.Application-Lateral-Movement-Analysis.html'\n", "techniques": ["T1021.003"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/LocalDeviceJoinInfoAndTransportKeyRegKeysAccess.yaml", "query_name": "AAD Local Device Join Information and Transport Key Registry Keys Access", "query": "// AADJoined or Register Device Registry Keys\nlet aadJoinRoot = \"\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\CloudDomainJoin\\\\JoinInfo\\\\\";\nlet aadRegisteredRoot = \"\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\WorkplaceJoin\";\n// Transport Key Registry Key\nlet keyTransportKey = \"\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Cryptography\\\\Ngc\\\\KeyTransportKey\\\\\";\n(union isfuzzy=true\n(\n// Access to Object Requested\nSecurityEvent\n| where EventID == '4656'\n| where EventData contains aadJoinRoot or EventData contains aadRegisteredRoot\n| extend EventData = parse_xml(EventData).EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Computer, EventID)\n| where ObjectType == 'Key'\n| where ObjectName startswith aadJoinRoot and SubjectLogonId != '0x3e7' //Local System\n| extend ProcessId = column_ifexists(\"ProcessId\", \"\"), Process = split(ProcessName, '\\\\', -1)[-1],Account = strcat(SubjectDomainName, \"\\\\\", SubjectUserName)\n| join kind=innerunique (\n    SecurityEvent\n    | where EventID == '4656'\n    | where EventData contains keyTransportKey\n    | extend EventData = parse_xml(EventData).EventData.Data\n    | mv-expand bagexpansion=array EventData\n    | evaluate bag_unpack(EventData)\n    | extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n    | evaluate pivot(Key, any(Value), TimeGenerated, Computer, EventID)\n    | extend ObjectName = column_ifexists(\"ObjectName\", \"\"),ObjectType = column_ifexists(\"ObjectType\", \"\")\n    | where ObjectType == 'Key'\n    | where ObjectName startswith keyTransportKey and SubjectLogonId != '0x3e7' //Local System\n    | extend ProcessId = column_ifexists(\"ProcessId\", \"\"), Process = split(ProcessName, '\\\\', -1)[-1],Account = strcat(SubjectDomainName, \"\\\\\", SubjectUserName)\n) on $left.Computer == $right.Computer and $left.SubjectLogonId == $right.SubjectLogonId and $left.ProcessId == $right.ProcessId\n| project TimeGenerated, Computer, Account, SubjectDomainName, SubjectUserName, SubjectLogonId, ObjectName, tostring(Process), ProcessName, ProcessId, EventID\n),\n// Accessing Object\n(\nSecurityEvent\n| where EventID == '4663'\n| where ObjectType == 'Key'\n| where (ObjectName startswith aadJoinRoot or ObjectName contains aadRegisteredRoot) and SubjectLogonId != '0x3e7' //Local System\n| extend Account = SubjectAccount\n| join kind=innerunique (\n    SecurityEvent\n    | where EventID == '4663'\n    | where ObjectType == 'Key'\n    | where ObjectName contains keyTransportKey and SubjectLogonId != '0x3e7' //Local System\n    | extend Account = SubjectAccount\n) on $left.Computer == $right.Computer and $left.SubjectLogonId == $right.SubjectLogonId and $left.ProcessId == $right.ProcessId\n| project TimeGenerated, Computer, Account, SubjectDomainName, SubjectUserName, SubjectLogonId, ObjectName, Process, ProcessName, ProcessId, EventID\n)\n)\n", "attributes": {"description": "'This detection uses Windows security events to detect suspicious access attempts by the same process\n to registry keys that provide information about an AAD joined or registered devices and Transport keys (tkpub / tkpriv).\n This information can be used to export the Device Certificate (dkpub / dkpriv) and Transport key (tkpub/tkpriv).\n These set of keys can be used to impersonate existing Azure AD joined devices.\n This detection requires an access control entry (ACE) on the system access control list (SACL) of the following securable objects:\n HKLM:\\SYSTEM\\CurrentControlSet\\Control\\CloudDomainJoin (AAD joined devices)\n HKCU:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WorkplaceJoin (AAD registered devices)\n HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Cryptography\\Ngc\\KeyTransportKey (Transport Key)\n Make sure you set the SACL to propagate to its sub-keys. You can find more information in here https://github.com/OTRF/Set-AuditRule/blob/master/rules/registry/aad_connect_health_service_agent.yml\n Reference: https://o365blog.com/post/deviceidentity/'\n", "techniques": ["T1012"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/MacroInvokingShellBrowserWindowCOMObjects.yaml", "query_name": "Detecting Macro Invoking ShellBrowserWindow COM Objects", "query": "Event\n | where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID==1\n | parse EventData with * 'Image\">' Image \"<\" * 'CommandLine\">' CommandLine \"<\" * 'ParentImage\">' ParentImage \"<\" *\n | where ParentImage has \"svchost.exe\" and Image has \"rundll32.exe\" and CommandLine has \"{c08afd90-f2a1-11d1-8455-00a0c91f3880}\"\n | parse EventData with * 'ProcessGuid\">' ProcessGuid \"<\" * 'Description\">' Description \"<\" * 'CurrentDirectory\">' CurrentDirectory \"<\" * 'User\">' User \"<\" * 'LogonGuid\">' LogonGuid \"<\" * 'ParentProcessGuid\">' ParentProcessGuid \"<\" * 'ParentImage\">' ParentImage \"<\" * 'ParentCommandLine\">' ParentCommandLine \"<\" * 'ParentUser\">' ParentUser \"<\" *\n | summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, User, ParentImage, ParentProcessGuid, ParentCommandLine, ParentUser, Image, ProcessGuid, CommandLine, Description\n", "attributes": {"description": "'This query detects a macro invoking ShellBrowserWindow COM Objects evade naive parent/child Office detection rules.\nRef: https://blog.menasec.net/2019/02/threat-hunting-doc-with-macro-invoking.html'\n", "techniques": ["T1021.003"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/malware_in_recyclebin.yaml", "query_name": "Malware in the recycle bin", "query": "let procList = externaldata(Process:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Microsoft_Lolbas_Execution_Binaries.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet ProcessCreationEvents=() {\nlet processEvents=(union isfuzzy=true\n(SecurityEvent\n| where EventID==4688\n| where isnotempty(CommandLine)\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, NewProcessName,\nFileName = Process, CommandLine,  ParentProcessName\n),\n(WindowsEvent\n| where EventID==4688 and EventData has_any (procList) and EventData has \":\\\\recycler\"\n| extend CommandLine = tostring(EventData.CommandLine)\n| where isnotempty(CommandLine)\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName) \n| extend NewProcessName = tostring(EventData.NewProcessName)  \n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, NewProcessName,\nFileName = Process, CommandLine,  ParentProcessName\n));\nprocessEvents};\nProcessCreationEvents \n| where FileName in~ (procList)\n| where CommandLine contains \":\\\\recycler\"\n| project StartTimeUtc = TimeGenerated, Computer, Account, NewProcessName, FileName, CommandLine, ParentProcessName\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'The query detects Windows binaries, that can be used for executing malware, that have been hidden in the recycle bin. \n The list of these binaries are sourced from https://lolbas-project.github.io/\n References: https://azure.microsoft.com/blog/how-azure-security-center-helps-reveal-a-cyberattack/.'\n", "techniques": NaN, "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/MultipleFailedFollowedBySuccess.yaml", "query_name": "SecurityEvent - Multiple authentication failures followed by a success", "query": "\nlet timeRange = 6h;\nlet authenticationWindow = 1h;\nlet authenticationThreshold = 5;\nSecurityEvent\n| where TimeGenerated > ago(timeRange)\n| where EventID == 4624 or EventID == 4625\n| where IpAddress != \"-\" and isnotempty(Account)\n| extend Outcome = iff(EventID == 4624, \"Success\", \"Failure\")\n// bin outcomes into 5 minute windows to reduce the volume of data\n| summarize OutcomeCount=count() by Account, IpAddress, Computer, Outcome, bin(TimeGenerated, 5m)\n| project TimeGenerated, Account, IpAddress, Computer, Outcome, OutcomeCount\n// sort ready for sessionizing - by account and time of the authentication outcome\n| sort by Account asc, TimeGenerated asc\n| serialize \n// sessionize into failure groupings until either the account changes or there is a success\n| extend SessionStartedUtc = row_window_session(TimeGenerated, timeRange, authenticationWindow, Account != prev(Account) or prev(Outcome) == \"Success\")\n// count the failures in each session\n| summarize FailureCountBeforeSuccess=sumif(OutcomeCount, Outcome == \"Failure\"), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), makelist(Outcome), makeset(Computer), makeset(IpAddress) by SessionStartedUtc, Account\n// the session must not start with a success, and must end with one\n| where array_index_of(list_Outcome, \"Success\") != 0\n| where array_index_of(list_Outcome, \"Success\") == array_length(list_Outcome) - 1\n| project-away SessionStartedUtc, list_Outcome \n// where the number of failures before the success is above the threshold \n| where FailureCountBeforeSuccess >= authenticationThreshold\n// expand out ip and computer for customer entity assignment\n| mvexpand set_IpAddress, set_Computer\n| extend IpAddress = tostring(set_IpAddress), Computer = tostring(set_Computer)\n| extend timestamp=StartTime, AccountCustomEntity=Account, HostCustomEntity=Computer, IPCustomEntity=IpAddress\n", "attributes": {"description": "'Identifies accounts who have failed to logon to the domain multiple times in a row, followed by a successful authentication\nwithin a short time frame. Multiple failed attempts followed by a success can be an indication of a brute force attempt or\npossible mis-configuration of a service account within an environment.\nThe lookback is set to 6h and the authentication window and threshold are set to 1h and 5, meaning we need to see a minimum\nof 5 failures followed by a success for an account within 1 hour to surface an alert.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/NewEXEdeployedviaDefaultDomainorDefaultDomainControllerPolicies.yaml", "query_name": "New EXE deployed via Default Domain or Default Domain Controller Policies", "query": "let known_processes = (\n  SecurityEvent\n  // If adjusting Query Period or Frequency update these\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where EventID == 4688\n  | where NewProcessName has_any (\"Policies\\\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\", \"Policies\\\\{31B2F340-016D-11D2-945F-00C04FB984F9}\")\n  | summarize by Process);\n  SecurityEvent\n  // If adjusting Query Period or Frequency update these\n  | where TimeGenerated > ago(1d)\n  | where EventID == 4688\n  | where NewProcessName has_any (\"Policies\\\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\", \"Policies\\\\{31B2F340-016D-11D2-945F-00C04FB984F9}\")\n  | where Process !in (known_processes)\n  // This will likely apply to multiple hosts so summarize these data\n  | summarize FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated) by Process, NewProcessName, CommandLine, Computer\n", "attributes": {"description": "'This detection highlights executables deployed to hosts via either the Default Domain or Default Domain Controller Policies. These policies apply to all hosts or Domain Controllers and best practice is that these policies should not be used for deployment of files.\nA threat actor may use these policies to deploy files or scripts to all hosts in a domain.'\n", "techniques": ["T1072", "T1570"], "tactics": ["Execution", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/NOBELIUM_SuspiciousRundll32Exec.yaml", "query_name": "NOBELIUM - suspicious rundll32.exe execution of vbscript", "query": "(union isfuzzy=true \n(SecurityEvent\n| where EventID == 4688\n| where Process =~ 'rundll32.exe' \n| where CommandLine has_all ('Execute','RegRead','window.close')\n| project TimeGenerated, Computer, Account, Process, NewProcessName, CommandLine, ParentProcessName, _ResourceId\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n),\n(WindowsEvent\n| where EventID == 4688 and EventData has 'rundll32.exe' and EventData has_any ('Execute','RegRead','window.close')\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| where Process =~ 'rundll32.exe' \n| extend CommandLine = tostring(EventData.CommandLine)\n| where CommandLine has_all ('Execute','RegRead','window.close')\n| extend Account =  strcat(EventData.SubjectDomainName,\"\\\\\", EventData.SubjectUserName)\n| extend ParentProcessName = tostring(EventData.ParentProcessName)  \n| project TimeGenerated, Computer, Account, Process, NewProcessName, CommandLine, ParentProcessName, _ResourceId\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n) )\n", "attributes": {"description": "'This query idenifies when rundll32.exe executes a specific set of inline VBScript commands\n References: https://www.microsoft.com/security/blog/2021/03/04/goldmax-goldfinder-sibot-analyzing-nobelium-malware/'\n", "techniques": ["T1547"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/NOBELIUM_SuspiciousScriptRegistryWrite.yaml", "query_name": "NOBELIUM - Script payload stored in Registry", "query": "let cmdTokens0 = dynamic(['vbscript','jscript']);\nlet cmdTokens1 = dynamic(['mshtml','RunHTMLApplication']);\nlet cmdTokens2 = dynamic(['Execute','CreateObject','RegRead','window.close']);\n(union isfuzzy=true \n(SecurityEvent\n| where TimeGenerated >= ago(14d)\n| where EventID == 4688\n| where CommandLine has @'\\Microsoft\\Windows\\CurrentVersion'\n| where not(CommandLine has_any (@'\\Software\\Microsoft\\Windows\\CurrentVersion\\Run', @'\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce'))\n// If you are receiving false positives, then it may help to make the query more strict by uncommenting one or both of the lines below to refine the matches\n//| where CommandLine has_any (cmdTokens0)\n//| where CommandLine has_all (cmdTokens1)\n| where CommandLine has_all (cmdTokens2)\n| project TimeGenerated, Computer, Account, Process, NewProcessName, CommandLine, ParentProcessName, _ResourceId\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n),\n(WindowsEvent\n| where TimeGenerated >= ago(14d)\n| where EventID == 4688 and EventData has_all(cmdTokens2) and  EventData has @'\\Microsoft\\Windows\\CurrentVersion'\n| where not(EventData has_any (@'\\Software\\Microsoft\\Windows\\CurrentVersion\\Run', @'\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce'))\n| extend CommandLine = tostring(EventData.CommandLine)\n| where CommandLine has @'\\Microsoft\\Windows\\CurrentVersion'\n| where not(CommandLine has_any (@'\\Software\\Microsoft\\Windows\\CurrentVersion\\Run', @'\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce'))\n// If you are receiving false positives, then it may help to make the query more strict by uncommenting one or both of the lines below to refine the matches\n//| where CommandLine has_any (cmdTokens0)\n//| where CommandLine has_all (cmdTokens1)\n| where CommandLine has_all (cmdTokens2)\n| extend Account =  strcat(EventData.SubjectDomainName,\"\\\\\", EventData.SubjectUserName)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| extend ParentProcessName = tostring(EventData.ParentProcessName)  \n| project TimeGenerated, Computer, Account, Process, NewProcessName, CommandLine, ParentProcessName, _ResourceId\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account))\n", "attributes": {"description": "'This query idenifies when a process execution commandline indicates that a registry value is written to allow for later execution a malicious script\n References: https://www.microsoft.com/security/blog/2021/03/04/goldmax-goldfinder-sibot-analyzing-nobelium-malware/'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/NonDCActiveDirectoryReplication.yaml", "query_name": "Non Domain Controller Active Directory Replication", "query": "// Enter a reference list of hostnames for your DC servers\n//let DCServersList = dynamic ([\"DC01.simulandlabs.com\",\"DC02.simulandlabs.com\"]);\nSecurityEvent\n//| where Computer in (DCServersList)\n| where EventID == 4662 and ObjectServer == 'DS'\n| where AccountType != 'Machine'\n| where Properties has '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2' //DS-Replication-Get-Changes\n    or Properties has '1131f6ad-9c07-11d1-f79f-00c04fc2dcd2' //DS-Replication-Get-Changes-All\n    or Properties has '89e95b76-444d-4c62-991a-0facbeda640c' //DS-Replication-Get-Changes-In-Filtered-Set\n| project TimeGenerated, Account, Activity, Properties, SubjectLogonId, Computer\n| join kind=leftouter\n(\n    SecurityEvent\n    //| where Computer in (DCServersList)\n    | where EventID == 4624 and LogonType == 3\n    | where AccountType != 'Machine'\n    | project TargetLogonId, IpAddress\n)\non $left.SubjectLogonId == $right.TargetLogonId\n| project-reorder TimeGenerated, Computer, Account, IpAddress\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, SourceAddress = IpAddress \n", "attributes": {"description": "This query detects potential attempts by non-computer accounts (non domain controllers) to retrieve/synchronize an active directory object leveraging directory replication services (DRS).\nA Domain Controller (computer account) would usually be performing these actions in a domain environment. Another detection rule can be created to cover domain controllers accounts doing at rare times.\nA domain user with privileged permissions to use directory replication services is rare. Ref: https://threathunterplaybook.com/notebooks/windows/06_credential_access/WIN-180815210510.html'\n", "techniques": ["T1003"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/NRT_base64_encoded_pefile.yaml", "query_name": "NRT Base64 encoded Windows process command-lines", "query": "SecurityEvent\n | where EventID==4688\n | where isnotempty(CommandLine)\n | where CommandLine contains \"TVqQAAMAAAAEAAA\"\n", "attributes": {"description": "'Identifies instances of a base64 encoded PE file header seen in the process command line parameter.'\n", "techniques": ["T1059", "T1027", "T1140"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/NRT_execute_base64_decodedpayload.yaml", "query_name": "NRT Process executed from binary hidden in Base64 encoded file", "query": "SecurityEvent\n| where EventID==4688\n| where isnotempty(CommandLine)\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, CommandLine, ParentProcessName\n| where CommandLine contains \".decode('base64')\"\n        or CommandLine contains \"base64 --decode\"\n        or CommandLine contains \".decode64(\"\n", "attributes": {"description": "'Encoding malicious software is a technique used to obfuscate files from detection.\nThe first CommandLine component is looking for Python decoding base64.\nThe second CommandLine component is looking for Bash/sh command line base64 decoding.\nThe third one is looking for Ruby decoding base64.'\n", "techniques": ["T1059", "T1027", "T1140"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/NRT_SecurityEventLogCleared.yaml", "query_name": "NRT Security Event log cleared", "query": "SecurityEvent\n| where EventID == 1102 and EventSourceName == \"Microsoft-Windows-Eventlog\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, EventID, Activity\n", "attributes": {"description": "'Checks for event id 1102 which indicates the security event log was cleared.\nIt uses Event Source Name \"Microsoft-Windows-Eventlog\" to avoid generating false positives from other sources, like AD FS servers for instance.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/password_never_expires.yaml", "query_name": "AD account with Don't Expire Password", "query": "\nunion isfuzzy=true \n(\n SecurityEvent\n | where EventID == 4738\n // 2089 value indicates the Don't Expire Password value has been set\n | where UserAccountControl has \"%%2089\" \n | extend Value_2089 = iff(UserAccountControl has \"%%2089\",\"'Don't Expire Password' - Enabled\", \"Not Changed\")\n // 2050 indicates that the Password Not Required value is NOT set, this often shows up at the same time as a 2089 and is the recommended value.  This value may not be in the event. \n | extend Value_2050 = iff(UserAccountControl has \"%%2050\",\"'Password Not Required' - Disabled\", \"Not Changed\")\n // If value %%2082 is present in the 4738 event, this indicates the account has been configured to logon WITHOUT a password. Generally you should only see this value when an account is created and only in Event 4720: Account Creation Event.  \n | extend Value_2082 = iff(UserAccountControl has \"%%2082\",\"'Password Not Required' - Enabled\", \"Not Changed\")\n | project StartTime = TimeGenerated, EventID, Activity, Computer, TargetAccount, TargetSid, AccountType, UserAccountControl, Value_2089, Value_2050, Value_2082, SubjectAccount\n | extend timestamp = StartTime, AccountCustomEntity = TargetAccount, HostCustomEntity = Computer\n ),\n (\n WindowsEvent\n | where EventID == 4738 and EventData has '2089'\n // 2089 value indicates the Don't Expire Password value has been set\n | extend UserAccountControl = tostring(EventData.UserAccountControl)\n | where UserAccountControl has \"%%2089\" \n | extend Value_2089 = iff(UserAccountControl has \"%%2089\",\"'Don't Expire Password' - Enabled\", \"Not Changed\")\n // 2050 indicates that the Password Not Required value is NOT set, this often shows up at the same time as a 2089 and is the recommended value.  This value may not be in the event. \n | extend Value_2050 = iff(UserAccountControl has \"%%2050\",\"'Password Not Required' - Disabled\", \"Not Changed\")\n // If value %%2082 is present in the 4738 event, this indicates the account has been configured to logon WITHOUT a password. Generally you should only see this value when an account is created and only in Event 4720: Account Creation Event.  \n | extend Value_2082 = iff(UserAccountControl has \"%%2082\",\"'Password Not Required' - Enabled\", \"Not Changed\")\n | extend Activity=\"4738 - A user account was changed.\"\n | extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n | extend TargetSid = tostring(EventData.TargetSid)\n | extend SubjectAccount = strcat(EventData.SubjectDomainName,\"\\\\\", EventData.SubjectUserName)\n | extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n | extend AccountType=case(SubjectAccount endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n | project StartTime = TimeGenerated, EventID, Activity, Computer, TargetAccount, TargetSid, AccountType, UserAccountControl, Value_2089, Value_2050, Value_2082, SubjectAccount\n | extend timestamp = StartTime, AccountCustomEntity = TargetAccount, HostCustomEntity = Computer\n )\n", "attributes": {"description": "'Identifies whenever a user account has the setting \"Password Never Expires\" in the user account properties selected.\nThis is indicated in Security event 4738 in the EventData item labeled UserAccountControl with an included value of %%2089.\n%%2089 resolves to \"Don't Expire Password - Enabled\".'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/password_not_set.yaml", "query_name": "AD user enabled and password not set within 48 hours", "query": "\nlet starttime = 3d;\nlet SecEvents = materialize ( SecurityEvent | where TimeGenerated >= ago(starttime)\n| where EventID in (4722,4723) | where TargetUserName !endswith \"$\"\n| project TimeGenerated, EventID, Activity, Computer, TargetAccount, TargetSid, SubjectAccount, SubjectUserSid);\nlet userEnable = SecEvents\n| extend EventID4722Time = TimeGenerated\n// 4722: User Account Enabled\n| where EventID == 4722\n| project Time_Event4722 = TimeGenerated, TargetAccount, TargetSid, SubjectAccount_Event4722 = SubjectAccount, SubjectUserSid_Event4722 = SubjectUserSid, Activity_4722 = Activity, Computer_4722 = Computer;\nlet userPwdSet = SecEvents\n// 4723: Attempt made by user to set password\n| where EventID == 4723\n| project Time_Event4723 = TimeGenerated, TargetAccount, TargetSid, SubjectAccount_Event4723 = SubjectAccount, SubjectUserSid_Event4723 = SubjectUserSid, Activity_4723 = Activity, Computer_4723 = Computer;\nuserEnable | join kind=leftouter userPwdSet on TargetAccount, TargetSid\n| extend PasswordSetAttemptDelta_Min = datetime_diff('minute', Time_Event4723, Time_Event4722)\n| where PasswordSetAttemptDelta_Min > 2880 or isempty(PasswordSetAttemptDelta_Min)\n| project-away TargetAccount1, TargetSid1\n| extend Reason = @\"User either has not yet attempted to set the initial password after account was enabled or it occurred after 48 hours\"\n| order by Time_Event4722 asc \n| extend timestamp = Time_Event4722, AccountCustomEntity = TargetAccount, HostCustomEntity = Computer_4722\n| project-reorder Time_Event4722, Time_Event4723, PasswordSetAttemptDelta_Min, TargetAccount, TargetSid\n", "attributes": {"description": "'Identifies when an account is enabled with a default password and the password is not set by the user within 48 hours.\nEffectively, there is an event 4722 indicating an account was enabled and within 48 hours, no event 4723 occurs which \nindicates there was no attempt by the user to set the password. This will show any attempts (success or fail) that occur \nafter 48 hours, which can indicate too long of a time period in setting the password to something that only the user knows.\nIt is recommended that this time period is adjusted per your internal company policy.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/PotenialResourceBasedConstrainedDelegationAbuse.yaml", "query_name": "Possible Resource-Based Constrained Delegation Abuse", "query": "SecurityEvent\n| where EventID == 5136 \n| parse EventData with * 'ObjectClass\">' ObjectClass \"<\" *\n| parse EventData with * 'AttributeLDAPDisplayName\">' AttributeLDAPDisplayName \"<\" *\n| where ObjectClass == \"computer\" and AttributeLDAPDisplayName == \"msDS-AllowedToActOnBehalfOfOtherIdentity\"\n| parse EventData with * 'ObjectDN\">' ObjectDN \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Computer, SubjectAccount, SubjectUserSid, SubjectLogonId, ObjectDN, AttributeLDAPDisplayName\n", "attributes": {"description": "'This query identifies Active Directory computer objects modifications that allow an adversary to abuse the Resource-based constrained delegation. \nThis query checks for event id 5136 that the Object Class field is \"computer\" and the LDAP Display Name is \"msDS-AllowedToActOnBehalfOfOtherIdentity\" which is an indicator of Resource-based constrained delegation.\nRef: https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html'\n", "techniques": ["T1134"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/PotentialBuildProcessCompromise.yaml", "query_name": "Potential Build Process Compromise", "query": "// How far back to look for events from\nlet timeframe = 1d;\n// How close together build events and file modifications should occur to alert (make this smaller to reduce FPs)\nlet time_window = 5m;\n// Edit this to include build processes used\nlet build_processes = dynamic([\"MSBuild.exe\", \"dotnet.exe\", \"VBCSCompiler.exe\"]);\n// Include any processes that you want to allow to edit files during/around the build process\nlet allow_list = dynamic([\"\"]);\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated > ago(timeframe)\n// Look for build process starts\n| where EventID == 4688\n| where Process has_any (build_processes)\n| summarize by BuildParentProcess=ParentProcessName, BuildProcess=Process, BuildAccount = Account, Computer, BuildCommand=CommandLine, timekey= bin(TimeGenerated, time_window), BuildProcessTime=TimeGenerated\n| join kind=inner(\nSecurityEvent\n| where TimeGenerated > ago(timeframe)\n// Look for file modifications to code file\n| where EventID == 4663\n| where Process !in (allow_list)\n// Look for code files, edit this to include file extensions used in build.\n| where ObjectName endswith \".cs\" or ObjectName endswith \".cpp\"\n// 0x6 and 0x4 for file append, 0x100 for file replacements\n| where AccessMask == \"0x6\"  or AccessMask == \"0x4\" or AccessMask == \"0X100\"\n| summarize by FileEditParentProcess=ParentProcessName, FileEditAccount = Account, Computer, FileEdited=ObjectName, FileEditProcess=ProcessName, timekey= bin(TimeGenerated, time_window), FileEditTime=TimeGenerated)\n// join where build processes and file modifications seen at same time on same host\non timekey, Computer\n// Limit to only where the file edit happens after the build process starts\n| where BuildProcessTime <= FileEditTime\n| summarize make_set(FileEdited), make_set(FileEditProcess), make_set(FileEditAccount) by timekey, Computer, BuildParentProcess, BuildProcess\n| extend HostCustomEntity=Computer, timestamp=timekey\n),\n(WindowsEvent\n| where TimeGenerated > ago(timeframe)\n// Look for build process starts\n| where EventID == 4688 and EventData has_any (build_processes)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| where Process has_any (build_processes)\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend CommandLine = tostring(EventData.CommandLine) \n| summarize by BuildParentProcess=ParentProcessName, BuildProcess=Process, BuildAccount = Account, Computer, BuildCommand=CommandLine, timekey= bin(TimeGenerated, time_window), BuildProcessTime=TimeGenerated\n| join kind=inner(\nWindowsEvent\n| where TimeGenerated > ago(timeframe)\n// Look for file modifications to code file\n| where EventID == 4663 and EventData has_any (\"0x6\", \"0x4\", \"0X100\") and EventData has_any (\".cs\", \".cpp\")\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| where Process !in (allow_list)\n// Look for code files, edit this to include file extensions used in build.\n| extend ObjectName = tostring(EventData.ObjectName)\n| where ObjectName endswith \".cs\" or ObjectName endswith \".cpp\"\n// 0x6 and 0x4 for file append, 0x100 for file replacements\n| extend AccessMask = tostring(EventData.AccessMask)  \n| where AccessMask == \"0x6\"  or AccessMask == \"0x4\" or AccessMask == \"0X100\"\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend ProcessName = tostring(EventData.ProcessName)\n| summarize by FileEditParentProcess=ParentProcessName, FileEditAccount = Account, Computer, FileEdited=ObjectName, FileEditProcess=ProcessName, timekey= bin(TimeGenerated, time_window), FileEditTime=TimeGenerated)\n// join where build processes and file modifications seen at same time on same host\non timekey, Computer\n// Limit to only where the file edit happens after the build process starts\n| where BuildProcessTime <= FileEditTime\n| summarize make_set(FileEdited), make_set(FileEditProcess), make_set(FileEditAccount) by timekey, Computer, BuildParentProcess, BuildProcess\n| extend HostCustomEntity=Computer, timestamp=timekey\n))\n", "attributes": {"description": "'The query looks for source code files being modified immediately after a build process is started. The purpose of this is to look for malicious code injection during the build process.\nMore details: https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-the-software-supply-chain-with-azure-sentinel/ba-p/2176463'\n", "techniques": ["T1554"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/PotentialFodhelperUACBypass.yaml", "query_name": "Potential Fodhelper UAC Bypass", "query": "SecurityEvent\n  | where EventID == 4657\n  | parse ObjectName with \"\\\\REGISTRY\\\\\" KeyPrefix \"\\\\\" RegistryKey\n  | project-reorder RegistryKey\n  | where RegistryKey has \"Software\\\\Classes\\\\ms-settings\\\\shell\\\\open\\\\command\"\n  | extend TimeKey = bin(TimeGenerated, 1h)\n  | join (\n  SecurityEvent\n  | where EventID == 4688\n  | where Process =~ \"fodhelper.exe\"\n  | where ParentProcessName endswith \"cmd.exe\" or ParentProcessName endswith \"powershell.exe\" or ParentProcessName endswith \"powershell_ise.exe\"\n  | extend TimeKey = bin(TimeGenerated, 1h)) on TimeKey, Computer\n", "attributes": {"description": "'This detection looks for the steps required to conduct a UAC bypass using Fodhelper.exe. By default this detection looks for the setting of the required registry keys and the invoking of the process within 1 hour - this can be tweaked as required.'\n", "techniques": ["T1548.002"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/PotentialKerberoast.yaml", "query_name": "Potential Kerberoasting", "query": "\nlet starttime = 1d;\nlet endtime = 1h;\nlet prev23hThreshold = 4;\nlet prev1hThreshold = 15;\nlet Kerbevent = (union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(starttime)\n| where EventID == 4769\n| parse EventData with * 'TicketEncryptionType\">' TicketEncryptionType \"<\" *\n| where TicketEncryptionType == '0x17'\n| parse EventData with * 'TicketOptions\">' TicketOptions \"<\" *\n| where TicketOptions == '0x40810000'\n| parse EventData with * 'Status\">' Status \"<\" *\n| where Status == '0x0'\n| parse EventData with * 'ServiceName\">' ServiceName \"<\" *\n| where ServiceName !contains \"$\" and ServiceName !contains \"krbtgt\" \n| parse EventData with * 'TargetUserName\">' TargetUserName \"<\" *\n| where TargetUserName !contains \"$@\" and TargetUserName !contains ServiceName\n| parse EventData with * 'IpAddress\">::ffff:' ClientIPAddress \"<\" *\n),\n(\nWindowsEvent\n| where TimeGenerated >= ago(starttime)\n| where EventID == 4769 and EventData has '0x17' and EventData has '0x40810000' and EventData has 'krbtgt'\n| extend TicketEncryptionType = tostring(EventData.TicketEncryptionType)\n| where TicketEncryptionType == '0x17'\n| extend TicketOptions = tostring(EventData.TicketOptions)\n| where TicketOptions == '0x40810000'\n| extend Status = tostring(EventData.Status)\n| where Status == '0x0'\n| extend ServiceName = tostring(EventData.ServiceName)\n| where ServiceName !contains \"$\" and ServiceName !contains \"krbtgt\"\n| extend TargetUserName = tostring(EventData.TargetUserName) \n| where TargetUserName !contains \"$@\" and TargetUserName !contains ServiceName\n| extend ClientIPAddress = tostring(EventData.IpAddress) \n));\nlet Kerbevent23h = Kerbevent\n| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)\n| summarize ServiceNameCountPrev23h = dcount(ServiceName), ServiceNameSet23h = makeset(ServiceName) \nby Computer, TargetUserName,TargetDomainName, ClientIPAddress, TicketOptions, TicketEncryptionType, Status\n| where ServiceNameCountPrev23h < prev23hThreshold;\nlet Kerbevent1h = \nKerbevent\n| where TimeGenerated >= ago(endtime)\n| summarize min(TimeGenerated), max(TimeGenerated), ServiceNameCountPrev1h = dcount(ServiceName), ServiceNameSet1h = makeset(ServiceName) \nby Computer, TargetUserName,TargetDomainName, ClientIPAddress, TicketOptions, TicketEncryptionType, Status;\nKerbevent1h \n| join kind=leftanti\n(\nKerbevent23h\n) on TargetUserName, TargetDomainName\n// Threshold value set above is based on testing, this value may need to be changed for your environment.\n| where ServiceNameCountPrev1h > prev1hThreshold\n| project StartTimeUtc = min_TimeGenerated, EndTimeUtc = max_TimeGenerated, TargetUserName, Computer, ClientIPAddress, TicketOptions, \nTicketEncryptionType, Status, ServiceNameCountPrev1h, ServiceNameSet1h, TargetDomainName\n| extend timestamp = StartTimeUtc, AccountCustomEntity = strcat(TargetDomainName,\"\\\\\", TargetUserName), HostCustomEntity = Computer, IPCustomEntity = ClientIPAddress\n", "attributes": {"description": "'A service principal name (SPN) is used to uniquely identify a service instance in a Windows environment. \nEach SPN is usually associated with a service account. Organizations may have used service accounts with weak passwords in their environment. \nAn attacker can try requesting Kerberos ticket-granting service (TGS) service tickets for any SPN from a domain controller (DC) which contains \na hash of the Service account. This can then be used for offline cracking. This hunting query looks for accounts that are generating excessive \nrequests to different resources within the last hour compared with the previous 24 hours.  Normal users would not make an unusually large number \nof request within a small time window. This is based on 4769 events which can be very noisy so environment based tweaking might be needed.'\n", "techniques": ["T1558"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/Potentialre-namedsdeleteusage.yaml", "query_name": "Potential re-named sdelete usage", "query": "SecurityEvent\n  | where EventID == 4688\n  | where Process !~ \"sdelete.exe\"\n  | where CommandLine has_all (\"accepteula\", \"-r\", \"-s\", \"-q\", \"c:/\")\n  | where CommandLine !has (\"sdelete\")\n", "attributes": {"description": "'This detection looks for command line parameters associated with the use of Sysinternals sdelete (https://docs.microsoft.com/sysinternals/downloads/sdelete) to delete multiple files on a host's C drive.\nA threat actor may re-name the tool to avoid detection and then use it for destructive attacks on a host.'\n", "techniques": ["T1485", "T1036"], "tactics": ["DefenseEvasion", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/PotentialRemoteDesktopTunneling.yaml", "query_name": "Potential Remote Desktop Tunneling", "query": "SecurityEvent\n   | where EventID in (4624,4625) and LogonType in (10) and IpAddress in (\"::1\",\"127.0.0.1\")\n   | summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, TargetUserName, TargetLogonId, LogonType, IpAddress\n", "attributes": {"description": "'This query detects remote desktop authentication attempts with a localhost source address which can indicate a tunneled login.\nRef: https://www.mandiant.com/resources/bypassing-network-restrictions-through-rdp-tunneling'\n", "techniques": ["T1572"], "tactics": ["CommandandControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/powershell_empire.yaml", "query_name": "Powershell Empire cmdlets seen in command line", "query": "\nlet regexEmpire = @\"SetDelay|GetDelay|Set-LostLimit|Get-LostLimit|Set-Killdate|Get-Killdate|Set-WorkingHours|Get-WorkingHours|Get-Sysinfo|Add-Servers|Invoke-ShellCommand|Start-AgentJob|Update-Profile|Get-FilePart|Encrypt-Bytes|Decrypt-Bytes|Encode-Packet|Decode-Packet|Send-Message|Process-Packet|Process-Tasking|Get-Task|Start-Negotiate|Invoke-DllInjection|Invoke-ReflectivePEInjection|Invoke-Shellcode|Invoke-ShellcodeMSIL|Get-ChromeDump|Get-ClipboardContents|Get-IndexedItem|Get-Keystrokes|Invoke-Inveigh|Invoke-NetRipper|local:Invoke-PatchDll|Invoke-NinjaCopy|Get-Win32Types|Get-Win32Constants|Get-Win32Functions|Sub-SignedIntAsUnsigned|Add-SignedIntAsUnsigned|Compare-Val1GreaterThanVal2AsUInt|Convert-UIntToInt|Test-MemoryRangeValid|Write-BytesToMemory|Get-DelegateType|Get-ProcAddress|Enable-SeDebugPrivilege|Invoke-CreateRemoteThread|Get-ImageNtHeaders|Get-PEBasicInfo|Get-PEDetailedInfo|Import-DllInRemoteProcess|Get-RemoteProcAddress|Copy-Sections|Update-MemoryAddresses|Import-DllImports|Get-VirtualProtectValue|Update-MemoryProtectionFlags|Update-ExeFunctions|Copy-ArrayOfMemAddresses|Get-MemoryProcAddress|Invoke-MemoryLoadLibrary|Invoke-MemoryFreeLibrary|Out-Minidump|Get-VaultCredential|Invoke-DCSync|Translate-Name|Get-NetDomain|Get-NetForest|Get-NetForestDomain|Get-DomainSearcher|Get-NetComputer|Get-NetGroupMember|Get-NetUser|Invoke-Mimikatz|Invoke-PowerDump|Invoke-TokenManipulation|Exploit-JMXConsole|Exploit-JBoss|Invoke-Thunderstruck|Invoke-VoiceTroll|Set-WallPaper|Invoke-PsExec|Invoke-SSHCommand|Invoke-PSInject|Invoke-RunAs|Invoke-SendMail|Invoke-Rule|Get-OSVersion|Select-EmailItem|View-Email|Get-OutlookFolder|Get-EmailItems|Invoke-MailSearch|Get-SubFolders|Get-GlobalAddressList|Invoke-SearchGAL|Get-SMTPAddress|Disable-SecuritySettings|Reset-SecuritySettings|Get-OutlookInstance|New-HoneyHash|Set-MacAttribute|Invoke-PatchDll|Get-SecurityPackages|Install-SSP|Invoke-BackdoorLNK|New-ElevatedPersistenceOption|New-UserPersistenceOption|Add-Persistence|Invoke-CallbackIEX|Add-PSFirewallRules|Invoke-EventLoop|Invoke-PortBind|Invoke-DNSLoop|Invoke-PacketKnock|Invoke-CallbackLoop|Invoke-BypassUAC|Get-DecryptedCpassword|Get-GPPInnerFields|Invoke-WScriptBypassUAC|Get-ModifiableFile|Get-ServiceUnquoted|Get-ServiceFilePermission|Get-ServicePermission|Invoke-ServiceUserAdd|Invoke-ServiceCMD|Write-UserAddServiceBinary|Write-CMDServiceBinary|Write-ServiceEXE|Write-ServiceEXECMD|Restore-ServiceEXE|Invoke-ServiceStart|Invoke-ServiceStop|Invoke-ServiceEnable|Invoke-ServiceDisable|Get-ServiceDetail|Find-DLLHijack|Find-PathHijack|Write-HijackDll|Get-RegAlwaysInstallElevated|Get-RegAutoLogon|Get-VulnAutoRun|Get-VulnSchTask|Get-UnattendedInstallFile|Get-Webconfig|Get-ApplicationHost|Write-UserAddMSI|Invoke-AllChecks|Invoke-ThreadedFunction|Test-Login|Get-UserAgent|Test-Password|Get-ComputerDetails|Find-4648Logons|Find-4624Logons|Find-AppLockerLogs|Find-PSScriptsInPSAppLog|Find-RDPClientConnections|Get-SystemDNSServer|Invoke-Paranoia|Invoke-WinEnum{|Get-SPN|Invoke-ARPScan|Invoke-Portscan|Invoke-ReverseDNSLookup|Invoke-SMBScanner|New-InMemoryModule|Add-Win32Type|Export-PowerViewCSV|Get-MacAttribute|Copy-ClonedFile|Get-IPAddress|Convert-NameToSid|Convert-SidToName|Convert-NT4toCanonical|Get-Proxy|Get-PathAcl|Get-NameField|Convert-LDAPProperty|Get-NetDomainController|Add-NetUser|Add-NetGroupUser|Get-UserProperty|Find-UserField|Get-UserEvent|Get-ObjectAcl|Add-ObjectAcl|Invoke-ACLScanner|Get-GUIDMap|Get-ADObject|Set-ADObject|Get-ComputerProperty|Find-ComputerField|Get-NetOU|Get-NetSite|Get-NetSubnet|Get-DomainSID|Get-NetGroup|Get-NetFileServer|SplitPath|Get-DFSshare|Get-DFSshareV1|Get-DFSshareV2|Get-GptTmpl|Get-GroupsXML|Get-NetGPO|Get-NetGPOGroup|Find-GPOLocation|Find-GPOComputerAdmin|Get-DomainPolicy|Get-NetLocalGroup|Get-NetShare|Get-NetLoggedon|Get-NetSession|Get-NetRDPSession|Invoke-CheckLocalAdminAccess|Get-LastLoggedOn|Get-NetProcess|Find-InterestingFile|Invoke-CheckWrite|Invoke-UserHunter|Invoke-StealthUserHunter|Invoke-ProcessHunter|Invoke-EventHunter|Invoke-ShareFinder|Invoke-FileFinder|Find-LocalAdminAccess|Get-ExploitableSystem|Invoke-EnumerateLocalAdmin|Get-NetDomainTrust|Get-NetForestTrust|Find-ForeignUser|Find-ForeignGroup|Invoke-MapDomainTrust|Get-Hex|Create-RemoteThread|Get-FoxDump|Decrypt-CipherText|Get-Screenshot|Start-HTTP-Server|Local:Invoke-CreateRemoteThread|Local:Get-Win32Functions|Local:Inject-NetRipper|GetCommandLine|ElevatePrivs|Get-RegKeyClass|Get-BootKey|Get-HBootKey|Get-UserName|Get-UserHashes|DecryptHashes|DecryptSingleHash|Get-UserKeys|DumpHashes|Enable-SeAssignPrimaryTokenPrivilege|Enable-Privilege|Set-DesktopACLs|Set-DesktopACLToAllowEveryone|Get-PrimaryToken|Get-ThreadToken|Get-TokenInformation|Get-UniqueTokens|Find-GPOLocation|Find-GPOComputerAdmin|Get-DomainPolicy|Get-NetLocalGroup|Get-NetShare|Get-NetLoggedon|Get-NetSession|Get-NetRDPSession|Invoke-CheckLocalAdminAccess|Get-LastLoggedOn|Get-NetProcess|Find-InterestingFile|Invoke-CheckWrite|Invoke-UserHunter|Invoke-StealthUserHunter|Invoke-ProcessHunter|Invoke-EventHunter|Invoke-ShareFinder|Invoke-FileFinder|Find-LocalAdminAccess|Get-ExploitableSystem|Invoke-EnumerateLocalAdmin|Get-NetDomainTrust|Get-NetForestTrust|Find-ForeignUser|Find-ForeignGroup|Invoke-MapDomainTrust|Get-Hex|Create-RemoteThread|Get-FoxDump|Decrypt-CipherText|Get-Screenshot|Start-HTTP-Server|Local:Invoke-CreateRemoteThread|Local:Get-Win32Functions|Local:Inject-NetRipper|GetCommandLine|ElevatePrivs|Get-RegKeyClass|Get-BootKey|Get-HBootKey|Get-UserName|Get-UserHashes|DecryptHashes|DecryptSingleHash|Get-UserKeys|DumpHashes|Enable-SeAssignPrimaryTokenPrivilege|Enable-Privilege|Set-DesktopACLs|Set-DesktopACLToAllowEveryone|Get-PrimaryToken|Get-ThreadToken|Get-TokenInformation|Get-UniqueTokens|Invoke-ImpersonateUser|Create-ProcessWithToken|Free-AllTokens|Enum-AllTokens|Invoke-RevertToSelf|Set-Speaker\\(\\$Volume\\){\\$wshShell|Local:Get-RandomString|Local:Invoke-PsExecCmd|Get-GPPPassword|Local:Inject-BypassStuff|Local:Invoke-CopyFile\\(\\$sSource,|ind-Fruit|New-IPv4Range|New-IPv4RangeFromCIDR|Parse-Hosts|Parse-ILHosts|Exclude-Hosts|Get-TopPort|Parse-Ports|Parse-IpPorts|Remove-Ports|Write-PortscanOut|Convert-SwitchtoBool|Get-ForeignUser|Get-ForeignGroup\";\n(union isfuzzy=true\n (SecurityEvent\n| where EventID == 4688\n//consider filtering on filename if perf issues occur\n//where FileName in~ (\"powershell.exe\",\"powershell_ise.exe\",\"pwsh.exe\")\n| where not(ParentProcessName has_any ('gc_worker.exe', 'gc_service.exe'))\n| where CommandLine has \"-encodedCommand\"\n| parse kind=regex flags=i CommandLine with * \"-EncodedCommand \" encodedCommand\n| extend encodedCommand = iff(encodedCommand has \" \", tostring(split(encodedCommand, \" \")[0]), encodedCommand)\n// Note: currently the base64_decode_tostring function is limited to supporting UTF8\n| extend decodedCommand = translate('\\0','', base64_decode_tostring(substring(encodedCommand, 0, strlen(encodedCommand) -  (strlen(encodedCommand) %8)))), encodedCommand, CommandLine , strlen(encodedCommand)\n| extend EfectiveCommand = iff(isnotempty(encodedCommand), decodedCommand, CommandLine)\n| where EfectiveCommand matches regex regexEmpire\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, EfectiveCommand, decodedCommand, encodedCommand, CommandLine, ParentProcessName\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(WindowsEvent\n| where EventID == 4688 \n| where EventData has_any (\"-encodedCommand\", \"powershell.exe\",\"powershell_ise.exe\",\"pwsh.exe\")\n| where not(EventData has_any ('gc_worker.exe', 'gc_service.exe'))\n//consider filtering on filename if perf issues occur\n//extend NewProcessName = tostring(EventData.NewProcessName)\n//extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n//FileName = Process\n//where FileName in~ (\"powershell.exe\",\"powershell_ise.exe\",\"pwsh.exe\")\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| where not(ParentProcessName has_any ('gc_worker.exe', 'gc_service.exe'))\n| extend CommandLine = tostring(EventData.CommandLine)\n| where CommandLine has \"-encodedCommand\"\n| parse kind=regex flags=i CommandLine with * \"-EncodedCommand \" encodedCommand\n| extend encodedCommand = iff(encodedCommand has \" \", tostring(split(encodedCommand, \" \")[0]), encodedCommand)\n// Note: currently the base64_decode_tostring function is limited to supporting UTF8\n| extend decodedCommand = translate('\\0','', base64_decode_tostring(substring(encodedCommand, 0, strlen(encodedCommand) -  (strlen(encodedCommand) %8)))), encodedCommand, CommandLine , strlen(encodedCommand)\n| extend EfectiveCommand = iff(isnotempty(encodedCommand), decodedCommand, CommandLine)\n| where EfectiveCommand matches regex regexEmpire\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| project TimeGenerated, Computer, Account = SubjectUserName, AccountDomain = SubjectDomainName, FileName = Process, EfectiveCommand, decodedCommand, encodedCommand, CommandLine, ParentProcessName\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n))\n", "attributes": {"description": "'Identifies instances of PowerShell Empire cmdlets in powershell process command line data.'\n", "techniques": NaN, "tactics": ["Execution", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/RDP_MultipleConnectionsFromSingleSystem.yaml", "query_name": "Multiple RDP connections from Single System", "query": "\nlet endtime = 1d;\nlet starttime = 8d;\nlet threshold = 2.0;\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and LogonType == 10\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ComputerCountToday = dcount(Computer), ComputerSet = makeset(Computer), ProcessSet = makeset(ProcessName)\nby Account, IpAddress, AccountType, Activity, LogonTypeName),\n(WindowsEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 \n| extend LogonType = tostring(EventData.LogonType)\n| where  LogonType == 10\n| extend ProcessName = tostring(EventData.ProcessName)\n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend TargetUserSid = tostring(EventData.TargetUserSid)\n| extend AccountType=case(Account endswith \"$\" or TargetUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(TargetUserSid), \"\", \"User\")\n| extend Activity=\"4624 - An account was successfully logged on.\"\n| extend LogonTypeName=\"10 - RemoteInteractive\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ComputerCountToday = dcount(Computer), ComputerSet = makeset(Computer), ProcessSet = makeset(ProcessName)\nby Account, IpAddress, AccountType, Activity, LogonTypeName)\n)\n| join kind=inner (\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)\n| where EventID == 4624 and LogonType == 10\n| summarize ComputerCountPrev7Days = dcount(Computer) by Account = tolower(Account), IpAddress\n),\n( WindowsEvent\n| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)\n| where EventID == 4624  and EventData has (\"10\")\n| extend LogonType = toint(EventData.LogonType)\n| where  LogonType == 10\n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend IpAddress = tostring(EventData.IpAddress)\n| summarize ComputerCountPrev7Days = dcount(Computer) by Account = tolower(Account), IpAddress)\n)\n) on Account, IpAddress\n| extend Ratio = iff(isempty(ComputerCountPrev7Days), toreal(ComputerCountToday), ComputerCountToday / (ComputerCountPrev7Days * 1.0))\n// Where the ratio of today to previous 7 days is more than double.\n| where Ratio > threshold\n| project StartTimeUtc, EndTimeUtc, Account, IpAddress, ComputerSet, ComputerCountToday, ComputerCountPrev7Days, Ratio, AccountType, Activity, LogonTypeName, ProcessSet\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Identifies when an RDP connection is made to multiple systems and above the normal for the previous 7 days.\nConnections from the same system with the same account within the same day.\nRDP connections are indicated by the EventID 4624 with LogonType = 10'\n", "techniques": ["T1021"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/RDP_Nesting.yaml", "query_name": "RDP Nesting", "query": "\nlet endtime = 1d;\nlet starttime = 8d;\n// The threshold below excludes matching on RDP connection computer counts of 5 or more by a given account and IP in a given day.  Change the threshold as needed.\nlet threshold = 5;\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and LogonType == 10\n// Labeling the first RDP connection time, computer and ip\n| extend FirstHop = TimeGenerated, FirstComputer = toupper(Computer), FirstIPAddress = IpAddress, Account = tolower(Account)\n),\n( WindowsEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and EventData has (\"10\")\n| extend LogonType = tostring(EventData.LogonType)\n| where  LogonType == 10  // Labeling the first RDP connection time, computer and ip\n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend FirstHop = TimeGenerated, FirstComputer = toupper(Computer), FirstIPAddress = IpAddress, Account = tolower(Account)\n))\n| join kind=inner (\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and LogonType == 10\n// Labeling the second RDP connection time, computer and ip\n| extend SecondHop = TimeGenerated, SecondComputer = toupper(Computer), SecondIPAddress = IpAddress, Account = tolower(Account)\n),\n(WindowsEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and EventData has (\"10\")\n| extend LogonType = toint(EventData.LogonType)\n| where  LogonType == 10   // Labeling the second RDP connection time, computer and ip\n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend SecondHop = TimeGenerated, SecondComputer = toupper(Computer), SecondIPAddress = IpAddress, Account = tolower(Account)\n))\n) on Account\n// Make sure that the first connection is after the second connection --> SecondHop > FirstHop\n// Then identify only RDP to another computer from within the first RDP connection by only choosing matches where the Computer names do not match --> FirstComputer != SecondComputer\n// Then make sure the IPAddresses do not match by excluding connections from the same computers with first hop RDP connections to multiple computers --> FirstIPAddress != SecondIPAddress\n| where FirstComputer != SecondComputer and FirstIPAddress != SecondIPAddress and SecondHop > FirstHop\n// where the second hop occurs within 30 minutes of the first hop\n| where SecondHop <= FirstHop+30m\n| distinct Account, FirstHop, FirstComputer, FirstIPAddress, SecondHop, SecondComputer, SecondIPAddress, AccountType, Activity, LogonTypeName, ProcessName\n// use left anti to exclude anything from the previous 7 days where the Account and IP has connected 5 or more computers.\n| join kind=leftanti (\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)\n| where EventID == 4624 and LogonType == 10\n| summarize makeset(Computer), ComputerCount = dcount(Computer) by bin(TimeGenerated, 1d), Account = tolower(Account), IpAddress\n// Connection count to computer by same account and IP to exclude counts of 5 or more on a given day\n| where ComputerCount >= threshold\n| mvexpand set_Computer\n| extend Computer = toupper(set_Computer)\n),\n(WindowsEvent\n| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)\n| where EventID == 4624 and EventData has (\"10\")\n| extend LogonType = tostring(EventData.LogonType)\n| where  LogonType == 10 \n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend IpAddress = tostring(EventData.IpAddress)\n| summarize makeset(Computer), ComputerCount = dcount(Computer) by bin(TimeGenerated, 1d), Account = tolower(Account), IpAddress\n// Connection count to computer by same account and IP to exclude counts of 5 or more on a given day\n| where ComputerCount >= threshold\n| mvexpand set_Computer\n| extend Computer = toupper(set_Computer)\n))\n) on Account, $left.SecondComputer == $right.Computer, $left.SecondIPAddress == $right.IpAddress\n| summarize FirstHopFirstSeen = min(FirstHop), FirstHopLastSeen = max(FirstHop) by Account, FirstComputer, FirstIPAddress, SecondHop, SecondComputer, \nSecondIPAddress, AccountType, Activity, LogonTypeName, ProcessName\n| extend timestamp = FirstHopFirstSeen, AccountCustomEntity = Account, HostCustomEntity = FirstComputer, IPCustomEntity = FirstIPAddress\n", "attributes": {"description": "'Identifies when an RDP connection is made to a first system and then an RDP connection is made from the first system\nto another system with the same account within the 60 minutes. Additionally, if historically daily\nRDP connections are indicated by the logged EventID 4624 with LogonType = 10'\n", "techniques": ["T1021"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/RDP_RareConnection.yaml", "query_name": "Rare RDP Connections", "query": "\nlet starttime = 14d;\nlet endtime = 1d;\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and LogonType == 10\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ConnectionCount = count()\nby Account = tolower(Account), Computer = toupper(Computer), IpAddress, AccountType, Activity, LogonTypeName, ProcessName\n// use left anti to exclude anything from the previous 14 days that is not rare\n),\n(WindowsEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and EventData has (\"10\")\n| extend LogonType = tostring(EventData.LogonType)\n| where  LogonType == 10 \n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend ProcessName = tostring(EventData.ProcessName)\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend TargetUserSid = tostring(EventData.TargetUserSid)\n| extend AccountType=case(Account endswith \"$\" or TargetUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(TargetUserSid), \"\", \"User\")\n| extend Activity=\"4624 - An account was successfully logged on.\"\n| extend LogonTypeName=\"10 - RemoteInteractive\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ConnectionCount = count()\nby Account = tolower(Account), Computer = toupper(Computer), IpAddress, AccountType, Activity, LogonTypeName, ProcessName\n))\n| join kind=leftanti (\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where EventID == 4624\n| summarize by Computer = toupper(Computer), IpAddress, Account = tolower(Account)\n),\n( WindowsEvent\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where EventID == 4624\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| summarize by Computer = toupper(Computer), IpAddress, Account = tolower(Account)\n))\n) on Account, Computer\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), ConnectionCount = sum(ConnectionCount)\nby Account, Computer, IpAddress, AccountType, Activity, LogonTypeName, ProcessName\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Identifies when an RDP connection is new or rare related to any logon type by a given account today based on comparison with the previous 14 days.\nRDP connections are indicated by the EventID 4624 with LogonType = 10'\n", "techniques": ["T1021"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/RegistryPersistenceViaAppCertDLLModification.yaml", "query_name": "Registry Persistence via AppCert DLL Modification", "query": "Event\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID in (13)\n| parse EventData with * 'TargetObject\">' TargetObject \"<\" * 'Details\">' Details \"<\" * \n| where TargetObject has (\"\\\\Control\\\\Session Manager\\\\AppCertDLLs\\\\\")\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventID, Computer,  TargetObject, Details\n", "attributes": {"description": "'Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppCert DLLs loaded into processes. \nDynamic-link libraries (DLLs) that are specified in the AppCertDLLs Registry key under HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\ are loaded into every process that calls the ubiquitously used application programming interface (API) functions CreateProcess, CreateProcessAsUser, CreateProcessWithLoginW, CreateProcessWithTokenW, or WinExec.\nRef: https://attack.mitre.org/techniques/T1546/009/'\n", "techniques": ["T1546.009"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/RegistryPersistenceViaAppInt_DLLsModification.yaml", "query_name": "Registry Persistence via AppInit DLLs Modification", "query": "Event\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID in (13)\n| parse EventData with * 'TargetObject\">' TargetObject \"<\" * 'Details\">' Details \"<\" * \n| where TargetObject has \"\\\\Windows NT\\\\CurrentVersion\\\\Windows\\\\AppInit_DLLs\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventID, Computer, TargetObject, Details\n", "attributes": {"description": "'Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppInit DLLs loaded into processes. \nDynamic-link libraries (DLLs) that are specified in the AppInit_DLLs value in the Registry keys HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows or HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows are loaded by user32.dll into every process that loads user32.dll. In practice this is nearly every program, since user32.dll is a very common library.\nRef: https://attack.mitre.org/techniques/T1546/010/'\n", "techniques": ["T1546.010"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/ScheduleTaskHide.yaml", "query_name": "Scheduled Task Hide", "query": "SecurityEvent\n| where EventID == 4657\n| extend EventData = parse_xml(EventData).EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, TargetAccount, Computer, EventSourceName, Channel, Task, Level, EventID, Activity, TargetLogonId, SourceComputerId, EventOriginId, Type, _ResourceId, TenantId, SourceSystem, ManagementGroupName, IpAddress, Account)\n| extend ObjectName = column_ifexists('ObjectName', \"\"), OperationType = column_ifexists('OperationType', \"\"), ObjectValueName = column_ifexists('ObjectValueName', \"\")\n| where ObjectName has 'Schedule\\\\TaskCache\\\\Tree' and ObjectValueName == \"SD\" and OperationType == \"%%1906\"  // %%1906 - Registry value deleted\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n", "attributes": {"description": "'This query detects attempts by malware to hide the scheduled task by deleting the SD (Security Descriptor) value. Removal of SD value results in the scheduled task disappearing from schtasks /query and Task Scheduler.\n The query requires auditing to be turned on for HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree registry hive as well as audit policy for registry auditing to be turned on.\n Reference: https://www.microsoft.com/security/blog/2022/04/12/tarrask-malware-uses-scheduled-tasks-for-defense-evasion/\n Reference: https://4sysops.com/archives/audit-changes-in-the-windows-registry/'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/SdeletedeployedviaGPOandrunrecursively.yaml", "query_name": "Sdelete deployed via GPO and run recursively", "query": "SecurityEvent\n  | where EventID == 4688\n  | where Process =~ \"svchost.exe\"\n  | where CommandLine has \"-k GPSvcGroup\" or CommandLine has \"-s gpsvc\"\n  | extend timekey = bin(TimeGenerated, 1m)\n  | project timekey, NewProcessId, Computer\n  | join kind=inner (SecurityEvent\n  | where EventID == 4688\n  | where Process =~ \"sdelete.exe\" or CommandLine has \"sdelete\"\n  | where ParentProcessName endswith \"svchost.exe\"\n  | where CommandLine has_all (\"-s\", \"-r\")\n  | extend newProcess = Process\n  | extend timekey = bin(TimeGenerated, 1m)\n  ) on $left.NewProcessId == $right.ProcessId, timekey, Computer\n", "attributes": {"description": "'This query looks for the Sdelete process being run recursively after being deployed to a host via GPO. Attackers could use this technique to deploy Sdelete to multiple host and delete data on them.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/SecurityEventLogCleared.yaml", "query_name": "Security Event log cleared", "query": "\n(union isfuzzy=true\n(\nSecurityEvent\n| where EventID == 1102 and EventSourceName == \"Microsoft-Windows-Eventlog\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, EventID, Activity\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(\nWindowsEvent\n| where EventID == 1102 and Provider == \"Microsoft-Windows-Eventlog\"  \n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend Activity= \"1102 - The audit log was cleared.\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, EventID, Activity\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n)\n)\n", "attributes": {"description": "'Checks for event id 1102 which indicates the security event log was cleared. \nIt uses Event Source Name \"Microsoft-Windows-Eventlog\" to avoid generating false positives from other sources, like AD FS servers for instance.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/SolorigateNamedPipe.yaml", "query_name": "Solorigate Named Pipe", "query": "\n(union isfuzzy=true\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID in (17,18)\n| where EventData has '583da945-62af-10e8-4902-a8f205c72b2e'\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, MG, ManagementGroupName, _ResourceId)\n| extend PipeName = column_ifexists(\"PipeName\", \"\")\n| extend Account = UserName\n),\n(\nSecurityEvent\n| where EventID == '5145'\n// %%4418 looks for presence of CreatePipeInstance value \n| where AccessList has '%%4418'     \n| where RelativeTargetName has '583da945-62af-10e8-4902-a8f205c72b2e'\n),\n(\nWindowsEvent\n| where EventID == '5145' and EventData has '%%4418'  and EventData has '583da945-62af-10e8-4902-a8f205c72b2e' \n// %%4418 looks for presence of CreatePipeInstance value \n| extend AccessList= tostring(EventData.AccessList)\n| where AccessList has '%%4418'     \n| extend RelativeTargetName= tostring(EventData.RelativeTargetName)\n| where RelativeTargetName has '583da945-62af-10e8-4902-a8f205c72b2e'\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies a match across various data feeds for named pipe IOCs related to the Solorigate incident.\n For the sysmon events required for this detection, logging for Named Pipe Events needs to be configured in Sysmon config (Event ID 17 and Event ID 18)\n Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/solarwinds-post-compromise-hunting-with-azure-sentinel/ba-p/1995095'\n", "techniques": ["T1055"], "tactics": ["DefenseEvasion", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/StartStopHealthService.yaml", "query_name": "Starting or Stopping HealthService to Avoid Detection", "query": "SecurityEvent\n| where EventID == 4656\n| extend EventData = parse_xml(EventData).EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, TargetAccount, Computer, EventSourceName, Channel, Task, Level, EventID, Activity, TargetLogonId, SourceComputerId, EventOriginId, Type, _ResourceId, TenantId, SourceSystem, ManagementGroupName, IpAddress, Account)\n| extend ObjectServer = column_ifexists('ObjectServer', \"\"), ObjectType = column_ifexists('ObjectType', \"\"), ObjectName = column_ifexists('ObjectName', \"\")\n| where isnotempty(ObjectServer) and isnotempty(ObjectType) and isnotempty(ObjectName)\n| where ObjectServer =~ \"SC Manager\" and ObjectType =~ \"SERVICE OBJECT\" and ObjectName =~ \"HealthService\"\n// Comment out the join below if the SACL only audits users that are part of the Network logon users, i.e. with user/group target pointing to \"NU.\"\n| join kind=leftouter (\n  SecurityEvent\n  | where EventID == 4624\n) on TargetLogonId\n| project TimeGenerated, Computer, Account, TargetAccount, IpAddress,TargetLogonId, ObjectServer, ObjectType, ObjectName\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This query detects events where an actor is stopping or starting HealthService to disable telemetry collection/detection from the agent.\n The query requires a SACL to audit for access request to the service.'\n", "techniques": ["T1562.001"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/TimeSeriesAnomaly-ProcessExecutions.yaml", "query_name": "Process execution frequency anomaly", "query": "\nlet starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet TotalEventsThreshold = 5;\nlet ExeList = dynamic([\"powershell.exe\",\"cmd.exe\",\"wmic.exe\",\"psexec.exe\",\"cacls.exe\",\"rundll.exe\"]);\nlet TimeSeriesData =\nSecurityEvent\n| where EventID == 4688 | extend Process = tolower(Process)\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where Process in (ExeList)\n| project TimeGenerated, Computer, AccountType, Account, Process\n| make-series Total=count() on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by Process;\nlet TimeSeriesAlerts = materialize(TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 1.5, -1, 'linefit')\n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n| where anomalies > 0\n| project Process, TimeGenerated, Total, baseline, anomalies, score\n| where Total > TotalEventsThreshold);\nlet AnomalyHours = materialize(TimeSeriesAlerts  | where TimeGenerated > ago(2d) | project TimeGenerated);\nTimeSeriesAlerts\n| where TimeGenerated > ago(2d)\n| join (\nSecurityEvent\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour\n| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours\n| where EventID == 4688 | extend Process = tolower(Process)\n| summarize CommandlineCount = count() by bin(TimeGenerated, 1h), Process, CommandLine, Computer, Account\n) on Process, TimeGenerated\n| project AnomalyHour = TimeGenerated, Computer, Account, Process, CommandLine, CommandlineCount, Total, baseline, anomalies, score\n| extend timestamp = AnomalyHour, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies anomalous spike in frequency of executions of sensitive processes which are often leveraged as attack vectors.\nThe query leverages KQL built-in anomaly detection algorithms to find large deviations from baseline patterns.\nSudden increases in execution frequency of sensitive processes should be further investigated for malicious activity.\nTune the values from 1.5 to 3 in series_decompose_anomalies for further outliers or based on custom threshold values for score.'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserAccountAdd-Removed.yaml", "query_name": "Account added and removed from privileged groups", "query": "\nlet WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$\";\nlet AC_Add = \n(union isfuzzy=true \n(SecurityEvent\n// Event ID related to member addition.\n| where EventID in (4728, 4732,4756) \n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID  \n| parse EventData with * '\"MemberName\">' * '=' AccountAdded \",OU\" *\n| where isnotempty(AccountAdded)\n| extend GroupAddedTo = TargetUserName, AddingAccount = Account \n| extend  AccountAdded_GroupAddedTo_AddingAccount = strcat(AccountAdded, \"||\", GroupAddedTo, \"||\", AddingAccount )\n| project AccountAdded_GroupAddedTo_AddingAccount, AccountAddedTime = TimeGenerated\n),\n(WindowsEvent\n// Event ID related to member addition.\n| where EventID in (4728, 4732,4756) \n| extend TargetSid = tostring(EventData.TargetSid)\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID  \n| parse EventData.MemberName with * '\"MemberName\">' * '=' AccountAdded \",OU\" *\n| where isnotempty(AccountAdded)\n| extend TargetUserName = tostring(EventData.TargetUserName)\n| extend AddingAccount =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend GroupAddedTo = TargetUserName\n| extend  AccountAdded_GroupAddedTo_AddingAccount = strcat(AccountAdded, \"||\", GroupAddedTo, \"||\", AddingAccount )\n| project AccountAdded_GroupAddedTo_AddingAccount, AccountAddedTime = TimeGenerated\n)\n);\nlet AC_Remove = \n( union isfuzzy=true \n(SecurityEvent\n// Event IDs related to member removal.\n| where EventID in (4729,4733,4757)\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID \n| parse EventData with * '\"MemberName\">' * '=' AccountRemoved \",OU\" * \n| where isnotempty(AccountRemoved)\n| extend GroupRemovedFrom = TargetUserName, RemovingAccount = Account\n| extend AccountRemoved_GroupRemovedFrom_RemovingAccount = strcat(AccountRemoved, \"||\", GroupRemovedFrom, \"||\", RemovingAccount)\n| project AccountRemoved_GroupRemovedFrom_RemovingAccount, AccountRemovedTime = TimeGenerated, Computer, RemovedAccountId = tolower(AccountRemoved), \nRemovedByUser = SubjectUserName, RemovedByUserLogonId = SubjectLogonId,  GroupRemovedFrom = TargetUserName, TargetDomainName\n),\n(WindowsEvent\n// Event IDs related to member removal.\n| where EventID in (4729,4733,4757)\n| extend TargetSid = tostring(EventData.TargetSid)\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID \n| parse EventData.MemberName with * '\"MemberName\">' * '=' AccountRemoved \",OU\" * \n| where isnotempty(AccountRemoved)\n| extend TargetUserName = tostring(EventData.TargetUserName)\n| extend RemovingAccount =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend GroupRemovedFrom = TargetUserName\n| extend AccountRemoved_GroupRemovedFrom_RemovingAccount = strcat(AccountRemoved, \"||\", GroupRemovedFrom, \"||\", RemovingAccount)\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectLogonId = tostring(EventData.SubjectLogonId)\n| extend TargetDomainName = tostring(EventData.TargetDomainName)\n| project AccountRemoved_GroupRemovedFrom_RemovingAccount, AccountRemovedTime = TimeGenerated, Computer, RemovedAccountId = tolower(AccountRemoved), \nRemovedByUser = SubjectUserName, RemovedByUserLogonId = SubjectLogonId,  GroupRemovedFrom = TargetUserName, TargetDomainName\n)); \nAC_Add \n| join kind= inner AC_Remove on $left.AccountAdded_GroupAddedTo_AddingAccount == $right.AccountRemoved_GroupRemovedFrom_RemovingAccount \n| extend DurationinSecondAfter_Removed = datetime_diff ('second', AccountRemovedTime, AccountAddedTime)\n| where DurationinSecondAfter_Removed > 0\n| project-away AccountRemoved_GroupRemovedFrom_RemovingAccount\n| extend timestamp = AccountAddedTime, AccountCustomEntity = RemovedAccountId, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies accounts that are added to privileged group and then quickly removed, which could be a sign of compromise.' \n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserAccountAddedToPrivlegeGroup_1h.yaml", "query_name": "User account added to built in domain local or global group", "query": "\n// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups\nlet WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-498$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1000$\";\nunion isfuzzy=true \n(\nSecurityEvent \n// When MemberName contains '-' this indicates addition of a group to a group\n| where AccountType == \"User\" and MemberName != \"-\"\n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group\n| where EventID in (4728, 4732, 4756)   \n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| where TargetSid !in (\"S-1-5-32-555\")\n| extend SimpleMemberName = substring(MemberName, 3, indexof_regex(MemberName, @\",OU|,CN\") - 3)\n| project TimeGenerated, EventID, Activity, Computer, SimpleMemberName, MemberName, MemberSid, TargetUserName, TargetDomainName, TargetSid, UserPrincipalName, SubjectUserName, SubjectUserSid\n| extend timestamp = TimeGenerated, AccountCustomEntity = SimpleMemberName, HostCustomEntity = Computer\n),\n(\nWindowsEvent \n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group\n| where EventID in (4728, 4732, 4756)  and  not(EventData has \"S-1-5-32-555\")\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend AccountType=case(Account endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n| extend MemberName = tostring(EventData.MemberName)\n// When MemberName contains '-' this indicates addition of a group to a group\n| where AccountType == \"User\" and MemberName != \"-\"\n| extend TargetSid = tostring(EventData.TargetSid)\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| where TargetSid !in (\"S-1-5-32-555\")\n| extend SimpleMemberName = substring(MemberName, 3, indexof_regex(MemberName, @\",OU|,CN\") - 3)\n| extend MemberSid = tostring(EventData.MemberSid)\n| extend TargetUserName = tostring(EventData.TargetUserName)\n| extend TargetDomainName = tostring(EventData.TargetDomainName)\n| extend UserPrincipalName = tostring(EventData.UserPrincipalName)\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| project TimeGenerated, EventID, Computer, SimpleMemberName, MemberName, MemberSid, TargetUserName, TargetDomainName, TargetSid, UserPrincipalName, SubjectUserName, SubjectUserSid\n| extend timestamp = TimeGenerated, AccountCustomEntity = SimpleMemberName, HostCustomEntity = Computer\n)\n", "attributes": {"description": "'Identifies when a user account has been added to a privileged built in domain local group or global group \nsuch as the Enterprise Admins, Cert Publishers or DnsAdmins. Be sure to verify this is an expected addition.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserAccountCreatedDeleted_10m.yaml", "query_name": "User account created and deleted within 10 mins", "query": "let timeframe = 1d;\nlet spanoftime = 10m;\nlet threshold = 0;\n (union isfuzzy=true\n (SecurityEvent\n| where TimeGenerated > ago(timeframe+spanoftime)\n// A user account was created\n| where EventID == 4720\n| where AccountType =~ \"User\"\n| project creationTime = TimeGenerated, CreateEventID = EventID, CreateActivity = Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToCreate = SubjectAccount, SIDofAccountUsedToCreate = SubjectUserSid, TargetAccount = tolower(TargetAccount), TargetSid\n),\n(\nWindowsEvent\n| where TimeGenerated > ago(timeframe+spanoftime)\n// A user account was created\n| where EventID == 4720\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend AccountType=case(EventData.SubjectUserName endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n| where AccountType =~ \"User\"\n| extend SubjectAccount = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend TargetSid = tostring(EventData.TargetSid)\n| extend UserPrincipalName = tostring(EventData.UserPrincipalName)\n| extend Activity = \"4720 - A user account was created.\"\n| extend TargetUserName = tostring(EventData.TargetUserName) \n| project creationTime = TimeGenerated, CreateEventID = EventID, CreateActivity = Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToCreate = SubjectAccount, SIDofAccountUsedToCreate = SubjectUserSid, TargetAccount = tolower(TargetAccount), TargetSid  \n))\n| join kind= inner (\n  (union isfuzzy=true\n  (SecurityEvent\n  | where TimeGenerated > ago(timeframe)\n  // A user account was deleted\n  | where EventID == 4726\n| where AccountType == \"User\"\n| project deletionTime = TimeGenerated, DeleteEventID = EventID, DeleteActivity = Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToDelete = SubjectAccount, SIDofAccountUsedToDelete = SubjectUserSid, TargetAccount = tolower(TargetAccount), TargetSid\n),\n(WindowsEvent\n| where TimeGenerated > ago(timeframe)\n  // A user account was deleted\n| where EventID == 4726\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend SubjectAccount = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend AccountType=case(SubjectAccount endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n| where AccountType == \"User\"\n| extend TargetSid = tostring(EventData.TargetSid)\n| extend UserPrincipalName = tostring(EventData.UserPrincipalName)\n| extend Activity = \"4726 - A user account was deleted.\"\n| extend TargetUserName = tostring(EventData.TargetUserName) \n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| project deletionTime = TimeGenerated, DeleteEventID = EventID, DeleteActivity = Activity, Computer, TargetUserName, UserPrincipalName, AccountUsedToDelete = SubjectAccount, SIDofAccountUsedToDelete = SubjectUserSid, TargetAccount = tolower(TargetAccount), TargetSid))\n) on Computer, TargetAccount\n| where deletionTime - creationTime < spanoftime\n| extend TimeDelta = deletionTime - creationTime\n| where tolong(TimeDelta) >= threshold\n| project TimeDelta, creationTime, CreateEventID, CreateActivity, Computer, TargetAccount, TargetSid, UserPrincipalName, AccountUsedToCreate, SIDofAccountUsedToCreate,\ndeletionTime, DeleteEventID, DeleteActivity, AccountUsedToDelete, SIDofAccountUsedToDelete\n| extend timestamp = creationTime, AccountCustomEntity = AccountUsedToCreate, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies when a user account is created and then deleted within 10 minutes. This can be an indication of compromise and\nan adversary attempting to hide in the noise.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserAccountEnabledDisabled_10m.yaml", "query_name": "User account enabled and disabled within 10 mins", "query": "let timeframe = 1d;\nlet spanoftime = 10m;\nlet threshold = 0;\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated > ago(timeframe+spanoftime)\n// A user account was enabled\n| where EventID == 4722\n| where AccountType =~ \"User\"\n| where TargetAccount !endswith \"$\"\n| project EnableTime = TimeGenerated, EnableEventID = EventID, EnableActivity = Activity, Computer, UserPrincipalName, \nAccountUsedToEnable = SubjectAccount, SIDofAccountUsedToEnable = SubjectUserSid, TargetAccount = tolower(TargetAccount), TargetSid\n),\n(\nWindowsEvent\n| where TimeGenerated > ago(timeframe+spanoftime)\n// A user account was enabled\n| where EventID == 4722\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend AccountType=case(EventData.SubjectUserName endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n| where AccountType =~ \"User\"\n| extend SubjectAccount = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| where TargetAccount !endswith \"$\"\n| extend Activity=\"4722 - A user account was enabled.\"\n| extend TargetSid = tostring(EventData.TargetSid)\n| extend UserPrincipalName = tostring(EventData.UserPrincipalName)\n| project EnableTime = TimeGenerated, EnableEventID = EventID, EnableActivity = Activity, Computer, UserPrincipalName, \nAccountUsedToEnable = SubjectAccount, SIDofAccountUsedToEnable = SubjectUserSid, TargetAccount = tolower(TargetAccount), TargetSid\n))\n| join kind= inner (\n  (union isfuzzy=true\n  (SecurityEvent\n  | where TimeGenerated > ago(timeframe)\n  // A user account was disabled\n  | where EventID == 4725\n| where AccountType =~ \"User\"\n| project DisableTime = TimeGenerated, DisableEventID = EventID, DisableActivity = Activity, Computer, UserPrincipalName, \nAccountUsedToDisable = SubjectAccount, SIDofAccountUsedToDisable = SubjectUserSid, TargetAccount = tolower(TargetAccount), TargetSid\n),\n(WindowsEvent\n  | where TimeGenerated > ago(timeframe)\n  // A user account was disabled\n  | where EventID == 4725\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend AccountType=case(EventData.SubjectUserName endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n| where AccountType =~ \"User\"\n| extend SubjectAccount = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend TargetSid = tostring(EventData.TargetSid)\n| extend UserPrincipalName = tostring(EventData.UserPrincipalName)\n| extend Activity = \"4725 - A user account was disabled.\"\n| project DisableTime = TimeGenerated, DisableEventID = EventID, DisableActivity = Activity, Computer, UserPrincipalName, \nAccountUsedToDisable = SubjectAccount, SIDofAccountUsedToDisable = SubjectUserSid, TargetAccount = tolower(TargetAccount), TargetSid))\n) on Computer, TargetAccount\n| where DisableTime - EnableTime < spanoftime\n| extend TimeDelta = DisableTime - EnableTime\n| where tolong(TimeDelta) >= threshold\n| project TimeDelta, EnableTime, EnableEventID, EnableActivity, Computer, TargetAccount, TargetSid, UserPrincipalName, AccountUsedToEnable, SIDofAccountUsedToEnable, \nDisableTime, DisableEventID, DisableActivity, AccountUsedToDisable, SIDofAccountUsedToDisable\n| extend timestamp = EnableTime, AccountCustomEntity = AccountUsedToEnable, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies when a user account is enabled and then disabled within 10 minutes. This can be an indication of compromise and\nan adversary attempting to hide in the noise.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserCreatedAddedToBuiltinAdmins_1d.yaml", "query_name": "New user created and added to the built-in administrators group", "query": "(union isfuzzy=true\n(SecurityEvent\n| where EventID == 4720\n| where AccountType == \"User\"\n| project CreatedUserTime = TimeGenerated, CreatedUserEventID = EventID, CreatedUserActivity = Activity, Computer = toupper(Computer), \nCreatedUser = tolower(TargetAccount), CreatedUserSid = TargetSid, AccountUsedToCreateUser = strcat(SubjectAccount), SidofAccountUsedToCreateUser = SubjectUserSid\n),\n(WindowsEvent\n| where EventID == 4720\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend AccountType=case(EventData.SubjectUserName endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n| where AccountType == \"User\"\n| extend SubjectAccount = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend Activity=\"4720 - A user account was created.\"\n| extend TargetSid = tostring(EventData.TargetSid)\n| project CreatedUserTime = TimeGenerated, CreatedUserEventID = EventID, CreatedUserActivity = Activity, Computer = toupper(Computer), \nCreatedUser = tolower(TargetAccount), CreatedUserSid = TargetSid, AccountUsedToCreateUser = strcat(SubjectAccount), SidofAccountUsedToCreateUser = SubjectUserSid\n))\n| join ((union isfuzzy=true\n(SecurityEvent \n| where AccountType == \"User\"\n// 4732 - A member was added to a security-enabled local group\n| where EventID == 4732\n// TargetSid is the builin Admins group: S-1-5-32-544\n| where TargetSid == \"S-1-5-32-544\"\n| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, Computer = toupper(Computer), GroupName = tolower(TargetAccount), \nGroupSid = TargetSid, AccountThatAddedUser = SubjectAccount, SIDofAccountThatAddedUser = SubjectUserSid, CreatedUserSid = MemberSid\n),\n(  WindowsEvent \n// 4732 - A member was added to a security-enabled local group\n| where EventID == 4732 and EventData has \"S-1-5-32-544\"\n//TargetSid is the builin Admins group: S-1-5-32-544\n| extend SubjectUserSid = tostring(EventData.SubjectUserSid)\n| extend AccountType=case(EventData.SubjectUserName endswith \"$\" or SubjectUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(SubjectUserSid), \"\", \"User\")\n| where AccountType == \"User\"\n| extend TargetSid = tostring(EventData.TargetSid)\n| where TargetSid == \"S-1-5-32-544\"\n| extend SubjectAccount = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend TargetAccount = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend Activity=\"4732 - A member was added to a security-enabled local group.\"\n| extend MemberSid = tostring(EventData.MemberSid)\n| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, Computer = toupper(Computer), GroupName = tolower(TargetAccount), \nGroupSid = TargetSid, AccountThatAddedUser = SubjectAccount, SIDofAccountThatAddedUser = SubjectUserSid, CreatedUserSid = MemberSid)\n))\non CreatedUserSid\n//Create User first, then the add to the group.\n| project Computer, CreatedUserTime, CreatedUserEventID, CreatedUserActivity, CreatedUser, CreatedUserSid, GroupAddTime, GroupAddEventID, \nGroupAddActivity, AccountUsedToCreateUser, GroupName, GroupSid, AccountThatAddedUser, SIDofAccountThatAddedUser \n| extend timestamp = CreatedUserTime, AccountCustomEntity = CreatedUser, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies when a user account was created and then added to the builtin Administrators group in the same day.\nThis should be monitored closely and all additions reviewed.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/UserPrincipalNameAssignedToUserAccount.yaml", "query_name": "Service Principal Name (SPN) Assigned to User Account", "query": "SecurityEvent\n| where EventID == 5136 \n| parse EventData with * 'AttributeLDAPDisplayName\">' AttributeLDAPDisplayName \"<\" *\n| parse EventData with * 'ObjectClass\">' ObjectClass \"<\" *\n| where AttributeLDAPDisplayName == \"servicePrincipalName\" and  ObjectClass == \"user\"\n| parse EventData with * 'ObjectDN\">' ObjectDN \"<\" *\n| parse EventData with * 'AttributeValue\">' AttributeValue \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Computer, SubjectAccount, ObjectDN, AttributeValue\n", "attributes": {"description": "'This query identifies whether a Active Directory user object was assigned a service principal name which could indicate that an adversary is preparing for performing Kerberoasting. \nThis query checks for event id 5136 that the Object Class field is \"user\" and the LDAP Display Name is \"servicePrincipalName\".\nRef: https://thevivi.net/assets/docs/2019/theVIVI-AD-Security-Workshop_AfricaHackon2019.pdf'\n", "techniques": ["T1134"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/WDigestDowngradeAttack.yaml", "query_name": "WDigest downgrade attack", "query": "Event\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID in (13)\n| parse EventData with * 'TargetObject\">' TargetObject \"<\" * 'Details\">' Details \"<\" * \n| where TargetObject==\"HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\SecurityProviders\\\\WDigest\\\\UseLogonCredential\" and Details !=\"DWORD (0x00000000)\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventID, Computer,  TargetObject, Details\n", "attributes": {"description": "'When the WDigest Authentication protocol is enabled, plain text passwords are stored in the Local Security Authority Subsystem Service (LSASS) exposing them to theft. This setting will prevent WDigest from storing credentials in memory.\nRef: https://www.stigviewer.com/stig/windows_7/2016-12-19/finding/V-72753'\n", "techniques": ["T1003"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/WindowsBinariesExecutedfromNon-DefaultDirectory.yaml", "query_name": "Windows Binaries Executed from Non-Default Directory", "query": "let procList = externaldata(Process:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Microsoft_Lolbas_Execution_Binaries.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nSecurityEvent\n| where EventID == 4688 and Process has_any (procList) and not (NewProcessName has (\"C:\\\\Windows\\\\\"))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, SubjectUserName, NewProcessName, Process, CommandLine\n", "attributes": {"description": "'The query detects Windows binaries, that can be executed from a non-default directory (e.g. C:\\Windows\\, C:\\Windows\\System32 etc.). \nRef: https://lolbas-project.github.io/'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityEvent/WindowsBinariesLolbinsRenamed.yaml", "query_name": "Windows Binaries Lolbins Renamed", "query": "let procList = externaldata(Process:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Microsoft_Lolbas_Execution_Binaries.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nEvent\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID==1\n| parse EventData with * 'Image\">' Image \"<\" * 'OriginalFileName\">' OriginalFileName \"<\" *\n| where OriginalFileName has_any (procList) and not (Image has_any (procList))\n| parse EventData with * 'ProcessGuid\">' ProcessGuid \"<\" * 'Description\">' Description \"<\" * 'CommandLine\">' CommandLine \"<\" * 'CurrentDirectory\">' CurrentDirectory \"<\" * 'User\">' User \"<\" * 'LogonGuid\">' LogonGuid \"<\" * 'Hashes\">' Hashes \"<\" * 'ParentProcessGuid\">' ParentProcessGuid \"<\" * 'ParentImage\">' ParentImage \"<\" * 'ParentCommandLine\">' ParentCommandLine \"<\" * 'ParentUser\">' ParentUser \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, User, ParentImage, ParentProcessGuid, ParentCommandLine, ParentUser, Image, ProcessGuid, CommandLine, Description, OriginalFileName, CurrentDirectory, Hashes\n", "attributes": {"description": "'This query detects the execution of renamed Windows binaries (Lolbins). This is a common technique used by adversaries to evade detection. \nRef: https://docs.paloaltonetworks.com/cortex/cortex-xdr/cortex-xdr-analytics-alert-reference/cortex-xdr-analytics-alert-reference/execution-of-renamed-lolbin.html'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SecurityNestedRecommendation/OMIGODVulnerableMachines.yaml", "query_name": "Vulnerable Machines related to OMIGOD CVE-2021-38647", "query": "SecurityNestedRecommendation\n| where RemediationDescription has 'CVE-2021-38647'\n| parse ResourceDetails with * 'virtualMachines/' VirtualMAchine '\"' *\n| summarize arg_min(TimeGenerated, *) by TenantId, RecommendationSubscriptionId, VirtualMAchine, RecommendationName,Description,RemediationDescription, tostring(AdditionalData),VulnerabilityId\n| extend Timestamp = TimeGenerated, HostCustomEntity = VirtualMAchine\n", "attributes": {"description": "'This query uses the Azure Defender Security Nested Recommendations data to find machines vulnerable to OMIGOD CVE-2021-38647. OMI is the Linux equivalent of Windows WMI and \n helps users manage configurations across remote and local environments. The query aims to find machines that have this OMI vulnerability (CVE-2021-38647).\n Security Nested Recommendations data is sent to Microsoft Sentinel using the continuous export feature of Azure Defender(refrence link below).\n Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure\n Reference: https://docs.microsoft.com/azure/security-center/continuous-export?tabs=azure-portal'\n", "techniques": ["T1190", "T1203"], "tactics": ["InitialAccess", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/AnomolousSingleFactorSignin.yaml", "query_name": "Anomolous Single Factor Signin", "query": "let known_locations = (SigninLogs\n  | where TimeGenerated between(ago(7d)..ago(1d))\n  | where ResultType == 0\n  | extend LocationDetail = strcat(Location, \"-\", LocationDetails.state)\n  | summarize by LocationDetail);\n  let known_asn = (SigninLogs\n  | where TimeGenerated between(ago(7d)..ago(1d))\n  | where ResultType == 0\n  | summarize by AutonomousSystemNumber);\n  SigninLogs\n  | where TimeGenerated > ago(1d)\n  | where ResultType == 0\n  | where isempty(DeviceDetail.deviceId)\n  | where AuthenticationRequirement == \"singleFactorAuthentication\"\n  | extend LocationDetail = strcat(Location, \"-\", LocationDetails.state)\n  | where AutonomousSystemNumber !in (known_asn) and LocationDetail !in (known_locations)\n", "attributes": {"description": "'Detects successful signins using single factor authentication where the device, location, and ASN are abnormal.\n  Single factor authentications pose an opportunity to access compromised accounts, investigate these for anomalous occurrencess.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-devices#non-compliant-device-sign-in'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/AuthenticationAttemptfromNewCountry.yaml", "query_name": "Authentication Attempt from New Country", "query": "let known_locations =\n  union isfuzzy=True AADNonInteractiveUserSignInLogs, SigninLogs\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where ResultType == 0\n  | summarize by Location;\n  union isfuzzy=True AADNonInteractiveUserSignInLogs, SigninLogs\n  | where TimeGenerated > ago(1d)\n  | where ResultType != 50126\n  | where Location !in (known_locations)\n  | extend LocationDetails_dynamic = column_ifexists(\"LocationDetails_dynamic\", \"\")\n  | extend DeviceDetail_dynamic = column_ifexists(\"DeviceDetail_dynamic\", \"\")\n  | extend LocationDetails = iif(isnotempty(LocationDetails_dynamic), LocationDetails_dynamic, parse_json(LocationDetails_string))\n  | extend DeviceDetail = iif(isnotempty(DeviceDetail_dynamic), DeviceDetail_dynamic, parse_json(DeviceDetail_string))\n  | extend City = tostring(LocationDetails.city)\n  | extend State = tostring(LocationDetails.state)\n  | extend Place = strcat(City, \" - \", State)\n  | extend DeviceId = tostring(DeviceDetail.deviceId)\n  | extend Result = strcat(tostring(ResultType), \" - \", ResultDescription)\n  | summarize FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated), make_set(Result), make_set(IPAddress), make_set(UserAgent), make_set(Place), make_set(DeviceId) by UserPrincipalName, Location, Category\n", "attributes": {"description": "'Detects when there is a log in attempt from a country that has not seen a successful login in the previous 14 days.\n  Threat actors may attempt to authenticate with credentials from compromised accounts - monitoring attempts from anomalous locations may help identify these attempts.\n  Authentication attempts should be investigated to ensure the activity was legitimate and if there is other similar activity.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/AuthenticationsofPrivilegedAccountsOutsideofExpectedControls.yaml", "query_name": "Authentications of Privileged Accounts Outside of Expected Controls", "query": "let admin_users = (IdentityInfo\n  | summarize arg_max(TimeGenerated, *) by AccountUPN\n  | where AssignedRoles contains \"admin\"\n  | summarize by tolower(AccountUPN));\n  let admin_asn = (SigninLogs\n  | where TimeGenerated between (ago(7d)..ago(1d))\n  | where tolower(UserPrincipalName) in (admin_users)\n  | summarize by AutonomousSystemNumber);\n  let admin_locations = (SigninLogs\n  | where TimeGenerated between (ago(7d)..ago(1d))\n  | where tolower(UserPrincipalName) in (admin_users)\n  | summarize by Location);\n  let admin_devices = (SigninLogs\n  | where TimeGenerated between (ago(7d)..ago(1d))\n  | where tolower(UserPrincipalName) in (admin_users)\n  | extend deviceId = tostring(DeviceDetail.deviceId)\n  | where isnotempty(deviceId)\n  | summarize by deviceId);\n  SigninLogs\n  | where TimeGenerated > ago(1d)\n  | where ResultType == 0\n  | where tolower(UserPrincipalName) in (admin_users)\n  | extend deviceId = tostring(DeviceDetail.deviceId)\n  | where AutonomousSystemNumber !in (admin_asn) and deviceId !in (admin_devices) and Location !in (admin_locations)\n", "attributes": {"description": "'Detects when a privileged user account successfully authenticates from a location, device or ASN that another admin has not logged in from in the last 7 days.\n  Privileged accounts are a key target for threat actors, monitoring for logins from these accounts that deviate from normal activity can help identify compromised accounts.\n  Authentication attempts should be investigated to ensure the activity was legitimate and if there is other similar activity.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/PrivilegedUserLogonfromnewASN.yaml", "query_name": "Privileged User Logon from new ASN", "query": "let admins=(IdentityInfo\n  | where AssignedRoles contains \"admin\"\n  | summarize by tolower(AccountUPN));\n  let known_asns = (\n  SigninLogs\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where ResultType == 0\n  | summarize by AutonomousSystemNumber);\n  SigninLogs\n  | where TimeGenerated > ago(1d)\n  | where ResultType == 0\n  | where tolower(UserPrincipalName) in (admins)\n  | where AutonomousSystemNumber !in (known_asns)\n  | project-reorder TimeGenerated, UserPrincipalName, UserAgent, IpAddress, AutonomousSystemNumber\n", "attributes": {"description": "'Detects a successful logon by a privileged account from an ASN not logged in from in the last 14 days.\n  Monitor these logons to ensure they are legitimate and identify if there are any similar sign ins.'\n", "techniques": ["T1078.004"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/SigninLogs/ServicePrincipalAuthenticationAttemptfromNewCountry.yaml", "query_name": "Service Principal Authentication Attempt from New Country", "query": "let known_locations = (\n  AADServicePrincipalSignInLogs\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where ResultType == 0\n  | summarize by Location);\n  AADServicePrincipalSignInLogs\n  | where TimeGenerated > ago(1d)\n  | where ResultType != 50126\n  | where Location !in (known_locations)\n  | extend City = tostring(parse_json(LocationDetails).city)\n  | extend State = tostring(parse_json(LocationDetails).state)\n  | extend Place = strcat(City, \" - \", State)\n  | extend Result = strcat(tostring(ResultType), \" - \", ResultDescription)\n  | summarize FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated), make_set(Result), make_set(IPAddress), make_set(Place) by ServicePrincipalName, Location\n", "attributes": {"description": "'Detects when there is a Service Principal login attempt from a country that has not seen a successful login in the previous 14 days.\n  Threat actors may attempt to authenticate with credentials from compromised accounts - monitoring attempts from anomalous locations may help identify these attempts.\n  Authentication attempts should be investigated to ensure the activity was legitimate and if there is other similar activity.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/FailedLogonAttempts_UnknownUser.yaml", "query_name": "Failed logon attempts in authpriv", "query": "let threshold = 15;\n// Below pulls messages from syslog-authpriv logs where there was an authentication failure with an unknown user.\n// IP address of system attempting logon is also extracted from the SyslogMessage field. Some of these messages\n// are aggregated.\nSyslog\n| where Facility =~ \"authpriv\"\n| where SyslogMessage has \"authentication failure\" and SyslogMessage has \" uid=0\"\n| parse SyslogMessage with * \"rhost=\" RemoteIP\n| project TimeGenerated, Computer, ProcessName, HostIP, RemoteIP, ProcessID\n| join kind=innerunique (\n    // Below pulls messages from syslog-authpriv logs that show each instance an unknown user tried to logon. \n    Syslog \n    | where Facility =~ \"authpriv\"\n    | where SyslogMessage has \"user unknown\"\n    | project Computer, HostIP, ProcessID\n    ) on Computer, HostIP, ProcessID\n// Count the number of failed logon attempts by External IP and internal machine\n| summarize FirstLogonAttempt = min(TimeGenerated), LatestLogonAttempt = max(TimeGenerated), TotalLogonAttempts = count() by Computer, HostIP, RemoteIP\n// Calculate the time between first and last logon attempt (AttemptPeriodLength)\n| extend TimeBetweenLogonAttempts = LatestLogonAttempt - FirstLogonAttempt\n| where TotalLogonAttempts >= threshold\n| project FirstLogonAttempt, LatestLogonAttempt, TimeBetweenLogonAttempts, TotalLogonAttempts, SourceAddress = RemoteIP, DestinationHost = Computer, DestinationAddress = HostIP\n| sort by DestinationHost asc nulls last\n| extend timestamp = FirstLogonAttempt, HostCustomEntity = DestinationHost, IPCustomEntity = DestinationAddress\n", "attributes": {"description": "'Identifies failed logon attempts from unknown users in Syslog authpriv logs. The unknown user means the account that tried to log in \nisn't provisioned on the machine. A few hits could indicate someone attempting to access a machine they aren't authorized to access. \nIf there are many of hits, especially from outside your network, it could indicate a brute force attack. \nDefault threshold for logon attempts is 15.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/NRT_squid_events_for_mining_pools.yaml", "query_name": "NRT Squid proxy events related to mining pools", "query": "let DomainList = dynamic([\"monerohash.com\", \"do-dear.com\", \"xmrminerpro.com\", \"secumine.net\", \"xmrpool.com\", \"minexmr.org\", \"hashanywhere.com\", \"xmrget.com\",\n\"mininglottery.eu\", \"minergate.com\", \"moriaxmr.com\", \"multipooler.com\", \"moneropools.com\", \"xmrpool.eu\", \"coolmining.club\", \"supportxmr.com\",\n\"minexmr.com\", \"hashvault.pro\", \"xmrpool.net\", \"crypto-pool.fr\", \"xmr.pt\", \"miner.rocks\", \"walpool.com\", \"herominers.com\", \"gntl.co.uk\", \"semipool.com\",\n\"coinfoundry.org\", \"cryptoknight.cc\", \"fairhash.org\", \"baikalmine.com\", \"tubepool.xyz\", \"fairpool.xyz\", \"asiapool.io\", \"coinpoolit.webhop.me\", \"nanopool.org\",\n\"moneropool.com\", \"miner.center\", \"prohash.net\", \"poolto.be\", \"cryptoescrow.eu\", \"monerominers.net\", \"cryptonotepool.org\", \"extrmepool.org\", \"webcoin.me\",\n\"kippo.eu\", \"hashinvest.ws\", \"monero.farm\", \"supportxmr.com\", \"xmrpool.eu\", \"linux-repository-updates.com\", \"1gh.com\", \"dwarfpool.com\", \"hash-to-coins.com\",\n\"hashvault.pro\", \"pool-proxy.com\", \"hashfor.cash\", \"fairpool.cloud\", \"litecoinpool.org\", \"mineshaft.ml\", \"abcxyz.stream\", \"moneropool.ru\", \"cryptonotepool.org.uk\",\n\"extremepool.org\", \"extremehash.com\", \"hashinvest.net\", \"unipool.pro\", \"crypto-pools.org\", \"monero.net\", \"backup-pool.com\", \"mooo.com\", \"freeyy.me\", \"cryptonight.net\",\n\"shscrypto.net\"]);\nSyslog\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage),\n        SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage),\n        Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage),\n        HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n        User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n        RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n        Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n        Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n        contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where HTTP_Status_Code == '200'\n| where Domain contains \".\"\n| where Domain has_any (DomainList)\n", "attributes": {"description": "'Checks for Squid proxy events in Syslog associated with common mining pools .This query presumes the default Squid log format is being used.\n http://www.squid-cache.org/Doc/config/access_log/'\n", "techniques": ["T1102"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/squid_cryptomining_pools.yaml", "query_name": "Squid proxy events related to mining pools", "query": "\nlet DomainList = dynamic([\"monerohash.com\", \"do-dear.com\", \"xmrminerpro.com\", \"secumine.net\", \"xmrpool.com\", \"minexmr.org\", \"hashanywhere.com\", \"xmrget.com\", \n\"mininglottery.eu\", \"minergate.com\", \"moriaxmr.com\", \"multipooler.com\", \"moneropools.com\", \"xmrpool.eu\", \"coolmining.club\", \"supportxmr.com\",\n\"minexmr.com\", \"hashvault.pro\", \"xmrpool.net\", \"crypto-pool.fr\", \"xmr.pt\", \"miner.rocks\", \"walpool.com\", \"herominers.com\", \"gntl.co.uk\", \"semipool.com\", \n\"coinfoundry.org\", \"cryptoknight.cc\", \"fairhash.org\", \"baikalmine.com\", \"tubepool.xyz\", \"fairpool.xyz\", \"asiapool.io\", \"coinpoolit.webhop.me\", \"nanopool.org\", \n\"moneropool.com\", \"miner.center\", \"prohash.net\", \"poolto.be\", \"cryptoescrow.eu\", \"monerominers.net\", \"cryptonotepool.org\", \"extrmepool.org\", \"webcoin.me\", \n\"kippo.eu\", \"hashinvest.ws\", \"monero.farm\", \"supportxmr.com\", \"xmrpool.eu\", \"linux-repository-updates.com\", \"1gh.com\", \"dwarfpool.com\", \"hash-to-coins.com\", \n\"hashvault.pro\", \"pool-proxy.com\", \"hashfor.cash\", \"fairpool.cloud\", \"litecoinpool.org\", \"mineshaft.ml\", \"abcxyz.stream\", \"moneropool.ru\", \"cryptonotepool.org.uk\",\n\"extremepool.org\", \"extremehash.com\", \"hashinvest.net\", \"unipool.pro\", \"crypto-pools.org\", \"monero.net\", \"backup-pool.com\", \"mooo.com\", \"freeyy.me\", \"cryptonight.net\",\n\"shscrypto.net\"]);\nSyslog\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n        SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n        Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n        HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n        User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n        RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n        Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n        Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n        contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where HTTP_Status_Code == '200'\n| where Domain contains \".\"\n| where Domain has_any (DomainList)\n| extend timestamp = TimeGenerated, URLCustomEntity = URL, IPCustomEntity = SourceIP, AccountCustomEntity = User\n", "attributes": {"description": "'Checks for Squid proxy events in Syslog associated with common mining pools .This query presumes the default Squid log format is being used. \n http://www.squid-cache.org/Doc/config/access_log/'\n", "techniques": ["T1102"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/squid_tor_proxies.yaml", "query_name": "Squid proxy events for ToR proxies", "query": "\nlet DomainList = dynamic([\"tor2web.org\", \"tor2web.com\", \"torlink.co\", \"onion.to\", \"onion.ink\", \"onion.cab\", \"onion.nu\", \"onion.link\", \n\"onion.it\", \"onion.city\", \"onion.direct\", \"onion.top\", \"onion.casa\", \"onion.plus\", \"onion.rip\", \"onion.dog\", \"tor2web.fi\", \n\"tor2web.blutmagie.de\", \"onion.sh\", \"onion.lu\", \"onion.pet\", \"t2w.pw\", \"tor2web.ae.org\", \"tor2web.io\", \"tor2web.xyz\", \"onion.lt\", \n\"s1.tor-gateways.de\", \"s2.tor-gateways.de\", \"s3.tor-gateways.de\", \"s4.tor-gateways.de\", \"s5.tor-gateways.de\", \"hiddenservice.net\"]);\nSyslog\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n        SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n        Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n        HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n        User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n        RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n        Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n        Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n        contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where HTTP_Status_Code == \"200\"\n| where Domain contains \".\"\n| where Domain has_any (DomainList)\n| extend timestamp = TimeGenerated, URLCustomEntity = URL, IPCustomEntity = SourceIP, AccountCustomEntity = User\n", "attributes": {"description": "'Check for Squid proxy events associated with common ToR proxies. This query presumes the default squid log format is being used.\nhttp://www.squid-cache.org/Doc/config/access_log/'\n", "techniques": ["T1090", "T1008"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/Syslog/ssh_potentialBruteForce.yaml", "query_name": "SSH - Potential Brute Force", "query": "\nlet threshold = 15;\nSyslog\n| where SyslogMessage contains \"Failed password for invalid user\"\n| where ProcessName =~ \"sshd\" \n| parse kind=relaxed SyslogMessage with * \"invalid user\" user \" from \" ip \" port\" port \" ssh2\"\n| project user, ip, port, SyslogMessage, EventTime\n| summarize EventTimes = make_list(EventTime), PerHourCount = count() by ip, bin(EventTime, 4h), user\n| where PerHourCount > threshold\n| mvexpand EventTimes\n| extend EventTimes = tostring(EventTimes) \n| summarize StartTimeUtc = min(EventTimes), EndTimeUtc = max(EventTimes), UserList = makeset(user), sum(PerHourCount) by IPAddress = ip\n| extend UserList = tostring(UserList) \n| extend timestamp = StartTimeUtc, IPCustomEntity = IPAddress, AccountCustomEntity = UserList\n", "attributes": {"description": "'Identifies an IP address that had 15 failed attempts to sign in via SSH in a 4 hour block during a 24 hour time period.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_CommonSecurityLog.yaml", "query_name": "TI map Domain entity to CommonSecurityLog", "query": "let dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\n//Create a list of TLDs in our threat feed for later validation of extracted domains\nlet list_tlds = ThreatIntelligenceIndicator\n| where TimeGenerated > ago(ioc_lookBack)\n| where isnotempty(DomainName)\n| extend DomainName = tolower(DomainName)\n| extend parts = split(DomainName, '.')\n| extend tld = parts[(array_length(parts)-1)]\n| summarize count() by tostring(tld)\n| summarize make_list(tld);\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(DomainName)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n   CommonSecurityLog\n   | extend IngestionTime = ingestion_time()\n   | where IngestionTime > ago(dt_lookBack)\n   | where DeviceEventClassID =~ 'url'\n   //Uncomment the line below to only alert on allowed connections\n   //| where DeviceAction !~ \"block-url\"\n   //Extract domain from RequestURL, if not present extarct it from AdditionalExtentions\n   | extend PA_Url = columnifexists(\"RequestURL\", \"None\")\n   | extend PA_Url = iif(isempty(PA_Url) and AdditionalExtensions !startswith \"PanOS\", extract(\"([^\\\"]+)\", 1, tolower(AdditionalExtensions)), trim('\"', PA_Url))\n   | extend PA_Url = iif(PA_Url !startswith \"http://\" and ApplicationProtocol !~ \"ssl\", strcat('http://', PA_Url), iif(PA_Url !startswith \"https://\" and ApplicationProtocol =~ \"ssl\", strcat('https://', PA_Url), PA_Url))\n   | extend Domain = trim(@\"\"\"\",tostring(parse_url(PA_Url).Host))\n   | where isnotempty(Domain)\n   | extend Domain = tolower(Domain)\n   | extend parts = split(Domain, '.')\n   //Split out the TLD for the purpose of checking if we have any TI indicators with this TLD to match on\n   | extend tld = parts[(array_length(parts)-1)]\n   //Validate parsed domain by checking TLD against TLDs from threat feed and drop domains where there is no chance of a match\n   | where tld in~ (list_tlds)\n   | extend CommonSecurityLog_TimeGenerated = TimeGenerated\n   ) on $left.DomainName==$right.Domain\n| where CommonSecurityLog_TimeGenerated < ExpirationDateTime\n| summarize CommonSecurityLog_TimeGenerated = arg_max(CommonSecurityLog_TimeGenerated, *) by IndicatorId, FileHashValue\n| project CommonSecurityLog_TimeGenerated, Description, ActivityGroupNames, PA_Url, Domain, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, DeviceAction, DestinationIP, DestinationPort, DeviceName, SourceIP, SourcePort, ApplicationProtocol, RequestMethod\n| extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, URLCustomEntity = PA_Url\n", "attributes": {"description": "'Identifies a match in CommonSecurityLog table from any Domain IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_DnsEvents.yaml", "query_name": "TI map Domain entity to DnsEvents", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\n//Create a list of TLDs in our threat feed for later validation\nlet list_tlds = ThreatIntelligenceIndicator\n| where TimeGenerated > ago(ioc_lookBack)\n| where isnotempty(DomainName)\n| extend parts = split(DomainName, '.')\n| extend tld = parts[(array_length(parts)-1)]\n| summarize count() by tostring(tld)\n| summarize make_list(tld);\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(DomainName)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n     DnsEvents\n    | where TimeGenerated > ago(dt_lookBack)\n    //Extract domain patterns from syslog message\n    | where isnotempty(Name)\n    | extend parts = split(Name, '.')\n    //Split out the TLD\n    | extend tld = parts[(array_length(parts)-1)]\n    //Validate parsed domain by checking if the TLD is in the list of TLDs in our threat feed\n    | where tld in~ (list_tlds)\n    | extend DNS_TimeGenerated = TimeGenerated\n) on $left.DomainName==$right.Name\n| where DNS_TimeGenerated < ExpirationDateTime\n| summarize DNS_TimeGenerated  = arg_max(DNS_TimeGenerated , *) by IndicatorId, Name\n| project DNS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Url, Computer, ClientIP, Name, QueryType\n| extend timestamp = DNS_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = ClientIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in DnsEvents from any Domain IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_imWebSession.yaml", "query_name": "(Preview) TI map Domain entity to Web Session Events (ASIM Web Session schema)", "query": "let HAS_ANY_MAX = 10000;\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\n//Create a list of TLDs in our threat feed for later validation\nlet DOMAIN_TI=ThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(DomainName);\nlet DOMAIN_TI_list= todynamic(toscalar(DOMAIN_TI | summarize NIoCs = dcount(DomainName), Domains = make_set(DomainName) \n  | project Domains=iff(NIoCs > HAS_ANY_MAX, dynamic([]), Domains) ));\nDOMAIN_TI\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    _Im_WebSession(starttime=ago(dt_lookBack), url_has_any= DOMAIN_TI_list )\n    //Extract domain patterns from syslog message\n    | extend domain = tostring(parse_url(Url)[\"Host\"])\n    | where isnotempty(domain)\n    | extend tld = tostring(split(domain, '.')[-1])\n    | extend Event_TimeGenerated = TimeGenerated\n) on $left.DomainName==$right.domain\n| where Event_TimeGenerated < ExpirationDateTime\n| summarize Event_TimeGenerated  = arg_max(Event_TimeGenerated , *) by IndicatorId, domain\n| project Event_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, domain, SrcIpAddr, Url\n", "attributes": {"description": "'This rule identifies Web Sessions for which the target URL hostname is a known IoC. <br><br>This rule uses the [Advanced Security Information Model (ASIM)](https://aka.ms/AboutSIM) and supports any web session source that complies with ASIM.'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_PaloAlto.yaml", "query_name": "TI map Domain entity to PaloAlto", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\n//Create a list of TLDs in our threat feed for later validation of extracted domains\nlet list_tlds = ThreatIntelligenceIndicator\n    | where TimeGenerated > ago(ioc_lookBack)\n    | where isnotempty(DomainName)\n    | extend DomainName = tolower(DomainName)\n    | extend parts = split(DomainName, '.')\n    | extend tld = parts[(array_length(parts)-1)]\n    | summarize count() by tostring(tld)\n    | summarize make_list(tld);\n    ThreatIntelligenceIndicator\n    | where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n    | summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n    | where Active == true\n    // Picking up only IOC's that contain the entities we want\n    | where isnotempty(DomainName)\n    // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n    | join kind=innerunique (\n        CommonSecurityLog\n        | extend IngestionTime = ingestion_time()\n        | where IngestionTime > ago(dt_lookBack)\n        | where DeviceVendor =~ 'Palo Alto Networks'\n        | where DeviceEventClassID =~ 'url'\n        //Uncomment the line below to only alert on allowed connections\n        //| where DeviceAction !~ \"block-url\"\n        //Extract domain from RequestURL, if not present extarct it from AdditionalExtentions\n        | extend PA_Url = columnifexists(\"RequestURL\", \"None\")\n        | extend PA_Url = iif(isempty(PA_Url) and AdditionalExtensions !startswith \"PanOS\", extract(\"([^\\\"]+)\", 1, tolower(AdditionalExtensions)), trim('\"', PA_Url))\n        | extend PA_Url = iif(PA_Url !startswith \"http://\" and ApplicationProtocol !~ \"ssl\", strcat('http://', PA_Url), iif(PA_Url !startswith \"https://\" and ApplicationProtocol =~ \"ssl\", strcat('https://', PA_Url), PA_Url))\n        | extend Domain = trim(@\"\"\"\",tostring(parse_url(PA_Url).Host))\n        | where isnotempty(Domain)\n        | extend Domain = tolower(Domain)\n        | extend parts = split(Domain, '.')\n        //Split out the TLD for the purpose of checking if we have any TI indicators with this TLD to match on\n        | extend tld = parts[(array_length(parts)-1)]\n        //Validate parsed domain by checking TLD against TLDs from threat feed and drop domains where there is no chance of a match\n        | where tld in~ (list_tlds)\n        | extend CommonSecurityLog_TimeGenerated = TimeGenerated\n    ) on $left.DomainName==$right.Domain\n    | where CommonSecurityLog_TimeGenerated < ExpirationDateTime\n    | summarize CommonSecurityLog_TimeGenerated = arg_max(CommonSecurityLog_TimeGenerated, *) by IndicatorId, Domain\n    | project CommonSecurityLog_TimeGenerated, Description, ActivityGroupNames, PA_Url, Domain, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, \n    DeviceAction, DestinationIP, DestinationPort, DeviceName, SourceIP, SourcePort, ApplicationProtocol, RequestMethod\n    | extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, URLCustomEntity = PA_Url\n", "attributes": {"description": "'Identifies a match in Palo Alto data in CommonSecurityLog table from any Domain IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_SecurityAlert.yaml", "query_name": "TI map Domain entity to SecurityAlert", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\n//Create a list of TLDs in our threat feed for later validation\nlet list_tlds = ThreatIntelligenceIndicator\n| where TimeGenerated > ago(ioc_lookBack)\n| where isnotempty(DomainName)\n| extend parts = split(DomainName, '.')\n| extend tld = parts[(array_length(parts)-1)]\n| summarize count() by tostring(tld)\n| summarize make_list(tld);\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(DomainName)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    SecurityAlert\n    | where TimeGenerated > ago(dt_lookBack)\n    | extend MSTI = case(AlertName has \"TI map\" and VendorName == \"Microsoft\" and ProductName == 'Azure Sentinel', true, false)\n    | where MSTI == false\n    //Extract domain patterns from message\n    | extend domain = todynamic(dynamic_to_json(extract_all(@\"(((xn--)?[a-z0-9\\-]+\\.)+([a-z]+|(xn--[a-z0-9]+)))\", dynamic([1]), tolower(Entities))))\n    | mv-expand domain\n    | extend domain = tostring(domain[0])\n    | extend parts = split(domain, '.')\n    //Split out the TLD\n    | extend tld = parts[(array_length(parts)-1)]\n    //Validate parsed domain by checking if the TLD is in the list of TLDs in our threat feed\n    | where tld in~ (list_tlds)\n    // Converting Entities into dynamic data type and use mv-expand to unpack the array\n    | extend EntitiesDynamicArray = parse_json(Entities)\n    | mv-apply EntitiesDynamicArray on\n        (summarize\n            HostName = take_anyif(tostring(EntitiesDynamicArray.HostName), EntitiesDynamicArray.Type == \"host\"),\n            IP_addr = take_anyif(tostring(EntitiesDynamicArray.Address), EntitiesDynamicArray.Type == \"ip\")\n    )\n    | extend Alert_TimeGenerated = TimeGenerated\n    | extend Alert_Description = Description\n) on $left.DomainName==$right.domain\n| where Alert_TimeGenerated < ExpirationDateTime\n| summarize Alert_TimeGenerated = arg_max(Alert_TimeGenerated, *) by IndicatorId, AlertName\n| project Alert_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, DomainName, AlertName, Alert_Description, ProviderName, AlertSeverity, ConfidenceLevel, HostName, IP_addr, Url, Entities\n| extend timestamp = Alert_TimeGenerated, HostCustomEntity = HostName, IPCustomEntity = IP_addr, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in SecurityAlert table from any Domain IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/DomainEntity_Syslog.yaml", "query_name": "TI map Domain entity to Syslog", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\n//Create a list of TLDs in our threat feed for later validation\nlet list_tlds = ThreatIntelligenceIndicator\n| where TimeGenerated > ago(ioc_lookBack)\n| where isnotempty(DomainName)\n| extend parts = split(DomainName, '.')\n| extend tld = parts[(array_length(parts)-1)]\n| summarize count() by tostring(tld)\n| summarize make_list(tld);\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(DomainName)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    Syslog\n    | where TimeGenerated > ago(dt_lookBack)\n    //Extract domain patterns from syslog message\n    | extend domain = extract(\"(([a-z0-9]+(-[a-z0-9]+)*\\\\.)+[a-z]{2,})\",1, tolower(SyslogMessage))\n    | where isnotempty(domain)\n    | extend parts = split(domain, '.')\n    //Split out the TLD\n    | extend tld = parts[(array_length(parts)-1)]\n    //Validate parsed domain by checking if the TLD is in the list of TLDs in our threat feed\n    | where tld in~ (list_tlds)\n    | extend Syslog_TimeGenerated = TimeGenerated\n) on $left.DomainName==$right.domain\n| where Syslog_TimeGenerated < ExpirationDateTime\n| summarize Syslog_TimeGenerated  = arg_max(Syslog_TimeGenerated , *) by IndicatorId, domain\n| project Syslog_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, SyslogMessage, Computer, ProcessName, domain, HostIP, Url\n| extend timestamp = Syslog_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = HostIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in Syslog table from any Domain IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_AzureActivity.yaml", "query_name": "TI map Email entity to AzureActivity", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$';\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n//Filtering the table for Email related IOCs\n| where isnotempty(EmailSenderAddress)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    AzureActivity | where TimeGenerated >= ago(dt_lookBack) and isnotempty(Caller)\n    | extend Caller = tolower(Caller)\n    | where Caller matches regex emailregex\n    | extend AzureActivity_TimeGenerated = TimeGenerated\n)\non $left.EmailSenderAddress == $right.Caller\n| where AzureActivity_TimeGenerated < ExpirationDateTime\n| summarize AzureActivity_TimeGenerated = arg_max(AzureActivity_TimeGenerated, *) by IndicatorId, Caller\n| project AzureActivity_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Url, EmailSenderName, EmailRecipient, \nEmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, Caller, Level, CallerIpAddress, CategoryValue, OperationNameValue, ActivityStatusValue, \nResourceGroup, SubscriptionId\n| extend timestamp = AzureActivity_TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in AzureActivity table from any Email IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_OfficeActivity.yaml", "query_name": "TI map Email entity to OfficeActivity", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$';\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n//Filtering the table for Email related IOCs\n| where isnotempty(EmailSenderAddress)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    OfficeActivity | where TimeGenerated >= ago(dt_lookBack) and isnotempty(UserId)\n    | where UserId matches regex emailregex\n    | extend OfficeActivity_TimeGenerated = TimeGenerated\n)\non $left.EmailSenderAddress == $right.UserId\n| where OfficeActivity_TimeGenerated < ExpirationDateTime\n| summarize OfficeActivity_TimeGenerated = arg_max(OfficeActivity_TimeGenerated, *) by IndicatorId, UserId\n| project OfficeActivity_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nEmailSenderName, EmailRecipient, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, UserId, ClientIP, Operation, UserType, RecordType, OfficeWorkload, Parameters\n| extend timestamp = OfficeActivity_TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in OfficeActivity table from any Email IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_PaloAlto.yaml", "query_name": "TI map Email entity to CommonSecurityLog", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$';\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n//Filtering the table for Email related IOCs\n| where isnotempty(EmailSenderAddress)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    CommonSecurityLog | where TimeGenerated >= ago(dt_lookBack) and isnotempty(DestinationUserID)\n    // Filtering PAN Logs for specific event type to match relevant email entities\n    | where DeviceVendor == \"Palo Alto Networks\" and  DeviceEventClassID == \"wildfire\" and ApplicationProtocol in (\"smtp\",\"pop3\")\n    | extend DestinationUserID = tolower(DestinationUserID)\n    | where DestinationUserID matches regex emailregex\n    | extend CommonSecurityLog_TimeGenerated = TimeGenerated\n)\non $left.EmailSenderAddress == $right.DestinationUserID\n| where CommonSecurityLog_TimeGenerated < ExpirationDateTime\n| summarize CommonSecurityLog_TimeGenerated = arg_max(CommonSecurityLog_TimeGenerated, *) by IndicatorId, DestinationUserID\n| project CommonSecurityLog_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, EmailSenderName, EmailRecipient, \nEmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, DestinationUserID, DeviceEventClassID, LogSeverity, DeviceAction, SourceIP, SourcePort, \nDestinationIP, DestinationPort, Protocol, ApplicationProtocol\n| extend timestamp = CommonSecurityLog_TimeGenerated, AccountCustomEntity = DestinationUserID, IPCustomEntity = SourceIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in CommonSecurityLog table from any Email IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_SecurityAlert.yaml", "query_name": "TI map Email entity to SecurityAlert", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$';\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n//Filtering the table for Email related IOCs\n| where isnotempty(EmailSenderAddress)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    SecurityAlert \n    | where TimeGenerated >= ago(dt_lookBack)\n    | extend MSTI = case(AlertName has \"TI map\" and VendorName == \"Microsoft\" and ProductName == 'Azure Sentinel', true, false)\n    | where MSTI == false\n    // Converting Entities into dynamic data type and use mv-expand to unpack the array\n    | extend EntitiesDynamicArray = parse_json(Entities) | mv-expand EntitiesDynamicArray\n    // Parsing relevant entity column to filter type account and creating new column by combining account and UPNSuffix\n    | extend Entitytype = tostring(parse_json(EntitiesDynamicArray).Type), EntityName = tostring(parse_json(EntitiesDynamicArray).Name),\n    EntityUPNSuffix = tostring(parse_json(EntitiesDynamicArray).UPNSuffix)\n    | where Entitytype =~ \"account\"\n    | extend EntityEmail = tolower(strcat(EntityName, \"@\", EntityUPNSuffix))\n    | where EntityEmail matches regex emailregex\n    | extend Alert_TimeGenerated = TimeGenerated\n)\non $left.EmailSenderAddress == $right.EntityEmail\n| where Alert_TimeGenerated < ExpirationDateTime\n| summarize Alert_TimeGenerated = arg_max(Alert_TimeGenerated, *) by IndicatorId, AlertName\n| project Alert_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, \nEmailSenderName, EmailRecipient, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, EntityEmail, AlertName, AlertType,\nAlertSeverity, Entities, ProviderName, VendorName\n| extend timestamp = Alert_TimeGenerated, AccountCustomEntity = EntityEmail, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in SecurityAlert table from any Email IOC from TI which will extend coverage to datatypes such as MCAS, StorageThreatProtection and many others'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_SecurityEvent.yaml", "query_name": "TI map Email entity to SecurityEvent", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$';\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n//Filtering the table for Email related IOCs\n| where isnotempty(EmailSenderAddress)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique ( \n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(dt_lookBack) and isnotempty(TargetUserName)\n//Normalizing the column to lower case for exact match with EmailSenderAddress column\n| extend TargetUserName = tolower(TargetUserName)\n// renaming timestamp column so it is clear the log this came from SecurityEvent table\n| extend SecurityEvent_TimeGenerated = TimeGenerated\n),\n(WindowsEvent\n| where TimeGenerated >= ago(dt_lookBack) \n| extend TargetUserName = tostring(EventData.TargetUserName) \n| where isnotempty(TargetUserName)\n//Normalizing the column to lower case for exact match with EmailSenderAddress column\n| extend TargetUserName = tolower(TargetUserName)\n// renaming timestamp column so it is clear the log this came from SecurityEvent table\n| extend SecurityEvent_TimeGenerated = TimeGenerated\n))\n)\non $left.EmailSenderAddress == $right.TargetUserName\n| where SecurityEvent_TimeGenerated < ExpirationDateTime\n| summarize SecurityEvent_TimeGenerated = arg_max(SecurityEvent_TimeGenerated, *) by IndicatorId, TargetUserName\n| project SecurityEvent_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nEmailSenderName, EmailRecipient, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, Computer, EventID, TargetUserName, Activity, IpAddress, AccountType,\nLogonTypeName, LogonProcessName, Status, SubStatus\n| extend\ntimestamp = SecurityEvent_TimeGenerated,\nAccountCustomEntity = TargetUserName,\nIPCustomEntity = IpAddress,\nHostCustomEntity = Computer,\nURLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in SecurityEvent table from any Email IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/EmailEntity_SigninLogs.yaml", "query_name": "TI map Email entity to SigninLogs", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet emailregex = @'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$';\nlet aadFunc = (tableName:string){\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n//Filtering the table for Email related IOCs\n| where isnotempty(EmailSenderAddress)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    table(tableName) | where TimeGenerated >= ago(dt_lookBack) and isnotempty(UserPrincipalName)\n    //Normalizing the column to lower case for exact match with EmailSenderAddress column\n    | extend UserPrincipalName = tolower(UserPrincipalName)\n    | where UserPrincipalName matches regex emailregex\n    | extend Status = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n    | extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n    | extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city), Region = tostring(LocationDetails.countryOrRegion)\n    // renaming timestamp column so it is clear the log this came from SigninLogs table\n    | extend SigninLogs_TimeGenerated = TimeGenerated, Type = Type\n)\non $left.EmailSenderAddress == $right.UserPrincipalName\n| where SigninLogs_TimeGenerated < ExpirationDateTime\n| summarize SigninLogs_TimeGenerated = arg_max(SigninLogs_TimeGenerated, *) by IndicatorId, UserPrincipalName\n| project SigninLogs_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nEmailSenderName, EmailRecipient, EmailSourceDomain, EmailSourceIpAddress, EmailSubject, FileHashValue, FileHashType, IPAddress, UserPrincipalName, AppDisplayName,\nStatusCode, StatusDetails, NetworkIP, NetworkDestinationIP, NetworkSourceIP, Type\n| extend timestamp = SigninLogs_TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress, URLCustomEntity = Url\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies a match in SigninLogs table from any Email IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/FileHashEntity_CommonSecurityLog.yaml", "query_name": "TI map File Hash to CommonSecurityLog Event", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet fileHashIndicators = ThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n| where isnotempty(FileHashValue);\n// Handle matches against both lower case and uppercase versions of the hash:\n(fileHashIndicators | extend  FileHashValue = tolower(FileHashValue)\n| union (fileHashIndicators | extend FileHashValue = toupper(FileHashValue)))\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n|  join kind=innerunique (\n  CommonSecurityLog | where TimeGenerated >= ago(dt_lookBack)\n  | where isnotempty(FileHash)\n  | extend CommonSecurityLog_TimeGenerated = TimeGenerated\n  )\non $left.FileHashValue == $right.FileHash\n| where CommonSecurityLog_TimeGenerated < ExpirationDateTime\n| summarize CommonSecurityLog_TimeGenerated = arg_max(CommonSecurityLog_TimeGenerated, *) by IndicatorId, FileHashValue\n| project CommonSecurityLog_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nSourceIP, SourcePort, DestinationIP, DestinationPort, SourceUserID, SourceUserName, DeviceName, DeviceAction,\nRequestURL, DestinationUserName, DestinationUserID, ApplicationProtocol, Activity, FileHashValue, FileHashType\n| extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, AccountCustomEntity = SourceUserName, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in CommonSecurityLog Event data from any FileHash IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/FileHashEntity_SecurityEvent.yaml", "query_name": "TI map File Hash to Security Event", "query": "\nlet dt_lookBack = 1h;\n let ioc_lookBack = 14d;\n ThreatIntelligenceIndicator\n | where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n | summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n | where Active == true\n | where isnotempty(FileHashValue)\n | extend FileHashValue = toupper(FileHashValue)\n // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n | join kind=innerunique ( union isfuzzy=true \n   (SecurityEvent | where TimeGenerated >= ago(dt_lookBack)\n       | where EventID in (\"8003\",\"8002\",\"8005\")\n       | where isnotempty(FileHash)\n       | extend SecurityEvent_TimeGenerated = TimeGenerated, Event = EventID, FileHash = toupper(FileHash)\n   ),\n   (WindowsEvent | where TimeGenerated >= ago(dt_lookBack)\n       | where EventID in (\"8003\",\"8002\",\"8005\")\n       | where isnotempty(EventData.FileHash)\n       | extend SecurityEvent_TimeGenerated = TimeGenerated, Event = EventID, FileHash = toupper(EventData.FileHash)\n   )\n )\n on $left.FileHashValue == $right.FileHash\n | where SecurityEvent_TimeGenerated < ExpirationDateTime\n | summarize SecurityEvent_TimeGenerated = arg_max(SecurityEvent_TimeGenerated, *) by IndicatorId, FileHash\n | project SecurityEvent_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\n Process, FileHash, Computer, Account, Event, FileHashValue, FileHashType\n | extend timestamp = SecurityEvent_TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in Security Event data from any File Hash IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_AppServiceHTTPLogs.yaml", "query_name": "TI map IP entity to AppServiceHTTPLogs", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n//Exclude local addresses, using the ipv4_is_private operator\n| where ipv4_is_private(TI_ipEntity) == false and  TI_ipEntity !startswith \"fe80\" and TI_ipEntity !startswith \"::\" and TI_ipEntity !startswith \"127.\"\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  AppServiceHTTPLogs | where TimeGenerated >= ago(dt_lookBack)\n  | where isnotempty(CIp)\n  | extend WebApp = split(_ResourceId, '/')[8]\n  // renaming time column so it is clear the log this came from\n  | extend AppService_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.CIp\n| where AppService_TimeGenerated < ExpirationDateTime\n| summarize AppService_TimeGenerated = arg_max(AppService_TimeGenerated, *) by IndicatorId, CIp\n| project AppService_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, TI_ipEntity, CsUsername, \nWebApp = split(_ResourceId, '/')[8], CIp, CsHost, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress, _ResourceId\n| extend timestamp = AppService_TimeGenerated, AccountCustomEntity = CsUsername, IPCustomEntity = CIp, URLCustomEntity = Url, HostCustomEntity = CsHost\n", "attributes": {"description": "'Identifies a match in AppServiceHTTPLogs from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_AWSCloudTrail.yaml", "query_name": "TI map IP entity to AWSCloudTrail", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    AWSCloudTrail | where TimeGenerated >= ago(dt_lookBack)\n    // renaming time column so it is clear the log this came from\n    | extend AWSCloudTrail_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.SourceIpAddress\n| where AWSCloudTrail_TimeGenerated < ExpirationDateTime\n| summarize AWSCloudTrail_TimeGenerated = arg_max(AWSCloudTrail_TimeGenerated, *) by IndicatorId, SourceIpAddress\n| project AWSCloudTrail_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserIdentityUserName, SourceIpAddress,\nNetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = AWSCloudTrail_TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in AWSCloudTrail from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_AzureActivity.yaml", "query_name": "TI map IP entity to AzureActivity", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    AzureActivity | where TimeGenerated >= ago(dt_lookBack)\n    // renaming time column so it is clear the log this came from\n    | extend AzureActivity_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.CallerIpAddress\n| where AzureActivity_TimeGenerated < ExpirationDateTime\n| summarize AzureActivity_TimeGenerated = arg_max(AzureActivity_TimeGenerated, *) by IndicatorId, CallerIpAddress\n| project AzureActivity_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, TI_ipEntity, CallerIpAddress, \nCaller, OperationNameValue, ActivityStatusValue, CategoryValue, ResourceId, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = AzureActivity_TimeGenerated, IPCustomEntity = CallerIpAddress, AccountCustomEntity = Caller, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in AzureActivity from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_AzureFirewall.yaml", "query_name": "TI map IP entity to AzureFirewall", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    AzureDiagnostics\n    | where TimeGenerated >= ago(dt_lookBack)\n    | where OperationName in (\"AzureFirewallApplicationRuleLog\", \"AzureFirewallNetworkRuleLog\")\n    | parse kind=regex flags=U msg_s with Protocol 'request from ' SourceHost 'to ' DestinationHost @'\\.? Action: ' Firewall_Action @'\\.' Rest_msg\n    | extend SourceAddress = extract(@'([\\.0-9]+)(:[\\.0-9]+)?', 1, SourceHost)\n    | extend DestinationAddress = extract(@'([\\.0-9]+)(:[\\.0-9]+)?', 1, DestinationHost)\n    | extend RemoteIP = case(not(ipv4_is_private(DestinationAddress)), DestinationAddress, not(ipv4_is_private(SourceAddress)), SourceAddress, \"\")\n    // Traffic that involves a public address, and in case this is the source address then the traffic was not denied\n    | where isnotempty(RemoteIP)\n    | project-rename AzureFirewall_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.RemoteIP\n| where AzureFirewall_TimeGenerated < ExpirationDateTime\n| summarize AzureFirewall_TimeGenerated = arg_max(AzureFirewall_TimeGenerated, *) by IndicatorId, RemoteIP\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, DomainName, ExpirationDateTime, ConfidenceScore, AzureFirewall_TimeGenerated,\nTI_ipEntity, Resource, Category, msg_s, SourceAddress, DestinationAddress, Firewall_Action, Protocol, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = AzureFirewall_TimeGenerated, IPCustomEntity = TI_ipEntity, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in AzureFirewall (NetworkRule & ApplicationRule Logs) from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_AzureKeyVault.yaml", "query_name": "TI map IP entity to Azure Key Vault logs", "query": "let dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n        AzureDiagnostics\n       | where ResourceType =~ \"VAULTS\"\n       | where TimeGenerated >= ago(dt_lookBack)\n       | extend KeyVaultEvents_TimeGenerated = TimeGenerated, ClientIP = CallerIPAddress\n)\non $left.TI_ipEntity == $right.ClientIP\n| where KeyVaultEvents_TimeGenerated < ExpirationDateTime\n| summarize KeyVaultEvents_TimeGenerated = arg_max(KeyVaultEvents_TimeGenerated, *) by IndicatorId, ClientIP\n| project KeyVaultEvents_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, ClientIP, ResourceId, SubscriptionId, OperationName, ResultType, CorrelationId, id_s, clientInfo_s, httpStatusCode_d, identity_claim_appid_g, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\n| extend timestamp = KeyVaultEvents_TimeGenerated\n", "attributes": {"description": "'Identifies a match in Azure Key Vault logsfrom any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_AzureNetworkAnalytics.yaml", "query_name": "TI map IP entity to AzureNetworkAnalytics_CL (NSG Flow Logs)", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    AzureNetworkAnalytics_CL\n    | where TimeGenerated >= ago(dt_lookBack)\n    // renaming time column so it is clear the log this came from\n    | extend AzureNetworkAnalytics_CL_TimeGenerated = TimeGenerated\n    // NSG Flow Logs have additional information concat with Public IP, removing onlp Public IP\n    | extend PIPs = split(PublicIPs_s, '|', 0)\n    | extend PIP = tostring(PIPs[0])\n)\non $left.TI_ipEntity == $right.PIP\n| where AzureNetworkAnalytics_CL_TimeGenerated < ExpirationDateTime\n| summarize AzureNetworkAnalytics_CL_TimeGenerated = arg_max(AzureNetworkAnalytics_CL_TimeGenerated, *) by IndicatorId, PIP\n// Set to alert on Allowed NSG Flows from TI Public IP IOC\n| where FlowStatus_s == \"A\"\n| project AzureNetworkAnalytics_CL_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, Computer, FlowDirection_s, FlowStatus_s, FlowType_s, SrcPublicIPs_s, DestPublicIPs_s, PublicIPs_s, L7Protocol_s, DestPort_d, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = AzureNetworkAnalytics_CL_TimeGenerated, IPCustomEntity = TI_ipEntity, HostCustomEntity = Computer, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in AzureNetworkAnalytics_CL (NSG Flow Logs) from any IP IOC from TI that was Allowed'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_AzureSQL.yaml", "query_name": "TI map IP entity to Azure SQL Security Audit Events", "query": "let dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n      AzureDiagnostics\n      | where TimeGenerated >= ago(dt_lookBack)\n      | where ResourceProvider == 'MICROSOFT.SQL'\n      | where Category == 'SQLSecurityAuditEvents'\n      | extend SQLSecurityAuditEvents_TimeGenerated = TimeGenerated\n      // projecting fields with column if exists as this is in AzureDiag and if the event is not in the table, then queries will fail due to event specific schemas\n      | extend ClientIP = column_ifexists(\"client_ip_s\", \"Not Available\"), Action = column_ifexists(\"action_name_s\", \"Not Available\"), \n      Application = column_ifexists(\"application_name_s\", \"Not Available\"), HostName = column_ifexists(\"host_name_s\", \"Not Available\")\n)\non $left.TI_ipEntity == $right.ClientIP\n| where SQLSecurityAuditEvents_TimeGenerated < ExpirationDateTime\n| summarize SQLSecurityAuditEvents_TimeGenerated = arg_max(SQLSecurityAuditEvents_TimeGenerated, *) by IndicatorId, ClientIP\n| project SQLSecurityAuditEvents_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, ResourceId, ClientIP, Action, Application, HostName, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = SQLSecurityAuditEvents_TimeGenerated\n", "attributes": {"description": "'Identifies a match in SQLSecurityAuditEvents from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_CustomSecurityLog.yaml", "query_name": "TI map IP entity to CommonSecurityLog", "query": "let IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    CommonSecurityLog\n    | where TimeGenerated >= ago(dt_lookBack)\n    | extend MessageIP = extract(IPRegex, 0, Message)\n    | extend CS_ipEntity = iff(isnotempty(SourceIP), SourceIP, DestinationIP)\n    | extend CS_ipEntity = iff(isempty(CS_ipEntity) and isnotempty(MessageIP), MessageIP, CS_ipEntity)\n    | extend CommonSecurityLog_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.CS_ipEntity\n| where CommonSecurityLog_TimeGenerated < ExpirationDateTime\n| summarize CommonSecurityLog_TimeGenerated = arg_max(CommonSecurityLog_TimeGenerated, *) by IndicatorId, CS_ipEntity\n| project CommonSecurityLog_TimeGenerated, SourceIP, DestinationIP, MessageIP, Message, DeviceVendor, DeviceProduct, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, TI_ipEntity, CS_ipEntity, LogSeverity, DeviceAction\n| extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = CS_ipEntity\n", "attributes": {"description": "'Identifies a match in CommonSecurityLog from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_DnsEvents.yaml", "query_name": "TI map IP entity to DnsEvents", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    DnsEvents\n    | where TimeGenerated >= ago(dt_lookBack)\n    | where SubType =~ \"LookupQuery\" and isnotempty(IPAddresses)\n    | mv-expand SingleIP = split(IPAddresses, \", \") to typeof(string)\n    // renaming time column so it is clear the log this came from\n    | extend DNS_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.SingleIP\n| where DNS_TimeGenerated < ExpirationDateTime\n| summarize DNS_TimeGenerated = arg_max(DNS_TimeGenerated , *) by IndicatorId, SingleIP\n| project DNS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, DomainName, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, Computer, EventId, SubType, ClientIP, Name, IPAddresses, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = DNS_TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in DnsEvents from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_imWebSession.yaml", "query_name": "(Preview) TI map IP entity to Web Session Events (ASIM Web Session schema)", "query": "let HAS_ANY_MAX = 10000;\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet IP_TI=ThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,\"NO_IP\")\n// Picking up only IOC's that contain the entities we want\n| where TI_ipEntity != \"NO_IP\";\nlet IP_TI_list=toscalar(IP_TI | summarize NIoCs= dcount(TI_ipEntity), IoCs=make_set(TI_ipEntity) \n  | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs )  );\nIP_TI\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    _Im_WebSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)\n    | where isnotempty(SrcIpAddr)\n    // renaming time column so it is clear the log this came from\n    | extend imNWS_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.SrcIpAddr\n| where imNWS_TimeGenerated < ExpirationDateTime\n| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, DstIpAddr\n| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, Dvc, SrcIpAddr, DstIpAddr\n", "attributes": {"description": "'This rule identifies Web Sessions for which the source IP address is a known IoC. <br><br>This rule uses the [Advanced Security Information Model (ASIM)](https://aka.ms/AboutASIM) and supports any web session source that complies with ASIM.'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_OfficeActivity.yaml", "query_name": "TI map IP entity to OfficeActivity", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    OfficeActivity\n    | where TimeGenerated >= ago(dt_lookBack)\n    | where isnotempty(ClientIP)\n    | extend ClientIPValues = extract_all(@'\\[?(::ffff:)?(?P<IPAddress>(\\d+\\.\\d+\\.\\d+\\.\\d+)|[^\\]%]+)(%\\d+)?\\]?([-:](?P<Port>\\d+))?', dynamic([\"IPAddress\", \"Port\"]), ClientIP)[0]\n    | extend IPAddress = tostring(ClientIPValues[0])\n    // renaming time column so it is clear the log this came from\n    | extend OfficeActivity_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.IPAddress\n| where OfficeActivity_TimeGenerated < ExpirationDateTime\n| summarize OfficeActivity_TimeGenerated = arg_max(OfficeActivity_TimeGenerated, *) by IndicatorId\n| project OfficeActivity_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, ClientIP, UserId, Operation, ResultStatus, RecordType, OfficeObjectId, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = OfficeActivity_TimeGenerated, IPCustomEntity = TI_ipEntity, AccountCustomEntity = UserId, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in OfficeActivity from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPentity_SigninLogs.yaml", "query_name": "TI map IP entity to SigninLogs", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet aadFunc = (tableName:string){\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    table(tableName) | where TimeGenerated >= ago(dt_lookBack)\n    | extend Status = todynamic(Status), LocationDetails = todynamic(LocationDetails)\n    | extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails), StatusReason = tostring(Status.failureReason)\n    | extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city), Region = tostring(LocationDetails.countryOrRegion)\n    // renaming time column so it is clear the log this came from\n    | extend SigninLogs_TimeGenerated = TimeGenerated, Type = Type\n)\non $left.TI_ipEntity == $right.IPAddress\n| where SigninLogs_TimeGenerated < ExpirationDateTime\n| summarize SigninLogs_TimeGenerated = arg_max(SigninLogs_TimeGenerated, *) by IndicatorId, IPAddress\n| project SigninLogs_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, IPAddress, UserPrincipalName, AppDisplayName, StatusCode, StatusDetails, StatusReason, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress, Type\n| extend timestamp = SigninLogs_TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress, URLCustomEntity = Url\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies a match in SigninLogs from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_VMConnection.yaml", "query_name": "TI map IP entity to VMConnection", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    VMConnection\n    | where TimeGenerated >= ago(dt_lookBack)\n    // renaming time column so it is clear the log this came from\n    | extend VMConnection_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.RemoteIp\n| where VMConnection_TimeGenerated < ExpirationDateTime\n| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, RemoteIp\n| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, Computer, Direction, ProcessName, SourceIp, DestinationIp, RemoteIp, Protocol, DestinationPort, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in VMConnection from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_W3CIISLog.yaml", "query_name": "TI map IP entity to W3CIISLog", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n//Exclude local addresses, using the ipv4_is_private operator\n| where ipv4_is_private(TI_ipEntity) == false and  TI_ipEntity !startswith \"fe80\" and TI_ipEntity !startswith \"::\" and TI_ipEntity !startswith \"127.\"\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    W3CIISLog\n    | where TimeGenerated >= ago(dt_lookBack)\n    | where isnotempty(cIP)\n    //Exclude local addresses, using the ipv4_is_private operator\n    | where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"\n    // renaming time column so it is clear the log this came from\n    | extend W3CIISLog_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.cIP\n| where W3CIISLog_TimeGenerated < ExpirationDateTime\n| summarize W3CIISLog_TimeGenerated = arg_max(W3CIISLog_TimeGenerated, *) by IndicatorId, cIP\n| project W3CIISLog_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, Computer, sSiteName, cIP, sIP, sPort, csMethod, csUserName, scStatus, scSubStatus, scWin32Status,\nNetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = W3CIISLog_TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in W3CIISLog from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/IPEntity_WireData.yaml", "query_name": "TI map IP entity to WireData", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    WireData | where TimeGenerated >= ago(dt_lookBack)\n    | where isnotempty(RemoteIP)\n    // renaming time column so it is clear the log this came from\n    | extend WireData_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.RemoteIP\n| where WireData_TimeGenerated < ExpirationDateTime\n| summarize WireData_TimeGenerated = arg_max(WireData_TimeGenerated, *) by IndicatorId, RemoteIP\n| project WireData_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, Computer, LocalIP, RemoteIP, ProcessName, ApplicationProtocol, LocalPortNumber, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = WireData_TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = Computer, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in WireData from any IP IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_AuditLogs.yaml", "query_name": "TI map URL entity to AuditLogs", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(Url)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  AuditLogs\n  | where TimeGenerated >= ago(dt_lookBack)\n  // Extract the URL that is contained within the JSON data\n  | extend Url = extract(\"(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+);\", 1,tostring(TargetResources))\n  | where isnotempty(Url)\n  | extend userPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend TargetResourceDisplayName = tostring(TargetResources[0].displayName)\n  | extend Audit_TimeGenerated = TimeGenerated\n) on Url\n| where Audit_TimeGenerated < ExpirationDateTime\n| summarize Audit_TimeGenerated = arg_max(Audit_TimeGenerated, *) by IndicatorId, Url\n| project Audit_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,\nOperationName, Identity, userPrincipalName, TargetResourceDisplayName, Url\n| extend timestamp = Audit_TimeGenerated, AccountCustomEntity = userPrincipalName, HostCustomEntity = TargetResourceDisplayName, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in AuditLogs from any URL IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_OfficeActivity.yaml", "query_name": "TI map URL entity to OfficeActivity data", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(Url)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  OfficeActivity\n  | where TimeGenerated >= ago(dt_lookBack)\n  //Extract the Url from a number of potential fields\n  | extend Url = iif(OfficeWorkload == \"AzureActiveDirectory\",extract(\"(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+);\", 1,ModifiedProperties),tostring(parse_json(ModifiedProperties)[12].NewValue))\n  | where isnotempty(Url)\n  // Ensure we get a clean URL\n  | extend Url = tostring(split(Url, ';')[0])\n  | extend OfficeActivity_TimeGenerated = TimeGenerated\n  // Project a single user identity that we can use for entity mapping\n  | extend User = iif(isnotempty(UserId), UserId, iif(isnotempty(Actor), tostring(parse_json(Actor)[0].ID), tostring(parse_json(Parameters)[0].Value)))\n) on Url\n| where OfficeActivity_TimeGenerated < ExpirationDateTime\n| summarize OfficeActivity_TimeGenerated = arg_max(OfficeActivity_TimeGenerated, *) by IndicatorId, Url\n| project OfficeActivity_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Operation, \nUserType, OfficeWorkload, Parameters, Url, User\n| extend timestamp = OfficeActivity_TimeGenerated, AccountCustomEntity = User, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in OfficeActivity data from any URL IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_PaloAlto.yaml", "query_name": "TI map URL entity to PaloAlto data", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(Url)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  CommonSecurityLog\n  | extend IngestionTime = ingestion_time()\n  | where IngestionTime > ago(dt_lookBack)\n  // Select on Palo Alto logs\n  | where DeviceVendor =~ \"Palo Alto Networks\"\n  | where DeviceEventClassID =~ 'url'\n  //Uncomment the line below to only alert on allowed connections\n  //| where DeviceAction !~ \"block-url\"\n  //Select logs where URL data is populated\n  | extend PA_Url = columnifexists(\"RequestURL\", \"None\")\n  | extend PA_Url = iif(isempty(PA_Url), extract(\"([^\\\"]+)\", 1, tolower(AdditionalExtensions)), trim('\"', PA_Url))\n  | extend PA_Url = iif(PA_Url !startswith \"http://\" and ApplicationProtocol !~ \"ssl\", strcat('http://', PA_Url), iif(PA_Url !startswith \"https://\" and ApplicationProtocol =~ \"ssl\", strcat('https://', PA_Url), PA_Url))\n  | where isnotempty(PA_Url)\n  | extend CommonSecurityLog_TimeGenerated = TimeGenerated\n) on $left.Url == $right.PA_Url\n| where CommonSecurityLog_TimeGenerated < ExpirationDateTime\n| summarize CommonSecurityLog_TimeGenerated = arg_max(CommonSecurityLog_TimeGenerated, *) by IndicatorId, PA_Url\n| project CommonSecurityLog_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, DeviceAction, SourceIP, PA_Url, DeviceName\n| extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, URLCustomEntity = PA_Url\n", "attributes": {"description": "'Identifies a match in PaloAlto data from any URL IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_SecurityAlerts.yaml", "query_name": "TI map URL entity to SecurityAlert data", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(Url)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  SecurityAlert\n  | where TimeGenerated >= ago(dt_lookBack)\n  | extend MSTI = case(AlertName has \"TI map\" and VendorName == \"Microsoft\" and ProductName == 'Azure Sentinel', true, false)\n  | where MSTI == false\n  // Extract URL from JSON data\n  | extend Url = extract(\"(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+)\", 1,Entities)\n  // We only want alerts that actually contain URL data\n  | where isnotempty(Url)\n  // Extract hostname from JSON data for entity mapping\n  | extend Compromised_Host = tostring(parse_json(ExtendedProperties).[\"Compromised Host\"])\n  | extend Alert_TimeGenerated = TimeGenerated\n) on Url\n| where Alert_TimeGenerated < ExpirationDateTime\n| summarize Alert_TimeGenerated = arg_max(Alert_TimeGenerated, *) by IndicatorId, AlertName\n| project Alert_TimeGenerated, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, AlertName, AlertSeverity, Description, Url, Compromised_Host\n| extend timestamp = Alert_TimeGenerated, HostCustomEntity = Compromised_Host, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in SecurityAlert data from any URL IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ThreatIntelligenceIndicator/URLEntity_Syslog.yaml", "query_name": "TI map URL entity to Syslog data", "query": "\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(Url)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  Syslog\n  | where TimeGenerated >= ago(dt_lookBack)\n  // Extract URL from the Syslog message but only take messages that include URLs\n  | extend Url = extract(\"(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+)\", 1,SyslogMessage)\n  | where isnotempty(Url)\n  | extend Syslog_TimeGenerated = TimeGenerated\n) on Url\n| where Syslog_TimeGenerated < ExpirationDateTime\n| summarize Syslog_TimeGenerated  = arg_max(Syslog_TimeGenerated , *) by IndicatorId, Url\n| project Syslog_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, SyslogMessage, Computer, ProcessName, Url, HostIP\n| extend timestamp = Syslog_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = HostIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in Syslog data from any URL IOC from TI'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/AnomomlousUserAgentConnection.yaml", "query_name": "Anomalous User Agent connection attempt", "query": "\nlet short_uaLength = 5;\nlet long_uaLength = 1000;\nlet c_threshold = 100;\nW3CIISLog \n// Exclude local IPs as these create noise\n| where cIP !startswith \"192.168.\" and cIP != \"::1\"\n| where isnotempty(csUserAgent) and csUserAgent !in~ (\"-\", \"MSRPC\") and (string_size(csUserAgent) <= short_uaLength or string_size(csUserAgent) >= long_uaLength)\n| extend csUserAgent_size = string_size(csUserAgent)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ConnectionCount = count() by Computer, sSiteName, sPort, csUserAgent, csUserAgent_size, csUserName , csMethod, csUriStem, sIP, cIP, scStatus, scSubStatus, scWin32Status\n| where ConnectionCount < c_threshold\n| extend timestamp = StartTimeUtc, AccountCustomEntity = csUserName, HostCustomEntity = Computer, IPCustomEntity = cIP\n", "attributes": {"description": "'Identifies connection attempts (success or fail) from clients with very short or very long User Agent strings and with less than 100 connection attempts.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/HAFNIUMSuspiciousExchangeRequestPattern.yaml", "query_name": "HAFNIUM Suspicious Exchange Request", "query": "let exchange_servers = (\nW3CIISLog\n| where TimeGenerated > ago(14d)\n| where sSiteName =~ \"Exchange Back End\"\n| summarize by Computer);\nW3CIISLog\n| where TimeGenerated > ago(1d)\n| where Computer in (exchange_servers)\n| where csUriQuery startswith \"t=\"\n| project-reorder TimeGenerated, Computer, csUriStem, csUriQuery, csUserName, csUserAgent, cIP\n| extend timestamp = TimeGenerated, AccountCustomEntity = csUserName, HostCustomEntity = Computer, IPCustomEntity = cIP\n", "attributes": {"description": "'This query looks for suspicious request patterns to Exchange servers that fit a pattern observed by HAFNIUM actors.\nThe same query can be run on HTTPProxy logs from on-premise hosted Exchange servers.\nReference: https://www.microsoft.com/security/blog/2021/03/02/hafnium-targeting-exchange-servers/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/HighFailedLogonCountByClientIP.yaml", "query_name": "High count of failed attempts from same client IP", "query": "\nlet timeBin = 1m;\nlet failedThreshold = 20;\nW3CIISLog\n| where scStatus in (\"401\",\"403\")\n| where csUserName != \"-\"\n| extend scStatusFull = strcat(scStatus, \".\",scSubStatus) \n// Map common IIS codes\n| extend scStatusFull_Friendly = case(\nscStatusFull == \"401.0\", \"Access denied.\",\nscStatusFull == \"401.1\", \"Logon failed.\",\nscStatusFull == \"401.2\", \"Logon failed due to server configuration.\",\nscStatusFull == \"401.3\", \"Unauthorized due to ACL on resource.\",\nscStatusFull == \"401.4\", \"Authorization failed by filter.\",\nscStatusFull == \"401.5\", \"Authorization failed by ISAPI/CGI application.\",\nscStatusFull == \"403.0\", \"Forbidden.\",\nscStatusFull == \"403.4\", \"SSL required.\",\n\"See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\")\n// Mapping to Hex so can be mapped using website in comments above\n| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) \n// Map common win32 codes\n| extend scWin32Status_Friendly = case(\nscWin32Status_Hex =~ \"775\", \"The referenced account is currently locked out and cannot be logged on to.\",\nscWin32Status_Hex =~ \"52e\", \"Logon failure: Unknown user name or bad password.\",\nscWin32Status_Hex =~ \"532\", \"Logon failure: The specified account password has expired.\",\nscWin32Status_Hex =~ \"533\", \"Logon failure: Account currently disabled.\", \nscWin32Status_Hex =~ \"2ee2\", \"The request has timed out.\", \nscWin32Status_Hex =~ \"0\", \"The operation completed successfully.\", \nscWin32Status_Hex =~ \"1\", \"Incorrect function.\", \nscWin32Status_Hex =~ \"2\", \"The system cannot find the file specified.\", \nscWin32Status_Hex =~ \"3\", \"The system cannot find the path specified.\", \nscWin32Status_Hex =~ \"4\", \"The system cannot open the file.\", \nscWin32Status_Hex =~ \"5\", \"Access is denied.\", \nscWin32Status_Hex =~ \"8009030e\", \"SEC_E_NO_CREDENTIALS\", \nscWin32Status_Hex =~ \"8009030C\", \"SEC_E_LOGON_DENIED\", \n\"See - https://msdn.microsoft.com/library/cc231199.aspx\")\n// decode URI when available\n| extend decodedUriQuery = url_decode(csUriQuery)\n// Count of failed attempts from same client IP\n| summarize makeset(decodedUriQuery), makeset(csUserName), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), FailedConnectionsCount = count() by bin(TimeGenerated, timeBin), cIP, Computer, sIP\n| where FailedConnectionsCount >= failedThreshold\n| project TimeGenerated, cIP, set_csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_sPort, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, FailedConnectionsCount\n| order by FailedConnectionsCount\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = cIP\n", "attributes": {"description": "'Identifies when 20 or more failed attempts from a given client IP in 1 minute occur on the IIS server.\nThis could be indicative of an attempted brute force. This could also simply indicate a misconfigured service or device.\nRecommendations: Validate that these are expected connections from the given Client IP.  If the client IP is not recognized, \npotentially block these connections at the edge device.\nIf these are expected connections, verify the credentials are properly configured on the system, service, application or device \nthat is associated with the client IP.\nReferences:\nIIS status code mapping: https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\nWin32 Status code mapping: https://msdn.microsoft.com/library/cc231199.aspx'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/HighFailedLogonCountByUser.yaml", "query_name": "High count of failed logons by a user", "query": "\nlet timeBin = 10m;\nlet failedThreshold = 100;\nW3CIISLog\n| where scStatus in (\"401\",\"403\")\n| where csUserName != \"-\"\n// Handling Exchange specific items in IIS logs to remove the unique log identifier in the URI\n| extend csUriQuery = iff(csUriQuery startswith \"MailboxId=\", tostring(split(csUriQuery, \"&\")[0]) , csUriQuery )\n| extend csUriQuery = iff(csUriQuery startswith \"X-ARR-CACHE-HIT=\", strcat(tostring(split(csUriQuery, \"&\")[0]),tostring(split(csUriQuery, \"&\")[1])) , csUriQuery )\n| extend scStatusFull = strcat(scStatus, \".\",scSubStatus) \n// Map common IIS codes\n| extend scStatusFull_Friendly = case(\nscStatusFull == \"401.0\", \"Access denied.\",\nscStatusFull == \"401.1\", \"Logon failed.\",\nscStatusFull == \"401.2\", \"Logon failed due to server configuration.\",\nscStatusFull == \"401.3\", \"Unauthorized due to ACL on resource.\",\nscStatusFull == \"401.4\", \"Authorization failed by filter.\",\nscStatusFull == \"401.5\", \"Authorization failed by ISAPI/CGI application.\",\nscStatusFull == \"403.0\", \"Forbidden.\",\nscStatusFull == \"403.4\", \"SSL required.\",\n\"See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\")\n// Mapping to Hex so can be mapped using website in comments above\n| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) \n// Map common win32 codes\n| extend scWin32Status_Friendly = case(\nscWin32Status_Hex =~ \"775\", \"The referenced account is currently locked out and cannot be logged on to.\",\nscWin32Status_Hex =~ \"52e\", \"Logon failure: Unknown user name or bad password.\",\nscWin32Status_Hex =~ \"532\", \"Logon failure: The specified account password has expired.\",\nscWin32Status_Hex =~ \"533\", \"Logon failure: Account currently disabled.\", \nscWin32Status_Hex =~ \"2ee2\", \"The request has timed out.\", \nscWin32Status_Hex =~ \"0\", \"The operation completed successfully.\", \nscWin32Status_Hex =~ \"1\", \"Incorrect function.\", \nscWin32Status_Hex =~ \"2\", \"The system cannot find the file specified.\", \nscWin32Status_Hex =~ \"3\", \"The system cannot find the path specified.\", \nscWin32Status_Hex =~ \"4\", \"The system cannot open the file.\", \nscWin32Status_Hex =~ \"5\", \"Access is denied.\", \nscWin32Status_Hex =~ \"8009030e\", \"SEC_E_NO_CREDENTIALS\", \nscWin32Status_Hex =~ \"8009030C\", \"SEC_E_LOGON_DENIED\", \n\"See - https://msdn.microsoft.com/library/cc231199.aspx\")\n// decode URI when available\n| extend decodedUriQuery = url_decode(csUriQuery)\n// Count of failed logons by a user\n| summarize makeset(decodedUriQuery), makeset(cIP), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), FailedConnectionsCount = count() by bin(TimeGenerated, timeBin), csUserName, Computer, sIP\n| where FailedConnectionsCount >= failedThreshold\n| project TimeGenerated, csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_cIP, set_sPort, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, FailedConnectionsCount\n| order by FailedConnectionsCount\n| extend timestamp = TimeGenerated, AccountCustomEntity = csUserName, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies when 100 or more failed attempts by a given user in 10 minutes occur on the IIS Server.\nThis could be indicative of attempted brute force based on known account information.\nThis could also simply indicate a misconfigured service or device. \nReferences:\nIIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\nWin32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/HighPortCountByClientIP.yaml", "query_name": "High count of connections by client IP on many ports", "query": "\nlet timeBin = 10m;\nlet portThreshold = 30;\nW3CIISLog\n| extend scStatusFull = strcat(scStatus, \".\",scSubStatus) \n// Map common IIS codes\n| extend scStatusFull_Friendly = case(\nscStatusFull == \"401.0\", \"Access denied.\",\nscStatusFull == \"401.1\", \"Logon failed.\",\nscStatusFull == \"401.2\", \"Logon failed due to server configuration.\",\nscStatusFull == \"401.3\", \"Unauthorized due to ACL on resource.\",\nscStatusFull == \"401.4\", \"Authorization failed by filter.\",\nscStatusFull == \"401.5\", \"Authorization failed by ISAPI/CGI application.\",\nscStatusFull == \"403.0\", \"Forbidden.\",\nscStatusFull == \"403.4\", \"SSL required.\",\n\"See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\")\n// Mapping to Hex so can be mapped using website in comments above\n| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) \n// Map common win32 codes\n| extend scWin32Status_Friendly = case(\nscWin32Status_Hex =~ \"775\", \"The referenced account is currently locked out and cannot be logged on to.\",\nscWin32Status_Hex =~ \"52e\", \"Logon failure: Unknown user name or bad password.\",\nscWin32Status_Hex =~ \"532\", \"Logon failure: The specified account password has expired.\",\nscWin32Status_Hex =~ \"533\", \"Logon failure: Account currently disabled.\", \nscWin32Status_Hex =~ \"2ee2\", \"The request has timed out.\", \nscWin32Status_Hex =~ \"0\", \"The operation completed successfully.\", \nscWin32Status_Hex =~ \"1\", \"Incorrect function.\", \nscWin32Status_Hex =~ \"2\", \"The system cannot find the file specified.\", \nscWin32Status_Hex =~ \"3\", \"The system cannot find the path specified.\", \nscWin32Status_Hex =~ \"4\", \"The system cannot open the file.\", \nscWin32Status_Hex =~ \"5\", \"Access is denied.\", \nscWin32Status_Hex =~ \"8009030e\", \"SEC_E_NO_CREDENTIALS\", \nscWin32Status_Hex =~ \"8009030C\", \"SEC_E_LOGON_DENIED\", \n\"See - https://msdn.microsoft.com/library/cc231199.aspx\")\n// decode URI when available\n| extend decodedUriQuery = url_decode(csUriQuery)\n// Count of attempts by client IP on many ports\n| summarize makeset(sPort), makeset(decodedUriQuery), makeset(csUserName), makeset(sSiteName), makeset(sPort), makeset(csUserAgent), makeset(csMethod), makeset(csUriQuery), makeset(scStatusFull), makeset(scStatusFull_Friendly), makeset(scWin32Status_Hex), makeset(scWin32Status_Friendly), ConnectionsCount = count() by bin(TimeGenerated, timeBin), cIP, Computer, sIP\n| extend portCount = arraylength(set_sPort)\n| where portCount >= portThreshold\n| project TimeGenerated, cIP, set_sPort, set_csUserName, set_decodedUriQuery, Computer, set_sSiteName, sIP, set_csUserAgent, set_csMethod, set_scStatusFull, set_scStatusFull_Friendly, set_scWin32Status_Hex, set_scWin32Status_Friendly, ConnectionsCount, portCount\n| order by portCount\n| extend timestamp = TimeGenerated, IPCustomEntity = cIP\n", "attributes": {"description": "'Identifies when 30 or more ports are used for a given client IP in 10 minutes occurring on the IIS server.\nThis could be indicative of attempted port scanning or exploit attempt at internet facing web applications.  \nThis could also simply indicate a misconfigured service or device.\nReferences:\nIIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\nWin32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/MaliciousAlertLinkedWebRequests.yaml", "query_name": "Malicious web application requests linked with Microsoft Defender for Endpoint (formerly Microsoft Defender ATP) alerts", "query": "\nlet alertTimeWindow = 1h;\nlet logTimeWindow = 7d;\n// Define script extensions that suit your web application environment - a sample are provided below\nlet scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\", \".cfm\", \".shtml\"]); \nlet alertData = materialize(SecurityAlert \n| where TimeGenerated > ago(alertTimeWindow) \n| where ProviderName == \"MDATP\" \n// Parse and expand the alert JSON \n| extend alertData = parse_json(Entities) \n| mvexpand alertData);\nlet fileData = alertData\n// Extract web script files from MDATP alerts - our malicious web scripts - candidate webshells\n| where alertData.Type =~ \"file\" \n| where alertData.Name has_any(scriptExtensions) \n| extend FileName = tostring(alertData.Name), Directory = tostring(alertData.Directory);\nlet hostData = alertData\n// Extract server details from alerts and map to alert id\n| where alertData.Type =~ \"host\"\n| project HostName = tostring(alertData.HostName), DnsDomain = tostring(alertData.DnsDomain), SystemAlertId\n| distinct HostName, DnsDomain, SystemAlertId;\n// Join the files on their impacted servers\nlet webshellData = fileData\n| join kind=inner (hostData) on SystemAlertId \n| project TimeGenerated, FileName, Directory, HostName, DnsDomain;\nwebshellData\n| join (  \n// Find requests that were made to this file on the impacted server in the W3CIISLog table \nW3CIISLog  \n| where TimeGenerated > ago(logTimeWindow) \n// Restrict to accesses to script extensions \n| where csUriStem has_any(scriptExtensions)\n| extend splitUriStem = split(csUriStem, \"/\")  \n| extend FileName = splitUriStem[-1], HostName = sComputerName\n// Summarize potential attacker activity\n| summarize count(), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), RequestUserAgents=make_set(csUserAgent), ReqestMethods=make_set(csMethod), RequestStatusCodes=make_set(scStatus), RequestCookies=make_set(csCookie), RequestReferers=make_set(csReferer), RequestQueryStrings=make_set(csUriQuery) by AttackerIP=cIP, SiteName=sSiteName, ShellLocation=csUriStem, tostring(FileName), HostName  \n) on FileName, HostName\n| project StartTime, EndTime, AttackerIP, RequestUserAgents, HostName, SiteName, ShellLocation, ReqestMethods, RequestStatusCodes, RequestCookies, RequestReferers, RequestQueryStrings, RequestCount = count_\n// Expose the attacker ip address as a custom entity\n| extend timestamp=StartTime, IPCustomEntity = AttackerIP, HostCustomEntity = HostName\n", "attributes": {"description": "'Takes Microsoft Defender for Endpoint (formerly Microsoft Defender ATP) alerts where web scripts are present in the evidence and correlates with requests made to those scripts\nin the WCSIISLog to surface new alerts for potentially malicious web request activity.\nThe lookback for alerts is set to 1h and the lookback for W3CIISLogs is set to 7d. A sample set of popular web script extensions\nhas been provided in scriptExtensions that should be tailored to your environment.'\n", "techniques": ["T1505"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/ProxyShellPwn2Own.yaml", "query_name": "Exchange SSRF Autodiscover ProxyShell - Detection", "query": "let successCodes = dynamic([200, 302, 401]);\nW3CIISLog\n| where scStatus has_any (successCodes)\n| where ipv4_is_private(cIP) == False\n| where csUriStem hasprefix \"/autodiscover/autodiscover.json\"\n| project TimeGenerated, cIP, sIP, sSiteName, csUriStem, csUriQuery, Computer, csUserName, _ResourceId, FileUri\n| where (csUriQuery !has \"Protocol\" and isnotempty(csUriQuery))\nor (csUriQuery has_any(\"/mapi/\", \"powershell\"))\nor (csUriQuery contains \"@\" and csUriQuery matches regex @\"\\.[a-zA-Z]{2,4}?(?:[a-zA-Z]{2,4}\\/)\")\nor (csUriQuery contains \":\" and csUriQuery matches regex @\"\\:[0-9]{2,4}\\/\")\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = cIP, AccountCustomEntity = csUserName, ResourceCustomEntity = _ResourceId, FileCustomEntity = FileUri\n", "attributes": {"description": "'This query looks for suspicious request patterns to Exchange servers that fit patterns recently\nblogged about by PeterJson. This exploitation chain utilises an SSRF vulnerability in Exchange\nwhich eventually allows the attacker to execute arbitrary Powershell on the server. In the example\npowershell can be used to write an email to disk with an encoded attachment containing a shell.\nReference: https://peterjson.medium.com/reproducing-the-proxyshell-pwn2own-exploit-49743a4ea9a1'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/W3CIISLog/Supernovawebshell.yaml", "query_name": "SUPERNOVA webshell", "query": "\nW3CIISLog\n| where csMethod == 'GET'\n| where isnotempty(csUriStem) and isnotempty(csUriQuery)\n| where csUriStem contains \"logoimagehandler.ashx\"\n| where csUriQuery contains \"codes\" and csUriQuery contains \"clazz\" and csUriQuery contains \"method\" and csUriQuery contains \"args\"\n| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName\n", "attributes": {"description": "'Identifies SUPERNOVA webshell based on W3CIISLog data.\n References:\n - https://unit42.paloaltonetworks.com/solarstorm-supernova/'\n", "techniques": ["T1505", "T1071"], "tactics": ["Persistence", "CommandandControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ZoomLogs/E2EEDisbaled.yaml", "query_name": "Zoom E2E Encryption Disabled", "query": "\nZoomLogs\n| where Event =~ \"account.settings_updated\"\n| extend NewE2ESetting = columnifexists(\"payload_object_settings_in_meeting_e2e_encryption_b\", \"\")\n| extend OldE2ESetting = columnifexists(\"payload_old_object_settings_in_meeting_e2e_encryption_b\", \"\")\n| where OldE2ESetting =~ 'false' and NewE2ESetting =~ 'true'\n| extend timestamp = TimeGenerated, AccountCustomEntity = User\n", "attributes": {"description": "'This alerts when end to end encryption is disabled for Zoom meetings.'\n", "techniques": ["T1040"], "tactics": ["CredentialAccess", "Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ZoomLogs/ExternalUserAccess.yaml", "query_name": "External User Access Enabled", "query": "\nZoomLogs\n| where Event =~ \"account.settings_updated\" \n| extend EnforceLogin = columnifexists(\"payload_object_settings_schedule_meeting_enfore_login_b\", \"\") \n| extend EnforceLoginDomain = columnifexists(\"payload_object_settings_schedule_meeting_enfore_login_b\", \"\") \n| extend GuestAlerts = columnifexists(\"payload_object_settings_in_meeting_alert_guest_join_b\", \"\") \n| where EnforceLogin == 'false' or EnforceLoginDomain == 'false' or GuestAlerts == 'false' \n| extend SettingChanged = case(EnforceLogin == 'false' and EnforceLoginDomain == 'false' and GuestAlerts == 'false', \"All settings changed\", \n                            EnforceLogin == 'false' and EnforceLoginDomain == 'false', \"Enforced Logons and Restricted Domains Changed\", \n                            EnforceLoginDomain == 'false' and GuestAlerts == 'false', \"Enforced Domains Changed\", \n                            EnforceLoginDomain == 'false', \"Enfored Domains Changed\", \n                            GuestAlerts == 'false', \"Guest Join Alerts Changed\", \n                            EnforceLogin == 'false', \"Enforced Logins Changed\", \n                            \"No Changes\")\n| extend timestamp = TimeGenerated, AccountCustomEntity = User\n", "attributes": {"description": "'This alerts when the account setting is changed to allow either external domain access or anonymous access to meetings.'\n", "techniques": ["T1098", "T1556"], "tactics": ["CredentialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ZoomLogs/JoiningMeetingFromAnotherTimeZone.yaml", "query_name": "User joining Zoom meeting from suspicious timezone", "query": "\nlet schedule_lookback = 14d; \nlet join_lookback = 1d; \n// If you want to whitelist specific timezones include them in a list here\nlet tz_whitelist = dynamic([]);\nlet meetings = ( \nZoomLogs \n| where TimeGenerated >= ago(schedule_lookback) \n| where Event =~ \"meeting.created\" \n| extend MeetingId = tostring(parse_json(MeetingEvents).MeetingId)  \n| extend SchedTimezone = tostring(parse_json(MeetingEvents).Timezone)); \nZoomLogs \n| where TimeGenerated >= ago(join_lookback) \n| where Event =~ \"meeting.participant_joined\" \n| extend JoinedTimeZone = tostring(parse_json(MeetingEvents).Timezone) \n| extend MeetingName = tostring(parse_json(MeetingEvents).MeetingName) \n| extend MeetingId = tostring(parse_json(MeetingEvents).MeetingId) \n| where JoinedTimeZone !in (tz_whitelist)\n| join (meetings) on MeetingId \n| where SchedTimezone != JoinedTimeZone \n| project TimeGenerated, MeetingName, JoiningUser=payload_object_participant_user_name_s, JoinedTimeZone, SchedTimezone, MeetingScheduler=User1 \n| extend timestamp = TimeGenerated, AccountCustomEntity = JoiningUser\n", "attributes": {"description": "'The alert shows users that join a Zoom meeting from a time zone other than the one the meeting was created in.\nYou can also whitelist known good time zones in the tz_whitelist value using the tz database name format https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Detections/ZoomLogs/SupiciousLinkSharing.yaml", "query_name": "Suspicious link sharing pattern", "query": "\nlet threshold = 3; \nZoomLogs \n| where Event =~ \"chat_message.sent\" \n| extend Channel = tostring(parse_json(ChatEvents).Channel)  \n| extend Message = tostring(parse_json(ChatEvents).Message) \n| where Message matches regex \"http(s?):\\\\/\\\\/\" \n| summarize Channels = makeset(Channel), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Message, User, UserId\n| extend ChannelCount = arraylength(Channels) \n| where ChannelCount > threshold\n| extend timestamp = StartTime, AccountCustomEntity = User\n", "attributes": {"description": "'Alerts in links that have been shared across multiple Zoom chat channels by the same user in a short space if time. \nAdjust the threshold figure to change the number of channels a message needs to be posted in before an alert is raised.'\n", "techniques": NaN, "tactics": ["CredentialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/Discorddownloadinvokedfromcmdline%28ASIMVersion%29.yaml", "query_name": "Discord download invoked from cmd line (ASIM Version)", "query": "imProcess\n  | where Process has_any (\"powershell.exe\", \"powershell_ise.exe\", \"cmd.exe\") or CommandLine has \"powershell\"\n  | where CommandLine has_any (\"cdn.discordapp.com\", \"moc.ppadrocsid.ndc\")\n  | project-reorder TimeGenerated, Computer, Account, Process, CommandLine\n", "attributes": {"description": "'This hunting query looks for hosts that have attempted to interact with the Discord CDN. This activity is not normally invoked from the command line and could indicate C2, exfiltration, or malware delivery activity.'\n", "techniques": ["T1204", "T1102", "T1567"], "tactics": ["Execution", "CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_Certutil-LOLBins.yaml", "query_name": "Certutil (LOLBins and LOLScripts, Normalized Process Events)", "query": "imProcessCreate\n| where Process has \"certutil.exe\"\n// Uncomment the next line and add your commandLine Whitelisted/ignore terms.For example \"urlcache\"\n// | where CommandLine !contains (\"urlcache\") \n| extend HostCustomEntity = Dvc, AccountCustomEntity = User\n", "attributes": {"description": "'This detection uses Normalized Process Events to hunt Certutil activities'\n", "techniques": ["T1105"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_cscript_summary.yaml", "query_name": "Cscript script daily summary breakdown (Normalized Process Events)", "query": "imProcessCreate\n| where Process has \"cscript.exe\"\n| extend FileName=tostring(split(Process, '\\\\')[-1])\n| where FileName =~ \"cscript.exe\"\n| extend removeSwitches = replace(@\"/+[a-zA-Z0-9:]+\", \"\", CommandLine)\n| extend CommandLine = trim(@\"[a-zA-Z0-9\\\\:\"\"]*cscript(.exe)?(\"\")?(\\s)+\", removeSwitches)\n// handle case where script name is enclosed in \" characters or is not enclosed in quotes \n| extend ScriptName= iff(CommandLine startswith @\"\"\"\", \nextract(@\"([:\\\\a-zA-Z_\\-\\s0-9\\.()]+)(\"\"?)\", 0, CommandLine), \nextract(@\"([:\\\\a-zA-Z_\\-0-9\\.()]+)(\"\"?)\", 0, CommandLine))\n| extend ScriptName=trim(@\"\"\"\", ScriptName) , ScriptNameLength=strlen(ScriptName)\n// extract remainder of commandline as script parameters: \n| extend ScriptParams = iff(ScriptNameLength < strlen(CommandLine), substring(CommandLine, ScriptNameLength +1), \"\")\n| summarize min(TimeGenerated), count() by Dvc, User, ScriptName, ScriptParams, EventVendor, EventProduct\n| order by count_ asc nulls last \n| extend timestamp = min_TimeGenerated, HostCustomEntity = Dvc, AccountCustomEntity = User\n", "attributes": {"description": "'breakdown of scripts running in the environment'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_Dev-0056CommandLineActivityNovember2021%28ASIMVersion%29.yaml", "query_name": "Dev-0056 Command Line Activity November 2021 (ASIM Version)", "query": "imProcess\n| where ( CommandLine has_any(\"/q /c color f7&\", \"Net.We$()bClient\", \"$b,15,$b.Length-15\")) or (CommandLine has \"FromBase64String\" and CommandLine has_all(\"-nop\", \"iex\", \"(iex\"))\n| summarize count(), FirstSeen=min(TimeGenerated), LastSeen = max(TimeGenerated) by DvcId, Dvc, CommandLine, AccountName, FilePath\n// Base risk score on number of command lines seen for each host\n| extend RiskScore = count_\n// Increase risk score if host has recent security alerts\n| join kind=leftouter (SecurityAlert\n| where ProviderName =~ \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| mv-expand todynamic(Entities)\n| extend DvcId = tostring(parse_json(Entities).MdatpDeviceId)\n| where isnotempty(DvcId)\n// Increase risk score further if alerts relate to malware assocaited with threat actor\n| extend AlertRiskScore = iif(ThreatName has_any (\"Backdoor:MSIL/ShellClient.A\", \"Backdoor:MSIL/ShellClient.A!dll\", \"Trojan:MSIL/Mimikatz.BA!MTB\"), 1.0, 0.5)) on DvcId\n// Create aggregate risk score\n| extend AlertRiskScore = iif(isempty(AlertRiskScore), 0.0 , AlertRiskScore)\n| extend RiskScore = RiskScore + AlertRiskScore\n| project-reorder  FirstSeen, LastSeen, RiskScore, Dvc, DvcId, CommandLine, AccountName\n| extend timestamp = FirstSeen, AccountCustomEntity = AccountName, HostCustomEntity = Dvc\n", "attributes": {"description": "' This hunting query looks for process command line activity related to activity observed by Dev-0056.The command lines this query hunts for are used as part of the threat actor's post exploitation activity.\n  This query uses the Microsoft Sentinel Information Model - https://docs.microsoft.com/azure/sentinel/normalization'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_enumeration_user_and_group.yaml", "query_name": "Enumeration of users and groups (Normalized Process Events)", "query": "\nimProcessCreate\n| where (CommandLine has ' user ' or CommandLine has ' group ') and (CommandLine hassuffix ' /do' or CommandLine hassuffix ' /domain') \n| where Process has 'net.exe' // performance pre-filtering\n| extend FileName=tostring(split(Process, '\\\\')[-1])\n| where FileName == 'net.exe' and ActorUsername != \"\" and CommandLine !contains '\\\\'  and CommandLine !contains '/add' \n| extend Target = extract(\"(?i)[user|group] (\\\"*[a-zA-Z0-9-_ ]+\\\"*)\", 1, CommandLine) \n| where Target  != '' \n| summarize minTimeGenerated=min(TimeGenerated), maxTimeGenerated=max(TimeGenerated), count() by ActorUsername, Target, CommandLine, Dvc, EventVendor, EventProduct\n| sort by ActorUsername, Target\n| extend timestamp = minTimeGenerated, AccountCustomEntity = ActorUsername, HostCustomEntity = Dvc\n", "attributes": {"description": "'Finds attempts to list users or groups using the built-in Windows 'net' tool '\n", "techniques": NaN, "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_ExchangePowerShellSnapin.yaml", "query_name": "Exchange PowerShell Snapin Added (Normalized Process Events)", "query": "imProcessCreate\n | where Process has_any (\"cmd.exe\", \"powershell.exe\", \"PowerShell_ISE.exe\")\n | where CommandLine has \"Add-PSSnapin Microsoft.Exchange.Management.Powershell.Snapin\"\n | summarize FirstSeen = min(TimeGenerated), LastSeen = max(TimeGenerated) by Dvc, User, CommandLine, EventVendor, EventProduct\n | extend timestamp = FirstSeen, AccountCustomEntity = User, HostCustomEntity = Dvc\n", "attributes": {"description": "'The Exchange Powershell Snapin was loaded on a host, this allows for a Exchange server management via PowerShell.\nWhilst this is a legitimate administrative tool it is abused by attackers to performs actions on a compromised\nExchange server. Hunt for unusual activity related to this Snapin including it being added on new hosts or by\nnew accounts.'\n", "techniques": ["T1119"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_HostExportingMailboxAndRemovingExport.yaml", "query_name": "Host Exporting Mailbox and Removing Export (Normalized Process Events)", "query": "\n// Adjust the timeframe to change the window events need to occur within to alert\n let timeframe = 1h;\n imProcessCreate\n | where Process has_any (\"powershell.exe\", \"cmd.exe\")\n | where CommandLine has 'New-MailboxExportRequest'\n | summarize by Dvc, timekey = bin(TimeGenerated, timeframe), CommandLine, ActorUsername, EventVendor, EventProduct\n | join kind=inner (imProcessCreate\n | where Process has_any (\"powershell.exe\", \"cmd.exe\")\n | where CommandLine has 'Remove-MailboxExportRequest'\n | summarize by Dvc, EventProduct, EventVendor, timekey = bin(TimeGenerated, timeframe), CommandLine, ActorUsername) on Dvc, timekey, ActorUsername\n | summarize by timekey, Dvc, CommandLine, ActorUsername\n | project-reorder timekey, Dvc, ActorUsername, CommandLine\n | extend HostCustomEntity = Dvc, AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'This hunting query looks for hosts exporting a mailbox from an on-prem Exchange server, followed by\nthat same host removing the export within a short time window. This pattern has been observed by attackers \nwhen exfiltrating emails from a target environment. A Mailbox export is unlikely to be a common command run so look for\nactivity from unexpected hosts and accounts.\nReference: https://www.volexity.com/blog/2020/12/14/dark-halo-leverages-solarwinds-compromise-to-breach-organizations/'\n", "techniques": ["T1114"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_Invoke-PowerShellTcpOneLine.yaml", "query_name": "Invoke-PowerShellTcpOneLine Usage (Normalized Process Events)", "query": "imProcessCreate\n | where Process has_any (\"powershell.exe\", \"PowerShell_ISE.exe\", \"cmd.exe\")\n | where CommandLine has \"$client = New-Object System.Net.Sockets.TCPClient\"\n | extend timestamp = TimeGenerated, AccountCustomEntity = User, HostCustomEntity = Dvc, IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Invoke-PowerShellTcpOneLine is a PowerShell script to create a simple and small reverse shell. It can be abused by attackers to exfiltrate data. This query looks for command line activity similar to Invoke-PowerShellTcpOneLine.'\n", "techniques": ["T1011"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_NishangReverseTCPShellBase64.yaml", "query_name": "Nishang Reverse TCP Shell in Base64 (Normalized Process Events)", "query": "imProcessCreate\n| where Process has_any (\"powershell.exe\",\"powershell_ise.exe\") and CommandLine contains \"-e\" \n| mvexpand SS = split(CommandLine, \" \") \n| where SS matches regex \"[A-Za-z0-9+/]{50,}[=]{0,2}\" \n| extend DecodeString = base64_decode_tostring(tostring(SS)) \n| extend FinalString = replace(\"\\\\0\", \"\", DecodeString) \n| where FinalString has \"tcpclient\" and FinalString contains \"$\" and (FinalString contains \"invoke\" or FinalString contains \"iex\") \n| extend timestamp = TimeGenerated, AccountCustomEntity = User, HostCustomEntity = Dvc\n", "attributes": {"description": "'Looks for Base64-encoded commands associated with the Nishang reverse TCP shell.\nRef: https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1'\n", "techniques": ["T1011"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_persistence_create_account.yaml", "query_name": "Summary of users created using uncommon/undocumented commandline switches (Normalized Process Events)", "query": "imProcessCreate\n| where Process has_any (\"net.exe\", \"net1.exe\") // preformance pre-filtering\n| extend FileName = tostring(split(Process, '\\\\')[-1]) \n| extend ActingProcessFileName= tostring(split(ActingProcessName, '\\\\')[-1]) \n| where FileName in~ (\"net.exe\", \"net1.exe\")\n| parse kind=regex flags=iU CommandLine with * \"user \" CreatedUser \" \" * \"/ad\"\n| where not(FileName =~ \"net1.exe\" and ActingProcessFileName =~ \"net.exe\" and replace(\"net\", \"net1\", ActingProcessCommandLine) =~ CommandLine)\n| extend CreatedOnLocalMachine=(CommandLine !has \"/do\")\n| where CommandLine has \"/add\" or (CreatedOnLocalMachine == 0 and CommandLine !has \"/domain\")\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), MachineCount=dcount(Dvc) by CreatedUser, CreatedOnLocalMachine, ActingProcessFileName, FileName, CommandLine, ActingProcessCommandLine, EventVendor, EventProduct\n| extend timestamp = StartTimeUtc, AccountCustomEntity = CreatedUser\n", "attributes": {"description": "'Summarizes uses of uncommon & undocumented commandline switches to create persistence\nUser accounts may be created to achieve persistence on a machine.\nRead more here: https://attack.mitre.org/wiki/Technique/T1136\nQuery for users being created using \"net user\" command\n\"net user\" commands are noisy, so needs to be joined with another signal -\ne.g. in this example we look for some undocumented variations (e.g. /ad instead of /add)'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_PowerCatDownload.yaml", "query_name": "Powercat Download (Normalized Process Events)", "query": "imProcessCreate\n| where Process has_any (\"cmd.exe\", \"powershell.exe\", \"PowerShell_ISE.exe\")\n| where CommandLine hassuffix \"powercat.ps1\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = User, HostCustomEntity = Dvc\n", "attributes": {"description": "'Powercat is a PowerShell implementation of netcat. Whilst it can be used as a legitimate administrative tool it can be abused by attackers to exfiltrate data. This query looks for command line activity downloading PowerCat.'\n", "techniques": ["T1011"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_powershell_downloads.yaml", "query_name": "PowerShell downloads (Normalized Process Events)", "query": "imProcessCreate \n  | where Process has_any (\"powershell.exe\", \"powershell_ise.exe\") // perfromance pre-filtering\n  | extend FileName=tostring(split(TargetProcessFilePath, '\\\\')[-1])\n  | where FileName in~ (\"powershell.exe\", \"powershell_ise.exe\")\n  | where CommandLine has_any (\"Net.WebClient\", \"DownloadFile\", \"Invoke-WebRequest\", \"Invoke-Shellcode\", \"http:\")\n  | project TimeGenerated, Dvc, User, InitiatingProcessFileName, FileName, CommandLine, EventVendor, EventProduct\n  | top 100 by TimeGenerated\n  | extend timestamp = TimeGenerated, HostCustomEntity = Dvc, AccountCustomEntity = User\n", "attributes": {"description": "'Finds PowerShell execution events that could involve a download'\n", "techniques": NaN, "tactics": ["Execution", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_ProcessEntropy.yaml", "query_name": "Entropy for Processes for a given Host (Normalized Process Events)", "query": "\n// exclude when over # of machines have the process\nlet excludeThreshold = 10;\n// exclude when more than percent (default 10%)\nlet ratioHighCount = 0.1;\n// exclude when less than percent (default 3%)\nlet ratioMidCount = 0.03;\n// Process count limit in one day per machine, perf improvement (default every 20 minutes for 24 hours - 3*24 = 72)\nlet procLimit = 3*24;\n// Decrease possibility of hitting memory limit by removing high process count items across all machines (default every 10 minutes for 24 hours - 6*24 = 144)\nlet maxLimit = 6*24;\nlet removeHigh = imProcessCreate \n| where TimeGenerated >= ago(1d)\n| summarize count() by TargetProcessFilePath = tolower(TargetProcessFilePath) | where count_ > maxLimit\n| summarize make_set(TargetProcessFilePath);\nlet SecEvents = imProcessCreate\n| where TimeGenerated >= ago(1d)\n| where tolower(TargetProcessFilePath) !in~ (removeHigh)\n// removing common items that may still show up in small environments, add here if you have additional exclusions \n| where TargetProcessFilePath !has ':\\\\Windows\\\\System32\\\\conhost.exe' and ActingProcessFileName !has ':\\\\Windows\\\\System32\\\\conhost.exe' \n| where ActingProcessFileName !has ':\\\\Windows\\\\System32\\\\wuauclt.exe' and TargetProcessFilePath !has':\\\\Windows\\\\System32\\\\wuauclt.exe' and TargetProcessFilePath !startswith 'C:\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\AM_Delta_Patch_' \n| where ActingProcessFileName !has ':\\\\WindowsAzure\\\\GuestAgent_' and TargetProcessFilePath !has ':\\\\WindowsAzure\\\\GuestAgent_' \n| where ActingProcessFileName !has ':\\\\WindowsAzure\\\\WindowsAzureNetAgent_' and TargetProcessFilePath !has ':\\\\WindowsAzure\\\\WindowsAzureNetAgent_' \n| where ActingProcessFileName !has ':\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\' and TargetProcessFilePath !has \"\\\\Windows Defender Advanced Threat Protection\\\\SenseCncProxy.exe\" and TargetProcessFilePath !has \"\\\\Windows Defender Advanced Threat Protection\\\\SenseIR.exe.exe\" \n| where TargetProcessFilePath !has ':\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\' \n| where TargetProcessFilePath !has ':\\\\Windows\\\\Microsoft.NET\\\\Framework' and not(TargetProcessFilePath endswith '\\\\ngentask.exe' or TargetProcessFilePath endswith '\\\\ngen.exe') \n| where ActingProcessFileName !has ':\\\\Windows\\\\Microsoft.NET\\\\Framework' and not(ActingProcessFileName endswith '\\\\ngentask.exe' or ActingProcessFileName endswith '\\\\ngen.exe') \n| where TargetProcessFilePath !has ':\\\\Windows\\\\System32\\\\taskhostw.exe' and ActingProcessFileName !has ':\\\\Windows\\\\System32\\\\taskhostw.exe' \n| where ActingProcessFileName !has ':\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\' and not(TargetProcessFilePath endswith '\\\\MpSigStub.exe') \n| where TargetProcessFilePath !has ':\\\\Program Files\\\\Microsoft Monitoring Agent\\\\Agent\\\\Health Service State\\\\' and ActingProcessFileName !has ':\\\\Program Files\\\\Microsoft Monitoring Agent\\\\Agent\\\\MonitoringHost.exe' \n| where TargetProcessFilePath !has ':\\\\Windows\\\\servicing\\\\trustedinstaller.exe' \n| where ActingProcessFileName !has ':\\\\Program Files\\\\Microsoft Dependency Agent\\\\bin\\\\MicrosoftDependencyAgent.exe' \n| where ActingProcessFileName !has ':\\\\Program Files (x86)\\\\Microsoft\\\\EdgeUpdate\\\\MicrosoftEdgeUpdate.exe'\n| project TimeGenerated, EventID, DvcHostname, ActorUserId, Account, AccountType, TargetProcessFileName, TargetProcessFilePath, TargetProcessCommandLine, ActingProcessFileName, _ResourceId, DvcId, EventVendor, EventProduct;\nlet Exclude = SecEvents \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ExcludeCompCount = dcount(DvcHostname), ExcludeProcCount = count() by TargetProcessFileName \n// Removing general limit for noise in one day \n| extend timediff = iff(datetime_diff('day', EndTime, StartTime) > 0, datetime_diff('day', EndTime, StartTime), 1) \n// Default exclude of 48 (2 per hour) or more executions in 24 hours on a given machine \n| where ExcludeProcCount > procLimit*timediff \n// Removing noisy processes for an environment, adjust as needed \n| extend compRatio = ExcludeCompCount/toreal(ExcludeProcCount) \n| where compRatio == 0 or (ExcludeCompCount > excludeThreshold and compRatio < ratioHighCount) or (ExcludeCompCount between (2 .. excludeThreshold) and compRatio < ratioMidCount);\nlet AllSecEvents =  \nSecEvents | project DvcHostname, TargetProcessFileName , EventVendor, EventProduct\n| join kind= leftanti (  \nSecEvents \n// Removing general limit for noise in one day \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), procCount = count() by DvcHostname, TargetProcessFileName \n| extend timediff = iff(datetime_diff('day', EndTime, StartTime) > 0, datetime_diff('day', EndTime, StartTime), 1) \n// Default exclude 48 (2 per hour) or more executions in 24 hours on a given machine to remove them from overall comparison list \n| where procCount > procLimit*timediff \n) on DvcHostname, TargetProcessFileName \n| project DvcHostname, TargetProcessFileName , EventVendor, EventProduct;\n// Removing noisy process from full list \nlet Include = materialize(AllSecEvents \n| join kind= leftanti ( \nExclude \n) on TargetProcessFileName);\n// Identifying prevalence for a given process in the environment \nlet DCwPC = materialize(Include \n| summarize DistinctHostsProcessCount = dcount(DvcHostname) by TargetProcessFileName \n| join kind=inner ( \nInclude \n) on TargetProcessFileName \n| distinct DvcHostname, TargetProcessFileName, DistinctHostsProcessCount);\n// Getting the Total process count on each host to use as the denominator in the entropy calc \nlet AHPC = materialize(Include \n| summarize AllHostsProcessCount = count() by DvcHostname \n| join kind=inner ( \nInclude \n) on DvcHostname \n| distinct DvcHostname, TargetProcessFileName, AllHostsProcessCount \n//Getting a decimal value for later computation \n| extend AHPCValue = todecimal(AllHostsProcessCount));\n// Need the count of each class in my bucket or also said as count of ProcName(Class) per Host(Bucket) for use in the entropy calc \nlet PCoH = Include \n| summarize ProcessCountOnHost = count() by DvcHostname, TargetProcessFileName \n| join kind=inner ( \nInclude \n) on DvcHostname,TargetProcessFileName \n| distinct DvcHostname, TargetProcessFileName, ProcessCountOnHost \n//Getting a decimal value for later computation \n| extend PCoHValue = todecimal(ProcessCountOnHost); \nlet Combined = DCwPC \n| join ( \nAHPC \n) on DvcHostname, TargetProcessFileName \n| join ( \nPCoH \n) on DvcHostname, TargetProcessFileName;\nlet Results = Combined \n// Entropy calculation \n| extend ProcessEntropy = -log2(PCoHValue/AHPCValue)*(PCoHValue/AHPCValue) \n// Calculating Weight, see details in description \n| extend Weight = toreal(ProcessEntropy*ProcessCountOnHost*DistinctHostsProcessCount) \n// Remove or increase value to see processes with low entropy, meaning more common. \n| where Weight <= 100\n| project DvcHostname, TargetProcessFileName, Weight , ProcessEntropy, AllHostsProcessCount, ProcessCountOnHost, DistinctHostsProcessCount; \n// Join back full entry \nResults \n| join kind= inner ( \nSecEvents\n| project TimeGenerated, EventID, DvcHostname, ActorUserId, Account, AccountType, TargetProcessFileName, TargetProcessFilePath, TargetProcessCommandLine, ActingProcessFileName, _ResourceId, DvcId , EventVendor, EventProduct\n) on DvcHostname, TargetProcessFileName \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResultCount = count() by EventID, DvcHostname, ActorUserId, Account, AccountType, Weight, ProcessEntropy,  \nTargetProcessFileName, TargetProcessFilePath, TargetProcessCommandLine, ActingProcessFileName, AllHostsProcessCount, ProcessCountOnHost, DistinctHostsProcessCount, _ResourceId, DvcId , EventVendor, EventProduct\n| project-reorder StartTime, EndTime, ResultCount, EventID, EventVendor, EventProduct, DvcHostname, ActorUserId, Account, AccountType, Weight, ProcessEntropy,TargetProcessFileName, TargetProcessFilePath, TargetProcessCommandLine, ActingProcessFileName, AllHostsProcessCount, ProcessCountOnHost, DistinctHostsProcessCount, _ResourceId, DvcId\n| sort by Weight asc, ProcessEntropy asc, TargetProcessFilePath asc \n| extend timestamp = StartTime, HostCustomEntity = DvcHostname, AccountCustomEntity = Account\n", "attributes": {"description": "'Entropy calculation used to help identify Hosts where they have a high variety of processes(a high entropy process list on a given Host over time).\nThis helps us identify rare processes on a given Host. Rare here means a process shows up on the Host relatively few times in the the last 7days.\nThe Weight is calculated based on the Entropy, Process Count and Distinct Hosts with that Process. The lower the Weight/ProcessEntropy the, more interesting.\nThe Weight calculation increases the Weight if the process executes more than once on the Host or has executed on more than 1 Hosts.\nIn general, this should identify processes on a Host that are rare and rare for the environment.\nReferences: https://medium.com/udacity/shannon-entropy-information-gain-and-picking-balls-from-buckets-5810d35d54b4\nhttps://en.wiktionary.org/wiki/Shannon_entropy'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_SolarWindsInventory.yaml", "query_name": "SolarWinds Inventory (Normalized Process Events)", "query": "imProcessCreate\n| where Process has 'solarwinds' \n| extend MachineName = DvcHostname , Process = TargetProcessFilePath\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), MachineCount = dcount(Dvc), AccountCount = dcount(User), MachineNames = make_set(Dvc),\nAccounts = make_set(User) by Process, EventVendor, EventProduct\n", "attributes": {"description": "'Beyond your internal software management systems, it is possible you may not have visibility into your entire footprint of SolarWinds installations.  This is intended to help use process exection information to discovery any systems that have SolarWinds processes'\n", "techniques": ["T1072"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_Suspicious_enumeration_using_adfind.yaml", "query_name": "Suspicious enumeration using Adfind tool (Normalized Process Events)", "query": "let lookupwindow = 2m;\nlet threshold = 3; //number of commandlines in the set below\nlet DCADFSServersList = dynamic ([\"DCServer01\", \"DCServer02\", \"ADFSServer01\"]); // Enter a reference list of hostnames for your DC/ADFS servers\nlet tokens = dynamic([\"objectcategory\",\"domainlist\",\"dcmodes\",\"adinfo\",\"trustdmp\",\"computers_pwdnotreqd\",\"Domain Admins\", \"objectcategory=person\", \"objectcategory=computer\", \"objectcategory=*\"]);\nimProcessCreate\n//| where Computer in (DCADFSServersList) // Uncomment to limit it to your DC/ADFS servers list if specified above or any pattern in hostnames (startswith, matches regex, etc).\n| where CommandLine has_any (tokens)\n| where CommandLine contains \">\"\n| summarize Commandlines = make_set(CommandLine), LastObserved=max(TimeGenerated) by bin(TimeGenerated, lookupwindow), User, Dvc, ActingProcessName, TargetProcessName, EventVendor, EventProduct\n  | extend Count = array_length(Commandlines)\n  | where Count > threshold", "attributes": {"description": "Attackers can use Adfind which is administrative tool to gather information about Domain controllers, ADFS Servers. They may also rename executables with other benign tools on the system.\nBelow query will look for adfind usage in commandline arguments irrespective of executable name in short span of time. You can limit query this to your DC and ADFS servers.\nBelow references talk about suspicious use of adfind by adversaries.\n- https://thedfirreport.com/2020/05/08/adfind-recon/\n- https://www.fireeye.com/blog/threat-research/2020/05/tactics-techniques-procedures-associated-with-maze-ransomware-incidents.html\n- https://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": ["T1059", "T1087", "T1482", "T1201", "T1069", "T1074"], "tactics": ["Execution", "Discovery", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_uncommon_processes.yaml", "query_name": "Uncommon processes - bottom 5% (Normalized Process Events)", "query": "let freqs = imProcessCreate \n  // filter out common randomly named files related to MSI installers and browsers\n  | where not(Process has_all ('TRA', '.tmp') and Process matches regex @\"\\\\TRA[0-9A-Fa-f]{3,4}\\.tmp\")\n  | where not(Process has_all ('MSI', '.tmp') and Process matches regex @\"\\\\MSI[0-9A-Fa-f]{3,4}\\.tmp\")\n  | extend FileName = tostring(split(Process, '\\\\')[-1])\n  // normalize guids\n  | extend FileName = replace(\"[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}\", \"<guid>\", FileName)\n  | extend FileName = replace(@'\\d', 'n', FileName)\n  | summarize frequency=count(), Since=min(TimeGenerated), LastSeen=max(TimeGenerated) by FileName , EventVendor, EventProduct;\nlet precentile_5 = toscalar ( freqs | summarize percentiles(frequency, 5));\nfreqs\n  | where frequency <= precentile_5\n  | order by frequency asc\n  | project FileName, frequency, precentile_5, Since, LastSeen , EventVendor, EventProduct\n  // restrict results to unusual processes seen in last day \n  | where LastSeen >= ago(1d)\n  | extend timestamp = LastSeen\n", "attributes": {"description": "'Shows the rarest processes seen running for the first time. (Performs best over longer time ranges - eg 3+ days rather than 24 hours!)\nThese new processes could be benign new programs installed on hosts; \nHowever, especially in normally stable environments, these new processes could provide an indication of an unauthorized/malicious binary that has been installed and run. \nReviewing the wider context of the logon sessions in which these binaries ran can provide a good starting point for identifying possible attacks.'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/imProcess_Windows%20System%20Shutdown-Reboot%28T1529%29.yaml", "query_name": "Windows System Shutdown/Reboot (Normalized Process Events)", "query": "let timeframe = 1d;\nimProcessCreate\n| where Process has \"shutdown.exe\" \n| extend HostCustomEntity = Dvc, AccountCustomEntity = User\n", "attributes": {"description": "'This detection uses Normalized Process Events to detect System Shutdown/Reboot (MITRE Technique: T1529)'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimProcess/inProcess_SignedBinaryProxyExecutionRundll32.yaml", "query_name": "Rundll32 (LOLBins and LOLScripts, Normalized Process Events)", "query": "imProcessCreate\n| where Process has \"rundll32.exe\"\n// Uncomment the next line and add your commandLine Whitelisted/ignore terms.For example \"payload.dll\"\n// | where CommandLine !contains (\"payload.dll\") \n| extend HostCustomEntity = Dvc, AccountCustomEntity = User\n", "attributes": {"description": "'This detection uses Normalized Process Events to hunt Signed Binary Proxy Execution: Rundll32 activities'\n", "techniques": ["T1218.011"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ASimRegistry/Crashdumpdisabledonhost%28ASIMVersion%29.yaml", "query_name": "Crash dump disabled on host (ASIM Version)", "query": "imRegistry\n| where RegistryKey == \"HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\CrashControl\"\n| where RegistryValue == \"CrashDumpEnabled\"\n| where RegistryValueData == 0\n| project-reorder TimeGenerated, RegistryKey, RegistryValue, RegistryValueData, Process, User, ParentProcessName\n", "attributes": {"description": "'This detection looks the prevention of crash dumps being created. This can be used to limit reporting by malware, look for suspicious processes setting this registry key.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/AccountAddedtoPrivilegedPIMGroup.yaml", "query_name": "Account Added to Privileged PIM Group", "query": "AuditLogs\n| where ActivityDisplayName =~ \"Add eligible member to role in PIM requested (timebound)\"\n| where AADOperationType =~ \"CreateRequestEligibleRole\"\n| where TargetResources has_any (\"-PRIV\", \"Administrator\", \"Security\")\n| extend BuiltinRole = tostring(parse_json(TargetResources[0].displayName))\n| extend CustomGroup = tostring(parse_json(TargetResources[3].displayName))\n| extend TargetAccount = tostring(parse_json(TargetResources[2].displayName))\n| extend Initiatedby = Identity\n| project TimeGenerated, ActivityDisplayName, AADOperationType, Initiatedby, TargetAccount, BuiltinRole, CustomGroup, LoggedByService, Result, ResultReason, ResourceId, Id\n| sort by TimeGenerated desc\n| extend timestamp = TimeGenerated, AccountCustomEntity = TargetAccount, ResourceCustomEntity = ResourceId\n", "attributes": {"description": "'Identifies accounts that have been added to a PIM managed privileged group'\n", "techniques": ["T1098", "T1548"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/AppRequiredResourceAccessUpdate.yaml", "query_name": "OAuth Application Required Resource Access Update", "query": "AuditLogs\n| where Category =~ \"ApplicationManagement\"\n| where ActivityDisplayName has_any (\"Update application\")\n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| extend UserAgent = tostring(AdditionalDetails[0].value)\n| extend InitiatingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend InitiatingIpAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend ModifiedApplication = tostring(TargetResources[0].displayName)\n| extend ModifiedApplicationObjectId = tostring(TargetResources[0].id)\n| extend ModifiedProperties = parse_json(tostring(TargetResources[0].modifiedProperties))\n| extend ModifiedPropertyName = tostring(ModifiedProperties[0].displayName)\n| extend ResourceAppId = parse_json(tostring(ModifiedProperties[0].newValue))[0].ResourceAppId\n| where ModifiedPropertyName =~ \"RequiredResourceAccess\"\n| extend Type = tostring(TargetResources[0].type)\n| project-away ModifiedProperties\n| project-reorder TimeGenerated, OperationName, InitiatingUser, InitiatingIpAddress, UserAgent, ModifiedApplication, ModifiedApplicationObjectId, CorrelationId, TenantId\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUser, IPCustomEntity = InitiatingIpAddress\n", "attributes": {"description": "'This hunting query identifies updates to the RequiredResourceAccess property of an OAuth application.\nThis property specifies resources that an application requires access to and the set of OAuth permission scopes and application roles that it needs under each of those resources.\nThis pre-configuration of required resource access drives the consent experience. The resourceAccess property of the requiredResourceAccess type is a collection of ResourceAccess.\nA threat actor might update this property before granting permissions to an application.\n'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/BitLockerKeyRetrieval.yaml", "query_name": "BitLocker Key Retrieval", "query": "AuditLogs\n  | where OperationName =~ \"Read BitLocker key\"\n  | extend userPrincipalName = tolower(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n  | extend KeyId = tostring(TargetResources[0].displayName)\n  | extend ipAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n  | summarize keys_accessed=dcount(KeyId), ipAddresses=make_set(ipAddress) by userPrincipalName\n  | join kind=leftouter (SecurityAlert\n  | where ProviderName =~ \"IPC\"\n  | extend userPrincipalName = tolower(tostring(parse_json(ExtendedProperties).[\"User Account\"]))\n  | summarize user_alert_count=count() by userPrincipalName) on userPrincipalName\n  | project userPrincipalName, keys_accessed, ipAddresses, user_alert_count\n", "attributes": {"description": "'Looks for users retrieving BitLocker keys. Enriches these logs with a summary of alerts associated with the user accessing the keys.\nUse this query to start looking for anomalous patterns of key retrieval.\nRef: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-devices#bitlocker-key-retrieval'\n", "techniques": ["T1555"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/ConsentToApplicationDiscovery.yaml", "query_name": "Consent to Application discovery", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet auditLookback = starttime - 14d;\n// Setting threshold to 3 as a default, change as needed.  Any operation that has been initiated by a user or app more than 3 times in the past 30 days will be exluded\nlet threshold = 3;\n// Helper function to extract relevant fields from AuditLog events\nlet auditLogEvents = view (startTimeSpan:timespan)  {\n    AuditLogs | where TimeGenerated >= auditLookback\n    | extend ModProps = TargetResources.[0].modifiedProperties\n    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)),\n    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))\n    | extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)),\n    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n    | extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n    | mvexpand ModProps\n    | extend PropertyName = tostring(ModProps.displayName), newValue = replace('\\\"',\"\",tostring(ModProps.newValue));\n};\n// Get just the InitiatedBy and CorrleationId so we can look at associated audit activity\n// 2 other operations that can be part of malicious activity in this situation are\n// \"Add OAuth2PermissionGrant\" and \"Add service principal\", replace the below if you are interested in those as starting points for OperationName\nlet HistoricalConsent = auditLogEvents(auditLookback)\n| where OperationName == \"Consent to application\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count()\nby Type, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id\n// Remove comment below to only include operations initiated by a user or app that is above the threshold for the last 30 days\n//| where OperationCount > threshold\n;\nlet Correlate = HistoricalConsent\n| summarize by InitiatedBy, CorrelationId;\n// 2 other operations that can be part of malicious activity in this situation are\n// \"Add OAuth2PermissionGrant\" and \"Add service principal\", replace the below if you changed the starting OperationName above\nlet allOtherEvents = auditLogEvents(auditLookback)\n| where OperationName != \"Consent to application\";\n// Gather associated activity based on audit activity for \"Consent to application\" and InitiatedBy and CorrleationId\nlet CorrelatedEvents = Correlate\n| join allOtherEvents on InitiatedBy, CorrelationId\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated)\nby Type, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id\n;\n// Union the results\nlet Results = (union isfuzzy=true HistoricalConsent,CorrelatedEvents);\n// newValues that are simple semi-colon separated, make those dynamic for easy viewing and Aggregate into the PropertyUpdate set based on CorrelationId and Id(DirectoryId)\nResults\n| extend newValue = split(newValue, \";\")\n| extend PropertyUpdate = pack(PropertyName, newValue, \"Id\", Id)\n// Extract scope requested\n| extend perms = tostring(parse_json(tostring(PropertyUpdate.[\"ConsentAction.Permissions\"]))[0])\n| extend scope = extract('Scope:\\\\s*([^,\\\\]]*)',1, perms)\n// Filter out some common openid, and low privilege request scopes - uncomment line below to filter out where no scope is requested\n//| where isnotempty(scope)\n| where scope !contains 'openid' and scope !in ('user_impersonation','User.Read')\n| summarize StartTime = min(StartTimeUtc), EndTime = max(EndTimeUtc), PropertyUpdateSet = make_bag(PropertyUpdate) , make_set(scope)\n  by InitiatedBy, IpAddress, TargetResourceName, OperationName, CorrelationId\n| extend timestamp = StartTime, AccountCustomEntity = InitiatedBy, IPCustomEntity = IpAddress\n// uncommnet below to summarize by app if many results\n//| summarize make_set(InitiatedBy), make_set(IpAddress), make_set(PropertyUpdateSet) by TargetResourceName, tostring(set_scope)\n", "attributes": {"description": "'This query looks at the last 14 days for any \"Consent to application\" operation\noccurs by a user or app. This could indicate that permissions to access the listed AzureApp\nwas provided to a malicious actor. Consent to appliction, Add service principal and\nAdd OAuth2PermissionGrant events should be rare. If available, additional context is added\nfrom the AuditLogs based on CorrleationId from the same account that performed \"Consent to\napplication\".\nFor further information on AuditLogs please see\nhttps://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities\nThis may help detect the Oauth2 attack that can be initiated by this publicly available tool\nhttps://github.com/fireeye/PwnAuth'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/NonredeemedGuesUserInvites.yaml", "query_name": "Invited Guest User but not redeemed Invite for longer period.", "query": "let lookback = 14d;\nlet invitethreshold = 5d;\n// Collect external user invitations\nlet ExtUserInvites = AuditLogs\n| where TimeGenerated > ago(lookback)\n| where Category =~ \"UserManagement\"\n| where OperationName =~ \"Invite external user\"\n| extend TargetUPN = tostring(TargetResources[0].[\"userPrincipalName\"])\n| extend InviteInitiator = tostring(InitiatedBy.[\"user\"].[\"userPrincipalName\"]) , IPAddress = tostring(InitiatedBy.[\"user\"].[\"ipAddress\"])\n| where isnotempty(InviteInitiator)\n| extend InviteTime = TimeGenerated;\n// Collect redeem events\nlet ExtUserRedeem = AuditLogs\n| where TimeGenerated > ago(lookback)\n| where Category =~ \"UserManagement\"\n| where OperationName =~ \"Redeem external user invite\"\n| where Result =~ \"success\"\n| extend InviteInitiator = tostring(InitiatedBy.[\"user\"].[\"userPrincipalName\"])\n| extend Target = tostring(TargetResources[0].[\"userPrincipalName\"])\n| extend TargetUPN = tostring(extract(@\"UPN\\:\\s(.+)\\,\\sEmail\",1,Target))\n| where isnotempty(Target);\n// Find invites who have not been redeemed since long time.\nExtUserInvites\n| join kind=leftanti ( ExtUserRedeem ) on TargetUPN\n| where InviteTime > ago(invitethreshold)\n| project TimeGenerated, \n", "attributes": {"description": "'This query will look for events where guest user was invited but has not accepted/redeemed invite for unusually longer period. \n Any invites not redeemed for longer period of time can be misused and pose risk if suspiciously redeemed in other ways'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/RareAuditActivityByApp.yaml", "query_name": "Rare Audit activity initiated by App", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet auditLookback = starttime - 14d;\nlet propertyIgnoreList = dynamic([\"TargetId.UserType\", \"StsRefreshTokensValidFrom\", \"LastDirSyncTime\", \"DeviceOSVersion\", \"CloudDeviceOSVersion\", \"DeviceObjectVersion\"]);\nlet appIgnoreList = dynamic([\"Microsoft Azure AD Group-Based Licensing\"]);\nlet AuditTrail = AuditLogs\n| where TimeGenerated between(auditLookback..starttime)\n| where isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n| extend InitiatedByApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend InitiatedByIpAddress = tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)\n| extend TargetUserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| mv-expand ModProps\n| where isnotempty(tostring(parse_json(tostring(ModProps.newValue))[0]))\n| extend PropertyName = tostring(ModProps.displayName), newValue = tostring(parse_json(tostring(ModProps.newValue))[0])\n| where PropertyName !in~ (propertyIgnoreList) and (PropertyName !~ \"Action Client Name\" and newValue !~ \"DirectorySync\") and (PropertyName !~ \"Included Updated Properties\" and newValue !~ \"LastDirSyncTime\")\n| where InitiatedByApp !in~ (appIgnoreList) and OperationName !~ \"Change user license\"\n| summarize by OperationName, InitiatedByApp, TargetUserPrincipalName, InitiatedByIpAddress, TargetResourceName, PropertyName;\nlet AccountMods = AuditLogs\n| where TimeGenerated >= starttime\n| where isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n| extend InitiatedByApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend InitiatedByIpAddress = tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)\n| extend TargetUserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| mv-expand ModProps\n| where isnotempty(tostring(parse_json(tostring(ModProps.newValue))[0]))\n| extend PropertyName = tostring(ModProps.displayName), newValue = tostring(parse_json(tostring(ModProps.newValue))[0])\n| where PropertyName !in~ (propertyIgnoreList) and (PropertyName !~ \"Action Client Name\" and newValue !~ \"DirectorySync\") and (PropertyName !~ \"Included Updated Properties\" and newValue !~ \"LastDirSyncTime\")\n| where InitiatedByApp !in~ (appIgnoreList) and OperationName !~ \"Change user license\"\n| extend ModifiedProps = pack(\"PropertyName\",PropertyName,\"newValue\",newValue, \"Id\", Id, \"CorrelationId\", CorrelationId)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedByApp, TargetUserPrincipalName, InitiatedByIpAddress, TargetResourceName, Category, OperationName, PropertyName;\nlet RareAudits = AccountMods | join kind= leftanti (\n   AuditTrail\n) on OperationName, InitiatedByApp, InitiatedByIpAddress, TargetUserPrincipalName;//, PropertyName; //uncomment if you want to see Rare Property changes.\nRareAudits\n| summarize StartTime = min(StartTimeUtc), EndTime = max(EndTimeUtc), make_set(Activity), make_set(PropertyName) by InitiatedByApp, OperationName, TargetUserPrincipalName, InitiatedByIpAddress, TargetResourceName\n| order by TargetUserPrincipalName asc, StartTime asc\n| extend timestamp = StartTime, AccountCustomEntity = TargetUserPrincipalName, HostCustomEntity = iff(set_PropertyName has_any ('DeviceOSType', 'CloudDeviceOSType'), TargetResourceName, ''), IPCustomEntity = InitiatedByIpAddress\n", "attributes": {"description": "'Compares the current day to the last 14 days of audits to identify new audit activities by\nOperationName, InitiatedByApp, UserPrincipalName, PropertyName, newValue\nThis can be useful when attempting to track down malicious activity related to additions of new users,\nadditions to groups, removal from groups by Azure Apps and automated approvals.'\n", "techniques": ["T1136"], "tactics": ["Persistence", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/RareAuditActivityByUser.yaml", "query_name": "Rare Audit activity initiated by User", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet auditLookback = starttime - 14d;\nlet propertyIgnoreList = dynamic([\"TargetId.UserType\", \"StsRefreshTokensValidFrom\", \"LastDirSyncTime\", \"DeviceOSVersion\", \"CloudDeviceOSVersion\", \"DeviceObjectVersion\"]);\nlet AuditTrail = AuditLogs \n| where TimeGenerated >= auditLookback and TimeGenerated < starttime\n| where isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n| extend InitiatedByUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend InitiatedByIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend TargetUserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| mv-expand ModProps\n| extend PropertyName = tostring(ModProps.displayName), newValue = tostring(parse_json(tostring(ModProps.newValue))[0])\n| where PropertyName !in~ (propertyIgnoreList) and (PropertyName !~ \"Action Client Name\" and newValue !~ \"DirectorySync\") and (PropertyName !~ \"Included Updated Properties\" and newValue !~ \"LastDirSyncTime\")\n| summarize count() by OperationName, InitiatedByUser, InitiatedByIPAddress, TargetUserPrincipalName, PropertyName, TargetResourceName;\nlet AccountMods = AuditLogs \n| where TimeGenerated >= starttime\n| where isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n| extend InitiatedByUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend InitiatedByIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend TargetUserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| mv-expand ModProps\n| extend PropertyName = tostring(ModProps.displayName), newValue = tostring(parse_json(tostring(ModProps.newValue))[0])\n| where PropertyName !in~ (propertyIgnoreList) and (PropertyName !~ \"Action Client Name\" and newValue !~ \"DirectorySync\") and (PropertyName !~ \"Included Updated Properties\" and newValue !~ \"LastDirSyncTime\")\n| extend ModifiedProps = pack(\"PropertyName\",PropertyName,\"newValue\",newValue, \"Id\", Id, \"CorrelationId\", CorrelationId) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedByUser, InitiatedByIPAddress, TargetUserPrincipalName, Category, OperationName, PropertyName, TargetResourceName;\nlet RareAudits = AccountMods | join kind= leftanti (\n   AuditTrail \n) on OperationName, InitiatedByUser, InitiatedByIPAddress;//, TargetUserPrincipalName, PropertyName; //uncomment if you want to see Rare Property changes to a given TargetUserPrincipalName.\nRareAudits \n| summarize StartTime = min(StartTimeUtc), EndTime = max(EndTimeUtc), make_set(Activity), make_set(PropertyName) by Type, InitiatedByUser, InitiatedByIPAddress, OperationName, TargetUserPrincipalName, TargetResourceName\n| order by InitiatedByUser asc, StartTime asc\n| extend timestamp = StartTime, AccountCustomEntity = InitiatedByUser, HostCustomEntity = iff(set_PropertyName has_any ('DeviceOSType', 'CloudDeviceOSType'), TargetResourceName, ''), IPCustomEntity = InitiatedByIPAddress\n", "attributes": {"description": "'Compares the current day to the last 14 days of audits to identify new audit activities by \nOperationName, InitiatedByUser, UserPrincipalName, PropertyName, newValue\nThis can be useful when attempting to track down malicious activity related to additions of \nnew users, additions to groups, removal from groups by specific users.'\n", "techniques": ["T1136"], "tactics": ["Persistence", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/StsRefreshTokenModification.yaml", "query_name": "Interactive STS refresh token modifications", "query": "// Include your additions to the allow list below as needed\nlet AllowedUserList = dynamic([\"Microsoft Cloud App Security\",\"ADConnectSyncAccount1\",\"SyncAccount2\"]);\nAuditLogs\n| where OperationName has 'StsRefreshTokenValidFrom'\n| where TargetResources[0].modifiedProperties != '[]'\n| where TargetResources[0].modifiedProperties !has 'DirectorySync'\n| extend TargetResourcesModProps = TargetResources[0].modifiedProperties\n| mv-expand TargetResourcesModProps\n| where tostring(TargetResourcesModProps.displayName) =~ 'StsRefreshTokensValidFrom'\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| where InitiatingUserOrApp !in (AllowedUserList)\n| extend targetUserOrApp = TargetResources[0].userPrincipalName\n| extend eventName = tostring(TargetResourcesModProps.displayName)\n| extend oldStsRefreshValidFrom = todatetime(parse_json(tostring(TargetResourcesModProps.oldValue))[0])\n| extend newStsRefreshValidFrom = todatetime(parse_json(tostring(TargetResourcesModProps.newValue))[0])\n| extend tokenMinutesAdded = datetime_diff('minute',newStsRefreshValidFrom,oldStsRefreshValidFrom)\n| extend tokenMinutesRemaining = datetime_diff('minute',TimeGenerated,newStsRefreshValidFrom)\n| project-reorder Result, AADOperationType\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUserOrApp, IPCustomEntity = InitiatingIpAddress\n", "attributes": {"description": "'This will show Active Directory Security Token Service (STS) refresh token modifications by Service Principals and Applications other than DirectorySync. Refresh tokens are used to validate identification and obtain access tokens.\nThis event is not necessarily an indication of malicious activity but can also be generated when legitimate administrators manually expire token validation or keep longer refresh tokens for better login experience with less prompts.\nAlso an allowlist has been included to filter known accounts which can be customized after careful review of past historical activity.\nAnalyze the results for unusual operations performed by administrators to extend a refresh token of a compromised account in order to extend the time they can use it without the need to re-authenticate (and thus potentially lose access).\nFor in-depth documentation of AAD Security Tokens, see https://docs.microsoft.com/azure/active-directory/develop/security-tokens.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\nFor valid use cases of altering token lifetime values, refer https://docs.microsoft.com/azure/active-directory/develop/access-tokens#token-timeouts\nMore information about risky use-cases, refer https://docs.microsoft.com/azure/active-directory/develop/active-directory-configurable-token-lifetimes#token-lifetimes-with-public-client-refresh-tokens'\n", "techniques": ["T1550.001"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/UserDetectPrivilegeGroup.yaml", "query_name": "User detection added to privilege groups based in Watchlist", "query": "let PrivilegedUsers = (_GetWatchlist('Accounts') | project Users);\nlet timeRange = 3d;\nlet lookBack = 7d;\nAuditLogs\n| where LoggedByService == 'Core Directory' or LoggedByService == 'PIM'\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| where Identity !in (PrivilegedUsers)\n| mv-expand TargetResources\n| extend modProps = parse_json(TargetResources).modifiedProperties\n| mv-expand bagexpansion=array modProps\n| evaluate bag_unpack(modProps)\n| extend displayName = column_ifexists(\"displayName\", \"NotAvailable\"), newValue = column_ifexists(\"newValue\", \"NotAvailable\")\n//if you want only extract hig privilege Rol display or WellKnowObject\n| where newValue contains \"UserAccountAdmins\" or newValue contains \"User Administrator\" or newValue contains \"ApplicationAdministrators\" or newValue contains \"BuiltInRole\"\n //| project TimeGenerated, displayName, newValue, OperationName, Category, Identity, LoggedByService, Location, ResourceGroup \n", "attributes": {"description": "'Based on a Watchlist Detects when a user has been added to a privileged group/role. We can exclude from the wathclist the users for whom we do not want this alert to be triggered'\n", "techniques": ["T1548"], "tactics": ["Reconnaissance", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/UserGrantedAccess_AllAuditActivity.yaml", "query_name": "User Granted Access and associated audit activity", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet auditLookback = starttime - 14d;\nlet opName = dynamic([\"Add user\", \"Invite external user\"]);\n// Setting threshold to 3 as a default, change as needed.  Any operation that has been initiated by a user or app more than 3 times in the past 14 days will be excluded\nlet threshold = 3;\n// Helper function to extract relevant fields from AuditLog events\nlet auditLogEvents = view (startTimeSpan:timespan)  {\n    AuditLogs | where TimeGenerated >= auditLookback\n    | extend ModProps = iff(TargetResources.[0].modifiedProperties != \"[]\", TargetResources.[0].modifiedProperties, todynamic(\"NoValues\"))\n    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), \n    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))\n    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n    | extend InitiatedBy = replace(\"_\",\"@\",tostring(split(InitiatedByFull, \"#\")[0]))\n    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetResourceName = case(\n    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,\n    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith \"upn:\", tolower(tostring(TargetResources.[0].displayName)),\n    tolower(tostring(TargetResources.[0].displayName))\n    )\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, \",\")[0], \" \")[1]), TargetUserName ) \n    | mvexpand ModProps\n    | extend PropertyName = tostring(ModProps.displayName), newValue = replace('\\\"','',tostring(ModProps.newValue));\n};\nlet HistoricalAdd = auditLogEvents(auditLookback)\n| where OperationName in~ (opName)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() \nby Type, InitiatedBy, IpAddress, TargetUserName, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id\n// Remove comment below to only include operations initiated by a user or app that is above the threshold for the last 14 days\n| where OperationCount > threshold\n;\n// Get list of new added users to correlate with all other events\nlet Correlate = HistoricalAdd \n| summarize by InitiatedBy, TargetUserName, CorrelationId;\n// Get all other events related to list of newly added users\nlet allOtherEvents = auditLogEvents(auditLookback);\n// Join the new added user list to get the list of associated events\nlet CorrelatedEvents = Correlate \n| join allOtherEvents on InitiatedBy, TargetUserName\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) \nby Type, InitiatedBy, IpAddress, TargetUserName, TargetResourceName, Category, OperationName, PropertyName, newValue, CorrelationId, Id\n;\n// Union the results so we can see when the user was added and any associated events that occurred during the same time.\nlet Results = union isfuzzy=true HistoricalAdd,CorrelatedEvents;\n// newValues that are simple semi-colon separated, make those dynamic for easy viewing and Aggregate into the PropertyUpdate set based on CorrelationId and Id(DirectoryId)\nResults\n| extend newValue = split(newValue, \";\")\n| extend PropertyUpdate = pack(PropertyName, newValue, \"Id\", Id)\n| summarize StartTime = min(StartTimeUtc), EndTime = max(EndTimeUtc), PropertyUpdateSet = make_bag(PropertyUpdate) \nby InitiatedBy, IpAddress, TargetUserName, TargetResourceName, OperationName, CorrelationId\n| extend timestamp = StartTime, AccountCustomEntity = InitiatedBy, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Identifies when a new user is granted access and any subsequent audit related activity.  This can help you identify rogue or malicious user behavior.'\n", "techniques": ["T1098", "T1078", "T1496"], "tactics": ["Persistence", "PrivilegeEscalation", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/UserGrantedAccess_GrantsOthersAccess.yaml", "query_name": "User Granted Access and Grants others Access", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet auditLookback = starttime - 14d;\nlet opName = dynamic([\"Add user\", \"Invite external user\"]);\n// Helper function to extract relevant fields from AuditLog events\nlet auditLogEvents = view (startTimeSpan:timespan, operation:dynamic)  {\n    AuditLogs | where TimeGenerated >= auditLookback\n    | where OperationName in~ (operation)\n    | extend ModProps = iff(TargetResources.[0].modifiedProperties != \"[]\", TargetResources.[0].modifiedProperties, todynamic(\"NoValues\"))\n    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)), \n    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))\n    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n    | extend InitiatedBy = replace(\"_\",\"@\",tostring(split(InitiatedByFull, \"#\")[0]))\n    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetResourceName = case(\n    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,\n    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith \"upn:\", tolower(tostring(TargetResources.[0].displayName)),\n    tolower(tostring(TargetResources.[0].displayName))\n    )\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, \",\")[0], \" \")[1]), TargetUserName ) \n    | mvexpand ModProps\n    | extend PropertyName = tostring(ModProps.displayName), newValue = replace('\\\"','',tostring(ModProps.newValue));\n};\n// Assigning time for First TargetUserName that was added\nlet FirstAdd = auditLogEvents(auditLookback, opName)  \n| project FirstAddTimeUtc = TimeGenerated, Type, FirstInitiatedBy = InitiatedBy, IpAddress, FirstTargetUserName = TargetUserName, FirstTargetResourceName = TargetResourceName, \nFirstOperationName = OperationName, FirstPropertyName = PropertyName, FirstnewValue = newValue, FirstCorrelationId = CorrelationId, FirstId = Id;\n// Assigning time for second TargetUserName that was added, which will allow us to see if a first TargetUserName added in is the Initiated by on the second in the later join\nlet SecondAdd = auditLogEvents(auditLookback, opName)  \n| project SecondAddTimeUtc = TimeGenerated, Type, SecondInitiatedBy = InitiatedBy, IpAddress, SecondTargetUserName = TargetUserName, SecondTargetResourceName = TargetResourceName, \nSecondOperationName = OperationName, SecondPropertyName = PropertyName, SecondnewValue = newValue, SecondCorrelationId = CorrelationId, SecondId = Id;\n//  Joining the FirstAdd with SecondAdd where the FirstAdd TargetUserName value matches the SecondAdd InitiatedBy.  This shows the new user adding a user.\nlet NewUserAddsUser = FirstAdd | join SecondAdd on $left.FirstTargetUserName == $right.SecondInitiatedBy\n// we only want items where the FirstAddTimeUtc is before the SecondAddTimeUtc\n| where FirstAddTimeUtc < SecondAddTimeUtc\n;\n// Build out some of the properties for context\nNewUserAddsUser\n| extend FirstnewValue = split(FirstnewValue, \";\"), SecondnewValue = split(SecondnewValue, \";\")\n| extend PropertyUpdate = pack(FirstPropertyName, FirstnewValue, SecondPropertyName, SecondnewValue, \"FirstCorrelationId\", FirstCorrelationId, \"FirstId\", FirstId, \"SecondCorrelationId\", SecondCorrelationId, \"SecondId\", SecondId)\n| summarize PropertyUpdateSet = make_bag(PropertyUpdate) by FirstAddTimeUtc, FirstInitiatedBy, FirstTargetUserName, SecondAddTimeUtc, SecondInitiatedBy, SecondTargetUserName, \nIpAddress, FirstTargetResourceName, SecondTargetResourceName, FirstOperationName, SecondOperationName\n| extend timestamp = FirstAddTimeUtc, AccountCustomEntity = FirstInitiatedBy, HostCustomEntity = FirstTargetResourceName, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Identifies when a new user is granted access and starts granting access to other users.  This can help you identify rogue or malicious user behavior.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AuditLogs/UsersAuthenticatingtoOtherAzureADTenants.yaml", "query_name": "Users Authenticating to Other Azure AD Tenants", "query": "SigninLogs\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where ResultType == 0\n  | where HomeTenantId != ResourceTenantId\n  | summarize by UserPrincipalName, ResourceTenantId\n  | join kind=rightanti (SigninLogs\n  | where TimeGenerated > ago(1d)\n  | where ResultType == 0\n  | where HomeTenantId != ResourceTenantId\n  | where isnotempty(HomeTenantId) and isnotempty(ResourceTenantId)) on UserPrincipalName, ResourceTenantId\n  | where RiskLevelAggregated != \"none\"\n", "attributes": {"description": "'Detects when a user has successfully authenticated to another Azure AD tenant with an identity in your organization's tenant.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_IAM_PolicyChange.yaml", "query_name": "Changes made to AWS IAM policy", "query": "\nAWSCloudTrail\n| where  EventName in~ (\"AttachGroupPolicy\", \"AttachRolePolicy\", \"AttachUserPolicy\", \"CreatePolicy\",\n\"DeleteGroupPolicy\", \"DeletePolicy\", \"DeleteRolePolicy\", \"DeleteUserPolicy\", \"DetachGroupPolicy\",\n\"PutUserPolicy\", \"PutGroupPolicy\", \"CreatePolicyVersion\", \"DeletePolicyVersion\", \"DetachRolePolicy\", \"CreatePolicy\")\n| project TimeGenerated, EventName, EventTypeName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, \nUserIdentityUserName, SessionMfaAuthenticated, SourceIpAddress, AWSRegion, EventSource, AdditionalEventData, ResponseElements\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityAccountId\n", "attributes": {"description": "Identity and Access Management (IAM) securely manages access to AWS services and resources. \nThis query looks for when an API call is made to change an IAM, particularly those related to new policies being \nattached to users and roles, as well as changes to access methods and changes to account level policies. \nIf these turn out to be noisy filter out the most common for your environment.  \n", "techniques": ["T1078", "T1484"], "tactics": ["PrivilegeEscalation", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_IAM_PrivilegeEscalationbyAttachment.yaml", "query_name": "IAM Privilege Escalation by Instance Profile attachment", "query": "\n// Creating separate table for RemoveRoleToInstanceProfile\nlet RemoveRole=AWSCloudTrail\n| where  EventName in~ (\"RemoveRoleFromInstanceProfile\") and isempty(ErrorMessage)\n| extend RoleRemoved = tostring(parse_json(RequestParameters).roleName), InstanceProfileName = tostring(parse_json(RequestParameters).instanceProfileName), TimeRemoved=TimeGenerated\n| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))\n| summarize RoleRemovedCount= dcount(TimeRemoved) by TimeRemoved, EventName, EventTypeName, UserIdentityArn, UserIdentityUserName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, \nSourceIpAddress, AWSRegion, EventSource, RoleRemoved, InstanceProfileName;\n// Creating separate table for AddRoleToInstanceProfile\nlet AddRole=AWSCloudTrail\n| where  EventName in~ (\"AddRoleToInstanceProfile\") and isempty(ErrorMessage)\n| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))\n| extend RoleAdded = tostring(parse_json(RequestParameters).roleName), InstanceProfileName = tostring(parse_json(RequestParameters).instanceProfileName), TimeAdded=TimeGenerated\n| summarize RoleAddedCount= dcount(TimeAdded) by TimeAdded, EventName, EventTypeName, UserIdentityArn, UserIdentityUserName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent, \nSourceIpAddress, AWSRegion, EventSource, RoleAdded, InstanceProfileName;\n//Joining both operations from the same source IP, user and instance profile name\nRemoveRole\n| join kind= inner (\n   AddRole \n) on AWSRegion,SourceIpAddress, InstanceProfileName, UserIdentityUserName\n| where TimeAdded  > TimeRemoved // Checking if RoleAdd operation was performed after removal\n| summarize TotalCount=count() by TimeAdded, TimeRemoved, RoleAdded, RoleRemoved, UserIdentityUserName, UserIdentityAccountId, UserIdentityPrincipalid, UserAgent,\nSourceIpAddress, AWSRegion, EventSource, RoleRemovedCount, RoleAddedCount\n| extend timestamp = iff(TimeAdded > TimeRemoved,TimeAdded, TimeRemoved), IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName\n", "attributes": {"description": "'An instance profile is a container for an IAM role that you can use to pass role information to an EC2 instance when the instance start.\nIdentifies when existing role is removed and new/existing high privileged role is added to instance profile. \nAny instance with this instance profile attached is able to perform privileged operations.\nAWS Instance Profile: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2_instance-profiles.html\nand CloudGoat - IAM PrivilegeEscalation by Attachment: https://github.com/RhinoSecurityLabs/cloudgoat/tree/master/scenarios/iam_privesc_by_attachment'\n", "techniques": ["T1098"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_PrivilegedRoleAttachedToInstance.yaml", "query_name": "Privileged role attached to Instance", "query": "\nlet EventNameList = dynamic([\"AttachUserPolicy\",\"AttachRolePolicy\",\"AttachGroupPolicy\"]);\nlet PolicyArnList = dynamic([\"arn:aws:iam::aws:policy/AdministratorAccess\",\"arn:aws:iam::aws:policy/DatabaseAdministrator\",\"arn:aws:iam::aws:policy/NetworkAdministrator\",\"arn:aws:iam::aws:policy/SystemAdministrator\",\"arn:aws:iam::aws:policy/AmazonS3FullAccess\"]);\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\n//Creating a temp table of events creating privileged role or users which can later be correlated with suspicious operations.\nlet PrivilegedRoleorUsers = AWSCloudTrail\n| where TimeGenerated >= lookback \n| where EventName in (EventNameList)\n| extend PolicyArn = tostring(parse_json(RequestParameters).policyArn), RoleName = tostring(parse_json(RequestParameters).roleName)\n| where PolicyArn in (PolicyArnList)\n| distinct PolicyArn, UserIdentityType, UserIdentityUserName,RoleName;\n// Joining the list of identities having Privileged roles with the API call AddRoleToInstanceProfile to indentify the instances which may be used by adversaries as pivot point for privilege escalation.\nPrivilegedRoleorUsers\n| join (\nAWSCloudTrail\n| where TimeGenerated between (starttime..endtime)\n| where EventName in (\"AddRoleToInstanceProfile\") \n| extend InstanceProfileName = tostring(parse_json(RequestParameters).InstanceProfileName), RoleName = tostring(parse_json(RequestParameters).roleName)\n| summarize EventCount=count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by EventSource, EventName, UserIdentityType , UserIdentityArn , UserIdentityUserName, SourceIpAddress, RoleName\n) on RoleName \n| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIpAddress, AccountCustomEntity = RoleName\n", "attributes": {"description": "'Identity and Access Management (IAM) securely manages access to AWS services and resources. \nIdentifies when a Privileged role is attached to an existing instance or new instance at deployment. This instance may be used by an adversary to escalate a normal user privileges to an adminsitrative level.\nand AWS API AddRoleToInstanceProfile at https://docs.aws.amazon.com/IAM/latest/APIReference/API_AddRoleToInstanceProfile.html'\n", "techniques": ["T1098"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_SuspiciousCredentialTokenAccessOfValid_IAM_Roles.yaml", "query_name": "Suspicious credential token access of valid IAM Roles", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\n// Generating historical table of AssumeRole operations for IAM Roles to be compared with last 24 hour\nAWSCloudTrail\n| where TimeGenerated between (starttime..endtime)\n| where EventName == \"AssumeRole\" | extend RoleArn = tostring(parse_json(RequestParameters).roleArn)\n| project TimeGenerated, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy , SourceIpAddress, RoleArn\n// Doing Leftanti join to find new AssumeRole operation for IAM role which was not seen historically generated from previous table.\n| join kind= leftanti\n(\n  AWSCloudTrail\n  | where TimeGenerated  between (lookback..starttime)\n  | where EventName == \"AssumeRole\" | extend RoleArn = tostring(parse_json(RequestParameters).roleArn)\n  | project TimeGenerated, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy , SourceIpAddress, RoleArn\n) on RoleArn, UserIdentityInvokedBy\n| summarize EventCount = count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by RoleArn, EventSource, EventName, UserIdentityType, UserIdentityInvokedBy, SourceIpAddress\n| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIpAddress, AccountCustomEntity = tostring(split(RoleArn, \"/\")[1])\n", "attributes": {"description": "'Adversaries may generate temporary credentials of existing privileged IAM roles to access AWS resources that were not previously accessible to perform malicious actions. The credentials may be generated by trusted IAM user or via AWS Cloud Instance Metadata API.\nThis query will look for AWS STS API Assume Role operations for RoleArn (Role Amazon Resource Names) which was not historically seen.\nYou can also limit the query to only sensitive IAM Roles which needs to be monitored.\nRead more about ingest custom logs using Logstash at https://github.com/Azure/Azure-Sentinel/wiki/Ingest-Custom-Logs-LogStash \nAWS API AssumeRole at https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html and AWS Instance Metadata API at https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html '\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSCloudTrail/AWS_Unused_UnsupportedCloudRegions.yaml", "query_name": "Unused or Unsupported Cloud Regions", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\n// Generating historical table of all events per AccountId and Region\nlet EventInfo_CurrentDay =  materialize (AWSCloudTrail | where TimeGenerated between(starttime..endtime));\nlet EventInfo_historical = AWSCloudTrail  | where TimeGenerated  between (lookback..starttime) | summarize max(TimeGenerated) by AWSRegion, UserIdentityAccountId;\n// Doing Leftanti join to find new regions historically not seen for the same account.\nlet EventInfo_Unseen = materialize (\nEventInfo_CurrentDay\n| summarize max(TimeGenerated) by AWSRegion, UserIdentityAccountId\n| join kind= leftanti\n(\n  EventInfo_historical\n) on AWSRegion, UserIdentityAccountId\n);\nEventInfo_Unseen\n// Join Ununsed region seen with current data to gather context about API events seen\n| join kind= inner (\n   EventInfo_CurrentDay\n) on AWSRegion, UserIdentityAccountId\n| extend UnusedRegion = AWSRegion\n| extend UserIdentityUserName = iff(isnotempty(UserIdentityUserName), UserIdentityUserName, tostring(split(UserIdentityArn,'/')[-1]))\n| summarize EventCount = count(), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), EventNameList=make_set(EventName), IPList=make_set(SourceIpAddress) by UserIdentityAccountId, UnusedRegion, UserIdentityUserName\n| extend timestamp = StartTime , AccountCustomEntity = UserIdentityUserName\n", "attributes": {"description": "'Adversaries may create cloud instances in unused geographic service regions in order to evade detection.\nAccess is usually obtained through compromising accounts used to manage cloud infrastructure.\nRefer: https://attack.mitre.org/techniques/T1535/'\n", "techniques": ["T1535"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSS3/AWSBucketAPILogs-S3BucketDataTransferTimeSeriesAnomaly.yaml", "query_name": "S3 Bucket outbound Data transfer anomaly", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet timeframe = 1h;\nlet scorethreshold = 1.5;\n// Preparing the time series data aggregated on BytesTransferredOut column in the form of multi-value array so that it can be used with time series anomaly function.\nlet TimeSeriesData=\nAwsBucketAPILogs_CL\n| where EventTime between (lookback..endtime)\n| where EventName == \"GetObject\"\n| make-series Total=sum(BytesTransferredOut) on EventTime from startofday(starttime) to startofday(endtime) step timeframe;\n// Use the time series data prepared in previous step with time series aomaly function to generate baseline pattern and flag the outlier based on scorethreshold value.\nlet TimeSeriesAlerts = TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, scorethreshold, -1, 'linefit')\n| mv-expand Total to typeof(double), EventTime to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n| where anomalies > 0\n| project EventTime, Total, baseline, anomalies, score;\n// Joining the flagged outlier from the previous step with the original dataset to present contextual information during the anomalyhour to analysts to conduct investigation or informed decistions.\nTimeSeriesAlerts\n| join\n(\n  AWSS3BucketAPILogParsed\n  | where EventTime between (startofday(lookback)..endofday(endtime))\n  | where EventName == \"GetObject\"\n  | summarize Total = sum(BytesTransferredOut), Files= makeset(Key) , max(EventTime) by bin(EventTime, 1h), EventSource,EventName, SourceIPAddress, UserIdentityType, UserIdentityArn, UserIdentityUserName, BucketName, Host, AuthenticationMethod, SessionMfaAuthenticated, SessionUserName\n) on EventTime\n| project AnomalyTime = max_EventTime, SourceIPAddress, UserIdentityType,UserIdentityUserName,SessionUserName, BucketName, Host, AuthenticationMethod, Files, Total, baseline, anomalies, score\n| extend timestamp = AnomalyTime, AccountCustomEntity = SessionUserName , HostCustomEntity = Host, IPCustomEntity = SourceIPAddress\n", "attributes": {"description": "'Identifies when an anomalous spike occur in data transfer from an S3 bucket based on GetObject API call and the BytesTransferredOut field.\nThe query leverages KQL built-in anomaly detection algorithms to find large deviations from baseline patterns.\nSudden increases in execution frequency of sensitive actions should be further investigated for malicious activity.\nManually change scorethreshold from 1.5 to 3 or higher to reduce the noise based on outliers flagged from the query criteria.\nRead more about ingest custom logs using Logstash at https://github.com/Azure/Azure-Sentinel/wiki/Ingest-Custom-Logs-LogStash\nAWS S3 API GetObject at https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html\nS3 LogStash Config: https://github.com/Azure/Azure-Sentinel/blob/master/Parsers/Logstash/input-aws_s3-output-loganalytics.conf\nS3 KQL Parser: https://github.com/Azure/Azure-Sentinel/blob/master/Parsers/AwsS3BucketAPILogsParser.txt'\n", "techniques": ["T1020"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AWSS3/AWSBucketAPILogs-SuspiciousDataAccessToS3BucketsfromUnknownIP.yaml", "query_name": "Suspicious Data Access to S3 Bucket from Unknown IP", "query": "\nlet EventNameList = dynamic([\"ListBucket\",\"ListObjects\",\"GetObject\"]);\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nAwsBucketAPILogs_CL \n| where EventTime TimeGenerated between(starttime..endtime)\n| where EventName in (EventNameList)\n| project EventTime, EventSource,EventName, SourceIPAddress, UserIdentityType, UserIdentityArn, UserIdentityUserName, BucketName, Host, AuthenticationMethod, SessionMfaAuthenticated, SessionUserName, Key\n| join kind=leftanti\n(\n  AWSS3BucketAPILogParsed \n  | where EventTime between (lookback..starttime)\n  | where EventName in (EventNameList)\n) on SourceIPAddress\n| summarize EventCount=count(), StartTimeUtc = min(EventTime), EndTimeUtc = max(EventTime), Files= makeset(Key), EventNames = makeset(EventName) by EventSource, SourceIPAddress, UserIdentityType, UserIdentityArn, UserIdentityUserName, BucketName, Host, AuthenticationMethod, SessionMfaAuthenticated, SessionUserName\n| project StartTimeUtc, EndTimeUtc, EventSource, Host, SourceIPAddress, UserIdentityType, BucketName, EventNames, Files, AuthenticationMethod, SessionMfaAuthenticated, SessionUserName, EventCount\n| extend timestamp = StartTimeUtc, HostCustomEntity = Host, AccountCustomEntity = SessionUserName, IPCustomEntity = SourceIPAddress\n", "attributes": {"description": "'Adversaries may access data objects from improperly secured cloud storage. This query will identify any access originating from a Source IP which was not seen historically accessing the bucket or downloading files from it.\nYou can also limit the query to only private buckets with sensitive files by setting the value or list of values to BucketName column.\nRead more about ingest custom logs using Logstash at https://github.com/Azure/Azure-Sentinel/wiki/Ingest-Custom-Logs-LogStash \nand AWS S3 API GetObject at https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html and ListObject at https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjects.html\nand ListBucket at https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListBuckets.html\nS3 LogStash Config: https://github.com/Azure/Azure-Sentinel/blob/master/Parsers/Logstash/input-aws_s3-output-loganalytics.conf\nS3 KQL Parser: https://github.com/Azure/Azure-Sentinel/blob/master/Parsers/AwsS3BucketAPILogsParser.txt'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnalyticsRulesAdministrativeOperations.yaml", "query_name": "Microsoft Sentinel Analytics Rules Administrative Operations", "query": "\nlet opValues = dynamic([\"Microsoft.SecurityInsights/alertRules/write\", \"Microsoft.SecurityInsights/alertRules/delete\"]);\n// Microsoft Sentinel Analytics - Rule Create / Update / Delete\nAzureActivity\n| where Category == \"Administrative\"\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue in (\"Created\", \"OK\")\n| sort by TimeGenerated desc\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Identifies Microsoft Sentinel Analytics Rules administrative operations'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AnomalousAzureOperationModel.yaml", "query_name": "Anomalous Azure Operation Hunting Model", "query": "// When the detection window will end (3 days prior to now)\nlet startDetectDate = 3d;\n// When the detection window will start (now)\nlet endDetectDate = 0d;\n// When to start collecting data for detection\nlet startDate = startDetectDate + 30d;\n// Operation to monitor, in this case Run Command\nlet monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);\n// The resource type to monitor, in this case virtual machines\nlet monitoredResource = pack_array('microsoft.compute/virtualmachines');\nlet pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)\n{\nlet T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));\nlet countOnScope = T | summarize countAllOnScope = count() by _scope;\nlet probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;\nlet probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;\nlet probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;\n    probAB\n    | join kind = leftouter (probA) on _A, _scope\n    | join kind = leftouter (probB) on _B, _scope\n    | extend P_AUB = P_A + P_B - P_AB\n           , P_AIB = P_AB/P_B\n           , P_BIA = P_AB/P_A\n    | extend Lift_AB = P_AB/(P_A * P_B)\n           , Jaccard_AB = P_AB/P_AUB\n    | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)\n    , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)\n    | sort by _scope, _A, _B\n};\nlet eventsTable = materialize (\nAzureActivity\n| where TimeGenerated between (ago(startDate) .. ago(endDetectDate))\n| where isnotempty(CallerIpAddress)\n| where ActivityStatusValue has_any ('Success', 'Succeeded')\n| extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)\n| extend splitOp = split(OperationNameValue, '/')\n| extend splitRes = split(ResourceId, '/')\n| project TimeGenerated , subscriptionId=SubscriptionId\n            , ResourceProvider\n            , ResourceName = tolower(tostring(splitRes[-1]))\n            , OperationNameValue = tolower(OperationNameValue)\n            , timeSlice = floor(TimeGenerated, 1d)\n            , clientIp = tostring(CallerIpAddress)\n            , Caller\n            , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)\n            , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)\n            , CorrelationId\n| extend clientIpMask = format_ipv4_mask(clientIp, 16)\n);\nlet modelData =  (\neventsTable\n| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)\n| summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)\n    , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)\n    by subscriptionId, Caller, clientIpMask\n);\nlet monOpProbs = materialize (\neventsTable\n| where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)\n| invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')\n| where _B == 1\n| sort by P_AIB desc\n| extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB\n| extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)\n| project-away sumBiggerCondProbs\n);\neventsTable\n| where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))\n| join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)\n    , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) \n        on subscriptionId, Caller\n| join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)\n    , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) \n        on subscriptionId, clientIpMask\n| join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)\n    , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)\n    , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)\n        on subscriptionId        \n| project-away subscriptionId1, Caller1, subscriptionId2\n| extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)\n| extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)\n| join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A\n| project-away _A, _B, _scope\n| sort by subscriptionId asc, TimeGenerated asc\n| extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))\n| sort by subscriptionId asc, Caller asc, TimeGenerated asc\n| extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))\n| extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)\n    , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)\n    , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)\n    , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)\n    , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)\n    , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)\n| project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource\n| order by TimeGenerated\n| where isMonitoredOp == 1\n// Optional - focus only on monitored operations or monitored resource in detection window\n| where isMonitoredOp == 1\n//| where isMonitoredResource == 1", "attributes": {"description": "'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.\nThe query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,\nNew Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect\nanomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured \nat the top of the query along with the detection window parameters'\n", "techniques": ["T1570", "T1078.004"], "tactics": ["LateralMovement", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Anomalous_Listing_Of_Storage_Keys.yaml", "query_name": "Azure storage key enumeration", "query": "\nAzureActivity\n| where OperationNameValue =~ \"microsoft.storage/storageaccounts/listkeys/action\"\n| where ActivityStatusValue == \"Succeeded\" \n| join kind= inner (\n    AzureActivity\n    | where OperationNameValue =~ \"microsoft.storage/storageaccounts/listkeys/action\"\n    | where ActivityStatusValue == \"Succeeded\" \n    | project ExpectedIpAddress=CallerIpAddress, Caller \n    | evaluate autocluster()\n) on Caller \n| where CallerIpAddress != ExpectedIpAddress\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = make_set(ResourceId), ResourceIdCount = dcount(ResourceId) by OperationNameValue, Caller, CallerIpAddress\n| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Listing of storage keys is an interesting operation in Azure which might expose additional \nsecrets and PII to callers as well as granting access to VMs. While there are many benign operations of this\ntype, it would be interesting to see if the account performing this activity or the source IP address from \nwhich it is being done is anomalous. \nThe query below generates known clusters of ip address per caller, notice that users which only had single\noperations do not appear in this list as we cannot learn from it their normal activity (only based on a single\nevent). The activities for listing storage account keys is correlated with this learned \nclusters of expected activities and activity which is not expected is returned.'\n", "techniques": ["T1087"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Azure-CloudShell-Usage.yaml", "query_name": "Azure CloudShell Usage", "query": "\nAzureActivity\n   | where ActivityStatusValue == \"Succeeded\"\n   | where ResourceGroup has \"cloud-shell-storage\"\n   | where OperationNameValue == \"Microsoft.Storage/storageAccounts/listKeys/action\"\n   // Change the timekey scope below to get activity for a longer window \n   | summarize by Caller, timekey= bin(TimeGenerated, 1h)\n   | join (AzureActivity | where TimeGenerated >= ago(1d)\n   | where OperationNameValue != \"Microsoft.Storage/storageAccounts/listKeys/action\"\n   | where isnotempty(OperationName)\n    // Change the timekey scope below to get activity for a longer window \n   | summarize make_set(OperationName) by Caller, timekey=bin(TimeGenerated, 1h)) on Caller, timekey\n   | extend timestamp = timekey, AccountCustomEntity = Caller\n", "attributes": {"description": "'This query look for users starting an Azure CloudShell session and summarizes the Azure Activity from that\nuser account during that timeframe (by default 1 hour). This can be used to help identify abuse of the CloudShell\nto modify Azure resources.'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureAdministrationFromVPS.yaml", "query_name": "AzureActivity Administration From VPS Providers", "query": "\nlet IP_Data = (externaldata(network:string)\n[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/VPS_Networks.csv\"] with (format=\"csv\"));\nAzureActivity\n| where CategoryValue =~ \"Administrative\"\n| evaluate ipv4_lookup(IP_Data, CallerIpAddress, network, return_unmatched = false)\n| summarize Operations = make_set(OperationNameValue), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by CallerIpAddress, Caller\n| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Looks for Administrative actions in AzureActivity from known VPS provider network ranges.\nThis is not an exhaustive list of VPS provider ranges but covers some of the most prevalent providers observed.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureNSG_AdministrativeOperations.yaml", "query_name": "Azure Network Security Group NSG Administrative Operations", "query": "\nlet opValues = dynamic([\"Microsoft.Network/networkSecurityGroups/write\", \"Microsoft.Network/networkSecurityGroups/delete\"]);\n// Azure NSG Create / Update / Delete\nAzureActivity\n| where Category == \"Administrative\"\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue in (\"Created\", \"OK\")\n| sort by TimeGenerated desc\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Identifies set of Azure NSG administrative operational detection queries for hunting activites'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureRunCommandFromAzureIP.yaml", "query_name": "Azure VM Run Command executed from Azure IP address", "query": "let azure_ranges = externaldata(changeNumber: string, cloud: string, values: dynamic)\n[\"https://download.microsoft.com/download/7/1/D/71D86715-5596-4529-9B13-DA13A5DE5B63/ServiceTags_Public_20220307.json\"]\nwith(format='multijson')\n| mv-expand values\n// Limit to virtual desktop IP ranges, uncomment to see all Azure ranges\n| where values contains \"VirtualDesktop\"\n| mv-expand values.properties.addressPrefixes\n| mv-expand values_properties_addressPrefixes\n| summarize by tostring(values_properties_addressPrefixes);\nAzureActivity\n| where TimeGenerated > ago(30d)\n// Isolate run command actions\n| where OperationNameValue == \"Microsoft.Compute/virtualMachines/runCommand/action\"\n// Confirm that the operation impacted a virtual machine\n| where Authorization has \"virtualMachines\"\n// Each runcommand operation consists of three events when successful, Started, Accepted (or Rejected), Successful (or Failed).\n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), max(CallerIpAddress), make_list(ActivityStatusValue) by CorrelationId, Authorization, Caller\n// Limit to Run Command executions that Succeeded\n| where list_ActivityStatusValue has \"Succeeded\"\n// Extract data from the Authorization field, allowing us to later extract the Caller (UPN) and CallerIpAddress\n| extend Authorization_d = parse_json(Authorization)\n| extend Scope = Authorization_d.scope\n| extend Scope_s = split(Scope, \"/\")\n| extend Subscription = tostring(Scope_s[2])\n| extend VirtualMachineName = tostring(Scope_s[-1])\n| project StartTime, EndTime, Subscription, VirtualMachineName, CorrelationId, Caller, CallerIpAddress=max_CallerIpAddress\n| evaluate ipv4_lookup(azure_ranges, CallerIpAddress, values_properties_addressPrefixes)\n| extend timestamp = StartTime, IPCustomEntity=CallerIpAddress\n", "attributes": {"description": "'Identifies any Azure VM Run Command operation executed from an Azure IP address.\nRun Command allows an attacker or legitimate user to execute aribitrary PowerShell\non a target VM. This technique has been seen in use by NOBELIUM.'\n", "techniques": ["T1570", "T1078.004"], "tactics": ["LateralMovement", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureSentinelConnectors_AdministrativeOperations.yaml", "query_name": "Microsoft Sentinel Connectors Administrative Operations", "query": "\nlet opValues = dynamic([\"Microsoft.SecurityInsights/dataConnectors/write\", \"Microsoft.SecurityInsights/dataConnectors/delete\"]);\n// Microsoft Sentinel Data Connectors Update / Delete\nAzureActivity\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue in (\"Created\", \"OK\")\n| sort by TimeGenerated desc\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Identifies set of Microsoft Sentinel Data Connectors administrative operational detection queries for hunting activites'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureSentinelWorkbooks_AdministrativeOperation.yaml", "query_name": "Microsoft Sentinel Workbooks Administrative Operations", "query": "\nlet opValues = dynamic([\"microsoft.insights/workbooks/write\", \"microsoft.insights/workbooks/delete\"]);\n// Microsoft Sentinel Workbook Create / Update / Delete\nAzureActivity\n| where Category == \"Administrative\"\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue in (\"Created\", \"OK\")\n| sort by TimeGenerated desc\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Identifies set of Microsoft Sentinel Workbooks administrative operational detection queries for hunting activites'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/AzureVirtualNetworkSubnets_AdministrativeOperationset.yaml", "query_name": "Azure Virtual Network Subnets Administrative Operations", "query": "\nlet opValues = dynamic([\"Microsoft.Network/virtualNetworks/subnets/write\"]);\n// Creating Virtual Network Subnets\nAzureActivity\n| where CategoryValue == \"Administrative\"\n| where OperationNameValue in (opValues)\n| where ActivitySubstatusValue == \"Created\"\n| sort by TimeGenerated desc\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Identifies set of Azure Virtual Network Subnets administrative operational detection queries for hunting activites'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Common_Deployed_Resources.yaml", "query_name": "Common deployed resources", "query": "\nAzureActivity\n| where OperationNameValue has_any (@\"deployments/write\", @\"virtualMachines/write\")  \n| where ActivityStatusValue == \"Succeeded\"\n| summarize by bin(TimeGenerated,1d), Resource, ResourceGroup, ResourceId, OperationNameValue, Caller\n| evaluate basket()\n| where isnotempty(Caller) and isnotempty(Resource) and isnotempty(TimeGenerated)\n| order by Percent desc, TimeGenerated desc\n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller, ResourceCustomEntity = ResourceId\n// remove comments below on filters if the goal is to see more common or more rare Resource, Resource Group and Caller combinations\n//| where Percent <= 40 // <-- more rare\n//| where Percent >= 60 // <-- more common\n", "attributes": {"description": "'This query looks for common deployed resources (resource name and resource groups) and can be used\nin combination with other signals that show suspicious deployment to evaluate if the resource is one\nthat is commonly being deployed/created or unique.\nTo understand the basket() function better see - https://docs.microsoft.com/azure/data-explorer/kusto/query/basketplugin' \n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Creating_Anomalous_Number_Of_Resources.yaml", "query_name": "Creation of an anomalous number of resources", "query": "\nAzureActivity\n| where OperationNameValue in~ (\"microsoft.compute/virtualMachines/write\", \"microsoft.resources/deployments/write\")\n| where ActivityStatusValue == \"Succeeded\" \n| make-series dcount(ResourceId)  default=0 on EventSubmissionTimestamp in range(ago(7d), now(), 1d) by Caller\n| extend AccountCustomEntity = Caller\n| extend timestamp = todatetime(EventSubmissionTimestamp[7])\n", "attributes": {"description": "'Looks for anomalous number of resources creation or deployment activities in azure activity log.\nIt is best to run this query on a look back period which is at least 7 days.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Granting_Permissions_to_Account.yaml", "query_name": "Granting permissions to account", "query": "\nAzureActivity\n| where OperationName == \"Create role assignment\"\n| where ActivityStatus == \"Succeeded\" \n| project Caller, CallerIpAddress\n| evaluate basket()\n| join kind=leftouter (AzureActivity\n| where OperationName == \"Create role assignment\"\n| where ActivityStatus == \"Succeeded\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Caller, CallerIpAddress)\non Caller, CallerIpAddress\n| project-away Caller1, CallerIpAddress1\n| where isnotempty(StartTime)\n| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Shows the most prevalent users who grant access to others on azure resources and for each account \ntheir common source ip address. If an operation is not from this IP address it may be worthy of investigation.'\n", "techniques": ["T1098"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/PortOpenedForAzureResource.yaml", "query_name": "Port opened for an Azure Resource", "query": "\nAzureActivity\n| where OperationNameValue has_any (\"ipfilterrules\", \"securityRules\", \"publicIPAddresses\", \"firewallrules\") and OperationNameValue endswith \"write\"\n// Choosing Accepted here because it has the Rule Attributes included\n| where ActivityStatusValue == \"Accepted\" \n// If there is publicIP info, include it\n| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) \n| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) \n| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) \n// Include rule attributes for context\n| extend access = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).access) \n| extend description = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).description) \n| extend destinationPortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).destinationPortRange) \n| extend direction = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).direction) \n| extend protocol = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).protocol) \n| extend sourcePortRange = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).sourcePortRange) \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResourceIds = makeset(ResourceId) by Caller, CallerIpAddress, Resource, ResourceGroup, \nActivityStatusValue, ActivitySubstatus, SubscriptionId, access, description, destinationPortRange, direction, protocol, sourcePortRange  \n| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Identifies what ports may have been opened for a given Azure Resource over the last 7 days'\n", "techniques": ["T1071", "T1571", "T1496"], "tactics": ["CommandAndControl", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureActivity/Rare_Custom_Script_Extension.yaml", "query_name": "Rare Custom Script Extension", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet Lookback = starttime - 14d;\nlet CustomScriptExecution = AzureActivity\n| where TimeGenerated >= Lookback\n| where OperationName =~ \"Create or Update Virtual Machine Extension\"\n| extend Settings = tostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).settings)))\n| parse Settings with * 'fileUris\":[' FileURI \"]\" *\n| parse Settings with * 'commandToExecute\":' commandToExecute '}' *\n| extend message_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).statusMessage)).error)).message);\nlet LookbackCustomScriptExecution = CustomScriptExecution\n| where TimeGenerated >= Lookback and TimeGenerated < starttime\n| where isnotempty(FileURI) and isnotempty(commandToExecute)\n| summarize max(TimeGenerated), OperationCount = count() by Caller, Resource, CallerIpAddress, FileURI, commandToExecute;\nlet CurrentCustomScriptExecution = CustomScriptExecution\n| where TimeGenerated between (starttime..endtime)\n| where isnotempty(FileURI) and isnotempty(commandToExecute)\n| project TimeGenerated, ActivityStatus, OperationId, CorrelationId, ResourceId, CallerIpAddress, Caller, OperationName, Resource, ResourceGroup, FileURI, commandToExecute, FailureMessage = message_, HTTPRequest, Settings;\nlet RareCustomScriptExecution =  CurrentCustomScriptExecution\n| join kind= leftanti (LookbackCustomScriptExecution) on Caller, CallerIpAddress, FileURI, commandToExecute;\nlet IPCheck = RareCustomScriptExecution\n| summarize arg_max(TimeGenerated, OperationName), OperationIds = makeset(OperationId), CallerIpAddresses = makeset(CallerIpAddress) by ActivityStatus, CorrelationId, ResourceId, Caller, Resource, ResourceGroup, FileURI, commandToExecute, FailureMessage\n| extend IPArray = arraylength(CallerIpAddresses);\n//Get IPs for later summarization so all associated CorrelationIds and Caller actions have an IP.  Success and Fails do not always have IP\nlet multiIP = IPCheck | where IPArray > 1\n| mvexpand CallerIpAddresses | extend CallerIpAddress = tostring(CallerIpAddresses)\n| where isnotempty(CallerIpAddresses);\nlet singleIP = IPCheck | where IPArray <= 1\n| mvexpand CallerIpAddresses | extend CallerIpAddress = tostring(CallerIpAddresses);\nlet FullDetails = singleIP | union multiIP;\n//Get IP address associated with successes and fails with no IP listed\nlet IPList = FullDetails | where isnotempty(CallerIpAddress) | summarize by CorrelationId, Caller, CallerIpAddress;\nlet EmptyIP = FullDetails | where isempty(CallerIpAddress) | project-away CallerIpAddress;\nlet IpJoin = EmptyIP | join kind= leftouter (IPList) on CorrelationId, Caller | project-away CorrelationId1, Caller1;\nlet nonEmptyIP = FullDetails | where isnotempty(CallerIpAddress);\nnonEmptyIP | union IpJoin\n// summarize all activities with a given CorrelationId and Caller together so we can provide a singular result\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ActivityStatusSet = makeset(ActivityStatus), OperationIds = makeset(OperationIds), FailureMessages = makeset(FailureMessage) by CorrelationId, ResourceId, CallerIpAddress, Caller, Resource, ResourceGroup, FileURI, commandToExecute\n| extend timestamp = StartTime, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'The Custom Script Extension downloads and executes scripts on Azure virtual machines. This extension is useful for post deployment configuration, software installation, or any other configuration or management tasks.\n Scripts could be downloaded from external links, Azure storage, GitHub, or provided to the Azure portal at extension run time. This could also be used maliciously by an attacker.\n The query tries to identify rare custom script extensions that have been executed in your envioenment'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/AAD%20Conditional%20Access%20Disabled.yaml", "query_name": "Azure DevOps- AAD Conditional Access Disabled", "query": "AzureDevOpsAuditing\n| where OperationName ==\"OrganizationPolicy.PolicyValueUpdated\"\n| where Data.PolicyName == \"Policy.EnforceAADConditionalAccess\"\n| where Data.PolicyValue == \"OFF\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This hunting query identifies Azure DevOps activities where organization AADConditionalAccess policy disable by the admin'\n", "techniques": ["T1098", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Addtional%20Org%20Admin%20Added.yaml", "query_name": "Azure DevOps- Addtional Org Admin added", "query": "AzureDevOpsAuditing\n| where OperationName == \"Group.UpdateGroupMembership.Add\"\n| where Category == \"Modify\"\n| where Area == \"Group\"\n| where Details contains (\"Project Collection Administrators\")\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This hunting query identifies Azure DevOps activities where additional organization admin is added'\n", "techniques": ["T1098", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/ADOBuildCheckDeleted.yaml", "query_name": "Azure DevOps - Build Check Deleted.", "query": "AzureDevOpsAuditing\n  | where OperationName =~ \"CheckConfiguration.Deleted\"\n  | extend ResourceName = tostring(Data.ResourceName)\n  | extend Type = tostring(Data.Type)\n  | project-reorder TimeGenerated, OperationName, ResourceName, Type, ActorUPN, IpAddress, UserAgent\n  | extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Build checks can be built into a pipeline in order control the release process, these can include things such as the successful passing of certain steps, or an explicit user approval. An attacker who has altered a build process may look to remove a check in order to ensure a compromised build is released. This hunting query simply looks for all check removal events,  these should be relatively uncommon. In the output Type shows the type of Check that was deleted. '\n", "techniques": ["T1578"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/ADOBuildDeletedAfterPipelineMod.yaml", "query_name": "Azure DevOps - Build Deleted After Pipeline Modification", "query": "AzureDevOpsAuditing\n| where OperationName =~ \"Release.ReleaseDeleted\"\n| extend PipelineId = tostring(Data.PipelineId)\n| extend PipelineName = tostring(Data.PipelineName)\n| extend timekey = bin(TimeGenerated, 1h)\n| join (AzureDevOpsAuditing\n| where OperationName =~ 'Release.ReleasePipelineModified'\n| extend PipelineId = tostring(Data.PipelineId)\n| extend PipelineName = tostring(Data.PipelineName)\n| extend timekey = bin(TimeGenerated, 1h)) on timekey, PipelineId, ActorUPN\n| where TimeGenerated1 < TimeGenerated\n| extend ReleaseName = tostring(Data.ReleaseName)\n| project-rename TimeModified = TimeGenerated1, TimeDeleted = TimeGenerated, ModifyOperation = OperationName1, ModifyUser=ActorUPN1, ModifyIP=IpAddress1, ModifyUA= UserAgent1, DeleteOperation=OperationName, DeleteUser=ActorUPN, DeleteIP=IpAddress, DeleteUA=UserAgent\n| project-reorder TimeModified, ProjectName, PipelineName, ModifyUser, ModifyIP, ModifyUA, TimeDeleted, DeleteOperation, DeleteUser, DeleteIP, DeleteUA,ReleaseName\n| extend timestamp = TimeDeleted, AccountCustomEntity = DeleteUser, IPCustomEntity = DeleteIP\n", "attributes": {"description": "'An attacker altering pipelines may look to delete builds to reduce the footprint they leave on a system. This query looks for a build for a pipline being deleted within 1 hour of a pipeline being modified. This event may produce false positives but should not be so common that it can't be effectively used as part of hunting.'\n", "techniques": ["T1053"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/ADOInternalUpstreamPacakgeFeedAdded.yaml", "query_name": "Azure DevOps - Internal Upstream Package Feed Added.", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*10);\n// Add any known allowed sources and source locations to the filter below.\nlet allowed_sources = dynamic([]);\nlet allowed_locations = dynamic([]);\nlet known_packages = (\nAzureDevOpsAuditing\n| where TimeGenerated > ago(lookback) and TimeGenerated < starttime\n// Look for feeds created or modified at either the organization or project level\n| where OperationName matches regex \"Artifacts.Feed.(Org|Project).Modify\"\n| where Details has \"UpstreamSources, added\"\n| extend UpstreamsAdded = Data.UpstreamsAdded\n// As multiple feeds may be added expand these out\n| mv-expand UpstreamsAdded\n// Only focus on internal feeds\n| where UpstreamsAdded.UpstreamSourceType =~ \"internal\"\n| extend SourceLocation = tostring(UpstreamsAdded.Location)\n| summarize by SourceLocation);\n// Look for internal feeds being added from a new location\nAzureDevOpsAuditing\n| where TimeGenerated between(starttime..endtime)\n| where OperationName matches regex \"Artifacts.Feed.(Org|Project).Modify\"\n| where Details has \"UpstreamSources, added\"\n| extend FeedName = tostring(Data.FeedName)\n| extend FeedId = tostring(Data.FeedId)\n| extend UpstreamsAdded = Data.UpstreamsAdded\n// As multiple feeds may be added expand these out\n| mv-expand UpstreamsAdded\n// Only focus on internal feeds\n| where UpstreamsAdded.UpstreamSourceType =~ \"internal\"\n| extend SourceLocation = tostring(UpstreamsAdded.Location)\n| extend SourceName = tostring(UpstreamsAdded.Name)\n// Exclude sources and locations in the allow list\n| where SourceLocation !in (known_packages)\n| where SourceLocation !in (allowed_locations) and SourceName !in (allowed_sources)\n| extend SourceProtocol = tostring(UpstreamsAdded.Protocol)\n| extend SourceStatus = tostring(UpstreamsAdded.Status)\n| project-reorder TimeGenerated, OperationName, ScopeDisplayName, ProjectName, FeedName, SourceName, SourceLocation, SourceProtocol, ActorUPN, UserAgent, IpAddress\n// See if there are details of who created this feed and when to add context\n| join kind=leftouter (AzureDevOpsAuditing\n| where TimeGenerated > ago(lookback)\n| where OperationName matches regex \"Artifacts.Feed.(Org|Project).Create\"\n| extend FeedId = tostring(Data.FeedId)\n| project FeedId, FeedCreatedBy=ActorUPN, TimeCreated=TimeGenerated) on FeedId, $left.ActorUPN==$right.FeedCreatedBy\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'An attacker aiming to insert malicious code into a build process could look to introduce compromised upstream packages into the build process. Looking at internal packages can have a significant false positive rate compared to looking at external feeds so running this as a hunting query at least initially is advised. If an environment has low number of events it can be upgraded to a detection.'\n", "techniques": ["T1195"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/ADONewAgentPoolCreated.yaml", "query_name": "Azure DevOps - New Agent Pool Created", "query": "AzureDevOpsAuditing\n| where OperationName =~ \"Library.AgentPoolCreated\"\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n| extend AgentPoolId = tostring(Data.AgentPoolId)\n| extend IsHosted = tostring(Data.IsHosted)\n| extend IsLegacy = tostring(Data.IsLegacy)\n| project-reorder TimeGenerated, ActorUPN, UserAgent, IpAddress, AuthenticationMechanism, OperationName, AgentPoolName, IsHosted, IsLegacy, Data\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Agent Pools provide a valuable resource to build processes. Creating and using a compromised agent pool in a pipeline could allow an attacker to compromise a build process. Whilst the creation of an agent pool itself is not malicious it is unlike to occur so often that it cannot be used as a hunting element when focusing on Azure DevOps activity.'\n", "techniques": ["T1578"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/ADONewPackageFeedCreated.yaml", "query_name": "Azure DevOps - New Package Feed Created", "query": "let alert_threshold = 0;\nAzureDevOpsAuditing\n| where OperationName matches regex \"Artifacts.Feed.(Org|Project).Create\"\n| extend FeedName = tostring(Data.FeedName)\n| extend FeedId = tostring(Data.FeedId)\n| join kind = leftouter (\nSecurityAlert\n| where ProviderName == \"IPC\"\n| extend AadUserId = tostring(parse_json(Entities)[0].AadUserId)\n| summarize Alerts=count() by AadUserId) on $left.ActorUserId == $right.AadUserId\n| extend Alerts = iif(isempty(Alerts), 0, Alerts)\n| project-reorder TimeGenerated, Details, ActorUPN, IpAddress, UserAgent\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'An attacker could look to introduce upstream compromised software packages by creating a new package feed within Azure DevOps. This query looks for new Feeds and includes details on any Azure AD Identity Protection alerts related to the user account creating the feed to assist in triage.'\n", "techniques": ["T1195"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/ADONewPATOperation.yaml", "query_name": "Azure DevOps - New PAT Operation", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*10);\nlet PAT_Actions = AzureDevOpsAuditing\n| where TimeGenerated > ago(lookback) and TimeGenerated < starttime\n| where AuthenticationMechanism startswith \"PAT\"\n| summarize by OperationName;\nAzureDevOpsAuditing\n| where TimeGenerated between(starttime..endtime)\n| where AuthenticationMechanism startswith \"PAT\"\n| where OperationName !in (PAT_Actions)\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'PATs are typically used for repeated, programmatic tasks. This query looks for PATs based authentication being used with an Operation not previous associated with PAT based authentication. This could indicate an attacker using a stolen PAT to perform malicious actions.'\n", "techniques": ["T1078"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/ADONewReleaseApprover.yaml", "query_name": "Azure DevOps - New Release Approver", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = 30d;\nAzureDevOpsAuditing\n| where TimeGenerated > ago(lookback) and TimeGenerated < starttime\n| where OperationName in (\"Release.ApprovalCompleted\", \"Release.ApprovalsCompleted\")\n| extend PipelineName = tostring(Data.PipelineName)\n| extend ApprovalType = tostring(Data.ApprovalType)\n| extend StageName = tostring(Data.StageName)\n| extend ReleaseName = tostring(Data.ReleaseName)\n| summarize by PipelineName, ActorUPN, ApprovalType\n| join kind=rightanti (\nAzureDevOpsAuditing\n| where TimeGenerated between(starttime..endtime)\n| where OperationName in (\"Release.ApprovalCompleted\", \"Release.ApprovalsCompleted\")\n| extend PipelineName = tostring(Data.PipelineName)\n| extend ApprovalType = tostring(Data.ApprovalType)\n| extend StageName = tostring(Data.StageName)\n| extend ReleaseName = tostring(Data.ReleaseName)) on ActorUPN\n| project-reorder TimeGenerated, PipelineName, ActorUPN, ApprovalType, StageName, ReleaseName, IpAddress, UserAgent, AuthenticationMechanism\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Releases in Azure Pipelines often require a user authorization to perform the release. An attacker that has compromised a build may look to self-approve a release using a compromised account to avoid user focus on that release. This query looks for release approvers in pipelines where they have not approved a release in the last 30 days. This query can have a significant false positive rate so its best suited as a hunting query rather than a detection.'\n", "techniques": ["T1078"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/ADOReleasePipelineCreated.yaml", "query_name": "Azure DevOps - New Release Pipeline Created", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = 30d;\n// Set the period for detections\n// Get a list of previous Release Pipeline creators to exclude\nlet releaseusers = AzureDevOpsAuditing\n| where TimeGenerated between(ago(lookback)..starttime)\n| where OperationName =~ \"Release.ReleasePipelineCreated\"\n// We want to look for users performing actions in specific organizations so we creat this userscope object to match on\n| extend UserScope = strcat(ActorUPN, \"-\", ProjectName)\n| summarize by UserScope;\n// Get Release Pipeline creations by new users\nAzureDevOpsAuditing\n| where TimeGenerated between(starttime..endtime)\n| where OperationName =~ \"Release.ReleasePipelineCreated\"\n| extend UserScope = strcat(ActorUPN, \"-\", ProjectName)\n| where UserScope !in (releaseusers)\n| extend ActorUPN = tolower(ActorUPN)\n| project-away Id, ActivityId, ActorCUID, ScopeId, ProjectId, TenantId, SourceSystem, UserScope\n// See if any of these users have Azure AD alerts associated with them in the same timeframe\n| join kind = leftouter (\nSecurityAlert\n| where TimeGenerated between(starttime..endtime)\n| where ProviderName == \"IPC\"\n| extend AadUserId = tostring(parse_json(Entities)[0].AadUserId)\n| summarize Alerts=count() by AadUserId) on $left.ActorUserId == $right.AadUserId\n| project-reorder TimeGenerated, ProjectName, Details, ActorUPN, IpAddress, UserAgent, Alerts\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'An attacker could look to create a new poisoned pipeline in Azure DevOps and attack a build process to it. This hunting query looks for new pipelines being created in projects where the creating user has not been seen creating a pipeline before. This query could have a significant false positive rate and records should be triaged to determine if a user creating a pipeline is authorized and expected.'\n", "techniques": ["T1053"], "tactics": ["Persistence", "Execution", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/ADOVariableCreatedDeleted.yaml", "query_name": "Azure DevOps - Variable Created and Deleted", "query": "AzureDevOpsAuditing\n| where OperationName =~ \"Library.VariableGroupModified\"\n| extend variables = Data.Variables\n| extend VariableGroupName = tostring(Data.VariableGroupName)\n| join (AzureDevOpsAuditing\n| where OperationName =~ \"Library.VariableGroupModified\"\n| extend variables = Data.Variables\n| extend VariableGroupName = tostring(Data.VariableGroupName)) on VariableGroupName\n| extend len = array_length(bag_keys(variables))\n| extend len1 = array_length(bag_keys(variables1))\n| where (TimeGenerated < TimeGenerated1 and len > len1) or (TimeGenerated1 > TimeGenerated and len1 < len)\n| project-away len, len1\n| extend VariablesRemoved = set_difference(bag_keys(variables), bag_keys(variables1)) \n| project-rename TimeCreated=TimeGenerated, TimeDeleted = TimeGenerated1, CreatingUser = ActorUPN, DeletingUser = ActorUPN1, CreatingIP = IpAddress, DeletingIP = IpAddress1, CreatingUA = UserAgent, DeletingUA = UserAgent1\n| project-reorder VariableGroupName, TimeCreated, TimeDeleted, VariablesRemoved, CreatingUser, CreatingIP, CreatingUA, DeletingUser, DeletingIP, DeletingUA\n| extend timestamp = TimeDeleted, AccountCustomEntity = DeletingUser, IPCustomEntity = DeletingIP\n", "attributes": {"description": "'Variables can be used at various stages of a pipeline to inject static variables. Depending on the build process these variables could be added by an attacker to get a build process to conduct an unwanted action such as communicating with an attacker-controlled endpoint or injecting values into code. This query looks for variables that are added and then deleted in a short space of time. This is not normal expected behavior and could ben an indicator of attacker creating elements and then covering tracks. If this hunting query produces only a small number of events in an environment it could be promoted to a detection.'\n", "techniques": ["T1578"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/AzDODisplayNameSwapping.yaml", "query_name": "Azure DevOps Display Name Changes", "query": "\nAzureDevOpsAuditing\n| where ActorCUID != '00000000-0000-0000-0000-000000000000' and ActorDisplayName != \"Azure DevOps User\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), DisplayNameCount = dcount(ActorDisplayName), ActorDisplayNames = make_set(ActorDisplayName), make_set(IpAddress), make_set(ProjectName) by ActorCUID, ActorUPN\n| where DisplayNameCount > 1\n| extend timestamp = StartTime, AccountCustomEntity = ActorUPN", "attributes": {"description": "'Shows all users with more than 1 display name in recent history.  This is to hunt for users maliciously changing their display name as a masquerading technique'\n", "techniques": ["T1098", "T1036"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/AzDOPrPolicyBypassers.yaml", "query_name": "Azure DevOps Pull Request Policy Bypassing", "query": "\nAzureDevOpsAuditing\n| where OperationName == 'Git.RefUpdatePoliciesBypassed'\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress", "attributes": {"description": "'Looks for users bypassing Update Policies in repos'\n", "techniques": ["T1098"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Guest%20users%20access%20enabled.yaml", "query_name": "Azure DevOps- Guest users access enabled", "query": "AzureDevOpsAuditing\n| where OperationName ==\"OrganizationPolicy.PolicyValueUpdated\"\n| where Data.PolicyName == \"Policy.DisallowAadGuestUserAccess\"\n| where Data.PolicyValue == \"OFF\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This hunting query identifies Azure DevOps activities where organization Guest Access policy is enabled by the admin'\n", "techniques": ["T1098", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Project%20visibility%20changed%20to%20public.yaml", "query_name": "Azure DevOps- Project visibility changed to public", "query": "AzureDevOpsAuditing\n| where Area == \"Project\"\n| where OperationName == \"Project.UpdateVisibilityCompleted\"\n| where Data.PreviousProjectVisibility == \"private\"\n| where Data.ProjectVisibility == \"public\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This hunting query identifies Azure DevOps activities where organization project visibility changed to public project'\n", "techniques": ["T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Public%20project%20created.yaml", "query_name": "Azure DevOps- Public project created", "query": "AzureDevOpsAuditing\n| where Data.ProjectVisibility == \"Public\"\n| where OperationName == \"Project.CreateCompleted\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This hunting query identifies Azure DevOps activities where a public project is created'\n", "techniques": ["T1098", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDevOpsAuditing/Public%20Projects%20enabled.yaml", "query_name": "Azure DevOps- Public project enabled by admin", "query": "AzureDevOpsAuditing\n| where OperationName == \"OrganizationPolicy.PolicyValueUpdated\"\n| where Data.PolicyName == \"Policy.AllowAnonymousAccess\"\n| where Data.PolicyValue == \"ON\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This hunting query identifies Azure DevOps activities where organization public projects policy enabled by the admin'\n", "techniques": ["T1098", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/AzureKeyVaultAccessManipulation.yaml", "query_name": "Azure Key Vault Access Policy Manipulation", "query": "\nAzureDiagnostics\n| where ResourceType == \"VAULTS\"\n| where OperationName == \"VaultPatch\"\n| where ResultType == \"Success\"\n| extend UserObjectAdded = addedAccessPolicy_ObjectId_g\n| extend AddedActor = identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_name_s\n| extend KeyAccessAdded = tostring(addedAccessPolicy_Permissions_keys_s)\n| extend SecretAccessAdded = tostring(addedAccessPolicy_Permissions_secrets_s)\n| extend CertAccessAdded = tostring(addedAccessPolicy_Permissions_certificates_s)\n| where isnotempty(UserObjectAdded)\n| project AccessAddedTime=TimeGenerated, ResourceType, OperationName, ResultType, KeyVaultName=id_s, AddedActor, UserObjectAdded, KeyAccessAdded, SecretAccessAdded, CertAccessAdded\n| join kind=inner \n( \nAzureDiagnostics\n| where ResourceType == \"VAULTS\"\n| where OperationName == \"VaultPatch\"\n| where ResultType == \"Success\"\n| extend RemovedActor = identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_name_s\n| extend UserObjectRemoved = removedAccessPolicy_ObjectId_g\n| extend KeyAccessRemoved = tostring(removedAccessPolicy_Permissions_keys_s)\n| extend SecretAccessRemoved = tostring(removedAccessPolicy_Permissions_secrets_s)\n| extend CertAccessRemoved = tostring(removedAccessPolicy_Permissions_certificates_s)\n| where isnotempty(UserObjectRemoved)\n| project AccessRemovedTime=TimeGenerated, ResourceType, OperationName, ResultType, KeyVaultName=id_s, RemovedActor, UserObjectRemoved, KeyAccessRemoved, SecretAccessRemoved, CertAccessRemoved\n)\non KeyVaultName\n| extend TimeDelta = abs(AccessAddedTime - AccessRemovedTime)\n| where TimeDelta < timeframe\n| project KeyVaultName, AccessAddedTime, AddedActor, UserObjectAdded, KeyAccessAdded, SecretAccessAdded, CertAccessAdded, AccessRemovedTime, RemovedActor, UserObjectRemoved, KeyAccessRemoved, SecretAccessRemoved, CertAccessRemoved, TimeDelta\n| extend timestamp = AccessAddedTime, AccountCustomEntity = UserObjectAdded\n", "attributes": {"description": "'Identifies when a user is added and then removed to an Azure Key Vault access policy within a short time period. \nThis may be a sign of credential access and persistence.'\n", "techniques": ["T1555"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/CriticalPortsOpened.yaml", "query_name": "Check critical ports opened to the entire internet", "query": "\n//Check critical ports opened to the entire internet\nAzureDiagnostics\n| where Category == \"NetworkSecurityGroupEvent\" \n| where direction_s == \"In\" \n| where conditions_destinationPortRange_s in (\n\"22\",\"22-22\"          //SSH\n,\"3389\",\"3389-3389\"   //RDP\n,\"137\",\"137-137\"      //NetBIOS\n,\"138\",\"138-138\"      //NetBIOS\n,\"139\",\"139-139\"      //SMB\n,\"53\",\"53-53\"         //DNS\n,\"3020\",\"3020-3020\"   //CIFS\n,\"3306\",\"3306-3306\"   //MySQL\n,\"1521\",\"1521-1521\"   //Oracle Database\n,\"2483\",\"2483-2483\"   //Oracle Database\n,\"5432\",\"5432-5432\"   //PostgreSQL\n,\"389\",\"389-389\"      //LDAP\n,\"27017\",\"27017-27017\"//MongoDB\n,\"20\",\"20-20\"         //FTP\n,\"21\",\"21-21\"         //FTP\n,\"445\",\"445-445\"      //Active Directory\n,\"161\",\"161-161\"      //SNMP\n,\"25\",\"25-25\"         //SMTP\n)\n or (conditions_destinationPortRange_s == \"0-65535\" and conditions_sourcePortRange_s == \"0-65535\")\n| where priority_d < 65000    //Not to check the Azure defaults\n| where conditions_sourceIP_s == \"0.0.0.0/0,0.0.0.0/0\" or conditions_sourceIP_s == \"0.0.0.0/0\" //With rules Any/Any\n| where type_s !~ \"block\"\n| order by TimeGenerated desc\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by OperationName, systemId_g, vnetResourceGuid_g, subnetPrefix_s, macAddress_s, primaryIPv4Address_s, ruleName_s, direction_s, priority_d, type_s, conditions_destinationIP_s, conditions_destinationPortRange_s, conditions_sourceIP_s, conditions_sourcePortRange_s, ResourceId\n| extend timestamp = StartTime\n", "attributes": {"description": "'Discover all critical ports from a list having rules like 'Any' for sourceIp, which means that they are opened to everyone. Critial ports should not be opened to everyone, and should be filtered.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/SpringShellExploitationAttempt.yaml", "query_name": "Possible SpringShell Exploitation Attempt (CVE-2022-22965)", "query": "let spring4shellstring = dynamic([\"class.module.classLoader.resources.context.parent.pipeline.first.pattern=\"]);\nAzureDiagnostics\n| where Category in (\"FrontdoorWebApplicationFirewallLog\", \"FrontdoorAccessLog\", \"ApplicationGatewayFirewallLog\", \"ApplicationGatewayAccessLog\")\n| extend originalRequestUriWithArgs_s = column_ifexists(\"originalRequestUriWithArgs_s\", \"\"), \n   userAgent_s = column_ifexists(\"userAgent_s\", \"\"), \n   clientIP_s = column_ifexists(\"clientIP_s\", \"\"),  \n   clientPort_d = column_ifexists(\"originalRequestUriWithArgs_s\", \"\"),\n   host_s = column_ifexists(\"host_s\", \"\"),\n   requestUri_s = column_ifexists(\"requestUri_s\", \"\"),\n   httpStatus_d = column_ifexists(\"httpStatus_d\",\"\"),\n   listenerName_s = column_ifexists(\"listenerName_s\", \"\"),\n   httpMethod_s = column_ifexists(\"httpMethod_s\", \"\")\n| where httpMethod_s =~ 'POST'\n| where originalRequestUriWithArgs_s has_any (spring4shellstring) or requestUri_s has_any (spring4shellstring)\n| summarize Total = count() by originalRequestUriWithArgs_s, userAgent_s, clientIP_s,clientPort_d, TimeGenerated, host_s, requestUri_s, httpStatus_d,listenerName_s, httpMethod_s, Category\n| extend IPCustomEntity = clientIP_s, timestamp = TimeGenerated, UrlCustomEntity = requestUri_s, HostCustomEntity = host_s\n", "attributes": {"description": "'This hunting query looks in Azure Web Application Firewall data to find possible SpringShell Exploitation Attempt (CVE-2022-22965).\n The Spring Framework is one of the most widely used lightweight open-source framework for Java. To exploit the vulnerability attackers can  \n send a specially crafted query to a web server running the Spring Core framework to change the target of logging facility and create a new \n malicious JSP file in a location accessible by http requests. Attackers then make requests to the malicious backdoor to run system commands.\n Reference: https://www.microsoft.com/security/blog/2022/04/04/springshell-rce-vulnerability-guidance-for-protecting-against-and-detecting-cve-2022-22965/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureDiagnostics/SpringshellWebshellUsage.yaml", "query_name": "Possible Webshell usage attempt related to SpringShell(CVE-2022-22965)", "query": "let spring4shellstring = dynamic([\".jsp?pwd=\", \".jsp?cmd=\"]);\nAzureDiagnostics\n| where Category in (\"FrontdoorWebApplicationFirewallLog\", \"FrontdoorAccessLog\", \"ApplicationGatewayFirewallLog\", \"ApplicationGatewayAccessLog\")\n| extend originalRequestUriWithArgs_s = column_ifexists(\"originalRequestUriWithArgs_s\", \"\"), \n   userAgent_s = column_ifexists(\"userAgent_s\", \"\"), \n   clientIP_s = column_ifexists(\"clientIP_s\", \"\"),  \n   clientPort_d = column_ifexists(\"originalRequestUriWithArgs_s\", \"\"),\n   host_s = column_ifexists(\"host_s\", \"\"),\n   requestUri_s = column_ifexists(\"requestUri_s\", \"\"),\n   httpStatus_d = column_ifexists(\"httpStatus_d\",\"\"),\n   listenerName_s = column_ifexists(\"listenerName_s\", \"\"),\n   httpMethod_s = column_ifexists(\"httpMethod_s\", \"\")\n| where httpMethod_s =~ 'GET'\n| where originalRequestUriWithArgs_s has_any (spring4shellstring) or requestUri_s has_any (spring4shellstring)\n| summarize Total = count() by originalRequestUriWithArgs_s, userAgent_s, clientIP_s,clientPort_d, TimeGenerated, host_s, requestUri_s, httpStatus_d,listenerName_s, httpMethod_s, Category\n| extend IPCustomEntity = clientIP_s, timestamp = TimeGenerated, UrlCustomEntity = requestUri_s, HostCustomEntity = host_s\n", "attributes": {"description": "'This hunting query looks in Azure Web Application Firewall data to find possible Webshell usage attempts related to SpringShell RCE vulnerability (CVE-2022-22965).\n The Spring Framework is one of the most widely used lightweight open-source framework for Java. The vulnerability in Spring Core can be exploited when an attacker \n sends a specially crafted query to a web server running the Spring Core framework to create a backdoor shell.\n Reference: https://www.microsoft.com/security/blog/2022/04/04/springshell-rce-vulnerability-guidance-for-protecting-against-and-detecting-cve-2022-22965/'\n", "techniques": ["T1059.007"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureStorage/AzureStorageFileCreateAccessDelete.yaml", "query_name": "Azure Storage File Create, Access, Delete", "query": "\nlet threshold = 5m;\n//Union the file and blob data\nlet StorageData = \nunion\nStorageFileLogs,\nStorageBlobLogs;\n//Get file and blob uploads\nStorageData\n//File upload operations \n| where StatusText =~ \"Success\" \n| where OperationName =~ \"PutBlob\" or OperationName =~ \"PutRange\"\n//Parse the URI to remove the parameters as they change per request \n| extend Uri = tostring(split(Uri, \"?\", 0)[0])\n//Join with deletions, this will return 0 rows if there was no deletion \n| join (\n    StorageData        \n    //File deletion operations     \n    | where OperationName =~ \"DeleteBlob\" or OperationName =~ \"DeleteFile\"     \n    | extend Uri = tostring(split(Uri, \"?\", 0)[0])     \n    | project OperationName, DeletedTime=TimeGenerated, Uri, CallerIpAddress, UserAgentHeader\n    ) on Uri \n| project UploadedTime=TimeGenerated, DeletedTime, OperationName, OperationName1, Uri, UploaderAccountName=AccountName, UploaderIP=CallerIpAddress, UploaderUA=UserAgentHeader, DeletionIP=CallerIpAddress1, DeletionUA=UserAgentHeader1, ResponseMd5\n//Collect file access events where the file was only accessed by a single IP, a single downloader \n| join (\n    StorageData \n    |where Category =~ \"StorageRead\" \n    //File download events \n    | where OperationName =~ \"GetBlob\" or OperationName =~ \"GetFile\"\n    //Again, parse the URI to remove the parameters as they change per request \n    | extend Uri = tostring(split(Uri, \"?\", 0)[0])\n    //Parse the caller IP as it contains the port \n    | extend CallerIpAddress = tostring(split(CallerIpAddress, \":\", 0)[0])\n    //Summarise the download events by the URI, we are only looking for instances where a single caller IP downloaded the file,\n    //so we can safely use any() on the IP. \n    | summarize Downloads=count(), DownloadTimeStart=max(TimeGenerated), DownloadTimeEnd=min(TimeGenerated), DownloadIP=any(CallerIpAddress), DownloadUserAgents=make_set(UserAgentHeader), dcount(CallerIpAddress) by Uri \n    | where dcount_CallerIpAddress == 1\n    ) on Uri \n| project UploadedTime, DeletedTime, OperationName, OperationName1, Uri, UploaderAccountName, UploaderIP, UploaderUA, DownloadTimeStart, DownloadTimeEnd, DownloadIP, DownloadUserAgents, DeletionIP, DeletionUA, ResponseMd5\n| extend timestamp = UploadedTime\n", "attributes": {"description": "'This hunting query will identify where a file is uploaded to Azure File or Blob storage\nand is then accessed once before being deleted. This activity may be indicative of\nexfiltration activity.'\n", "techniques": ["T1537"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureStorage/AzureStorageFileCreatedQuicklyDeleted.yaml", "query_name": "Azure Storage File Create and Delete", "query": "\nlet threshold = 5m;\nlet StorageData =\nunion\nStorageFileLogs,\nStorageBlobLogs;\nStorageData\n| where StatusText =~ \"Success\"\n| where OperationName =~ \"PutBlob\" or OperationName =~ \"PutRange\"\n| extend Uri = tostring(split(Uri, \"?\", 0)[0])\n| join (\n    StorageData\n    | where StatusText =~ \"Success\"\n    | where OperationName =~ \"DeleteBlob\" or OperationName =~ \"DeleteFile\"\n    | extend Uri = tostring(split(Uri, \"?\", 0)[0])\n    | project OperationName, DeletedTime=TimeGenerated, Uri\n) on Uri\n| project TimeGenerated, DeletedTime, Uri, CallerIpAddress, UserAgentHeader, ResponseMd5, StorageAccount=AccountName\n| extend windowEnd = TimeGenerated+5m \n| where DeletedTime between (TimeGenerated .. windowEnd)\n", "attributes": {"description": "'This hunting query will try to identify instances where a file us uploaded to file storage and then deleted\nwithin a given threshold. By default the query will find instances where a file is uploaded and deleted within\n5 minutes. This hunting query will help detect automated exfiltration.'\n", "techniques": ["T1020", "T1537"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureStorage/AzureStorageFileOnEndpoint.yaml", "query_name": "Storage File Seen on Endpoint", "query": "\nunion StorageFileLogs,\nStorageBlobLogs\n//File upload operations\n| where OperationName =~ \"PutBlob\" or OperationName =~ \"PutRange\"\n//Parse out the uploader IP\n| extend ClientIP = tostring(split(CallerIpAddress, \":\", 0)[0])\n//Extract the filename from the Uri\n| extend FileName = extract(@\"\\/([\\w\\-. ]+)\\?\", 1, Uri)\n//Base64 decode the MD5 filehash, we will encounter non-ascii hex so string operations don't work\n//We can work around this by making it an array then converting it to hex from an int\n| extend base64Char = base64_decode_toarray(ResponseMd5)\n| mv-expand base64Char\n| extend hexChar = tohex(toint(base64Char))\n| extend hexChar = iff(strlen(hexChar) < 2, strcat(\"0\", hexChar), hexChar)\n| extend SourceTable = iff(OperationName has \"range\", \"StorageFileLogs\", \"StorageBlobLogs\")\n| summarize make_list(hexChar) by CorrelationId, ResponseMd5, FileName, AccountName, TimeGenerated, RequestBodySize, ClientIP, SourceTable\n| extend Md5Hash = strcat_array(list_hexChar, \"\")\n| project-away list_hexChar, ResponseMd5\n| join (\n  DeviceFileEvents\n  | where ActionType =~ \"FileCreated\"\n  | where isnotempty(MD5)\n  | extend p = pack(\"FileCreateTime\", TimeGenerated, \"Device\", DeviceName, \"DeviceId\", DeviceId, \"FileName\", FileName, \"InititatingProcess\", InitiatingProcessFileName)\n  | summarize make_bag(p), dcount(DeviceName) by MD5\n) on $left.Md5Hash == $right.MD5\n| project TimeGenerated, FileName, FileHashCustomEntity=Md5Hash, AccountName, SourceTable, DevicesImpacted=dcount_DeviceName, Entitites=bag_p\n", "attributes": {"description": "'Finds instances where a file uploaded to blob or file storage and it is seen on an endpoint by Microsoft 365 Defender.'\n", "techniques": ["T1570"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureStorage/AzureStorageMassDeletion.yaml", "query_name": "Azure Storage Mass File Deletion", "query": "\nlet deleteThreshold = 3;\nlet deleteWindow = 10m;\nunion\nStorageFileLogs,\nStorageBlobLogs\n| where StatusText =~ \"Success\"\n| where OperationName =~ \"DeleteBlob\" or OperationName =~ \"DeleteFile\"\n| extend CallerIpAddress = tostring(split(CallerIpAddress, \":\", 0)[0])\n| summarize dcount(Uri) by bin(TimeGenerated, deleteWindow), CallerIpAddress, UserAgentHeader, AccountName\n| where dcount_Uri >= deleteThreshold\n| project TimeGenerated, IPCustomEntity=CallerIpAddress, UserAgentHeader, FilesDeleted=dcount_Uri, AccountName\n", "attributes": {"description": "'Detect mass file deletion events within Azure File and Blob storage. deleteWindow controls\nthe period of time the deletions must occur in, whilst the deleteThreshold controls how many files\nmust be deleted within that threshold. Query works on a per-IP address basis, so will only detect a single\nIP deleting multiple files.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureStorage/AzureStorageUploadFromVPS.yaml", "query_name": "Azure Storage file upload from VPS Providers", "query": "\nlet IP_Data = (externaldata(network:string)\n[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/VPS_Networks.csv\"] with (format=\"csv\"));\nunion\nStorageFileLogs,\nStorageBlobLogs\n//File upload operations\n| where StatusText =~ \"Success\"\n| where OperationName =~ \"PutBlob\" or OperationName =~ \"PutRange\"\n| evaluate ipv4_lookup(IP_Data, CallerIpAddress, network, return_unmatched = false)\n| summarize make_set(OperationName), min(TimeGenerated), max(TimeGenerated) by IPCustomEntity=CallerIpAddress, URLCustomEntity=Uri  \n", "attributes": {"description": "'Looks for file uploads actions to Azure File and Blob Storage from known VPS provider network ranges.\nThis is not an exhaustive list of VPS provider ranges but covers some of the most prevalent providers observed.'\n", "techniques": ["T1570"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/AzureStorage/AzureStorageUploadLinkAccount.yaml", "query_name": "User Account Linked to Storage Account File Upload", "query": "\n//Period of time to look back in signin logs\nlet lookback = 1m;\nlet TargetFile = \"mimikatz.exe\"; //Example\nunion\nStorageFileLogs,\nStorageBlobLogs\n//Collect file uploads\n| where StatusText =~ \"Success\"\n| where OperationName =~ \"PutBlob\" or OperationName =~ \"PutRange\"\n| extend FileName = extract(@\"\\/([\\w\\-. ]+)\\?\", 1, Uri)\n//Uncomment below to enable file specific matching\n//| where FileName =~ TargetFile\n//Caller IP has the port appended, remove it\n| extend CallerIpAddress = tostring(split(CallerIpAddress, \":\", 0)[0])\n| extend FileUploadTime = TimeGenerated\n| extend WindowStart = FileUploadTime - lookback\n| join (\n    SigninLogs\n    | project AzureLoginTime=TimeGenerated, UserPrincipalName, IPAddress, LoginUserAgent=UserAgent\n) on $left.CallerIpAddress == $right.IPAddress\n//Look back in the signinlogs for the most recent login\n| where AzureLoginTime between (WindowStart .. FileUploadTime)\n| project AccountUsed=UserPrincipalName, AzureLoginTime, OperationName, FileUploadPath=Uri, CallerIpAddress, LoginUserAgent, UploadUserAgent=UserAgentHeader\n//Optional user agent check\n| where LoginUserAgent =~ UploadUserAgent\n//Pack and summarise the matching login events by the upload event\n| extend p = pack(\"AccountUsed\", AccountUsed, \"IPUsed\", CallerIpAddress, \"AzureLoginTime\", AzureLoginTime, \"UserAgent\", LoginUserAgent)\n| summarize LoginEvents=make_bag(p) by FileUploadPath, OperationName, UploadUserAgent\n", "attributes": {"description": "'This hunting query will try to identify the user account used to perform a file upload to blob storage.\nThis query can be used to match all file upload events, or filtering can be applied on filename to search for a specific upload.'\n", "techniques": ["T1528"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/AbnormallyLargeJPEGFiledDownloadedfromNewSource.yaml", "query_name": "Abnormally Large JPEG Filed Downloaded from New Source", "query": "let percentile = 95;\n  let lookback_data = materialize(CommonSecurityLog\n  | where TimeGenerated between(ago(7d)..ago(1d))\n  | where FileType == \"Jpeg Files\" or RequestURL endswith \".jpg\"\n  | where isnotempty(RequestURL));\n  let domains = lookback_data | summarize by DestinationHostName;\n  CommonSecurityLog\n  | where TimeGenerated > ago(1d)\n  | where FileType =~ \"Jpeg Files\" or RequestURL endswith \".jpg\"\n  | where isnotempty(RequestURL)\n  | extend filename = split(RequestURL, \"/\")[-1]\n  | where ReceivedBytes > toscalar(lookback_data\n  | summarize percentile(ReceivedBytes, percentile))\n  | project-reorder TimeGenerated, filename, RequestURL, ReceivedBytes, RequestClientApplication, SourceUserName, DestinationHostName, RequestContext \n  | where DestinationHostName !in (domains) or isempty(DestinationHostName)\n", "attributes": {"description": "'Threat actors can use JPEG files to hide malware, or other malicious code from inspection. This query looks for the downloading of abnormally large JPEG files from a source where large JPEG files have not been downloaded.\n  Ref: https://www.microsoft.com/security/blog/2022/07/27/untangling-knotweed-european-private-sector-offensive-actor-using-0-day-exploits/'\n", "techniques": ["T1001.002"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/B64IPInURL.yaml", "query_name": "Base64 encoded IPv4 address in request url", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet ipv4_plaintext_extraction_regex = @\"((?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.)){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]){1,3})\";\nlet ipv4_encoded_identification_regex = @\"\\=([a-zA-Z0-9\\/\\+]*(?:(?:MC|Au|wL|MS|Eu|xL|Mi|Iu|yL|My|Mu|zL|NC|Qu|0L|NS|Uu|1L|Ni|Yu|2L|Ny|cu|3L|OC|gu|4L|OS|ku|5L){1}[a-zA-Z0-9\\/\\+]{2,4}){3}[a-zA-Z0-9\\/\\+\\=]*)\";\nlet ipv4_decoded_hex_extract = @\"((?:(?:61|62|63|64|65|66|67|68|69|6a|6b|6c|6d|6e|6f|70|71|72|73|74|75|76|77|78|79|7a|41|42|43|44|45|46|47|48|49|4a|4b|4c|4d|4e|4f|50|51|52|53|54|55|56|57|58|59|5a|2f|2b|3d),){7,15})\";\nCommonSecurityLog\n| where TimeGenerated between(starttime .. endtime)\n| where isnotempty(RequestURL)\n// Identify requests with encoded IPv4 addresses\n| where RequestURL matches regex ipv4_encoded_identification_regex\n| project TimeGenerated, RequestURL\n// Extract IP candidates in their base64 encoded format, significantly reducing the dataset\n| extend extracted_encoded_ip_candidate = extract_all(ipv4_encoded_identification_regex, RequestURL)\n// We could have more than one candidate, expand them out\n| mv-expand extracted_encoded_ip_candidate to typeof(string)\n| summarize Start=min(TimeGenerated), End=max(TimeGenerated), make_set(RequestURL) by extracted_encoded_ip_candidate\n// Pad if we need to\n| extend extracted_encoded_ip_candidate = iff(strlen(extracted_encoded_ip_candidate) % 2 == 0, extracted_encoded_ip_candidate, strcat(extracted_encoded_ip_candidate, \"=\"))\n// Now decode the candidate to a long array, we cannot go straight to string as it cannot handle non-UTF8, we need to strip that first\n| extend extracted_encoded_ip_candidate = tostring(base64_decode_toarray(extracted_encoded_ip_candidate))\n// Extract the IP candidates from the array\n| extend hex_extracted = extract_all(ipv4_decoded_hex_extract, extracted_encoded_ip_candidate)\n// Expand, it's still possible that we might have more than 1 IP\n| mv-expand hex_extracted\n// Now we should have a clean string. We need to put it back into a dynamic array to convert back to a string.\n| extend hex_extracted = trim_end(\",\", tostring(hex_extracted))\n| extend hex_extracted = strcat(\"[\",hex_extracted,\"]\")\n| extend hex_extracted = todynamic(hex_extracted)\n| extend extracted_encoded_ip_candidate = todynamic(extracted_encoded_ip_candidate)\n// Convert the array back into a string\n| extend decoded_ip_candidate = make_string(hex_extracted)\n| summarize by decoded_ip_candidate, tostring(set_RequestURL), Start, End\n// Now the IP candidates will be in plaintext, extract the IPs using a regex\n| extend ipmatch = extract_all(ipv4_plaintext_extraction_regex, decoded_ip_candidate)\n// If it's not an IP, throw it out\n| where isnotnull(ipmatch)\n| mv-expand ipmatch to typeof(string)\n| extend timestamp = Start, IPCustomEntity = ipmatch\n", "attributes": {"description": "'This hunting query will detect when a Base64 IPv4 address is seen in a outbound request URL. This query uses pre-computed base64 offsets for IPv4 sequences allowing detection\nof an IPv4 address under base64 without the need to decode. After identifying a candidate this query will decode the base64 into an array of longs where a regex will extract\nthe ip candidate into plaintext. Finally the query will extract the plaintext IPv4 address pattern from the IP candidate.'\n", "techniques": ["T1071.001"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/CommonSecurityLog/RiskyCommandB64EncodedInUrl.yaml", "query_name": "Risky base64 encoded command in URL", "query": "let mapping = datatable (CommandFound:string, match_list:dynamic) [\n\"whoami\", dynamic(['d2hvYW1p', 'dob2Fta', '3aG9hbW']),\n\"net share\", dynamic(['bmV0IHNoYXJl', '5ldCBzaGFyZ', 'uZXQgc2hhcm']),\n\"net use\", dynamic(['bmV0IHVzZ', '5ldCB1c2', 'uZXQgdXNl']),\n\"net view\", dynamic(['bmV0IHZpZX', '5ldCB2aWV3', 'uZXQgdmlld']),\n\"ipconfig\", dynamic(['aXBjb25maWc', 'lwY29uZmln', 'pcGNvbmZpZ']),\n\"net sh\", dynamic(['bmV0c2gg', '5ldHNoI', 'uZXRzaC']),\n\"schtasks\", dynamic(['2NodGFza3', 'NjaHRhc2tz', 'zY2h0YXNrc']),\n\"Invoke- \", dynamic(['SW52b2tlL', 'ludm9rZS', 'JbnZva2Ut']),\n];\nlet riskyCommandRegex = @\"(d2hvYW1p|dob2Fta|3aG9hbW|bmV0IHNoYXJl|5ldCBzaGFyZ|uZXQgc2hhcm|bmV0IHVzZ|5ldCB1c2|uZXQgdXNl|bmV0IHZpZX|5ldCB2aWV3|uZXQgdmlld|aXBjb25maWc|lwY29uZmln|pcGNvbmZpZ|bmV0c2gg|5ldHNoI|uZXRzaC|2NodGFza3|NjaHRhc2tz|zY2h0YXNrc|SW52b2tlL|ludm9rZS|JbnZva2Ut)\";\nCommonSecurityLog\n| where TimeGenerated > ago(3d)\n| where RequestURL matches regex riskyCommandRegex\n| extend B64MatchData = extract_all(riskyCommandRegex, RequestURL)\n| where isnotempty(B64MatchData)\n| mv-expand B64MatchData to typeof(string)\n| join kind=leftouter ( \n    mapping\n    | mv-expand match_list to typeof(string)\n) on $left.B64MatchData == $right.match_list\n| project TimeGenerated, B64MatchData, CommandFound, RequestURL, RequestMethod, DestinationHostName, DestinationIP, SourceIP, DeviceVendor, DeviceProduct, Activity\n| extend timestamp = TimeGenerated, DomainCustomEntity = DestinationHostName, IPCustomEntity = DestinationIP\n", "attributes": {"description": "'This hunting query will detect risky base64 encoded commands are seen in web requests. Some threat actors transmit base64 commands from the target host\nback to the C2 servers so they know which command has been executed. This query also reguarly illumniates base64 encoded webshells being injected.\nThe limitation of this query is that base64 is case sensitive, so different case versions of each command need generating for full coverage. This query\ncomputes base64 permutations for each command, resulting in 3 possible permutations depending on padding.'\n", "techniques": ["T1071.001"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/First%20Time%20User%20Invite%20and%20Add%20Member%20to%20Org.yaml", "query_name": "GitHub First Time Invite Member and Add Member to Repo", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet LearningPeriod = 7d;\nlet EndLearningTime = starttime - LearningPeriod;\nlet GitHubOrgMemberLogs = (GitHubAudit\n| where Action == \"org.invite_member\" or Action == \"org.update_member\" or Action == \"org.add_member\" or Action == \"repo.add_member\" or Action == \"team.add_member\");\nGitHubOrgMemberLogs\n| where TimeGenerated between (EndLearningTime..starttime)\n| distinct Actor\n| join kind=rightanti (\n  GitHubOrgMemberLogs\n  | where TimeGenerated between (starttime..endtime)\n  | distinct Actor\n) on Actor\n", "attributes": {"description": "'This hunting query identifies a user that add/invite a member to the organization for the first time. This technique can be leveraged by attackers to add stealth account access to the organization.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Inactive%20or%20New%20Account%20Usage.yaml", "query_name": "GitHub Inactive or New Account Access or Usage", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet LearningPeriod = 7d;\nlet EndLearningTime = starttime - LearningPeriod;\nlet GitHubActorLogin = (GitHubAudit\n| where Actor != \"\");\nlet GitHubUser = (GitHubAudit\n| where ImpactedUser != \"\");\nlet GitHubNewActorLogin = (GitHubActorLogin\n| where TimeGenerated between (EndLearningTime .. starttime)\n| summarize makeset(Actor)\n| extend Dummy = 1\n| join kind=innerunique (\n  GitHubActorLogin\n  | where TimeGenerated between (starttime .. endtime)\n  | distinct Actor\n  | extend Dummy = 1\n) on Dummy\n| project-away Dummy\n| where set_Actor  !contains Actor);\nlet GitHubNewUser = ( GitHubUser\n| where TimeGenerated between (EndLearningTime .. starttime)\n| summarize makeset(ImpactedUser)\n| extend Dummy = 1\n| join kind=innerunique (\n  GitHubUser\n  | where TimeGenerated between (startime .. endtime)\n  | distinct ImpactedUser\n  | extend Dummy = 1\n) on Dummy\n| project-away Dummy\n| where set_ImpactedUser !contains ImpactedUser);\nunion GitHubNewActorLogin, GitHubNewUser\n", "attributes": {"description": "'This hunting query identifies Accounts that are new or inactive and have accessed or used GitHub that may be a sign of compromise.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Mass%20Deletion%20of%20Repositories%20.yaml", "query_name": "GitHub Mass Deletion of repos or projects", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet LearningPeriod = 7d;\nlet EndLearningTime = starttime - LearningPeriod;\nlet NumberOfStds = 3;\nlet MinThreshold = 10.0;\nlet GitHubRepositoryDestroyEvents = (GitHubAudit\n| where Action == \"repo.destroy\");\nGitHubRepositoryDestroyEvents\n| where TimeGenerated between (EndLearningTime .. starttime)\n| summarize count() by bin(TimeGenerated, BinTime)\n| summarize AvgInLearning = avg(count_), StdInLearning = stdev(count_)\n| extend LearningThreshold = max_of(AvgInLearning + StdInLearning * NumberOfStds, MinThreshold)\n| extend Dummy = 1\n| join kind=innerunique (\n  GitHubRepositoryDestroyEvents\n  | where TimeGenerated between (starttime..endtime)\n  | summarize CountInRunTime = count() by bin(TimeGenerated, BinTime)\n  | extend Dummy = 1\n) on Dummy\n| project-away Dummy\n| where CountInRunTime > LearningThreshold\n", "attributes": {"description": "'This hunting query identifies GitHub activites where there are a large number of deletions that may be a sign of compromise.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Oauth%20App%20Restrictions%20Disabled.yaml", "query_name": "GitHub OAuth App Restrictions Disabled", "query": "\nGitHubAudit\n| where Action == \"org.disable_oauth_app_restrictions\"\n| project TimeGenerated, Action, Actor, Country\n", "attributes": {"description": "'This hunting query identifies GitHub OAuth Apps that have restrictions disabled that may be a sign of compromise. Attacker will want to disable such security tools in order to go undetected. '\n", "techniques": ["T1505", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Org%20Repositories%20Default%20Permissions%20Change.yaml", "query_name": "GitHub Update Permissions", "query": "\nGitHubAudit\n| where Action == \"org.update_default_repository_permission\"\n| project TimeGenerated, Action, Actor, Country, Repository, PreviousPermission, CurrentPermission\n", "attributes": {"description": "'This hunting query identifies GitHub activites where permissions are updated that may be a sign of compromise.'\n", "techniques": ["T1098", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Repository%20Permission%20Switched%20to%20Public.yaml", "query_name": "GitHub Repo switched from private to public", "query": "\nGitHubAudit\n| where Action == \"repo.access\"\n| where OperationType == \"MODIFY\"\n| where Visibility == \"PUBLIC\" \n| project TimeGenerated, Action, Actor, Country, Repository, Visibility\n", "attributes": {"description": "'This hunting query identifies GitHub activites where a repo was changed from private to public that may be a sign of compromise.'\n", "techniques": ["T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Suspicious%20Fork%20Activity.yaml", "query_name": "GitHub OAuth App Restrictions Disabled", "query": "\nlet CollaboratorsUserToRepoMapping = (\nGitHubRepo\n| where Action == \"Collaborators\"\n| distinct Repository , Actor, Organization);\nlet UserCommitsInRepoMapping = (\nGitHubRepo\n| where Action == \"Commits\"\n| distinct  Repository ,Actor, Organization);\nunion CollaboratorsUserToRepoMapping, UserCommitsInRepoMapping\n| summarize ContributedToRepos = make_set(Repository) by Actor, Organization\n| join kind=innerunique (\nGitHubRepo\n| where Action == \"Forks\"\n| distinct Repository , Actor, Organization\n) on Actor, Organization\n| project-away Actor1, Organization1\n| where ContributedToRepos !contains Repository\n", "attributes": {"description": "'This hunting query identifies a fork activity against a repository done by a user who is not the owner of the repo nor a contributes.'\n", "techniques": ["T1537"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/Unusual%20Number%20of%20Repository%20Clones.yaml", "query_name": "GitHub Repo Clone - Time Series Anomly", "query": "\nlet min_t = toscalar(GitHubRepo\n| summarize min(timestamp_t));\nlet max_t = toscalar(GitHubRepo\n| summarize max(timestamp_t));\nGitHubRepo\n| where Action == \"Clones\"\n| distinct TimeGenerated, Repository, Count\n| make-series num=sum(tolong(Count)) default=0 on TimeGenerated in range(min_t, max_t, 1h) by Repository \n| extend (anomalies, score, baseline) = series_decompose_anomalies(num, 1.5, -1, 'linefit')\n| render timechart \n", "attributes": {"description": "'Attacker can exfiltrate data from you GitHub repository after gaining access to it by performing clone action. This hunting queries allows you to track the clones activities for each of your repositories. The visualization allow you to quickly identify anomalies/excessive clone, to further investigate repo access & permissions'\n", "techniques": ["T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/User%20First%20Time%20Repository%20Delete%20Activity.yaml", "query_name": "GitHub First Time Repo Delete", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet LearningPeriod = 7d;\nlet EndLearningTime = starttime - LearningPeriod;\nlet GitHubRepositoryDestroyEvents = (GitHubAudit\n| where Action == \"repo.destroy\");\nGitHubRepositoryDestroyEvents\n| where TimeGenerated between (EndLearningTime .. starttime)\n| distinct Actor\n| join kind=rightanti (\n  GitHubRepositoryDestroyEvents\n  | where TimeGenerated between (starttime .. endtime)\n  | distinct Actor\n) on Actor\n", "attributes": {"description": "'This hunting query identifies GitHub activites its the first time a user deleted a repo that may be a sign of compromise.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/GitHub/User%20Grant%20Access%20and%20Grants%20Other%20Access.yaml", "query_name": "GitHub User Grants Access and Other User Grants Access", "query": "\nGitHubAudit\n| where ImpactedUser != \"\"\n| where Action == \"org.invite_member\" or Action == \"org.add_member\" or Action == \"team.add_member\" or Action == \"repo.add_member\"\n| distinct ImpactedUser, TimeGenerated, Actor\n| project-rename firstUserAdded = ImpactedUser, firstEventTime = TimeGenerated, firstAdderUser = Actor\n| join kind= innerunique (\n  GitHubAudit\n  | where ImpactedUser != \"\"\n  | where Action == \"org.invite_member\" or Action == \"org.add_member\" or Action == \"team.add_member\" or Action == \"repo.add_member\"\n  | distinct ImpactedUser, TimeGenerated, Actor\n  | project-rename secondUserAdded = ImpactedUser, secondEventTime = TimeGenerated, secondAdderUser = Actor\n) on $right.secondAdderUser == $left.firstUserAdded\n| where secondEventTime between (firstEventTime .. (firstEventTime + 1h))\n", "attributes": {"description": "'This hunting query identifies Accounts in GitHub that have granted access to another account which then grants access to yet another account that may be a sign of compromise.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/CrossServiceADXQueries.yaml", "query_name": "Cross-service Azure Data Explorer queries", "query": "let StringToSearch = @\"\\badx\\s*\\(\";\nlet ExtractQueriedClusterAddress = @\"([^\\w]|^)adx\\s*\\(([^\\)]*)\\)\";\nLAQueryLogs\n| where QueryText matches regex StringToSearch\n| extend QueriedClusterAddress = extract_all(ExtractQueriedClusterAddress, dynamic([2]), QueryText)\n| mv-expand QueriedClusterAddress to typeof(string)\n| where isnotempty(QueriedClusterAddress)\n| project TimeGenerated, AADEmail, QueriedClusterAddress, ResponseCode, QueryText, RequestTarget\n", "attributes": {"description": "'Under specific circumstances, executing KQL queries can exfiltrate information like access tokens, regarding external data functions like adx().\nThis query tries to list executed KQL queries that used the adx() function and where an access token might have been exposed to.\nRef: https://docs.microsoft.com/azure/azure-monitor/logs/azure-monitor-data-explorer-proxy\nRef: https://securecloud.blog/2022/04/27/azure-monitor-malicious-kql-query/'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/CrossWorkspaceQueryAnomolies.yaml", "query_name": "Cross workspace query anomolies", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 30d;\nlet threshold = 0;\nLAQueryLogs\n| where TimeGenerated between (lookback..starttime)\n| mv-expand(RequestContext)\n| extend RequestContextExtended = split(RequestTarget, \"/\")\n| extend Subscription = tostring(RequestContextExtended[2]), ResourceGroups = tostring(RequestContextExtended[4]), Workspace = tostring(RequestContextExtended[8])\n| summarize count(), HistWorkspaceCount=dcount(Workspace) by AADEmail\n| join (\nLAQueryLogs\n| where TimeGenerated between(starttime..endtime)\n| mv-expand(RequestContext)\n| extend RequestContextExtended = split(RequestTarget, \"/\")\n| extend Subscription = tostring(RequestContextExtended[2]), ResourceGroups = tostring(RequestContextExtended[4]), Workspace = tostring(RequestContextExtended[8])\n| summarize make_set(Workspace), count(), CurrWorkspaceCount=dcount(Workspace) by AADEmail\n) on AADEmail\n| where CurrWorkspaceCount > HistWorkspaceCount\n// Uncomment follow rows to see queries made by these users\n//| join (\n//LAQueryLogs\n//| where TimeGenerated between(starttime..endtime)\n//on AADEmail\n//| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail", "attributes": {"description": "'This hunting query looks for increases in the number of workspaces queried by a user.'\n", "techniques": ["T1530", "T1213", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/MultipleLargeQueriesByUser.yaml", "query_name": "Multiple large queries made by user", "query": "\nlet UI_apps = dynamic(['ASI_Portal','AzureMonitorLogsConnector','AppAnalytics']);\nlet threshold = 3;\nLAQueryLogs\n| where (ResponseRowCount == 10001 and RequestClientApp in(UI_apps)) or (ResponseRowCount > 10001 and RequestClientApp !in(UI_apps))\n| summarize count() by AADEmail\n| where count_ > threshold\n| join kind=rightsemi (\nLAQueryLogs\n| where (ResponseRowCount == 10001 and RequestClientApp in(UI_apps)) or (ResponseRowCount > 10001 and RequestClientApp !in(UI_apps)))\non AADEmail\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail\n", "attributes": {"description": "'This hunting query looks for users who are running multiple queries that return either a very large\namount of data or the maximum amount allowed by the query method.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/NewClientRunningQueries.yaml", "query_name": "New client running queries", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nLAQueryLogs\n| where TimeGenerated between (ago(lookback)..starttime)\n| where ResponseCode == 200\n| join kind= rightanti(\nLAQueryLogs\n| where TimeGenerated between(starttime..endtime)\n)\non RequestClientApp\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail", "attributes": {"description": "'This hunting query looks for clients running queries that have not previously been seen running queries.'\n", "techniques": ["T1530", "T1213", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/NewServicePrincipalRunningQueries.yaml", "query_name": "New ServicePrincipal running queries", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nLAQueryLogs\n| where TimeGenerated between (ago(lookback)..starttime)\n| where ResponseCode == 200 and RequestClientApp != \"AppAnalytics\" and AADEmail !contains \"@\"\n| distinct AADClientId\n| join kind=rightanti(\nLAQueryLogs\n| where TimeGenerated between(starttime..endtime)\n| where ResponseCode == 200 and RequestClientApp != \"AppAnalytics\" and AADEmail !contains \"@\"\n)\non AADClientId\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail", "attributes": {"description": "'This hunting query looks for new Service Principals running queries that have not previously been seen running queries.'\n", "techniques": ["T1530", "T1213", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/NewUserCallingSensitiveWatchlist.yaml", "query_name": "New users calling sensitive Watchlist", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nLAQueryLogs\n| where TimeGenerated between(lookback..starttime)\n| where QueryText has_any ('_GetWatchlist(\"VIPUsers\")', \"_GetWatchlist('VIPUsers')\", '_GetWatchlist(\"ServiceAccounts\")', \"_GetWatchlist('ServiceAccounts')\",'_GetWatchlist(\"HighValueAssets\")', \"_GetWatchlist('HighValueAssets')\")\n| summarize by AADEmail\n| join kind = rightanti (LAQueryLogs\n| where TimeGenerated between(starttime..endtime)\n| where QueryText has_any ('_GetWatchlist(\"VIPUsers\")', \"_GetWatchlist('VIPUsers')\", '_GetWatchlist(\"ServiceAccounts\")', \"_GetWatchlist('ServiceAccounts')\",'_GetWatchlist(\"HighValueAssets\")', \"_GetWatchlist('HighValueAssets')\"))\non AADEmail\n| project TimeGenerated, AADEmail, QueryText, RequestClientApp, RequestTarget\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail\n", "attributes": {"description": "'This hunting query looks for users who have run queries calling a watchlist template relating to sensitive data that have not previously been seen calling these watchlists.'\n", "techniques": ["T1530", "T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/NewUserRunningQueries.yaml", "query_name": "New users running queries", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nLAQueryLogs\n| where TimeGenerated between(startofday(ago(lookback))..starttime)\n| summarize by AADEmail\n| join kind = rightanti (LAQueryLogs\n| where TimeGenerated between(starttime..endtime))\non AADEmail\n| project TimeGenerated, AADEmail, QueryText, RequestClientApp, RequestTarget\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail\n", "attributes": {"description": "'This hunting query looks for users who have run queries that have not previously been seen running queries.'\n", "techniques": ["T1530", "T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/QueryDataVolumeAnomolies.yaml", "query_name": "Query data volume anomolies", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet delta = totimespan((endtime-starttime)*7);\nlet lookback = starttime - delta;\nlet threshold = 0;\nLAQueryLogs\n| where TimeGenerated between(starttime..endtime)\n| make-series rows = sum(ResponseRowCount) on TimeGenerated in range(lookback, endtime, 1h)\n| extend (anomalies, score, baseline) = series_decompose_anomalies(rows,3, -1, 'linefit')\n| mv-expand anomalies to typeof(int), score to typeof(double), TimeGenerated to typeof(datetime)\n| where anomalies > threshold\n| sort by score desc\n| join kind=rightsemi (\nLAQueryLogs\n| where TimeGenerated between(starttime..endtime)\n| summarize make_set(QueryText) by AADEmail, RequestTarget, TimeGenerated = bin(TimeGenerated, 1h))\non TimeGenerated\n| project TimeGenerated, AADEmail, RequestTarget, set_QueryText\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail\n", "attributes": {"description": "'This hunting query looks for anomalously large LA queries by users.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/QueryLookingForSecrets.yaml", "query_name": "Query looking for secrets", "query": "\n// Extend this list with items to search for\nlet keywords = dynamic([\"password\", \"pwd\", \"creds\", \"credentials\", \"secret\"]);\n// To exclude key phrases or tables to exclude add to these lists\nlet table_exclusions = dynamic([\"AuditLogs\",\"SigninLogs\", \"LAQueryLogs\", \"SecurityEvent\"]);\nlet keyword_exclusion = dynamic([\"reset user password\", \"change user password\"]);\nLAQueryLogs\n| where RequestClientApp != 'Sentinel-General'\n| extend querytext_lower = tolower(QueryText)\n| where querytext_lower has_any(keywords)\n| project TimeGenerated, AADEmail, QueryText, RequestClientApp, RequestTarget, ResponseCode, ResponseRowCount, ResponseDurationMs, CorrelationId\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail\n| join kind=leftanti ( LAQueryLogs\n| where RequestClientApp != 'Sentinel-General'\n| extend querytext_lower = tolower(QueryText)\n| where QueryText has_any(table_exclusions) or querytext_lower has_any(keyword_exclusion))\non CorrelationId\n", "attributes": {"description": "'This hunting query looks for queries that appear to be looking for secrets or passwords in tables.'\n", "techniques": ["T1530", "T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/UserReturningMoreDataThanDailyAverage.yaml", "query_name": "User returning more data than daily average", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nlet threshold = 10;\nlet baseline = 10000;\nlet diff = 5;\nlet anomolous_users = (\nLAQueryLogs\n| where TimeGenerated between(startofday(ago(lookback))..starttime)\n| summarize score=sum(ResponseRowCount) by AADEmail\n| join kind = fullouter (LAQueryLogs\n| where TimeGenerated between(starttime..endtime)\n| summarize score_now=sum(ResponseRowCount) by AADEmail)\non AADEmail\n| extend hist_score = iif((score/29)*threshold > baseline, (score/29)*threshold, baseline)\n| where isnotempty(score)\n| where score_now > hist_score*diff\n| project AADEmail);\nLAQueryLogs\n| where TimeGenerated between(starttime..endtime)\n| where AADEmail in(anomolous_users)\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail\n// Comment out the line below to see the queries run by users.\n| summarize total_rows = sum(ResponseRowCount), NoQueries = count(), AvgQuerySize = sum(ResponseRowCount)/count() by AADEmail\n", "attributes": {"description": "'This hunting query looks for users whose total returned data that is significantly above their average.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/LAQueryLogs/UserRunningMultipleQueriesThatFail.yaml", "query_name": "User running multiple queries that fail", "query": "\nlet timeframe = 1h;\nlet threshold = 10;\nLAQueryLogs\n| where ResponseCode != 200\n| summarize count() by AADEmail, bin(TimeGenerated, timeframe)\n| where count_ > threshold\n| join kind=rightsemi (\nLAQueryLogs\n| summarize make_set(QueryText) by AADEmail, bin(TimeGenerated, timeframe))\non AADEmail, TimeGenerated\n| extend timestamp = TimeGenerated, AccountCustomEntity = AADEmail\n", "attributes": {"description": "'This hunting query looks for users who have multiple failed queries in a short space of time.'\n", "techniques": ["T1020"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Abuse.ch%20Recent%20Threat%20Feed%20%281%29.yaml", "query_name": "Abuse.ch Recent Threat Feed (1)", "query": "let MaxAge = ago(1d);\nlet AbuseFeed = toscalar (\n    (externaldata(report:string)\n    [@\"https://bazaar.abuse.ch/export/txt/sha256/recent/\"]\n    with (format = \"txt\"))\n    | where report !startswith '#'\n    | summarize make_set(report)\n);\nunion (\n    DeviceProcessEvents\n    | where Timestamp > MaxAge and SHA256 in (AbuseFeed)\n), (\n    DeviceFileEvents\n    | where Timestamp > MaxAge and SHA256 in (AbuseFeed)\n), ( \n    DeviceImageLoadEvents\n    | where Timestamp > MaxAge and SHA256 in (AbuseFeed)\n)\n", "attributes": {"description": "This query will hunt for files matching the current abuse.ch recent threat feed based on Sha256. Currently the query is set up to analyze the last day worth of events, but this is configurable using the MaxAge variable.\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Privilege escalation", "Credential Access", "Discovery", "Impact", "Exploit", "Malware, component", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Abuse.ch%20Recent%20Threat%20Feed.yaml", "query_name": "Abuse.ch Recent Threat Feed", "query": "let MaxAge = ago(1d);\nlet AbuseFeed = materialize (\n    (externaldata(report:string)\n    [@\"https://bazaar.abuse.ch/export/csv/recent/\"]\n    with (format = \"txt\"))\n    | where report !startswith '#'\n    | extend report = parse_csv(report)\n    | extend FirstSeenUtc = tostring(report[0])\n    | project FirstSeenUtc = todatetime(FirstSeenUtc)\n        ,SHA256 = trim('[ \"]+',tostring(report[1]))\n        , MD5 = trim('[ \"]+',tostring(report[2]))\n        , SHA1 = trim('[ \"]+',tostring(report[3]))\n        , Reporter = trim('[ \"]+',tostring(report[4]))\n        , FileName = trim('[ \"]+',tostring(report[5]))\n        , FileType = trim('[ \"]+',tostring(report[6]))\n        , MimeType = trim('[ \"]+',tostring(report[7]))\n        , Signer = iff(report[8] == 'n/a', '', trim('[ \"]+',tostring(report[8])))\n        , ClamAV = iff(report[9] == 'n/a', '', trim('[ \"]+',tostring(report[9])))\n        , VTPercent = iff(report[10] == 'n/a', 0.0, todouble(report[10]))\n        , ImpHash = iff(report[11] == 'n/a', '', trim('[ \"]+',tostring(report[11])))\n        , SSDeep = iff(report[12] == 'n/a', '', trim('[ \"]+',tostring(report[12])))\n        , TLSH = iff(report[13] == 'n/a', '', trim('[ \"]+',tostring(report[13])))\n);\nunion (\n    AbuseFeed\n    | join (\n        DeviceProcessEvents\n        | where Timestamp > MaxAge\n    ) on SHA256\n), (\n    AbuseFeed\n    | join (\n        DeviceFileEvents\n        | where Timestamp > MaxAge\n    ) on SHA256\n), ( \n    AbuseFeed\n    | join (\n        DeviceImageLoadEvents\n        | where Timestamp > MaxAge\n    ) on SHA256\n)\n", "attributes": {"description": "This query will hunt for files matching the current abuse.ch recent threat feed based on Sha256. Currently the query is set up to analyze the last day worth of events, but this is configurable using the MaxAge variable.\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Privilege escalation", "Credential Access", "Discovery", "Impact", "Exploit", "Malware, component", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Abusing%20settingcontent-ms.yaml", "query_name": "Abusing settingcontent-ms", "query": "DeviceFileEvents\n| where InitiatingProcessFileName in~ (\"browser_broker.exe\", \"chrome.exe\", \"iexplore.exe\", \"firefox.exe\", \"outlook.exe\")\n| where FileName endswith \".settingcontent-ms\"\n// The FileOrigin* columns are available only on Edge and Chrome and from Windows 10 version 1703\n// https://techcommunity.microsoft.com/t5/Threat-Intelligence/Hunting-tip-of-the-month-Browser-downloads/td-p/220454\n| project Timestamp, DeviceName, FileName, FolderPath, FileOriginUrl, FileOriginReferrerUrl, FileOriginIP\n", "attributes": {"description": "Sample query that search for .settingcontent-ms that has been downloaded from the web.\nThrough Microsoft Edge, Internet Explorer, Google Chrome, Mozilla Firefox, Microsoft Outlook.\nFor questions @MiladMSFT on Twitter or milad.aslaner@microsoft.com.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/APT%20Baby%20Shark.yaml", "query_name": "APT Baby Shark", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where ProcessCommandLine =~ @\"reg query \"\"HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Default\"\"\" \n     or ProcessCommandLine startswith \"powershell.exe mshta.exe http\"\n     or ProcessCommandLine =~ \"cmd.exe /c taskkill /im cmd.exe\"\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_babyshark.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/apt%20sofacy%20zebrocy.yaml", "query_name": "apt sofacy zebrocy", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where ProcessCommandLine endswith \"cmd.exe /c SYSTEMINFO & TASKLIST\"\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_sofacy_zebrocy.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/apt%20sofacy.yaml", "query_name": "apt sofacy", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where ProcessCommandLine matches regex @'rundll32\\.exe %APPDATA%.*\\.dat\",'\n     or ProcessCommandLine matches regex @'rundll32\\.exe %APPDATA%.*\\.dll\",#1'\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_sofacy.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/apt%20ta17%20293a%20ps.yaml", "query_name": "apt ta17 293a ps", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where ProcessCommandLine =~ \"ps.exe -accepteula\"\n| top 100 by Timestamp desc \n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_ta17_293a_ps.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/apt%20tropictrooper.yaml", "query_name": "apt tropictrooper", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where ProcessCommandLine contains \"abCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCc\"\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_tropictrooper.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/apt%20unidentified%20nov%2018%20%281%29.yaml", "query_name": "apt unidentified nov 18 (1)", "query": "DeviceFileEvents  \n| where Timestamp  > ago(7d)\n| where FolderPath has \"ds7002.lnk\"\n| top 100 by Timestamp desc \n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_unidentified_nov_18.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/apt%20unidentified%20nov%2018.yaml", "query_name": "apt unidentified nov 18", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where ProcessCommandLine endswith \"cyzfc.dat, PointFunctionCall\" \n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_unidentified_nov_18.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/APT29%20thinktanks.yaml", "query_name": "APT29 thinktanks", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where ProcessCommandLine has \"-noni -ep bypass $\"\n| top 100 by Timestamp desc \n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_apt29_thinktanks.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bear%20Activity%20GTR%202019.yaml", "query_name": "Bear Activity GTR 2019", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d) \n| where (FileName =~ \"xcopy.exe\" and ProcessCommandLine has @\" /S /E /C /Q /H \\\") \n     or (FileName =~ \"adexplorer.exe\" and ProcessCommandLine has @\" -snapshot \"\"\"\" c:\\users\\\")\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_bear_activity_gtr19.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/c2-lookup-from-nonbrowser%5BNobelium%5D%20%281%29.yaml", "query_name": "c2-lookup-from-nonbrowser[Nobelium] (1)", "query": "IdentityQueryEvents\n| where ActionType == \"DNS query\"\n| where QueryTarget has \"appsync-api\" or QueryTarget has \"avsvmcloud.com\"\n| project Timestamp, QueryTarget, DeviceName ,IPAddress,ReportId\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query detects events when Nobelium received a DNS response after launching a lookup request to known command-and-control infrastructure.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/c2-lookup-from-nonbrowser%5BNobelium%5D.yaml", "query_name": "c2-lookup-from-nonbrowser[Nobelium]", "query": "DeviceEvents\n| where ActionType == \"DnsQueryResponse\" //DNS Query Response\nand AdditionalFields has \".avsvmcloud\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query detects events when Nobelium received a DNS response after launching a lookup request to known command-and-control infrastructure.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/c2-lookup-response%5BNobelium%5D%20%281%29.yaml", "query_name": "c2-lookup-response[Nobelium] (1)", "query": "IdentityQueryEvents\n| where ActionType == \"DNS query\"\n| where QueryTarget has \"appsync-api\" or QueryTarget has \"avsvmcloud.com\"\n| project Timestamp, QueryTarget, DeviceName, IPAddress, ReportId\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query detects events when Nobelium received a DNS response after launching a lookup request to known command-and-control infrastructure.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/c2-lookup-response%5BNobelium%5D.yaml", "query_name": "c2-lookup-response[Nobelium]", "query": "DeviceEvents\n| where ActionType == \"DnsQueryResponse\" //DNS Query Response\nand AdditionalFields has \".avsvmcloud\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query detects events when Nobelium received a DNS response after launching a lookup request to known command-and-control infrastructure.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Cloud%20Hopper.yaml", "query_name": "Cloud Hopper", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where FileName =~ @\"cscript.exe\" and ProcessCommandLine has \".vbs /shell \"\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_cloudhopper.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/cobalt-strike-invoked-w-wmi.yaml", "query_name": "cobalt-strike-invoked-w-wmi", "query": "// Find use of Base64 encoded PowerShell\n// Indicating possible Cobalt Strike\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n// Only WMI-initiated instances, remove to broaden scope\n| where InitiatingProcessFileName =~ 'wmiprvse.exe'\n| where FileName =~ 'powershell.exe'\n and (ProcessCommandLine hasprefix '-e' or\n ProcessCommandLine contains 'frombase64')\n// Check for Base64 with regex\n| where ProcessCommandLine matches regex '[A-Za-z0-9+/]{50,}[=]{0,2}'\n// Exclusions: The above regex may trigger false positive on legitimate SCCM activities.\n// Remove this exclusion to search more broadly.\n| where ProcessCommandLine !has 'Windows\\\\CCM\\\\'\n| project DeviceId, Timestamp, InitiatingProcessId,\nInitiatingProcessFileName, ProcessId, FileName, ProcessCommandLine\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ryuk ransomware. There is also a related blog.\nRyuk is human-operated ransomware. Much like DoppelPaymer ransomware, Ryuk is spread manually, often on networks that are already infected with Trickbot.\nDuring the earliest stages of a Ryuk infection, an operator downloads Cobalt Strike, a penetration testing kit that is also used by malicious actors. Cobalt Strike is used by Ryuk operators to explore the network before deploying the Ryuk payload. This malicious behavior is often obscured by Base64 encoding and other tricks.\nThe following query detects possible invocation of Cobalt Strike using Windows Management Instrumentation (WMI).\nThe See also section below lists links to other queries associated with Ryuk ransomware.\nReferences:\nhttps://www.microsoft.com/security/blog/2020/03/05/human-operated-ransomware-attacks-a-preventable-disaster/\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Ransom:Win32/Ryuk&threatId=-2147232689\nhttps://www.microsoft.com/security/blog/2020/03/05/human-operated-ransomware-attacks-a-preventable-disaster/\nhttps://www.cobaltstrike.com/\nhttps://docs.microsoft.com/windows/win32/wmisdk/wmi-start-page\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/compromised%20nvidia%20certificates%5BLapsus%24%5D.yaml", "query_name": "compromised NVIDIA certificates[Lapsus$]", "query": "DeviceFileCertificateInfo\n| where CertificateSerialNumber == \"43BB437D609866286DD839E1D00309F5\" or CertificateSerialNumber == \"14781bc862e8dc503a559346f5dcc518\"\n| join DeviceFileEvents on SHA1\n| distinct DeviceName, FileName, FolderPath, SHA1, SHA256, IsTrusted, IsRootSignerMicrosoft, SignerHash\n //| distinct DeviceName\n //| distinct FileName\n //| summarize mylist = make_list(FileName) by DeviceName\n", "attributes": {"description": "Search for the files that are using a compromised certificate associated with the Lapsus$ group.\nYou can remove the comments to:\n1. get the list of devices where there is at least one file signed with the certificate\n2. get the list of files signed with the certificate\n3. get the list of files signed with the certificate group by Devices\n", "techniques": NaN, "tactics": ["Privilege escalation", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/compromised-certificate%5BNobelium%5D.yaml", "query_name": "compromised-certificate[Nobelium]", "query": "DeviceFileCertificateInfo\n| where Signer == 'Solarwinds Worldwide, LLC' and SignerHash == '47d92d49e6f7f296260da1af355f941eb25360c4'\n| join DeviceFileEvents on SHA1\n| distinct DeviceName, FileName, FolderPath, SHA1, SHA256, IsTrusted, IsRootSignerMicrosoft, SignerHash\n//| distinct DeviceName\n//| distinct FileName\n//| summarize mylist = make_list(FileName) by DeviceName\n", "attributes": {"description": "Search for the files that are using a compromised certificate associated with the Nobelium campaign.\nYou can remove the comments to:\n1. get the list of devices where there is at least one file signed with the certificate\n2. get the list of files signed with the certificate\n3. get the list of files signed with the certificate group by Devices\n", "techniques": NaN, "tactics": ["Privilege escalation", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/confluence-weblogic-targeted.yaml", "query_name": "confluence-weblogic-targeted", "query": "DeviceProcessEvents\n| where Timestamp >= ago(7d)\n| where \n// \"Grandparent\" process is Oracle WebLogic or some process loading Confluence\nInitiatingProcessParentFileName == \"beasvc.exe\" or \nInitiatingProcessFileName == \"beasvc.exe\" \nor InitiatingProcessCommandLine contains \"//confluence\"\n// Calculate for Base64 in Commandline\n| extend Caps = countof(ProcessCommandLine, \"[A-Z]\", \"regex\"), \nTotal = countof(ProcessCommandLine, \".\", \"regex\")\n| extend Ratio = todouble(Caps) / todouble(Total) \n| where\n(\n    FileName in~ (\"powershell.exe\" , \"powershell_ise.exe\") // PowerShell is spawned\n    // Omit known clean processes\n    and ProcessCommandLine !startswith \"POWERSHELL.EXE  -C \\\"GET-WMIOBJECT -COMPUTERNAME\"\n    and ProcessCommandLine !contains \"ApplicationNo\"\n    and ProcessCommandLine !contains \"CustomerGroup\"\n    and ProcessCommandLine !contains \"Cosmos\"\n    and ProcessCommandLine !contains \"Unrestricted\"\n    and\n    (\n        ProcessCommandLine contains \"$\" // PowerShell variable declaration\n        or ProcessCommandLine contains \"-e \" // Alias for \"-EncodedCommand\" parameter\n        or ProcessCommandLine contains \"encodedcommand\"\n        or ProcessCommandLine contains \"wget\"\n        //or ( Ratio > 0.4 and Ratio < 1.0) // Presence of Base64 strings\n    )\n)\nor\n(\n    FileName =~ \"cmd.exe\" // cmd.exe is spawned\n    and ProcessCommandLine contains \"@echo\" and \n    ProcessCommandLine contains \">\" // Echoing commands into a file\n)\nor\n(\n    FileName =~ \"certutil.exe\" // CertUtil.exe abuse\n    and ProcessCommandLine contains \"-split\" \n    // the \"-split\" parameter is required to write files to the disk\n)\n| project\n       Timestamp,\n       InitiatingProcessCreationTime ,\n       DeviceId ,\n       Grandparent_PID = InitiatingProcessParentId,\n       Grandparent = InitiatingProcessParentFileName,\n       Parent_Account = InitiatingProcessAccountName,\n       Parent_PID = InitiatingProcessId,\n       Parent = InitiatingProcessFileName ,\n       Parent_Commandline = InitiatingProcessCommandLine,\n       Child_PID = ProcessId,\n       Child = FileName ,\n       Child_Commandline = ProcessCommandLine\n", "attributes": {"description": "This query was originally published in the threat analytics report, Confluence and WebLogic abuse.\n2019 has seen several seemingly related campaigns targeting Atlassian Confluence Server and Oracle WebLogic Server. Although these campaigns use different implants and delivery methods, they consistently use the same infrastructure, and exploit the same vulnerabilities.\nThe campaigns have specifically targeted:\n1. CVE-2019-3396 - Software update\n2. CVE-2019-2725 - Software update\nThe following query detects activity broadly associated with these campaigns.\n", "techniques": NaN, "tactics": ["Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/cypherpunk-exclusive-commands.yaml", "query_name": "cypherpunk-exclusive-commands", "query": "// Searches for possible Cypherpunk ransomware activity\nDeviceProcessEvents\n| where InitiatingProcessParentFileName startswith \"psexe\"\n| where ProcessCommandLine has \"Dvr /go\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Cypherpunk ransomware leaves wake of tampered AVs.\nCypherpunk is a human-operated ransomware campaign named after the unusual .cypherpunk extension given to encrypted files.\nThe query below surfaces commands that follow the distinctive pattern Cypherpunk operators would use to remotely execute code.\n", "techniques": NaN, "tactics": ["Execution", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/cypherpunk-remote-exec-w-psexesvc.yaml", "query_name": "cypherpunk-remote-exec-w-psexesvc", "query": "// Searches for remote batch file launch using PSEXESVC.exe\nDeviceProcessEvents\n| where InitiatingProcessParentFileName startswith \"psexe\"\n| where InitiatingProcessCommandLine has \".bat\"\n| where ProcessCommandLine has \"DisableIOAVProtection\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Cypherpunk ransomware leaves wake of tampered AVs.\nCypherpunk is a human-operated ransomware campaign named after the unusual .cypherpunk extension given to encrypted files. The attackers often used PSEXESVC, a service that helps the PsExe.exe utility run commands on a remote device. Both PSEXESVC and PsExe.exe are legitimate parts of Windows; however, they can be repurposed by attackers to perform malicious actions.\nThe query below can find instances of PSEXESVC being used to launch batch files, as often occurred in Cypherpunk attacks.\n", "techniques": NaN, "tactics": ["Execution", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/detect-cyzfc-activity%20%281%29.yaml", "query_name": "detect-cyzfc-activity (1)", "query": "// Query 2: C2 connection\nDeviceNetworkEvents\n| where Timestamp > ago(10d)\n| where RemoteUrl == \"pandorasong.com\"\n", "attributes": {"description": "These queries was originally published in the threat analytics report, Attacks on gov't, think tanks, NGOs.\nAs described further in Analysis of cyberattack on U.S. think tanks, non-profits, public sector by unidentified attackers, there was a very large spear-phishing campaign launched in November 2019.\nThe attackers would gain access to a target by having the user click on a link to a compromised website and download a .zip archive.\nOnce established on a target's device, the attackers used a malicious DLL named cyzfc.dat to execute additional payloads. They would call a function in the malicious DLL via the legitimate Windows process, rundll32.exe, to connect directly to their command-and-control (C2) servers.\nThe following queries detect activity associated with the malicious DLL, cyzfc.dat., used in this campaign.\nReference - https://docs.microsoft.com/windows-server/administration/windows-commands/rundll32\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/detect-cyzfc-activity%20%282%29.yaml", "query_name": "detect-cyzfc-activity (2)", "query": "// Query 3: Malicious PowerShell\nDeviceProcessEvents\n| where Timestamp > ago(10d)\n| where ProcessCommandLine contains\n\"-noni -ep bypass $zk='JHB0Z3Q9MHgwMDA1ZTJiZTskdmNxPTB4MDAwNjIzYjY7JHRiPSJ\"\n", "attributes": {"description": "These queries was originally published in the threat analytics report, Attacks on gov't, think tanks, NGOs.\nAs described further in Analysis of cyberattack on U.S. think tanks, non-profits, public sector by unidentified attackers, there was a very large spear-phishing campaign launched in November 2019.\nThe attackers would gain access to a target by having the user click on a link to a compromised website and download a .zip archive.\nOnce established on a target's device, the attackers used a malicious DLL named cyzfc.dat to execute additional payloads. They would call a function in the malicious DLL via the legitimate Windows process, rundll32.exe, to connect directly to their command-and-control (C2) servers.\nThe following queries detect activity associated with the malicious DLL, cyzfc.dat., used in this campaign.\nReference - https://docs.microsoft.com/windows-server/administration/windows-commands/rundll32\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/detect-cyzfc-activity%20%283%29.yaml", "query_name": "detect-cyzfc-activity (3)", "query": "// Query 4: Malicious domain in default browser commandline\nDeviceProcessEvents\n| where Timestamp > ago(10d)\n| where ProcessCommandLine contains\n\"https://www.jmj.com/personal/nauerthn_state_gov\"\n", "attributes": {"description": "These queries was originally published in the threat analytics report, Attacks on gov't, think tanks, NGOs.\nAs described further in Analysis of cyberattack on U.S. think tanks, non-profits, public sector by unidentified attackers, there was a very large spear-phishing campaign launched in November 2019.\nThe attackers would gain access to a target by having the user click on a link to a compromised website and download a .zip archive.\nOnce established on a target's device, the attackers used a malicious DLL named cyzfc.dat to execute additional payloads. They would call a function in the malicious DLL via the legitimate Windows process, rundll32.exe, to connect directly to their command-and-control (C2) servers.\nThe following queries detect activity associated with the malicious DLL, cyzfc.dat., used in this campaign.\nReference - https://docs.microsoft.com/windows-server/administration/windows-commands/rundll32\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/detect-cyzfc-activity%20%284%29.yaml", "query_name": "detect-cyzfc-activity (4)", "query": "// Query 5: Events involving the ZIP\nlet fileHash = \"cd92f19d3ad4ec50f6d19652af010fe07dca55e1\";\nfind in (DeviceFileEvents, DeviceProcessEvents, DeviceEvents,\nDeviceRegistryEvents, DeviceNetworkEvents, DeviceImageLoadEvents)\nwhere SHA1 == fileHash or InitiatingProcessSHA1 == fileHash\n| where Timestamp > ago(10d)\n", "attributes": {"description": "These queries was originally published in the threat analytics report, Attacks on gov't, think tanks, NGOs.\nAs described further in Analysis of cyberattack on U.S. think tanks, non-profits, public sector by unidentified attackers, there was a very large spear-phishing campaign launched in November 2019.\nThe attackers would gain access to a target by having the user click on a link to a compromised website and download a .zip archive.\nOnce established on a target's device, the attackers used a malicious DLL named cyzfc.dat to execute additional payloads. They would call a function in the malicious DLL via the legitimate Windows process, rundll32.exe, to connect directly to their command-and-control (C2) servers.\nThe following queries detect activity associated with the malicious DLL, cyzfc.dat., used in this campaign.\nReference - https://docs.microsoft.com/windows-server/administration/windows-commands/rundll32\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/detect-cyzfc-activity.yaml", "query_name": "detect-cyzfc-activity", "query": "// Query 1: Events involving the DLL container\nlet fileHash = \"9858d5cb2a6614be3c48e33911bf9f7978b441bf\";\nfind in (DeviceFileEvents, DeviceProcessEvents, DeviceEvents,\nDeviceRegistryEvents, DeviceNetworkEvents, DeviceImageLoadEvents)\nwhere SHA1 == fileHash or InitiatingProcessSHA1 == fileHash\n| where Timestamp > ago(10d)\n", "attributes": {"description": "These queries was originally published in the threat analytics report, Attacks on gov't, think tanks, NGOs.\nAs described further in Analysis of cyberattack on U.S. think tanks, non-profits, public sector by unidentified attackers, there was a very large spear-phishing campaign launched in November 2019.\nThe attackers would gain access to a target by having the user click on a link to a compromised website and download a .zip archive.\nOnce established on a target's device, the attackers used a malicious DLL named cyzfc.dat to execute additional payloads. They would call a function in the malicious DLL via the legitimate Windows process, rundll32.exe, to connect directly to their command-and-control (C2) servers.\nThe following queries detect activity associated with the malicious DLL, cyzfc.dat., used in this campaign.\nReference - https://docs.microsoft.com/windows-server/administration/windows-commands/rundll32\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/DofoilNameCoinServerTraffic.yaml", "query_name": "DofoilNameCoinServerTraffic", "query": "DeviceNetworkEvents \n| where RemoteIP in (\n    \"139.59.208.246\",\"130.255.73.90\",\"31.3.135.232\",\"52.174.55.168\",\"185.121.177.177\",\"185.121.177.53\",\n    \"62.113.203.55\",\"144.76.133.38\",\"169.239.202.202\",\"5.135.183.146\",\"142.0.68.13\",\"103.253.12.18\",\n    \"62.112.8.85\",\"69.164.196.21\",\"107.150.40.234\",\"162.211.64.20\",\"217.12.210.54\",\"89.18.27.34\",\n    \"193.183.98.154\",\"51.255.167.0\",\"91.121.155.13\",\"87.98.175.85\",\"185.97.7.7\")\n| project DeviceName, InitiatingProcessCreationTime, InitiatingProcessFileName, InitiatingProcessCommandLine, RemoteIP, RemotePort\n", "attributes": {"description": "This is a query to retrieve last 30 days network connections to known Dofoil NameCoin servers.\nThe full article is available here: https://cloudblogs.microsoft.com/microsoftsecure/2018/04/04/hunting-down-dofoil-with-windows-defender-atp.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Dopplepaymer%20In-Memory%20Malware%20Implant.yaml", "query_name": "Dopplepaymer In-Memory Malware Implant", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where ProcessCommandLine startswith \"-q -s {{\" and ProcessCommandLine contains \"}} -p \"\n", "attributes": {"description": "Dopplepaymer In-Memory Malware Implant.\nThis query identifies processes with command line launch strings.\nWhich match the pattern used in Dopplepaymer ransomware attacks.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Dragon%20Fly.yaml", "query_name": "Dragon Fly", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where FileName =~ \"crackmapexec.exe\"\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_dragonfly.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Elise%20backdoor.yaml", "query_name": "Elise backdoor", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where (FolderPath =~ @\"C:\\Windows\\SysWOW64\\cmd.exe\" and ProcessCommandLine has @\"\\Windows\\Caches\\NavShExt.dll\") \n     or (ProcessCommandLine endswith @\"\\AppData\\Roaming\\MICROS~1\\Windows\\Caches\\NavShExt.dll,Setting\")\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_elise.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Equation%20Group%20C2%20Communication.yaml", "query_name": "Equation Group C2 Communication", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where (FolderPath endswith @\"\\rundll32.exe\" and ProcessCommandLine endswith \",dll_u\") \n        or ProcessCommandLine has \" -export dll_u \"\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_equationgroup_c2.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/fireeye-red-team-tools-CVEs%20%5BNobelium%5D.yaml", "query_name": "fireeye-red-team-tools-CVEs [Nobelium]", "query": "let FireEyeCVE= dynamic(\n[\n\"CVE-2019-11510\", //pre-auth arbitrary file reading from Pulse Secure SSL VPNs - CVSS 10.0\n\"CVE-2020-1472\", //Microsoft Active Directory escalation of privileges - CVSS 10.0\n\"CVE-2018-13379\", //pre-auth arbitrary file reading from Fortinet Fortigate SSL VPN - CVSS 9.8 //no find CVE\n\"CVE-2018-15961\", //RCE via Adobe ColdFusion (arbitrary file upload that can be used to upload a JSP web shell) - CVSS 9.8\n\"CVE-2019-0604\", //RCE for Microsoft Sharepoint - CVSS 9.8\n\"CVE-2019-0708\", //RCE of Windows Remote Desktop Services (RDS) - CVSS 9.8\n\"CVE-2019-11580\", //Atlassian Crowd Remote Code Execution - CVSS 9.8\n\"CVE-2019-19781\", //RCE of Citrix Application Delivery Controller and Citrix Gateway - CVSS 9.8  //no find CVE\n\"CVE-2020-10189\", //RCE for ZoHo ManageEngine Desktop Central - CVSS 9.8\n\"CVE-2014-1812\", //Windows Local Privilege Escalation - CVSS 9.0\n\"CVE-2019-3398\", //Confluence Authenticated Remote Code Execution - CVSS 8.8\n\"CVE-2020-0688\", //Remote Command Execution in Microsoft Exchange - CVSS 8.8\n\"CVE-2016-0167\", //local privilege escalation on older versions of Microsoft Windows - CVSS 7.8\n\"CVE-2017-11774\", //RCE in Microsoft Outlook via crafted document execution (phishing) - CVSS 7.8\n\"CVE-2018-8581\", //Microsoft Exchange Server escalation of privileges - CVSS 7.4\n\"CVE-2019-8394\" //arbitrary pre-auth file upload to ZoHo ManageEngine ServiceDesk Plus - CVSS 6.5\n]\n);\nDeviceTvmSoftwareVulnerabilitiesKB\n| where CveId in(FireEyeCVE)\n| join DeviceTvmSoftwareVulnerabilities on CveId\n| project-away CveId1, VulnerabilitySeverityLevel1, AffectedSoftware\n", "attributes": {"description": "Search for the CVEs that should be prioritized and resolved to reduce the success of the FireEye Red Team tools compromised by the Nobelium activity group.\nSee red_team_tool_countermeasures on the official FireEye repo.\nReferences:\nhttps://github.com/fireeye/red_team_tool_countermeasures/blob/master/CVEs_red_team_tools.md\nhttps://github.com/fireeye\n", "techniques": NaN, "tactics": ["Privilege escalation", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/fireeye-red-team-tools-HASHs%20%5BNobelium%5D.yaml", "query_name": "fireeye-red-team-tools-HASHs [Nobelium]", "query": "let MD5Hash= dynamic(\n    [\n'013c7708f1343d684e3571453261b586',\n'01d68343ac46db6065f888a094edfe4f',\n'04eb45f8546e052fe348fda2425b058c',\n'05b99d438dac63a5a993cea37c036673',\n'09bdbad8358b04994e2c04bb26a160ef',\n'0a86d64c3b25aa45428e94b6e0be3e08',\n'0b1e512afe24c31531d6db6b47bac8ee',\n'100d73b35f23b2fe84bf7cd37140bf4d',\n'11b5aceb428c3e8c61ed24a8ca50553e',\n'12c3566761495b8353f67298f15b882c',\n'150224a0ccabce79f963795bf29ec75b',\n'152fc2320790aa16ef9b6126f47c3cca',\n'226b1ac427eb5a4dc2a00cc72c163214',\n'2398ed2d5b830d226af26dedaf30f64a',\n'24a7c99da9eef1c58f09cf09b9744d7b',\n'25a97f6dba87ef9906a62c1a305ee1dd',\n'294b1e229c3b1efce29b162e7b3be0ab',\n'2b686a8b83f8e1d8b455976ae70dab6e',\n'2e67c62bd0307c04af469ee8dcb220f2',\n'3322fba40c4de7e3de0fda1123b0bf5d',\n'3651f252d53d2f46040652788499d65a',\n'383161e4deaf7eb2ebeda2c5e9c3204c',\n'3b926b5762e13ceec7ac3a61e85c93bb',\n'3bb34ebd93b8ab5799f4843e8cc829fa',\n'3e61ca5057633459e96897f79970a46d',\n'3fb9341fb11eca439b50121c6f7c59c7',\n'4022baddfda3858a57c9cbb0d49f6f86',\n'4326a7e863928ffbb5f6bdf63bb9126e',\n'4410e95de247d7f1ab649aa640ee86fb',\n'4414953fa397a41156f6fa4f9462d207',\n'4456e52f6f8543c3ba76cb25ea3e9bd2',\n'44887551a47ae272d7873a354d24042d',\n'45736deb14f3a68e88b038183c23e597',\n'4bf96a7040a683bd34c618431e571e26',\n'4e7e90c7147ee8aa01275894734f4492',\n'4fd62068e591cbd6f413e1c2b8f75442',\n'5125979110847d35a338caac6bff2aa8',\n'562ecbba043552d59a0f23f61cea0983',\n'590d98bb74879b52b97d8a158af912af',\n'5e14f77f85fd9a5be46e7f04b8a144f5',\n'66cdaa156e4d372cfa3dea0137850d20',\n'66e0681a500c726ed52e5ea9423d2654',\n'68acf11f5e456744262ff31beae58526',\n'6902862bd81da402e7ac70856afbe6a2',\n'6a9a114928554c26675884eeb40cc01b',\n'6efb58cf54d1bb45c057efcfbbd68a93',\n'6f04a93753ae3ae043203437832363c4',\n'79259451ff47b864d71fb3f94b1774f3',\n'7af24305a409a2b8f83ece27bb0f7900',\n'7c2a06ceb29cdb25f24c06f2a8892fba',\n'7e6bc0ed11c2532b2ae7060327457812',\n'7f8102b789303b7861a03290c79feba0',\n'8025bcbe3cc81fc19021ad0fbc11cf9b',\n'82773afa0860d668d7fe40e3f22b0f3e',\n'82e33011ac34adfcced6cddc8ea56a81',\n'83ed748cd94576700268d35666bf3e01',\n'848837b83865f3854801be1f25cb9f4d',\n'8c91a27bbdbe9fb0877daccd28bd7bb5',\n'8d949c34def898f0f32544e43117c057',\n'9529c4c9773392893a8a0ab8ce8f8ce1',\n'98ecf58d48a3eae43899b45cec0fc6b7',\n'995120b35db9d2f36d7d0ae0bfc9c10d',\n'9c8eb908b8c1cda46e844c24f65d9370',\n'9ccda4d7511009d5572ef2f8597fba4e',\n'9dcb6424662941d746576e62712220aa',\n'9e85713d615bda23785faf660c1b872c',\n'9f401176a9dd18fa2b5b90b4a2aa1356',\n'a107850eb20a4bb3cc59dbd6861eaf0f',\n'a495c6d11ff3f525915345fb762f8047',\n'a8b5dcfea5e87bf0e95176daa243943d',\n'a91bf61cc18705be2288a0f6f125068f',\n'aeb0e1d0e71ce2a08db9b1e5fb98e0aa',\n'b66347ef110e60b064474ae746701d4a',\n'b8415b4056c10c15da5bba4826a44ffd',\n'c0598321d4ad4cf1219cc4f84bad4094',\n'c74ebb6c238bbfaefd5b32d2bf7c7fcc',\n'cdf58a48757010d9891c62940c439adb',\n'cf752e9cd2eccbda5b8e4c29ab5554b6',\n'd0a830403e56ebaa4bfbe87dbfdee44f',\n'd5d3d23c8573d999f1c48d3e211b1066',\n'd7cfb9fbcf19ce881180f757aeec77dd',\n'd93100fe60c342e9e3b13150fd91c7d8',\n'db0eaad52465d5a2b86fdd6a6aa869a5',\n'dd8805d0e470e59b829d98397507d8c2',\n'dfbb1b988c239ade4c23856e42d4127b',\n'e0683f8ee787313cfd2c61cd0995a830',\n'e4efa759d425e2f26fbc29943a30f5bd',\n'e7beece34bdf67cbb8297833c5953669',\n'e89efa88e3fda86be48c0cc8f2ef7230',\n'e91670423930cbbd3dbf5eac1f1a7cb6',\n'ece07daca53dd0a7c23dacabf50f56f1',\n'edcd58ba5b1b87705e95089002312281',\n'eeedc09570324767a3de8205f66a5295',\n'f20824fa6e5c81e3804419f108445368',\n'f3dd8aa567a01098a8a610529d892485',\n'f41074be5b423afb02a74bc74222e35d',\n'f59095f0ab15f26a1ead7eed8cdb4902',\n'f7d9961463b5110a3d70ee2e97842ed3',\n'fa255fdc88ab656ad9bc383f9b322a76',\n'fbefb4074f1672a3c29c1a47595ea261'\n    ]\n);\nlet SHA1Hash= dynamic(\n    [\n'5968670c0345b0ab5404bd84cb60d7af7a625020',\n'fb514d59d4beabd97a25c2eefb74ce85b16edaac',\n'863514b3c3f88d084bbe27bf7ba59189fbdbd902',\n'0c8e807969295237c74a1016c284f99975e761b9',\n'226c07a66c530350e9c89ddbe550646e94b5ff96',\n'1bfaccc392df6d62fb3d8c9e69b72f0b4c5a478a',\n'7bbdbe9f26a3d96e31d648551e66f91a9bd928ab',\n'0613d4a7556d13889727e2e3312abfc2f6bbc046',\n'c47cf12067a0ddf212a890f26dc8578d8bb705cb',\n'9a6e4d1a0b682abc848e5c7a6f8782cb0213fc5c',\n'af35d96b1e70d05a0c556bb9fa46af7450db1474',\n'f7d483346611ce1d3e5bf8eeebfc7be122a131b9',\n'4e1aead0a6c181afbd12c75f8da5a1a01acafc6c',\n'8ac4feca574feb39aa887ac24803cc66fc658789',\n'ac9db0eb0ef64d4b9fa68f52c713904e6fd4d6e6',\n'f142936d2ab1e023ffc39d41a801d18a0c7df398',\n'12e46031d953fd0a9a2b0ec573b695420eafd5f2',\n'03324510e41c7b9fec35516aca947850d4ef7529',\n'5d358567e549a6f8e471697f7c78bc8bdf2a6534',\n'33d6eef3c7c5a496cc22acaaa7aed03d59af498a',\n'803b1743cb5498543802c14e67a34c61977d73b5',\n'4d0c07c7a215ec9d563b0a3e73899e56fcf94566',\n'67f7ba6b4c301d372d8fb28cb231fb13a58b1dc9',\n'd5adb0dc551c3c97fc929d86e039672b97ddc65e',\n'063ede02eb666c16c61135aa27b1a026014cfc77',\n'e54f5737847287e49a306f312995c9aba38314d4',\n'e74f4f592e17a7c3c9be85b430dddeea2c3abda4',\n'ae9d8a3e09b55a45c0452a293dcb01fab556f810',\n'a1065c1a5d908796745e9c5be297ea2d402859dc',\n'05ddb03cd423042ee6af3a14b6c4c0772eb75757',\n'3c0c8e162bb8d42348beb6f4527f303c7487ce96',\n'df8543eaddb005dab92ef0cdab7c19b41ef647f8',\n'75e87b5ff18b2c53688e43a2e599fd6b3ab06d92',\n'268d4e63b8fb38d37556384549717531e50eb65f',\n'f4cb5107f1b9755ce0e8f7a7f85f5536fd204019',\n'38e866dd44dce667dd19652e28324b6110e808bd',\n'218651ac5b575c3f9642c2e9a5928aa22fab8483',\n'472af2b122c23bf0ca10c78d389a5a7f030a3536',\n'520cab82bb5bcfd8abd2301b648aafe0555044c4',\n'b49972eed626571914116bae4446be571598dd81',\n'3a4adb4ff64ddcdd0f1b2a86f04d2b72da5d9c92',\n'22109552d6af71d392de199e21ae272009db608a',\n'ccc5cb5b399bbf9d2959aafdc90233fa4ca9380d',\n'849f81a20a4bb9985066d9e38f4adfba07bc5444',\n'cc542c0f873470b3eb292f082771eec61c16b3d7',\n'590bd7609edf9ea8dab0b5fbc38393a870b329de',\n'41c11e48c3a64484b38a2d64ab3b9453bae05a14',\n'e468a7947c497b435bdf1a50cf0f73abf849c79b',\n'a5c4975199bfe820bd0076bb5b7c68be93ba7bf8',\n'f38bf87c73ac188fc60a2bfa5bba1c838148a8a1',\n'a1e3e694b147767efcab214f099a1488726abd0f',\n'aaa153236b7676899572760482951d3edad7a8b5',\n'25be1b61ce1f9dcc498c64a5a753efb96df3ae4c',\n'39bb0e9765e0137d09dc8d41fa1dded24e1fdeed',\n'5b93345c18faa20ef1f2d3f7fb5a299c27e4b66d',\n'f5a605c29af773c9f5604c8f5546c991d24d2dc2',\n'db99f1ef9b630fc16deb23d8c7d7df2441bc80e5',\n'c226cb69f2a017712cc94493f51d7726f933bcda',\n'5b3b08f15ac3bbf2644f88b0615536f33a1ff1a8',\n'42f81c4cfca1438371829b7ad5e7b3db54a2cddf',\n'1c23dd83c6ebba6f870b1ad02f326ea730ea53a5',\n'2b663679da2a7070f91945784ac167ed3ded7280',\n'fd1e67da7919dc7d0fbab0c5d02ee6e12537f2ef',\n'93c1078cb6d0aeab90eb0b83ec4a737ce7bcccdc',\n'05d900d16d2738b0bded3ba4a60ff24adc0776f1',\n'fc19e8dae2215446ade30b6bc7aa5d4b0d6627f7',\n'f30ef3957c930cf2aa74361d4d229777e7ee40ef',\n'964e161dd92df9b160a6f7c7d1dedf216e8fed2c',\n'bf4254555a5f4d3299aae8d4ffc28bbb1dfec3c6',\n'50726acc45f673d6f0924a8bf030f3f07b1cd9c5',\n'd535de08875cef1c49bfa2532281fa1254a8cb93',\n'7935da6efb19ea558fe6b1f98f3b244b4a74794b',\n'589f7878efd02dd5a0832c6e523f4914cbcfd450',\n'8f7d4f9eed06c1d175ef6321fb7110183aabbb7c',\n'467b32e7414308b245c6c004303a5638e0fa7bdf',\n'b98cded462dfd80c682c953830e3df744cac756d',\n'3df6b6fb4870b66931e91a59a5f9c013198bc310',\n'c26f164336ea82a40b2186270249d2fe5571b12d',\n'e53ff219a6d5d0713ddfa54f8fff7ff703e5e85f',\n'fa9905d231bb1565086dcf2608ee2125bf585c01',\n'c1fe1a306c4d7106d5a0bb47d3880836d9ecc2c6',\n'7323ca7b92edbd195b2d7e18c91fd48b4c96a0cc',\n'f9881d2380363cb7b3d316bbf2bde6c2d7089681',\n'ca112215ba3abf12bd65e15f018def811b9d5938',\n'bcdf6ddccab0c348d85ca52077ffbef12f94a336',\n'28a15a0b532c47110297aa6f4f46bad4d72235a2',\n'ad5bff008e0e270d19eaa7e211b1c821d4091b68',\n'7f308945c4904ef168bbf57c86e56c8a3f836a2e',\n'74fc338bbab1a1f42699165c588dc91639d0343b',\n'4f3ec6a4af8fddf85a0f2933b6cabee44e74fe33',\n'41a491270ec2bd6d230be4d163c719e6d46265e7',\n'17e199488c301aad10861cdeb1ee5087d2c87517',\n'0225b06163d58bc55c6e4f6b451c5553dc9558c7',\n'f6bb18873580f645c09758fda398655ce5e3eff3',\n'2933c394fa06892dbd1ce2937b4c2344e8239ef8',\n'a6119a5c321b2755bffdb4919d910a18b0613842',\n'86e975d05de96e0ea088ffdde9993f9247f0ee03',\n'3248ac428a7c888723398a5c2535b5b95f550754',\n'b1b5dbea32917b7db654dc193de98b840abdbcb5',\n'004809dcd28c0cf078d65cc11a478d50cb3cba0d'\n    ]\n);\nlet SHA256Hash = dynamic(\n    [\n'77bdcb2a9873c4629d8675c8ce9cc8a0cf35c514e27f7a6dc2bc4b31f79dd9e2',\n'f937aa71e0b1cb3f9a4d5c0e8ffa4f383b781dd878e71e4b73c1f084b4a7e6de',\n'8469341f65cc42b86ef7ded04eca8a00266f34d6d2916330af1bf40fb69e26f0',\n'd3ca5583c98a4ab0cc65773addd3444435eea13e70e3929629535f14dfe8b63b',\n'2051f5d7c79e67a02880ca9f2fc0cdf4fa8827fc515f16baa743193c9b178ba0',\n'4ce2df07fecdc7f7852c686440e3b421c159d8fc382481ce70165a77741fb2c4',\n'9e170d1146efeee09f888c7b1bbfb10dec3ede9cc0b20b6b137c52dd146fd302',\n'2b7a2703e77cb735fae7b90bbd5a2fa481aea1c34c3fb7bfada61cbcebb35efc',\n'd0b6413c3dabe564435291b65f28119ad5a9c1fabc05ee48820f728740cb1a03',\n'4be84a291b6c6a5f019c1c6b1ceff3b4bc3668d5874b1a423838a57560788158',\n'79f2cd2009fe104e5ed6ad25d0ba06b10fb7c0983e88beab27e55b78cd2a5300',\n'c4bb5b85710d7e78e82a57eb2ac2c8f7796972bada1ddc6af7ae6d318bc87aa3',\n'a9827ea4e45194c65a3ff6cf03345b16bd24047165bd91d4595caae8488529db',\n'59a4ae454be71f8a036a7b4c74ae40f4ca6e7105dabfabb4637e87b7a9afb51d',\n'fe33146518676279692217e32f8c36a9749d705981e672ebbde79c80b32dd8b7',\n'6e1c976151313a24fbd1f620a0a2c66aaf5489d44b8153eb12e789bfbea3731f',\n'5751ac3b127f6c8cf251d995ac6254f8999ab227dd6da870f1e0249b3ce56bb6',\n'964efc495e4e1a2075fcd48a661166fb8df81d81d8ac2c26768325dc15da7f70',\n'd9882283ee2dc487c2a5fb97f8067051c259c4721cd4aea8c435302fe6b274c4',\n'c11d6bdda1972a2f538f0daea099df17ce76077098b9f3f72459cf7db1ec5ec6',\n'178dc666df641f4f1f184d54c7bcac4764e81bb1c3b03a7207b321660c77770b',\n'5756a54a1d9ae74df58008048c6042e7254cc7eed0389f556db3f000cb191000',\n'c828558c67601c94511720748a49703b09814bcd21be2caa98b36faa445e19db',\n'a57112c53bf2ee334a6d01b39cb43ec8de42ba18ea925d55132567274b742ce6',\n'6e05bebdc38c4bd34c83d2ca6b954ce84c87ed78fd0d932576593a3ad710e3c3',\n'25e755c8957163376b3437ce808843c1c2598e0fb3c5f31dc958576cd5cde63e',\n'8e16cd7d498eb69d7b3e079e1353e0df6eec70a845986475d7cf65a6740b4434',\n'44f3c63c1f6414f2c3e602a57ba38f340287fe2acc15ff0c88dca503c67b1a0c',\n'fe664bb9dc2976d6d2ccc07582b5c5eb85b896cc439a9af91db7e51b1c905bdb',\n'3805caa8e426a6f7d7d3ce9c87ce188b20185b134d936a69b9d51125b1264dea',\n'40db7affc23dcaf88c288d6a918b6371a45dcfa16e08543e9442d4d952a9ecc4',\n'4878d5d7933e096305c70c83499b84893b6bd0dbe226e16ea90430efeb8b8593',\n'faf76f9e66c7392cddbe7bcc73b00dc2ca2d8d1da6f46f5686dadc2e0a559acb',\n'09b1003b673b559c3599dcb9250112bd3a602602f2836b54d5d7cdd1c4c4e6f2',\n'3f1d22893c626346f8d361076bc66797d55b09a959ec0d36ec3d48048983f138',\n'652d3717353df8fc3145ecc9f2c871034a58f2519bdd0c70a72a3d8c88bad48c',\n'078403b4e89ff06d2fe2ed7e75428a381f83ffb708dbd01b0220767498947f0c',\n'82cce26c60a5105e6caf5ac92eabb3dedcd883cd075f2056f27b0ec58aefaaa6',\n'4d004d168b0bb9bed836404e850796173ac27efd8489738394a265478224cf27',\n'6652e27ad1bf5002665b2d0821e75092a087103408560682295f90706a3289cb',\n'b051ee189faf36e2d6c382fede530e9274b42bc9c42e210b4ee1bc84b0419ba6',\n'0340043481091d92dcfb2c498aad3c0afca2fd208ef896f65af790cc147f8891',\n'bfe88e7986fbf27db90f18959a0b1e237b6f0395fa11b9eb386e5bac143c1d2d',\n'7404a08ecc0aa0d84f039d078ad39804856206ae58dde360238d4a1943557333',\n'efb533249f71ea6ebfb6418bb67c94e8fbd5f2a26cbd82ef8ec1d30c0c90c6c1',\n'73233ca7230fb5848e220723caa06d795a14c0f1f42c6a59482e812bfb8c217f',\n'9a84cb10b7ba0b96eea473900d58052511af7b235383b6a496dffab9b982d20d',\n'9af4272d6cc0e926f74ccf68d0a4d056eb37059214c312ef3628bca45a7d76cf',\n'b262d0c81ac5a13c1a6aa650d1ca7b04117f654a2a97bfe7ac4a7ca8ae9a6ed5',\n'432010e6d7a42710b10464e440fa4e2df2bb387839d56a5b371727dc6c3da272',\n'b58de9beaf70bfd12cd6fb372f52eff5405f96602c22034a80ef01b4f9e2ded4',\n'5f0bc27c272937e3ef788c290939481137148c1c5c70dbb7d1fb13cb22e3e2c1',\n'7b59090b78127381593460ccea2ea64d6c5838cd8cb0e97c5e436ae58e69cdee',\n'e7046b7eac25ceb5274c815aba4384099524eacf9aed683179aa29ac5f45ede8',\n'38c1cab0a8c9870f2cc7cfa5f3f782c0bb8ede94ce89a41a5e9509a79d7fdf5e',\n'393cd1ecf955d6938f9a9ba65808a209e7741e2fd17baa91e4960aca799be86f',\n'681b1b85a0f8a7ede2c6bf8c71ad4cb56ccc4e1bb400783c93ee9b5ab76d3da6',\n'd104de2912949e598f12b2b517bdbec17896cee8305766e72bbb4e604205b2b4',\n'eb7bada29bcf4c6b94f7ab710a8a6702f26845c9678826ff0dfc7494a5e8186d',\n'4a5f1df73581c531e62e73fe1ab374d1d93b3846d8e6b80833fd295e0fbc23f1',\n'895d49db09b64f15782073d4ff4a0fe21cd91f9b9fa9902053278799313b13b1',\n'99b622046fb5e122a6f2dadad0858cdd1056582701fb0968c57ec6171dc4c0ee',\n'8f79942feb0c8533ce01f867902f4a72d328681249fd474b0215e9d9b4477f67',\n'948f9fc9b5979fb66e91964bb2bee0b42b7e8f6b6436188fee9fb69b676d2f42',\n'356266255b6aa6ba096cd8048a6a43488ffc21845430d7d0f798fd9022879377',\n'4e35c7d135bd7f55cdec68d7acf176ae84b850e927fdffb005e000fef5b35a21',\n'609aa1b6ebbeb93a76898219ad470832c4dd838fb3214989841af8b90fcef695',\n'5e0fb8cab745678487ac1ed99b5ec2fa2d54a65cbf0e2cb9208785200f2c2b8b',\n'aa4349b6531544093c4dbc1d2a7b8680d3308cbde313a38c27cd211dd80ee9d1',\n'f0a59a724ee6631b7f2ae88aa9ec7c24a82f8c912512352d93d058a928c33c70',\n'1cf5710e500a423b84b51fa3afdd923fe0a8255c5817d3238175623e2ebbfad9',\n'959be603c11951ead9c13efd0451ba23e743ec3019562f7715c5b0306ae70537',\n'0cb570e4e5229dbe488bba92f57b5951a69335dd625aa6ada0ccb34c918613b2',\n'60d3a8c8a7e8bdb67a44ad4f220e52593bf46d2ce6e8d40b6db9045c68cee413',\n'71b11d28dec1dadc738c4b993dba32e3c33a85421de66120be62f3ec0ed50c3e',\n'b6ef03aec5d10e371f0b06c661036d838ef55fa7dc75cf91fca3622bdefa8140',\n'791cb9883187ada5274c976a2e05dc756c48eda88fabdfe2eb7e19f59f0182e5',\n'1ba2ef33e69d6bc03ba02a68ecd701b1eee6a33aabd44509e3b344d0948cf9f4',\n'1353ffc96e0a701fa8b3dc2835a8be6199e3c8f079663ebffb6b665750ef8af9',\n'2effc706d002ebf5c18160ba1cec9f88adbc4a36a3daaf5dbacc8c0dd6ad46b6',\n'd13ec5610c22bad31a47b59791b6e964d4703b4019094fd44c8151ee802db7ea',\n'3ac5a8f9f2f80b7a8b5267a5cd523dd449b2de5ccb7b30e448ef0dcfc8995506',\n'c0621954bd329b5cabe45e92b31053627c27fa40853beb2cce2734fa677ffd93',\n'899ad5af2b4ad14fa58612dc2938598ac7e892d759659aef87e4db46d70f62bf',\n'e1d466b44e0dffafe4a2d0ebade37ea5f9b6a30ccf16f59d4d2e32f9204a03f8',\n'a022820a62198fa3e3b89749b38db1cc3a09136524682fb99a3ce36652725065',\n'3c9a7aa8cc4fd0538532e757a756709897c94b2653152a40993c7d0a47503980',\n'6c8f967b12cf84eed7b8c039e04614e50cd7fcd8ca9e01563bb6f5f0a11dcb8c',\n'bb4229d4fe06209fc7c8ed44da8f353dcb980b5f1a5229c7e1f17b772ff8fd8c',\n'e2f7afedf6dbeaeae60a1434a8735acd426087fd16689b29b869ebe88cdbef85',\n'504be292cf783ce6cb0c356034e69b76a465ec534386a776663810266d64da33',\n'42389f51dc60590c2daab696e8782c3f4dd9f9a4c98a3b987e10d43174deba38',\n'eec42b1fb5275eaf3e0229db99421e2b16a3c82bb64da3305662622dc2d6e07a',\n'33b8b7198b8e9a24b415d280d673cfa4efe4d249ac9e21703a61c65dc0933d74',\n'c91e8e5c2491f7708c4e550c18acab121e1b245ade7b2abb79cdd25b8a9cf379',\n'b292ae784ab91b99cc2b8f5cc173813cdb52fb75c6dab85bd1ce05a244b85fca',\n'629c0a325f24016534ebc2e0578068593ca883557f8c10cc1ae4d5b0ab91bfec',\n'bc6d23e865cdbc4d57451e80797be2b2feff531ca2743c533e5d114c3a19433d',\n'7b1e06cf7c362e62b156652b069a4ca1800e0ab72730636f64cc24dabd3830a8',\n'cc9da7fce451e409a4d994b4675db6a3651a551b9a004461d14a3d3532765d84'\n    ]\n);\nDeviceFileEvents\n| where SHA1 in(SHA1Hash) or SHA256 in(SHA256Hash) or MD5 in(MD5Hash)\n| union DeviceImageLoadEvents\n| where SHA1 in(SHA1Hash) or SHA256 in(SHA256Hash) or MD5 in(MD5Hash)\n", "attributes": {"description": "This query searches for the HASHs of the FireEye Red Team tools compromised by the Nobelium activity group.\nSee all-hashes.csv on the official FireEye repo.\nReferences:\nhttps://github.com/fireeye/red_team_tool_countermeasures/blob/master/all-hashes.csv\nhttps://github.com/fireeye\n", "techniques": NaN, "tactics": ["Privilege escalation", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Hurricane%20Panda%20activity.yaml", "query_name": "Hurricane Panda activity", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where ProcessCommandLine endswith \" localgroup administrators admin /add\"\n     or ProcessCommandLine has @\"\\Win64.exe\"\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_hurricane_panda.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Judgement%20Panda%20exfil%20activity.yaml", "query_name": "Judgement Panda exfil activity", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where ProcessCommandLine has @\"\\ldifde.exe -f -n \"\n     or ProcessCommandLine has @\"\\7za.exe a 1.7z \" \n     or ProcessCommandLine endswith @\" eprod.ldf\" \n     or ProcessCommandLine has @\"\\aaaa\\procdump64.exe\" \n     or ProcessCommandLine has @\"\\aaaa\\netsess.exe\" \n     or ProcessCommandLine has @\"\\aaaa\\7za.exe\" \n     or ProcessCommandLine has @\"copy .\\1.7z \\\" \n     or ProcessCommandLine has @\"copy \\client\\c$\\aaaa\\\" \n     or FolderPath == @\"C:\\Users\\Public\\7za.exe\"\n| top 100 by Timestamp desc\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_judgement_panda_gtr19.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/known-affected-software-orion%5BNobelium%5D.yaml", "query_name": "known-affected-software-orion[Nobelium]", "query": "DeviceTvmSoftwareVulnerabilities\n| where CveId == 'TVM-2020-0002'\n| project DeviceId, DeviceName, SoftwareVendor, SoftwareName, SoftwareVersion\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query searches Threat and Vulnerability Management (TVM) data for Orion software known to be affected by the Nobelium campaign.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/launching-base64-powershell%5BNobelium%5D.yaml", "query_name": "launching-base64-powershell[Nobelium]", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName =~ \"SolarWinds.BusinessLayerHost.exe\"\n| where FileName =~ \"powershell.exe\"\n// Extract base64 encoded string, ensure valid base64 length\n| extend base64_extracted = extract('([A-Za-z0-9+/]{20,}[=]{0,3})', 1, ProcessCommandLine)\n| extend base64_extracted = substring(base64_extracted, 0, (strlen(base64_extracted) / 4) * 4)\n| extend base64_decoded = replace(@'\\0', '', make_string(base64_decode_toarray(base64_extracted)))\n//\n| where notempty(base64_extracted) and base64_extracted matches regex '[A-Z]' and base64_extracted matches regex '[0-9]'\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query detects events when SolarWinds processes launched PowerShell commands that were possibly encoded in Base64. Attackers may encode PowerShell commands in Base64 to obfuscate malicious activity.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/launching-cmd-echo%5BNobelium%5D.yaml", "query_name": "launching-cmd-echo[Nobelium]", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName =~ \"SolarWinds.BusinessLayerHost.exe\"\n| where FileName == \"cmd.exe\" and ProcessCommandLine has \"echo\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query detects events when SolarWinds processes attempted to launch the cmd.exe command prompt using the 'echo' command. Using 'echo' in this way is suspicious, as it is an indirect way of issuing commands, and may not be readily detected by certain kinds of security solutions.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\nhttps://docs.microsoft.com/windows-server/administration/windows-commands/cmd\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/locate-dll-created-locally%5BNobelium%5D.yaml", "query_name": "locate-dll-created-locally[Nobelium]", "query": "DeviceFileEvents \n| where SHA1 in (\"76640508b1e7759e548771a5359eaed353bf1eec\",\"d130bd75645c2433f88ac03e73395fba172ef676\",\"1acf3108bf1e376c8848fbb25dc87424f2c2a39c\",\"e257236206e99f5a5c62035c9c59c57206728b28\",\"6fdd82b7ca1c1f0ec67c05b36d14c9517065353b\",\"2f1a5a7411d015d01aaee4535835400191645023\",\"bcb5a4dcbc60d26a5f619518f2cfc1b4bb4e4387\",\"16505d0b929d80ad1680f993c02954cfd3772207\",\"d8938528d68aabe1e31df485eb3f75c8a925b5d9\",\"395da6d4f3c890295f7584132ea73d759bd9d094\",\"c8b7f28230ea8fbf441c64fdd3feeba88607069e\",\"2841391dfbffa02341333dd34f5298071730366a\",\"2546b0e82aecfe987c318c7ad1d00f9fa11cd305\",\"2dafddbfb0981c5aa31f27a298b9c804e553c7bc\",\"e2152737bed988c0939c900037890d1244d9a30e\",\"fd15760abfc0b2537b89adc65b1ff3f072e7e31c\") or SHA256 in (\"32519b85c0b422e4656de6e6c41878e95fd95026267daab4215ee59c107d6c77\",\"ce77d116a074dab7a22a0fd4f2c1ab475f16eec42e1ded3c0b0aa8211fe858d6\",\"dab758bf98d9b36fa057a66cd0284737abf89857b73ca89280267ee7caf62f3b\",\"eb6fab5a2964c5817fb239a7a5079cabca0a00464fb3e07155f28b0a57a2c0ed\",\"ac1b2b89e60707a20e9eb1ca480bc3410ead40643b386d624c5d21b47c02917c\",\"019085a76ba7126fff22770d71bd901c325fc68ac55aa743327984e89f4b0134\",\"c09040d35630d75dfef0f804f320f8b3d16a481071076918e9b236a321c1ea77\",\"0f5d7e6dfdd62c83eb096ba193b5ae394001bac036745495674156ead6557589\",\"e0b9eda35f01c1540134aba9195e7e6393286dde3e001fce36fb661cc346b91d\",\"20e35055113dac104d2bb02d4e7e33413fae0e5a426e0eea0dfd2c1dce692fd9\",\"2b3445e42d64c85a5475bdbc88a50ba8c013febb53ea97119a11604b7595e53d\",\"a3efbc07068606ba1c19a7ef21f4de15d15b41ef680832d7bcba485143668f2d\",\"92bd1c3d2a11fc4aba2735d9547bd0261560fb20f36a0e7ca2f2d451f1b62690\",\"a58d02465e26bdd3a839fd90e4b317eece431d28cab203bbdde569e11247d9e2\",\"b8a05cc492f70ffa4adcd446b693d5aa2b71dc4fa2bf5022bf60d7b13884f666\",\"cc082d21b9e880ceb6c96db1c48a0375aaf06a5f444cb0144b70e01dc69048e6\",\"ffdbdd460420972fd2926a7f460c198523480bc6279dd6cca177230db18748e8\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query locates malicious Nobelium-associated DLLs that have been created in the system or locally.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": NaN, "tactics": ["Persistence", "Impact", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/locate-dll-loaded-in-memory%5BNobelium%5D.yaml", "query_name": "locate-dll-loaded-in-memory[Nobelium]", "query": "DeviceImageLoadEvents \n| where SHA1 in (\"76640508b1e7759e548771a5359eaed353bf1eec\",\"d130bd75645c2433f88ac03e73395fba172ef676\",\"1acf3108bf1e376c8848fbb25dc87424f2c2a39c\",\"e257236206e99f5a5c62035c9c59c57206728b28\",\"6fdd82b7ca1c1f0ec67c05b36d14c9517065353b\",\"2f1a5a7411d015d01aaee4535835400191645023\",\"bcb5a4dcbc60d26a5f619518f2cfc1b4bb4e4387\",\"16505d0b929d80ad1680f993c02954cfd3772207\",\"d8938528d68aabe1e31df485eb3f75c8a925b5d9\",\"395da6d4f3c890295f7584132ea73d759bd9d094\",\"c8b7f28230ea8fbf441c64fdd3feeba88607069e\",\"2841391dfbffa02341333dd34f5298071730366a\",\"2546b0e82aecfe987c318c7ad1d00f9fa11cd305\",\"2dafddbfb0981c5aa31f27a298b9c804e553c7bc\",\"e2152737bed988c0939c900037890d1244d9a30e\",\"fd15760abfc0b2537b89adc65b1ff3f072e7e31c\") or SHA256 in (\"32519b85c0b422e4656de6e6c41878e95fd95026267daab4215ee59c107d6c77\",\"ce77d116a074dab7a22a0fd4f2c1ab475f16eec42e1ded3c0b0aa8211fe858d6\",\"dab758bf98d9b36fa057a66cd0284737abf89857b73ca89280267ee7caf62f3b\",\"eb6fab5a2964c5817fb239a7a5079cabca0a00464fb3e07155f28b0a57a2c0ed\",\"ac1b2b89e60707a20e9eb1ca480bc3410ead40643b386d624c5d21b47c02917c\",\"019085a76ba7126fff22770d71bd901c325fc68ac55aa743327984e89f4b0134\",\"c09040d35630d75dfef0f804f320f8b3d16a481071076918e9b236a321c1ea77\",\"0f5d7e6dfdd62c83eb096ba193b5ae394001bac036745495674156ead6557589\",\"e0b9eda35f01c1540134aba9195e7e6393286dde3e001fce36fb661cc346b91d\",\"20e35055113dac104d2bb02d4e7e33413fae0e5a426e0eea0dfd2c1dce692fd9\",\"2b3445e42d64c85a5475bdbc88a50ba8c013febb53ea97119a11604b7595e53d\",\"a3efbc07068606ba1c19a7ef21f4de15d15b41ef680832d7bcba485143668f2d\",\"92bd1c3d2a11fc4aba2735d9547bd0261560fb20f36a0e7ca2f2d451f1b62690\",\"a58d02465e26bdd3a839fd90e4b317eece431d28cab203bbdde569e11247d9e2\",\"b8a05cc492f70ffa4adcd446b693d5aa2b71dc4fa2bf5022bf60d7b13884f666\",\"cc082d21b9e880ceb6c96db1c48a0375aaf06a5f444cb0144b70e01dc69048e6\",\"ffdbdd460420972fd2926a7f460c198523480bc6279dd6cca177230db18748e8\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query locates malicious Nobelium-associated DLLs that have been loaded into memory on affected systems.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": NaN, "tactics": ["Persistence", "Impact", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/MacOceanLotusBackdoor.yaml", "query_name": "MacOceanLotusBackdoor", "query": "DeviceProcessEvents\n| where Timestamp > ago(14d)\n| where FileName in~ (\"screenassistantd\",\"spellagentd\")\n| top 100 by Timestamp \n", "attributes": {"description": "Backdoor processes associated with OceanLotus Mac Malware Backdoor.\nReferences:.\nHttps://blog.trendmicro.com/trendlabs-security-intelligence/new-macos-backdoor-linked-to-oceanlotus-found/.\nOS platforms: Macintosh.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/MacOceanLotusDropper.yaml", "query_name": "MacOceanLotusDropper", "query": "DeviceProcessEvents\n| where Timestamp > ago(14d)\n| where ProcessCommandLine contains \"theme0\" \n| project Timestamp, DeviceId , DeviceName, AccountName , AccountSid , InitiatingProcessCommandLine , ProcessCommandLine  \n| top 100 by Timestamp \n", "attributes": {"description": "Backdoor processes associated with OceanLotus Mac malware backdoor dropper.\nReferences:.\nHttps://blog.trendmicro.com/trendlabs-security-intelligence/new-macos-backdoor-linked-to-oceanlotus-found/.\nOS Platforms: Macintosh.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/OceanLotus%20registry%20activity.yaml", "query_name": "OceanLotus registry activity", "query": "DeviceRegistryEvents \n| where Timestamp > ago(7d)\n| where ActionType == \"RegistryValueSet\" \n| where RegistryKey endswith @\"\\SOFTWARE\\Classes\\CLSID\\{E08A0F4B-1F65-4D4D-9A09-BD4625B9C5A1}\\Model\" \n     or RegistryKey endswith @\"\\SOFTWARE\\App\\AppXbf13d4ea2945444d8b13e2121cb6b663\\Application\" \n     or RegistryKey endswith @\"\\SOFTWARE\\App\\AppXbf13d4ea2945444d8b13e2121cb6b663\\DefaultIcon\" \n     or RegistryKey endswith @\"\\SOFTWARE\\App\\AppX70162486c7554f7f80f481985d67586d\\Application\" \n     or RegistryKey endswith @\"\\SOFTWARE\\App\\AppX70162486c7554f7f80f481985d67586d\\DefaultIcon\" \n     or RegistryKey endswith @\"\\SOFTWARE\\App\\AppX37cc7fdccd644b4f85f4b22d5a3f105a\\Application\" \n     or RegistryKey endswith @\"\\SOFTWARE\\App\\AppX37cc7fdccd644b4f85f4b22d5a3f105a\\DefaultIcon\"\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/apt/apt_oceanlotus_registry.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/oceanlotus-apt32-files.yaml", "query_name": "oceanlotus-apt32-files", "query": "let MaliciousFiles=pack_array(//'KerrDown Lure Documents',\n'b32b5f76e7386a65bd9220befb21e0c46d4084c4',\n'c9d6b6fa37ca3d8cb57248993bb7c8a8fcd1bc89',\n'bf127e2a526240c7e65f24c544dad820cebe6d88',\n'347f555857d56a5afd33cfa19f8b5c771eed2553',\n'26c86c777fc074f5bbad27084bcb3bbc7afff88e',\n'872d2f4ccc43c08f73e84647b3098ff044cdfb75',\n'fb20427d0ac3cd4542755168886a96bde04c4f81',\n//'KerrDown Malware Downloader',\n'5f42b1771ce97679df78713292838c830e606e48',\n'72571ea4389af7a3a0e04d87327427d199f1d178',\n'3f2a7b5605262d8aa189c32a049756c6bfed589b',\n'220ea47d692afc196b5b913a9693323fd51f00f5',\n'85021e711d5c7d5bd968f6dfed7102ab4d8828e8',\n'c9e101c77f67203dfef66d21f2fa6c8765a6c649',\n'3182141a8255baa5b82c0953dd4541c6f9f26a03',\n'2d92d6459ef83ddf006bff4046b1bab86161a26b',\n'6aef7916f1c5d1886db06fe2d4bf35614a0b921f',\n'edd306617f1c7390a6bc067d3e8dfb44ac57287c',\n'd8cd8068cb30605646258c7a0d9b47e00eac28c5',\n'36422fe35473cc28a14701e5d9dcff4c2426d0ae',\n//'OceanLotus Documents Exploiting CVE-2017-11882',\n'd1357b284c951470066aaa7a8228190b88a5c7c3',\n'49dff13500116b6c085c5ce3de3c233c28669678',\n'9df3f0d8525edf2b88c4a150134c7699a85a1508',\n'50a755b30e8f3646f9476080f2c3ae1347f8f556',\n'bb060e5e7f7e946613a3497d58fbf026ae7c369a',\n'e2d949cf06842b5f7ae6b2dffaa49771a93a00d9',\n'OceanLotus Malicious SFX Files',\n'ac10f5b1d5ecab22b7b418d6e98fa18e32bbdeab',\n'cd13210a142da4bc02da47455eb2cfe13f35804a',\n'b4e6ddcd78884f64825fdf4710b35cdbeaabe8e2',\n'cc918f0da51794f0174437d336e6f3edfdd3cbe4',\n'8b991d4f2c108fd572c9c2059685fc574591e0be',\n'3dfc3d81572e16ceaae3d07922255eb88068b91d',\n//'OceanLotus OCX Dropper Files',\n'efac23b0e6395b1178bcf7086f72344b24c04dcc',\n'7642f2181cb189965c596964d2edf8fe50da742b',\n'377fdc842d4a721a103c32ce8cb4daf50b49f303',\n'bd39591a02b4e403a25aae502648264308085ded',\n'b998f1b92ed6246ded13b79d069aa91c35637dec',\n'83d520e8c3fdaefb5c8b180187b45c65590db21a',\n'b744878e150a2c254c867bad610778852c66d50a',\n'77c42f66dadf5b579f6bcd0771030adc7aefa97c',\n//'Malicious PNG Loader Files Used By OceanLotus ',\n'b58b7e8361e15fdc9fb21d0f7c26d5fc17241ff7',\n'5d5c1297415cc5746559182d91c9114700be07e2',\n'43191e81e1dcc9fac138fc1cc5e3aeb9b25cc1f4',\n//'Malicious DLL Files Used By OceanLotus ',\n'fa6be68b59b204c9f5ae886a888627a190491cf7',\n'20c3a72ff476aa1fb71367e1d5dd6e0eb166167e',\n'9d39e11f48b3ed4df35f5e19dd00b47764c98bdd',\n'81c1aff8589dc1e556f68562d7154377c745a1d5',\n'eb27eb72c4709d77db260b942d87ed486e271c93',\n'a28095221fbaad64af7a098e3dda80f6f426b1c2',\n'dabefa810a4febf4e7178df9d2ca2576333e04f2',\n'e716a98a4f0ebd366ff29bd9164e81e7c39a7789',\n'89abb3d70f200d480f05162c6877fab64941c5dd',\n//'OceanLotus Documents Exploiting CVE-2017-0199',\n'928b391af8e029dd8bef4f6dd82223b961429f0d',\n'295a99bebb8122a0fc26086ecc115582f37f6b47', \n'8b9fc2281a604a0ef2d56591a79f9f9397a6a2d2', \n'ec34a6b8943c110687ef6f39a838e68d42d24863', \n'd8be4f41886666687caf69533e11193e65e2a8e5', \n'd8be4f41886666687caf69533e11193e65e2a8e5', \n//'Malicious Documents Used By OceanLotus', \n'8b599ecdbec12a5bd76cf290f9297f13e8397d56', \n'c9073998d2a202e944f21e973448062af4fd29c0', \n'91510b97f764296b16fc88f0195cec6e6f1604af', \n'e00a4e0a03655dccff5ffdb4f4540115d820b5bb', \n'd39a7ecf844545363b96b8ee2eda9b76d51d602b', \n//'JEShell Malware Downloader', \n'8cad6621901b5512f4ecab7a22f8fcc205d3762b', \n'668572ba2aff5374a3536075b01854678c392c04'); \nunion DeviceFileEvents, DeviceProcessEvents \n| where Timestamp > ago(14d) \n| where SHA1 in(MaliciousFiles) or SHA1 in(MaliciousFiles)\n", "attributes": {"description": "This query was originally published in a threat analytics report about the group known to other security researchers as APT32 or OceanLotus\nThis tracked activity group uses a wide array of malicious documents to conduct attacks. Some of their favorite techniques include sideloading dynamic link libraries,  and disguising payloads as image files. The group has weaponized files with exploits for the following vulnerabilities:\n1. CVE-2017-11882 - Software update\n2. CVE-2017-0199 - Software update\nThe following query detects known malicious files associated with the group's campaigns.\nSee Detect malicious network activity associated with group known as \"OceanLotus\" for another query related to this group's activity.\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Defense evasion", "Discovery", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/oceanlotus-apt32-network.yaml", "query_name": "oceanlotus-apt32-network", "query": "//Network activities \nDeviceNetworkEvents \n| where Timestamp > ago(30d) \n| where RemoteUrl in ( \n//'Malicious URL Indicators for OceanLotus Activities 2019', \n'open.betaoffice.net', \n'outlook.updateoffices.net', \n'load.newappssystems.com', \n'syn.servebbs.com', \n//'C2 Indicators for OceanLotus Activities 2019', \n'cortanazone.com', \n'cortanasyn.com', \n'ristineho.com', \n'syn.servebbs.com') \n", "attributes": {"description": "This query was originally published in a threat analytics report about the group known to other security researchers as APT32 or OceanLotus\nThis tracked activity group uses a wide array of malicious documents to conduct attacks. Some of their favored techniques include sideloading dynamic link libraries,  and disguising payloads as image files.\nThe following query detects network activity that may indicate an attack by this group.\nSee Detect malicious documents associated with group known as \"OceanLotus\" for another query related to this group's activity.\n", "techniques": NaN, "tactics": ["Discovery", "Lateral movement", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/possible-affected-software-orion%5BNobelium%5D.yaml", "query_name": "possible-affected-software-orion[Nobelium]", "query": "DeviceTvmSoftwareVulnerabilities\n| where SoftwareVendor == 'solarwinds'\n| where SoftwareName startswith 'orion'\n| summarize dcount(DeviceName) by SoftwareName\n| sort by dcount_DeviceName desc\n", "attributes": {"description": "This query was originally published in the threat analytics report, Solorigate supply chain attack. Please note that these attacks are currently known as the Nobelium campaign.\nMicrosoft detects the 2020 SolarWinds supply chain attack implant and its other components as part of a campaign by the Nobelium activity group. Nobelium is the threat actor behind the attack against SolarWinds, which was previously referred to as Solorigate.\nNobelium silently added malicious code to legitimate software updates for Orion, which is IT monitoring software provided by SolarWinds. In this way, malicious dynamic link libraries (DLLs) were distributed to SolarWinds customers.\nThe following query retrieves an inventory of SolarWinds Orion software use in your organization, organized by product name and ordered by how many devices the software is installed on.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Ransomware%20hits%20healthcare%20-%20Alternate%20Data%20Streams%20use.yaml", "query_name": "Ransomware hits healthcare - Alternate Data Streams use", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d) \n// Command lines used \n| where ProcessCommandLine startswith \"-q -s\" and ProcessCommandLine has \"-p\" \n// Removing IDE processes \nand not(FolderPath has_any(\"visual studio\", \"ide\")) \n| summarize make_set(ProcessCommandLine), make_set(FolderPath), \nmake_set(InitiatingProcessCommandLine) by DeviceId, bin(Timestamp, 1h)\n", "attributes": {"description": "Find use of Alternate Data Streams (ADS) for anti-forensic purposes.\nAlternate Data Streams execution.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Ransomware%20hits%20healthcare%20-%20Backup%20deletion.yaml", "query_name": "Ransomware hits healthcare - Backup deletion", "query": "AlertInfo\n| where Timestamp > ago(7d) \n| where Title == \"File backups were deleted\" \n| join AlertEvidence on AlertId \n", "attributes": {"description": "List alerts flagging attempts to delete backup files.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Ransomware%20hits%20healthcare%20-%20Cipher.exe%20tool%20deleting%20data.yaml", "query_name": "Ransomware hits healthcare - Cipher.exe tool deleting data", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)  \n| where FileName =~ \"cipher.exe\"  \n// Looking for /w flag for deleting  \n| where ProcessCommandLine has \"/w\"  \n| summarize CommandCount = dcount(ProcessCommandLine), \nmake_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 1m)  \n// Looking for multiple drives in a short timeframe  \n| where CommandCount > 1\n", "attributes": {"description": "// Look for cipher.exe deleting data from multiple drives.\nThis is often performed as an anti-forensic measure prior to encryption.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Ransomware%20hits%20healthcare%20-%20Clearing%20of%20system%20logs.yaml", "query_name": "Ransomware hits healthcare - Clearing of system logs", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName =~ \"fsutil.exe\"\nand ProcessCommandLine has \"usn\" and ProcessCommandLine has \"deletejournal\"\n", "attributes": {"description": "// Look for attempts to use fsutil.exe to delete file system logs that can be used as forensic artifacts.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Ransomware%20hits%20healthcare%20-%20Possible%20compromised%20accounts.yaml", "query_name": "Ransomware hits healthcare - Possible compromised accounts", "query": "AlertInfo \n| where Timestamp > ago(7d)\n// Attempts to clear security event logs.\n| where Title in(\"Event log was cleared\", \n// List alerts flagging attempts to delete backup files.\n\"File backups were deleted\", \n// Potential Cobalt Strike activity - Note that other threat activity can also \n// trigger alerts for suspicious decoded content\n\"Suspicious decoded content\", \n// Cobalt Strike activity\n\"'Atosev' malware was detected\", \n\"'Ploty' malware was detected\", \n\"'Bynoco' malware was detected\")\n| extend AlertTime = Timestamp\n| join AlertEvidence on AlertId \n| distinct DeviceName, AlertTime, AlertId, Title\n| join DeviceLogonEvents on DeviceName\n// Creating 10 day Window surrounding alert activity\n| where Timestamp < AlertTime +5d and Timestamp > AlertTime - 5d \n// Projecting specific columns\n| project Title, DeviceName, DeviceId, Timestamp, LogonType, AccountDomain, \nAccountName, AccountSid, AlertTime, AlertId, RemoteIP, RemoteDeviceName\n", "attributes": {"description": "Identify accounts that have logged on to affected endpoints.\nCheck for specific alerts.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Ransomware%20hits%20healthcare%20-%20Robbinhood%20activity.yaml", "query_name": "Ransomware hits healthcare - Robbinhood activity", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d) \n| where InitiatingProcessFileName =~ \"winlogon.exe\"  \n| where FileName == \"cmd.exe\" and ProcessCommandLine has_any(\"taskkill\", \"net\", \n\"robbin\", \"vssadmin\", \"bcdedit\", \"wevtutil\")\n", "attributes": {"description": "Find distinct evasion and execution activities.\nAssociated with the Robbinhood ransomware campaign.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Ransomware%20hits%20healthcare%20-%20Turning%20off%20System%20Restore.yaml", "query_name": "Ransomware hits healthcare - Turning off System Restore", "query": "DeviceProcessEvents  \n| where Timestamp > ago(7d)  \n// Pivoting for rundll32  \nand InitiatingProcessFileName =~ 'rundll32.exe'   \n// Looking for empty command line   \nand isnotempty(InitiatingProcessCommandLine)  \n// Looking for schtasks.exe as the created process  \nand FileName in~ ('schtasks.exe')  \n// Disabling system restore   \nand ProcessCommandLine has 'Change' and ProcessCommandLine has 'SystemRestore' \nand ProcessCommandLine has 'disable'\n", "attributes": {"description": "Find attempts to stop System Restore and.\nPrevent the system from creating restore points.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Ransomware%20hits%20healthcare%20-%20Vulnerable%20Gigabyte%20drivers.yaml", "query_name": "Ransomware hits healthcare - Vulnerable Gigabyte drivers", "query": "DeviceFileEvents \n| where Timestamp > ago(7d) \n| where SHA1 in('0b15b5cc64caf0c6ad9bd759eb35383b1f718edf3d7ab4cd912d0d8c1826edf8', \n'31f4cfb4c71da44120752721103a16512444c13c2ac2d857a7e6f13cb679b427')\n", "attributes": {"description": "Locate vulnerable Gigabyte drivers used by RobbinHood ransomware to turn off security tools.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/redmenshen-bpfdoor-backdoor.yaml", "query_name": "RedMenshen-BPFDoor-backdoor", "query": "DeviceProcessEvents\n| where InitiatingProcessCommandLine  has (\"/dev/shm/kdmtmpflush\") or FileName has (\"haldrund.pid\", \"kdevrund.pid\")\n", "attributes": {"description": "This query was originally published by PWC Security Research Team.\nBPFDoor is custom backdoor malware used by Red Menshen. The BPFDoor allows an adversary to backdoor a system and remotely execute codes without opening any new network ports or firewall rules.\n", "techniques": ["T1095", "T1059.004", "T1070"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/robbinhood-driver.yaml", "query_name": "robbinhood-driver", "query": "DeviceFileEvents\n| where Timestamp > ago(7d)\n| where SHA1 in('0b15b5cc64caf0c6ad9bd759eb35383b1f718edf3d7ab4cd912d0d8c1826edf8',\n'31f4cfb4c71da44120752721103a16512444c13c2ac2d857a7e6f13cb679b427')\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ransomware continues to hit healthcare, critical services. There is also a related blog.\nRobbinhood is ransomware that has been involved in several high-profile incidents, including a 2019 attack on the city of Baltimore, Maryland. Robbinhood operators often employ a distinctive defense evasion technique, where they load a vulnerable driver on to a target and exploit it, in order to turn off security software -- essentially using the driver as malware.\nThe following query detects if a device contains the vulnerable drivers. These are often, but not always, implanted on the target by operators seeking to use this technique to turn off security software.\nFor a query that detects a later stage of this technique, see Detect security evasion related to the Robbinhood ransomware campaign.\nReferences:\nhttps://www.microsoft.com/security/blog/2020/04/28/ransomware-groups-continue-to-target-healthcare-critical-services-heres-how-to-reduce-risk/\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Ransom:Win32/Robinhood.A&ThreatID=2147735370\nhttps://www.nytimes.com/2019/05/22/us/baltimore-ransomware.html\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/robbinhood-evasion.yaml", "query_name": "robbinhood-evasion", "query": "// RobbinHood execution and security evasion\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n| where InitiatingProcessFileName =~ \"winlogon.exe\"\n| where FileName == \"cmd.exe\" and ProcessCommandLine has_any(\"taskkill\", \"net\",\n\"robbin\", \"vssadmin\", \"bcdedit\", \"wevtutil\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ransomware continues to hit healthcare, critical services. There is also a related blog.\nRobbinhood is ransomware that has been involved in several high-profile incidents, including a 2019 attack on the city of Baltimore, Maryland. Robbinhood operators often employ a distinctive defense evasion technique, where they load a vulnerable driver on to a target and exploit it, in order to turn off security software -- essentially using the driver as malware.\nThe following query detects a late stage of this technique, when the operator is issuing commands to turn off the driver.\nFor a query that detects an earlier stage of this technique, see Detect loading of vulnerable drivers by Robbinhood ransomware campaign.\nReferences:\nhttps://www.microsoft.com/security/blog/2020/04/28/ransomware-groups-continue-to-target-healthcare-critical-services-heres-how-to-reduce-risk/\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Ransom:Win32/Robinhood.A&ThreatID=2147735370\nhttps://www.nytimes.com/2019/05/22/us/baltimore-ransomware.html\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/SEABORGIUMDomainIOCsAug2022.yaml", "query_name": "SEABORGIUM-Domain IOCs", "query": "let IOCs_Domains = pack_array(\"cache-dns.com\",\"cache-dns-forwarding.com\",\"cache-dns-preview.com\",\"cache-docs.com\",\"cache-pdf.com\",\"cache-pdf.online\",\"cache-services.live\",\n                              \"cloud-docs.com\",\"cloud-drive.live\",\"cloud-storage.live\",\"docs-cache.com\",\"docs-forwarding.online\",\"docs-info.com\",\"docs-shared.com\",\n                              \"docs-shared.online\",\"docs-view.online\",\"document-forwarding.com\",\"document-online.live\",\"document-preview.com\",\"documents-cloud.com\",\n                              \"documents-cloud.online\",\"documents-forwarding.com\",\"document-share.live\",\"documents-online.live\",\"documents-pdf.online\",\"documents-preview.com\",\n                              \"documents-view.live\",\"document-view.live\",\"drive-docs.com\",\"drive-share.live\",\"goo-link.online\",\"hypertextteches.com\",\"mail-docs.online\",\n                              \"officeonline365.live\",\"online365-office.com\",\"online-document.live\",\"online-storage.live\",\"pdf-cache.com\",\"pdf-cache.online\",\"pdf-docs.online\",\n                              \"pdf-forwarding.online\",\"protection-checklinks.xyz\",\"protection-link.online\",\"protectionmail.online\",\"protection-office.live\",\"protect-link.online\",\n                              \"proton-docs.com\",\"proton-reader.com\",\"proton-viewer.com\",\"relogin-dashboard.online\",\"safe-connection.online\",\"safelinks-protect.live\",\"secureoffice.live\",                                \n                              \"webresources.live\",\"word-yand.live\",\"yandx-online.cloud\",\"y-ml.co\",\"docs-drive.online\",\"docs-info.online\",\"cloud-mail.online\",\"onlinecloud365.live\",\n                              \"pdf-cloud.online\",\"pdf-shared.online\",\"proton-pdf.online\",\"proton-view.online\",\"cloud-mail.online\",\"office365-online.live\",\"doc-viewer.com\",\n                              \"file-milgov.systems\",\"office-protection.online\");\nDeviceNetworkEvents \n| where RemoteUrl has_any(IOCs_Domains)", "attributes": {"description": "'This query identifies matches based on domain IOCs related to SEABORGIUM against Microsoft Defender for Endpoint device network connections'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/snip3-aviation-targeting-emails.yaml", "query_name": "snip3-aviation-targeting-emails", "query": "let SubjectTerms = \npack_array(\"Cargo Charter\",\"Airbus Meeting\",\"WorldWide Symposium\",\"Airbus Family\",\"Flight Request\",\n\"Advice from NetJets\",\"May/ACMI\",\"AIRCRAFT PRESENTATION\",\"Airworthiness\", \"Air Quote\", \"RFQ #9B17811\");\nEmailEvents\n| where SenderDisplayName has_any(SubjectTerms)\n// Optional Sender restriction for organizations with high FP\n// where SenderIpv4 == \"192.145.239.18\"  \n| where EmailDirection == \"Inbound\"  \n| join EmailUrlInfo on $left.NetworkMessageId == $right.NetworkMessageId\n| where Url has_any(\"drive.google.com\",\"1drv.ms\",\"onedrive.live.com\")\n| take 100\n", "attributes": {"description": "Snip3 is a family of related remote access trojans. Although the malware in this family contain numerous small variations, they all exhibit similar behaviors and techniques.\nThe following query looks for keywords observed in emails involved in a Snip3-associated campaign in April and May of 2021. The emails often have an aviation theme, and the campaign primarily targets organizations involved in travel or  aviation. Note that keywords may change overtime. These emails were used to send malicious legitimate hosting provider links that redirected to VBS documents hosting loaders. The loaders initiate RevengeRAT or AsyncRAT downloads that eventually establish persistence on targets and exfiltrate data.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/snip3-detectsanboxie-function-call.yaml", "query_name": "snip3-detectsanboxie-function-call", "query": "DeviceEvents\n| where ActionType == \"PowerShellCommand\" \n| where AdditionalFields == \"{\\\"Command\\\":\\\"DetectSandboxie\\\"}\"\n", "attributes": {"description": "Snip3 is a family of related remote access trojans. Although the malware in this family contain numerous small variations, they all exhibit similar behaviors and techniques.\nThe following query looks for a function call to a method named DetectSandboxie. This method is used in RevengeRAT and AsyncRAT instances involved in a campaign targeting the aviation industry, first observed in 2021. It has also been associated in the past other malware, such as WannaCry and QuasarRAT. Individual PowerShell functions can be detected in the same way in some instances, though care should be taken to ensure that the command name is unique -- otherwise, this query may return many false positives.\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/snip3-encoded-powershell-structure.yaml", "query_name": "snip3-encoded-powershell-structure", "query": "DeviceFileEvents\n| where InitiatingProcessFileName =~ \"powershell.exe\"\n| where InitiatingProcessCommandLine has_all (\"IEX\",\"Text.Encoding\",\"UTF8.GetString(@\")\n| where InitiatingProcessCommandLine has_any (\"Unrestricted\",\"Hidden\")\n", "attributes": {"description": "Snip3 is a family of related remote access trojans. Although the malware in this family contain numerous small variations, they all exhibit similar behaviors and techniques.\nThe following query looks for the method that Snip3 malware use to obfuscate PowerShell commands with UTF8 encoding. This technique is intended to evade detection from security products, and avoids the more standard switches used for encoding in malware such as Emotet.\nAt present, this method of encoding is much more rare, being seen largely with loader installation of RevengeRAT, AsyncRAT and other RATs used in campaigns targeting the aviation industry.\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/snip3-malicious-network-connectivity.yaml", "query_name": "snip3-malicious-network-connectivity", "query": "DeviceNetworkEvents \n| where InitiatingProcessFileName in (\"RegSvcs.exe\",\"RegAsm.exe\", \"InstallUtil.exe\") \n| where InitiatingProcessCommandLine in (\"\\\"RegAsm.exe\\\"\",\"\\\"RegSvcs.exe\\\"\",\"\\\"InstallUtil.exe\\\"\") \n| where InitiatingProcessParentFileName endswith \"Powershell.exe\"\n", "attributes": {"description": "Snip3 is a family of related remote access trojans. Although the malware in this family contain numerous small variations, they all exhibit similar behaviors and techniques.\nThe following query looks for potentially hollowed processes that may be used to facilitate command-and-control or exfiltration by Snip3 malware. This technique has been used in recent cases to exfiltrate data, including credentials.\nThe query may return additional malware or campaigns not necessarily associated with Snip3. However, Microsoft recommends triaging all non-benign results as potential malware.\n", "techniques": NaN, "tactics": ["Command and control", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/snip3-revengerat-c2-exfiltration.yaml", "query_name": "snip3-revengerat-c2-exfiltration", "query": "DeviceNetworkEvents \n| where RemoteUrl in (\"mail.alamdarhardware.com\",\"kexa600200.ddns.net\",\"h0pe1759.ddns.net\",\"n0ahark2021.ddns.net\",\" kimjoy007.dyndns.org\",\" kimjoy.ddns.net\",\" asin8988.ddns.net\",\" asin8989.ddns.net\", \"asin8990.ddns.net\")\n", "attributes": {"description": "Snip3 is a family of related remote access trojans. Although the malware in this family contain numerous small variations, they all exhibit similar behaviors and techniques.\nThe following query looks for network connections using any protocols associated with recent RevengeRAT, AsyncRAT, and other malware campaigns targeting the aviation industry.\nThis activity is often followed by connections to copy-and-paste sites such as pastebin.com, stikked.ch, academia.edu, and archive.org. Many of these connections will occur on non-standard ports.\n", "techniques": NaN, "tactics": ["Command and control", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Threat%20actor%20Phosphorus%20masquerading%20as%20conference%20organizers%20%281%29.yaml", "query_name": "Threat actor Phosphorus masquerading as conference organizers (1)", "query": "//Filter for emails that were delivered check the FinalEmailAction to see if there was policy applied on this email\nlet MaliciousSenders = dynamic([\"t20saudiarabia@outlook.sa\", \"t20saudiarabia@hotmail.com\", \"t20saudiarabia@gmail.com\", \"munichconference@outlook.com\",  \n\"munichconference@outlook.de\", \"munichconference1962@gmail.com\"]);\nEmailEvents\n| where SenderFromAddress  in~ (MaliciousSenders) and DeliveryAction == \"Delivered\"\n", "attributes": {"description": "Identify prior activity from this campaign using IOCs shared by Microsoft's Threat Intelligence Center, or MSTIC.\nRead more: https://blogs.microsoft.com/on-the-issues/2020/10/28/cyberattacks-phosphorus-t20-munich-security-conference/\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Threat%20actor%20Phosphorus%20masquerading%20as%20conference%20organizers%20%282%29.yaml", "query_name": "Threat actor Phosphorus masquerading as conference organizers (2)", "query": "//Filter for emails that were delivered and check if there was any action taken on them post delivery, by joining with EmailPostDeliveryEvents\nlet MaliciousSenders = dynamic([\"t20saudiarabia@outlook.sa\", \"t20saudiarabia@hotmail.com\", \"t20saudiarabia@gmail.com\", \"munichconference@outlook.com\",  \n\"munichconference@outlook.de\", \"munichconference1962@gmail.com\"]);\nEmailEvents\n| where SenderFromAddress  in~ (MaliciousSenders) and DeliveryAction == \"Delivered\"\n| join EmailPostDeliveryEvents on NetworkMessageId, RecipientEmailAddress \n", "attributes": {"description": "Identify prior activity from this campaign using IOCs shared by Microsoft's Threat Intelligence Center, or MSTIC.\nRead more: https://blogs.microsoft.com/on-the-issues/2020/10/28/cyberattacks-phosphorus-t20-munich-security-conference/\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Threat%20actor%20Phosphorus%20masquerading%20as%20conference%20organizers.yaml", "query_name": "Threat actor Phosphorus masquerading as conference organizers", "query": "//All emails from the threat actor Phosphorus, masquerading as conference organizers, based on the IOCs shared \n// by Microsoft's Threat Intelligence Center in: https://blogs.microsoft.com/on-the-issues/2020/10/28/cyberattacks-phosphorus-t20-munich-security-conference/\nlet MaliciousSenders = dynamic([\"t20saudiarabia@outlook.sa\", \"t20saudiarabia@hotmail.com\", \"t20saudiarabia@gmail.com\", \"munichconference@outlook.com\",  \n\"munichconference@outlook.de\", \"munichconference1962@gmail.com\"]);\nEmailEvents\n| where SenderFromAddress  in~ (MaliciousSenders)\n", "attributes": {"description": "Identify prior activity from this campaign using IOCs shared by Microsoft's Threat Intelligence Center, or MSTIC.\nRead more: https://blogs.microsoft.com/on-the-issues/2020/10/28/cyberattacks-phosphorus-t20-munich-security-conference/\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/WastedLocker%20Downloader.yaml", "query_name": "WastedLocker Downloader", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName =~ 'wscript.exe' and FileName =~ 'powershell.exe' and InitiatingProcessCommandLine matches regex @\"(?i)\\\\chrome\\.update\\..+?\\.js\"\n", "attributes": {"description": "This query identifies the launch pattern associated with wastedlocker ransomware.\nReference writeup: https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/wastedlocker-ransomware-us\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazacall/Bazacall%20Emails.yaml", "query_name": "Bazacall Emails", "query": "EmailEvents\n| where Subject matches regex @\"[A-Z]{1,3}\\d{9,15}\"\n    and Subject has_any('trial', 'free', 'demo', 'membership', 'premium', 'gold', 'notification', 'notice', 'claim', 'order', 'license', 'licenses')\n", "attributes": {"description": "Bazacall malware uses emails that contain a phone number for the user to call in order to cancel a fake subscription. These emails contain no links or attachments, and use automatic payment lures to trick users into contacting the number included in the email.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazacall/Cobalt%20Strike%20Lateral%20Movement.yaml", "query_name": "Cobalt Strike Lateral Movement", "query": "AlertInfo\n| where Title in(\"File dropped and launched from remote location\", \"Suspicious transfer of an executable file\")\n// Joining in instances where Cobalt Strike's built-in PsExec is used for lateral movement\n| join AlertEvidence on $left.AlertId == $right.AlertId\n| where FileName matches regex @\"^([a-z0-9]){7}\\.exe$\" and FileName matches regex \"[0-9]{1,5}\"\n", "attributes": {"description": "Microsoft has observed Bazacall using Cobalt Strike in order to move laterally to other machines on the network.\n", "techniques": NaN, "tactics": ["Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazacall/Dropping%20payload%20via%20certutil.yaml", "query_name": "Dropping payload via certutil", "query": "DeviceFileEvents\n| where InitiatingProcessFileName !~ \"certutil.exe\"\n| where InitiatingProcessFileName !~ \"cmd.exe\"\n| where InitiatingProcessCommandLine has_all(\"-urlcache\", \"split\", \"http\")\n", "attributes": {"description": "BazaCall is a campaign that manipulate users into calling a customer support center, where they are instructed to download an Excel file to unsubscribe from a phony service. When the user opens the Excel file, they are prompted to enable a malicious macro that infects their device with BazaLoader.\nThis query hunts for an attacker-created copy of certutil.exe, a legitimate process, which the macro uses to download BazaLoader.\n", "techniques": NaN, "tactics": ["Initial access", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazacall/Excel%20file%20download%20domain%20pattern.yaml", "query_name": "Excel file download domain pattern", "query": "DeviceNetworkEvents\n| where RemoteUrl matches regex @\".{14}\\.xyz/config\\.php\"\n", "attributes": {"description": "BazaCall is a campaign that manipulate users into calling a customer support center, where they are instructed to download an Excel file to unsubscribe from a phony service. When the user opens the Excel file, they are prompted to enable a malicious macro that infects their device with BazaLoader.\nThis query surfaces connections to the distinctive .xyz domains that the BazaCall campaign uses to host malicious Excel files.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazacall/Excel%20Macro%20Execution.yaml", "query_name": "Excel Macro Execution", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName =~ \"excel.exe\"\n    and ProcessCommandLine has_all('mkdir', '&& copy', 'certutil.exe')\n", "attributes": {"description": "Bazacall uses malicious macro-enabled Excel documents to execute their payload.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazacall/Malicious%20Excel%20Delivery.yaml", "query_name": "Malicious Excel Delivery", "query": "DeviceFileEvents\n| where FileOriginUrl has \"/cancel.php\" and FileOriginReferrerUrl has \"/account\"\n  or FileOriginUrl has \"/download.php\" and FileOriginReferrerUrl has \"/case\"\n", "attributes": {"description": "Bazacall uses malicious Excel files to execute payloads on affected devices.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazacall/NTDS%20theft.yaml", "query_name": "NTDS theft", "query": "DeviceProcessEvents\n| where FileName =~ \"ntdsutil.exe\"\n| where ProcessCommandLine has_any(\"full\", \"fu\")\n| where ProcessCommandLine has_any (\"temp\", \"perflogs\", \"programdata\")\n// Exclusion\n| where ProcessCommandLine !contains @\"Backup\"\n", "attributes": {"description": "Microsoft has observed compromises related to Bazacall resulting in theft of the Active Directory database using ntdsutil.exe.\n", "techniques": NaN, "tactics": ["Credential Access", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazacall/Renamed%20Rclone%20Exfil.yaml", "query_name": "Renamed Rclone Exfil", "query": "DeviceProcessEvents \n| where ProcessVersionInfoProductName has \"rclone\" and not(FileName has \"rclone\")\n", "attributes": {"description": "Microsoft has observed Bazacall using a renamed version of Rclone for data exfiltration.\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazacall/RunDLL%20Suspicious%20Network%20Connection.yaml", "query_name": "RunDLL Suspicious Network Connection", "query": "DeviceNetworkEvents\n| where InitiatingProcessFileName =~ 'rundll32.exe' and InitiatingProcessCommandLine has \",GlobalOut\"\n", "attributes": {"description": "During the chain of events from Bazacall to Bazaloader, RunDLL makes several network connections, including to command and control (C2) infrastructure. The command line for these connections contains a specific process paramter, \",GlobalOut\" that can surface potentially malicious activity related to Bazacall and Bazaloader.\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazarloader/Stolen%20Images%20Execution.yaml", "query_name": "Stolen Images Execution", "query": "DeviceProcessEvents\n| where FileName =~ \"wscript.exe\" and ProcessCommandLine has_all(\"stolen\", \"images\")\n", "attributes": {"description": "The \"Stolen Images\" Bazarloader campaign uses fake copyright infingement contact form emails and malicious files pretending to contain \"stolen images\" to trick users into downloading the malware.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazarloader/Zip-Doc%20-%20Creation%20of%20JPG%20Payload%20File.yaml", "query_name": "Zip-Doc - Creation of JPG Payload File", "query": "DeviceImageLoadEvents\n| where InitiatingProcessFileName =~ \"regsvr32.exe\" and InitiatingProcessCommandLine has \".jpg\" and FileName endswith \".jpg\"\n| summarize by FileName, SHA256, DeviceId, bin(Timestamp, 1d)\n", "attributes": {"description": "In the campaign where Bazarloader is delivered via emails containing pw protected zip attachments, regsvr32.exe is used to launch a malicious payload that is disguised as a JPG file.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Bazarloader/Zip-Doc%20-%20Word%20Launching%20MSHTA.yaml", "query_name": "Zip-Doc - Word Launching MSHTA", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName =~ 'WINWORD.EXE' and FileName =~ 'cmd.exe' and ProcessCommandLine has_all('hta')\n", "attributes": {"description": "The pw protected zip attachment -> Word doc delivery method of Bazarloader utilizes Word to create an .hta file and launch it via MSHTA to connect to a malicious domain and pull down the Bazarloader paylaod.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/EUROPIUM/Identify%20EUROPIUM%20IOCs.yaml", "query_name": "Identify EUROPIUM IOCs", "query": "DeviceFileEvents \n| where SHA256 in (\"f116acc6508843f59e59fb5a8d643370dce82f492a217764521f46a856cc4cb5\",\"e1204ebbd8f15dbf5f2e41dddc5337e3182fc4daf75b05acc948b8b965480ca0\",\"bad65769c0b416bb16a82b5be11f1d4788239f8b2ba77ae57948b53a69e230a6\",\"bb45d8ffe245c361c04cca44d0df6e6bd7596cabd70070ffe0d9f519e3b620ea\",\"d1bec48c2a6a014d3708d210d48b68c545ac086f103016a20e862ac4a189279e\",\"fb49dce92f9a028a1da3045f705a574f3c1997fe947e2c69699b17f07e5a552b\",\"45bf0057b3121c6e444b316afafdd802d16083282d1cbfde3cdbf2a9d0915ace\",\"f8db380cc495e98c38a9fb505acba6574cbb18cfe5d7a2bb6807ad1633bf2df8\",\"7ad64b64e0a4e510be42ba631868bbda8779139dc0daad9395ab048306cc83c5\",\"cad2bc224108142b5aa19d787c19df236b0d12c779273d05f9b0298a63dc1fe5\",\"84be43f5830707cd421979f6775e9edde242bab98003644b3b491dbc08cc7c3e\")\n", "attributes": {"description": "The following query can locate activity possibly associated with the EUROPIUM threat actor\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/EUROPIUM/Identify%20Microsoft%20Defender%20Antivirus%20detection%20related%20to%20EUROPIUM.yaml", "query_name": "Identify Microsoft Defender Antivirus detection related to EUROPIUM", "query": "let europium_sigs = dynamic([\"BatRunGoXml\", \"WprJooblash\", \"Win32/Eagle!MSR\", \"Win32/Debitom.A\"]);  \nAlertEvidence \n| where ThreatFamily in~ (europium_sigs) \n| join AlertInfo on AlertId \n| project ThreatFamily, AlertId \n", "attributes": {"description": "This query looks for Microsoft Defender Antivirus detections related to EUROPIUM actor\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/EUROPIUM/Identify%20unusual%20identity%20additions%20related%20to%20EUROPIUM.yaml", "query_name": "Identify unusual identity additions related to EUROPIUM", "query": "DeviceProcessEvents \n| where ProcessCommandLine has_any (\"New-Mailbox\",\"Update-RoleGroupMember\") and ProcessCommandLine has \"HealthMailbox55x2yq\"\n", "attributes": {"description": "This query looks for identity add through exchange PowerShell\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Jupyter-Solarmaker/deimos-component-execution.yaml", "query_name": "deimos-component-execution", "query": "DeviceEvents   \n| where InitiatingProcessFileName =~ \"powershell.exe\"\n| where ActionType == \"AmsiScriptContent\"\n| where AdditionalFields endswith '[mArS.deiMos]::inteRaCt()\"}'\n| project InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessCommandLine, ActionType, AdditionalFields\n", "attributes": {"description": "Jupyter, otherwise known as SolarMarker, is a malware family and cluster of components known for its info-stealing and backdoor capabilities that mainly proliferates through search engine optimization manipulation and malicious advertising in order to successfully encourage users to download malicious templates and documents. This malware has been popular since 2020 and currently is still active as of 2021.\n", "techniques": NaN, "tactics": ["Execution", "Collection", "Exfiltration", "Impact", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Jupyter-Solarmaker/evasive-powershell-executions.yaml", "query_name": "evasive-powershell-executions", "query": "DeviceProcessEvents\n| where FileName =~ \"powershell.exe\"\n| where ProcessCommandLine has_all\n(\"-command\",\"FromBase64String\",\"));remove-item $\",\".length;$j++){$\",\"$i++;if($i -ge $\",\"-bxor\",\"UTF8.GetString\")\n", "attributes": {"description": "Jupyter, otherwise known as SolarMarker, is a malware family and cluster of components known for its info-stealing and backdoor capabilities that mainly proliferates through search engine optimization manipulation and malicious advertising in order to successfully encourage users to download malicious templates and documents. This malware has been popular since 2020 and currently is still active as of 2021.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Jupyter-Solarmaker/evasive-powershell-strings.yaml", "query_name": "evasive-powershell-strings", "query": "DeviceProcessEvents\n| where FileName == \"powershell.exe\"\n| where ProcessCommandLine has_all(\"-ep bypass\",\"-command\",\"get-content\",\"remove-item\",\"iex\")\n", "attributes": {"description": "This query searches for a string pattern detected in evasive PowerShell usage. Jupyter or SolarMarker will iterate on this pattern multiple times to read data and call additional processes. This query is not fully specific to Jupyter or SolarMarker, and will also return other malicious malware, but is unlikely to return false positives.\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Jupyter-Solarmaker/successive-tk-domain-calls.yaml", "query_name": "successive-tk-domain-calls", "query": "DeviceNetworkEvents\n| where RemoteUrl endswith \".tk\"\n| summarize make_set(RemoteUrl) by DeviceId,bin(Timestamp, 10m)\n| extend domainCount = array_length(set_RemoteUrl)\n| where  domainCount >= 5\n", "attributes": {"description": "Jupyter, otherwise known as SolarMarker, is a malware family and cluster of components known for its info-stealing and backdoor capabilities that mainly proliferates through search engine optimization manipulation and malicious advertising in order to successfully encourage users to download malicious templates and documents. This malware has been popular since 2020 and currently is still active as of 2021.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/KNOTWEED/KNOTWEED-AVDetections.yaml", "query_name": "KNOTWEED-AV Detections", "query": "// AV Detections\nlet knotweed_sigs = dynamic([\"JumplumpDropper\", \"Jumplump\", \"Corelump\", \"Mexlib\", \"Medcerc \", \"SuspModuleLoad\"]);\nAlertEvidence \n| where Timestamp > ago(30d) \n| where ThreatFamily in~ (knotweed_sigs)\n| join MtpAlerts on AlertId\n| project OriginalReportOccurrenceTime, LastSeen, MachineId1, ThreatFamily, AlertId\n", "attributes": {"description": "'This query looks for Microsoft Defender Antivirus detections with the family names used by KNOTWEED'\n", "techniques": [null], "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/KNOTWEED/KNOTWEED-COMRegistryKeyModifiedtoPointtoColorProfileFolder.yaml", "query_name": "KNOTWEED-COM Registry Key Modified to Point to Color Profile Folder", "query": "// COM hi-jack via registry \nlet guids = dynamic([\"{ddc05a5a-351a-4e06-8eaf-54ec1bc2dcea}\",\"{1f486a52-3cb1-48fd-8f50-b8dc300d9f9d}\",\"{4590f811-1d3a-11d0-891f-00aa004b2e24}\", \"{4de225bf-cf59-4cfc-85f7-68b90f185355}\", \"{F56F6FDD-AA9D-4618-A949-C1B91AF43B1A}\"]); \nDeviceRegistryEvents \n| where ActionType == \"RegistryValueSet\" \n| where RegistryKey startswith \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Classes\\\\CLSID\" \n| where RegistryKey has_any (guids) \n| where RegistryValueData has \"System32\\\\spool\\\\drivers\\\\color\" \n", "attributes": {"description": "'This query identifies modifications to COM registry keys to point to executable files in C:\\Windows\\System32\\spool\\drivers\\color\\'\n", "techniques": [null], "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/KNOTWEED/KNOTWEED-DomainIOCsJuly2022.yaml", "query_name": "KNOTWEED-Domain IOCs", "query": "// c2 domains \nlet c2domains = dynamic([\"acrobatrelay[.]com\",\"finconsult[.]cc\",\"realmetaldns[.]com\"]); \nlet iocs = print c2domains \n| mv-expand domains=print_0 \n| extend domainioc = replace_string(tostring(domains),\"[.]\",\".\") \n| distinct domainioc; \nDeviceNetworkEvents \n| where Timestamp > ago(1d) \n| where RemoteUrl has_any(iocs)\n", "attributes": {"description": "'This query identifies matches based on domain IOCs related to KNOTWEED against Microsoft Defender for Endpoint device network connections'\n", "techniques": [null], "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/KNOTWEED/KNOTWEED-DownloadingnewfileusingCurl.yaml", "query_name": "KNOTWEED-Downloading new file using Curl", "query": "let known_files = DeviceNetworkEvents\n| where Timestamp between (ago(7d)..ago(1d))\n| where InitiatingProcessFileName has \"curl\" \n| extend url = extract(\"http[s]?:\\\\/\\\\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\", 0,InitiatingProcessCommandLine)\n| extend ip = extract(\"(\\\\b25[0-5]|\\\\b2[0-4][0-9]|\\\\b[01]?[0-9][0-9]?)(\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}[^ ]*\", 0, InitiatingProcessCommandLine)\n| extend remote_file = iif(isnotempty(url), url, ip)\n| summarize by remote_file;\nDeviceNetworkEvents\n| where Timestamp > ago(1d)\n| where InitiatingProcessFileName has \"curl\" \n| extend url = extract(\"http[s]?:\\\\/\\\\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\", 0,InitiatingProcessCommandLine)\n| extend ip = extract(\"(\\\\b25[0-5]|\\\\b2[0-4][0-9]|\\\\b[01]?[0-9][0-9]?)(\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}[^ ]*\", 0, InitiatingProcessCommandLine)\n| extend remote_file = iif(isnotempty(url), url, ip)\n| where remote_file !in (known_files)\n", "attributes": {"description": "'This query looks for new files being downloaded using Curl.'\n", "techniques": [null], "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/KNOTWEED/KNOTWEED-FileHashIOCsJuly2022.yaml", "query_name": "KNOTWEED-File Hash IOCs", "query": "// malware hash indicators \nlet hashes = dynamic([ \n\"78c255a98003a101fa5ba3f49c50c6922b52ede601edac5db036ab72efc57629\", // SHA-256 Malicious Excel document and VBA  \n\"0588f61dc7e4b24554cffe4ea56d043d8f6139d2569bc180d4a77cf75b68792f\", // SHA-256 Malicious Excel document and VBA  \n\"441a3810b9e89bae12eea285a63f92e98181e9fb9efd6c57ef6d265435484964\", // SHA-256 Jumplump malware  \n\"cbae79f66f724e0fe1705d6b5db3cc8a4e89f6bdf4c37004aa1d45eeab26e84b\", // SHA-256 Jumplump malware  \n\"fd6515a71530b8329e2c0104d0866c5c6f87546d4b44cc17bbb03e64663b11fc\", // SHA-256 Jumplump malware  \n\"5d169e083faa73f2920c8593fb95f599dad93d34a6aa2b0f794be978e44c8206\", // SHA-256 Jumplump malware  \n\"7f29b69eb1af1cc6c1998bad980640bfe779525fd5bb775bc36a0ce3789a8bfc\", // SHA-256 Jumplump malware  \n\"02a59fe2c94151a08d75a692b550e66a8738eb47f0001234c600b562bf8c227d\", // SHA-256 Jumplump malware  \n\"7f84bf6a016ca15e654fb5ebc36fd7407cb32c69a0335a32bfc36cb91e36184d\", // SHA-256 Jumplump malware  \n\"afab2e77dc14831f1719e746042063a8ec107de0e9730249d5681d07f598e5ec\", // SHA-256 Jumplump malware  \n\"894138dfeee756e366c65a197b4dbef8816406bc32697fac6621601debe17d53\", // SHA-256 Jumplump malware  \n\"4611340fdade4e36f074f75294194b64dcf2ec0db00f3d958956b4b0d6586431\", // SHA-256 Jumplump malware  \n\"7f29b69eb1af1cc6c1998bad980640bfe779525fd5bb775bc36a0ce3789a8bfc\", // SHA-256 Jumplump malware  \n\"c96ae21b4cf2e28eec222cfe6ca903c4767a068630a73eca58424f9a975c6b7d\", // SHA-256 Corelump malware  \n\"fa30be45c5c5a8f679b42ae85410f6099f66fe2b38eb7aa460bcc022babb41ca\", // SHA-256 Mex tool  \n\"e64bea4032cf2694e85ede1745811e7585d3580821a00ae1b9123bb3d2d442d6\"  // SHA-256 Passlib tool  \n]); \nlet iochashes =  \nprint hashes \n| mv-expand sha256hashes=hashes \n| distinct tostring(sha256hashes); \nunion withsource=TableName Device* \n| where Timestamp > ago(7d) \n| where SHA256 in (iochashes)\n", "attributes": {"description": "'This query identifies matches based on KNOTWEED file hash IOCs across Microsoft Defender for Endpoint tables'\n", "techniques": [null], "tactics": ["InitialAccess", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/KNOTWEED/KNOTWEED-PEFileDroppedinColorProfileFolder.yaml", "query_name": "KNOTWEED-PE File Dropped in Color Profile Folder", "query": "// PE file dropped in C:\\Windows\\System32\\spool\\drivers\\color\\ \nDeviceFileEvents \n| where Timestamp > ago(7d) \n| where ActionType == \"FileCreated\" \n| where FolderPath has \"C:\\\\Windows\\\\System32\\\\spool\\\\drivers\\\\color\\\\\" \n| where FileName endswith \".exe\" or FileName endswith \".dll\"\n", "attributes": {"description": "'This query identifies modifications to COM registry keys to point to executable files in C:\\Windows\\System32\\spool\\drivers\\color\\'\n", "techniques": [null], "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/LemonDuck/LemonDuck-competition-killer.yaml", "query_name": "LemonDuck-competition-killer", "query": "DeviceProcessEvents\n| where ProcessCommandLine has_all(\"schtasks.exe\",\"/Delete\",\"/TN\",\"/F\")\n| summarize make_set(ProcessCommandLine) by DeviceId\n| extend DeleteVolume = array_length(set_ProcessCommandLine)\n| where set_ProcessCommandLine has_any(\"Mysa\",\"Sorry\",\"Oracle Java Update\",\"ok\")\n| where DeleteVolume >= 40 and DeleteVolume <= 80\n", "attributes": {"description": "LemonDuck is an actively updated and robust malware primarily known for its botnet and cryptocurrency mining objectives. First discovered in 2019, LemonDuck has since adopted more sophisticated behavior and escalated its operations in 2021. Today, beyond using resources for its traditional bot and mining activities, LemonDuck steals credentials, removes security controls, spreads via emails, moves laterally, and ultimately drops more tools for human-operated activity.\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Defense evasion", "Impact", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/LemonDuck/LemonDuck-component-download-structure.yaml", "query_name": "LemonDuck-component-download-structure", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName =~ \"cmd.exe\"\n| where InitiatingProcessCommandLine has_all(\"echo\",\"tmp+\",\".bin\",\"gmd5\",\"downloaddata\",\"down_url\")\n", "attributes": {"description": "LemonDuck is an actively updated and robust malware primarily known for its botnet and cryptocurrency mining objectives. First discovered in 2019, LemonDuck has since adopted more sophisticated behavior and escalated its operations in 2021. Today, beyond using resources for its traditional bot and mining activities, LemonDuck steals credentials, removes security controls, spreads via emails, moves laterally, and ultimately drops more tools for human-operated activity.\n", "techniques": NaN, "tactics": ["Defense evasion", "Command and control", "Impact", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/LemonDuck/LemonDuck-component-names.yaml", "query_name": "LemonDuck-component-names", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName =~ \"cmd.exe\"\n| where InitiatingProcessCommandLine has_any(\"kr.bin\",\"if.bin\",\"m6.bin\")\n", "attributes": {"description": "LemonDuck is an actively updated and robust malware primarily known for its botnet and cryptocurrency mining objectives. First discovered in 2019, LemonDuck has since adopted more sophisticated behavior and escalated its operations in 2021. Today, beyond using resources for its traditional bot and mining activities, LemonDuck steals credentials, removes security controls, spreads via emails, moves laterally, and ultimately drops more tools for human-operated activity.\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Lateral movement", "Impact", "Vulnerability", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/LemonDuck/LemonDuck-control-structure.yaml", "query_name": "LemonDuck-control-structure", "query": "DeviceNetworkEvents\n| where InitiatingProcessFileName =~ \"powershell.exe\"\n| where InitiatingProcessCommandLine has_all(\"Exponent=\",\"FromBase64String\",\"$url+\")\n", "attributes": {"description": "LemonDuck is an actively updated and robust malware primarily known for its botnet and cryptocurrency mining objectives. First discovered in 2019, LemonDuck has since adopted more sophisticated behavior and escalated its operations in 2021. Today, beyond using resources for its traditional bot and mining activities, LemonDuck steals credentials, removes security controls, spreads via emails, moves laterally, and ultimately drops more tools for human-operated activity.\n", "techniques": NaN, "tactics": ["Command and control", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/LemonDuck/LemonDuck-defender-exclusions.yaml", "query_name": "LemonDuck-defender-exclusions", "query": "DeviceProcessEvents  \n| where InitiatingProcessCommandLine has_all (\"Set-MpPreference\", \"DisableRealtimeMonitoring\", \"Add-MpPreference\", \"ExclusionProcess\")  \n| project ProcessCommandLine, InitiatingProcessCommandLine, DeviceId, Timestamp  \n", "attributes": {"description": "LemonDuck is an actively updated and robust malware primarily known for its botnet and cryptocurrency mining objectives. First discovered in 2019, LemonDuck has since adopted more sophisticated behavior and escalated its operations in 2021. Today, beyond using resources for its traditional bot and mining activities, LemonDuck steals credentials, removes security controls, spreads via emails, moves laterally, and ultimately drops more tools for human-operated activity.\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/LemonDuck/LemonDuck-email-subjects.yaml", "query_name": "LemonDuck-email-subjects", "query": "EmailEvents\n| where Subject in ('The Truth of COVID-19','COVID-19 nCov Special info WHO','HALTH ADVISORY:CORONA VIRUS',\n'WTF','What the fcuk','good bye','farewell letter','broken file','This is your order?')\n| where AttachmentCount >= 1\n", "attributes": {"description": "LemonDuck is an actively updated and robust malware primarily known for its botnet and cryptocurrency mining objectives. First discovered in 2019, LemonDuck has since adopted more sophisticated behavior and escalated its operations in 2021. Today, beyond using resources for its traditional bot and mining activities, LemonDuck steals credentials, removes security controls, spreads via emails, moves laterally, and ultimately drops more tools for human-operated activity.\n", "techniques": NaN, "tactics": ["Initial access", "Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/LemonDuck/LemonDuck-id-generation.yaml", "query_name": "LemonDuck-id-generation", "query": "DeviceNetworkEvents\n| where InitiatingProcessFileName =~ \"powershell.exe\"\n| where InitiatingProcessCommandLine endswith \"(@($env:COMPUTERNAME,$env:USERNAME,(get-wmiobject Win32_ComputerSystemProduct).UUID,(random))-join'*'))\"\n", "attributes": {"description": "LemonDuck is an actively updated and robust malware primarily known for its botnet and cryptocurrency mining objectives. First discovered in 2019, LemonDuck has since adopted more sophisticated behavior and escalated its operations in 2021. Today, beyond using resources for its traditional bot and mining activities, LemonDuck steals credentials, removes security controls, spreads via emails, moves laterally, and ultimately drops more tools for human-operated activity.\n", "techniques": NaN, "tactics": ["Lateral movement", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/LemonDuck/LemonDuck-registration-function.yaml", "query_name": "LemonDuck-registration-function", "query": "DeviceEvents\n| where ActionType == \"PowerShellCommand\"\n| where AdditionalFields =~ \"{\\\"Command\\\":\\\"SIEX\\\"}\"\n", "attributes": {"description": "LemonDuck is an actively updated and robust malware primarily known for its botnet and cryptocurrency mining objectives. First discovered in 2019, LemonDuck has since adopted more sophisticated behavior and escalated its operations in 2021. Today, beyond using resources for its traditional bot and mining activities, LemonDuck steals credentials, removes security controls, spreads via emails, moves laterally, and ultimately drops more tools for human-operated activity.\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Lateral movement", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Log4J/Alerts%20related%20to%20Log4j%20vulnerability.yaml", "query_name": "Alerts related to Log4j vulnerability", "query": "AlertInfo\n| where Title in~('Suspicious script launched',\n'Exploitation attempt against Log4j (CVE-2021-44228)',\n'Suspicious process executed by a network service',\n'Possible target of Log4j exploitation (CVE-2021-44228)',\n'Possible target of Log4j exploitation',\n'Possible Log4j exploitation',\n'Network connection seen in CVE-2021-44228 exploitation',\n'Log4j exploitation detected',\n'Possible exploitation of CVE-2021-44228',\n'Possible target of Log4j vulnerability (CVE-2021-44228) scanning',\n'Possible source of Log4j exploitation',\n'Log4j exploitation attempt via cloud application', // Previously titled Exploitation attempt against Log4j\n'Log4j exploitation attempt via email' // Previously titled Log4j Exploitation Attempt\n)\n", "attributes": {"description": "Microsoft has observed attackers exploiting vulnerabilities associated with Log4J.\n", "techniques": NaN, "tactics": ["Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Log4J/Devices%20with%20Log4j%20vulnerability%20alerts%20and%20additional%20other%20alert%20related%20context.yaml", "query_name": "Devices with Log4j vulnerability alerts and additional other alert related context", "query": "// Get any devices with Log4J related Alert Activity\nlet DevicesLog4JAlerts = AlertInfo\n| where Title in~('Suspicious script launched',\n'Exploitation attempt against Log4j (CVE-2021-44228)',\n'Suspicious process executed by a network service',\n'Possible target of Log4j exploitation (CVE-2021-44228)',\n'Possible target of Log4j exploitation',\n'Possible Log4j exploitation',\n'Network connection seen in CVE-2021-44228 exploitation',\n'Log4j exploitation detected',\n'Possible exploitation of CVE-2021-44228',\n'Possible target of Log4j vulnerability (CVE-2021-44228) scanning',\n'Possible source of Log4j exploitation'\n'Log4j exploitation attempt via cloud application', // Previously titled Exploitation attempt against Log4j\n'Log4j exploitation attempt via email' // Previously titled Log4j Exploitation Attempt\n)\n// Join in evidence information\n| join AlertEvidence on AlertId\n| where DeviceId != \"\"\n| summarize by DeviceId, Title;\n// Get additional alert activity for each device\nAlertEvidence\n| where DeviceId in(DevicesLog4JAlerts)\n// Add additional info\n| join kind=leftouter AlertInfo on AlertId\n| summarize DeviceAlerts = make_set(Title), AlertIDs = make_set(AlertId) by DeviceId, bin(Timestamp, 1d)\n", "attributes": {"description": "Microsoft has observed threat actors exploiting vulnerabilities associated with Log4J.\n", "techniques": NaN, "tactics": ["Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Log4J/Suspicious%20JScript%20staging%20comment.yaml", "query_name": "Suspicious JScript staging comment", "query": "DeviceProcessEvents\n| where FileName =~ \"powershell.exe\"\n| where ProcessCommandLine has \"VMBlastSG\"\n", "attributes": {"description": "Microsoft has observed attackers who have gained entry to an environment via the Log4J vulnerability utilizing identifiable strings in PowerShell commands.\n", "techniques": NaN, "tactics": ["Execution", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Log4J/Suspicious%20PowerShell%20curl%20flags.yaml", "query_name": "Suspicious PowerShell curl flags", "query": "DeviceProcessEvents\n| where FileName =~ \"powershell.exe\"\n| where ProcessCommandLine has_all(\"-met\", \"POST\", \"-Body\")\n", "attributes": {"description": "Microsoft has observed attackers who have gained entry to an environment via the Log4J vulnerability utilizing uncommon PowerShell flags to communicate to command-and-control infrastructure.\n", "techniques": NaN, "tactics": ["Execution", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Log4J/Suspicious%20process%20event%20creation%20from%20VMWare%20Horizon%20TomcatService.yaml", "query_name": "Suspicious process event creation from VMWare Horizon TomcatService", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName has \"ws_TomcatService.exe\"\n| where FileName != \"repadmin.exe\"\n", "attributes": {"description": "Microsoft has observed attackers who have gained entry to an environment via the Log4J vulnerability utilizing the ws_TomcatService.exe process to launch malicious processes.\n", "techniques": NaN, "tactics": ["Execution", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Macaw%20Ransomware/Disable%20Controlled%20Folders.yaml", "query_name": "Disable Controlled Folders", "query": "DeviceProcessEvents \n| where InitiatingProcessFileName =~ 'cmd.exe' \n| where FileName =~ 'powershell.exe' and ProcessCommandLine has('powershell.exe  -command \"Set-MpPreference -EnableControlledFolderAccess Disabled\"') \n", "attributes": {"description": "Prior to deploying Macaw ransomware in an organization, the adversary will disable all controlled folders, which will enable them to be encrypted once the ransomware payload is deployed.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Macaw%20Ransomware/Imminent%20Ransomware.yaml", "query_name": "Imminent Ransomware", "query": "DeviceProcessEvents \n// Pivot on specific commands \n| where ProcessCommandLine has_any(\"-ExclusionPath\", \"Set-MpPreference\", \"advfirewall\", \"-ExclusionExtension\", \n\"-EnableControlledFolderAccess\", \"windefend\", \"onstart\", \"bcdedit\", \"Startup\") \n// Making list of found commands \n| summarize ProcessCommandLine = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 6h) \n// Extending columns for later aggregration, based on TTP \n| extend StartUpExclusionPath = iff(ProcessCommandLine has_all(\"-ExclusionPath\", \"Startup\"), 1, 0) \n| extend DefenderTamp = iff(ProcessCommandLine has \"Set-MpPreference\" \nand ProcessCommandLine has_any( \n\"-SevereThreatDefaultAction 6\" \n\"-HighThreatDefaultAction 6\", \n\"-ModerateThreatDefaultAction 6\", \n\"-LowThreatDefaultAction 6\" \n\"-ScanScheduleDay 8\"), 1, 0) \n| extend NetshFirewallTampering = iff(ProcessCommandLine has_all( \"netsh\", \"advfirewall\", \"allprofiles state off\"), 1, 0) \n| extend BatExclusion = iff(ProcessCommandLine has_all(\"-ExclusionExtension\", \".bat\"), 1, 0) \n| extend ExeExclusion = iff(ProcessCommandLine has_all(\"-ExclusionExtension\", \".exe\"), 1, 0) \n| extend DisableControlledFolderAccess = iff(ProcessCommandLine has_all(\"-EnableControlledFolderAccess\", \"Disabled\"), 1, 0) \n| extend ScDeleteDefend = iff(ProcessCommandLine has_all(\"sc\", \"delete\", \"windefend\"), 1, 0) \n| extend BootTampering = iff(ProcessCommandLine has_all(\"bcdedit\", \"default\") and ProcessCommandLine has_any (\"recoveryenabled No\", \"bootstatuspolicy ignoreallfailures\"), 1, 0) \n| extend SchTasks = iff(ProcessCommandLine has_all(\"/sc\", \"onstart\", \"system\", \"/create\", \"/delay\"), 1, 0) \n// Summarizing found commands \n| summarize by NetshFirewallTampering ,BatExclusion, ExeExclusion, DisableControlledFolderAccess, ScDeleteDefend, SchTasks, BootTampering, DefenderTamp, StartUpExclusionPath, DeviceId, Timestamp \n// Adding up each piece of evidence \n| extend EvidenceCount = NetshFirewallTampering + BatExclusion + ExeExclusion + DisableControlledFolderAccess + ScDeleteDefend + SchTasks + BootTampering + DefenderTamp + StartUpExclusionPath \n| where EvidenceCount > 4 \n", "attributes": {"description": "Directly prior to deploying Macaw ransomware in an organization, the attacker will run several commands designed to disable security tools and system recovery tools.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Macaw%20Ransomware/Inhibit%20recovery%20by%20disabling%20tools%20and%20functionality.yaml", "query_name": "Inhibit recovery by disabling tools and functionality", "query": "DeviceProcessEvents \n| where ProcessCommandLine has_all (\"reg\", \"add\") \n| where ProcessCommandLine has_any(\"DisableTaskMgr\", \"DisableCMD\", \"DisableRegistryTools\", \"NoRun\") and ProcessCommandLine has \"REG_DWORD /d \\\"1\\\"\" \n| summarize ProcessCount = dcount(ProcessCommandLine), make_set(ProcessCommandLine) by InitiatingProcessCommandLine, DeviceId, bin(Timestamp, 3m) \n| where ProcessCount > 2 \n", "attributes": {"description": "Prior to deploying Macaw ransomware in an organization, the adversary will disable several tools and functions in order to inhibit later recovery efforts.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Macaw%20Ransomware/Mass%20account%20password%20change.yaml", "query_name": "Mass account password change", "query": "DeviceProcessEvents \n| where ProcessCommandLine has_all('user', '/Domain', '/Active:Yes', '/PasswordChg:No') \n| summarize commands=count() by DeviceId, bin(Timestamp, 1d)  \n| where commands > 200 \n", "attributes": {"description": "Prior to deploying Macaw ransomware in an organization, adversaries will change the password for hundreds or thousands of accounts in order to lock users out of the network and impeded recovery efforts.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Macaw%20Ransomware/PSExec%20Attrib%20commands.yaml", "query_name": "PSExec Attrib commands", "query": "DeviceProcessEvents \n| where InitiatingProcessParentFileName endswith \"PSEXESVC.exe\" \n| where InitiatingProcessCommandLine has \".bat\" \n| where FileName =~ \"cmd.exe\" and ProcessCommandLine has_all(\"-s\", \"-h\", \"-r\", \"-a\", \"*.*\") \n| take 100 \n", "attributes": {"description": "Prior to deploying Macaw ransomware in an organization, adversaries wil use Attrib to display file attribute information on multiple drives and all subfolders.\n", "techniques": NaN, "tactics": ["Discovery", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Macaw%20Ransomware/Use%20of%20MSBuild%20as%20LOLBin.yaml", "query_name": "Use of MSBuild as LOLBin", "query": "DeviceProcessEvents \n| where InitiatingProcessFileName =~ \"wmiprvse.exe\" \n| where FileName =~ \"msbuild.exe\" and ProcessCommandLine has \"programdata\"\n", "attributes": {"description": "Prior to deploying Macaw ransomware in an organization, the adversary frequently uses MSBuild.exe as a LOLBin to communicate with the C2.\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Qakbot/Excel%20launching%20anomalous%20processes.yaml", "query_name": "Excel launching anomalous processes", "query": "DeviceProcessEvents\n| where InitiatingProcessParentFileName has \"excel.exe\" or InitiatingProcessFileName =~ \"excel.exe\"\n| where InitiatingProcessFileName in~ (\"excel.exe\",\"regsvr32.exe\")\n| where FileName in~ (\"regsvr32.exe\", \"rundll32.exe\")| where ProcessCommandLine has @\"..\\\"\n", "attributes": {"description": "Use this query to find Excel launching anomalous processes congruent with Qakbot payloads which contain additional markers from recent Qakbot executions.\nThe presence of such anomalous processes indicate that the payload was delivered and executed, though reconnaissance and successful implantation hasn't been completed yet.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Qakbot/General%20attempts%20to%20access%20local%20email%20store.yaml", "query_name": "General attempts to access local email store", "query": "DeviceFileEvents\n| where FolderPath hasprefix \"EmailStorage\"\n| where FolderPath has \"Outlook\"\n| project FileName, FolderPath, InitiatingProcessFileName,\nInitiatingProcessCommandLine, DeviceId, Timestamp\n", "attributes": {"description": "Use this query to find attempts to access files in the local path containing Outlook emails.\n", "techniques": NaN, "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Qakbot/Qakbot%20Craigslist%20Domains.yaml", "query_name": "Qakbot Craigslist Domains", "query": "DeviceNetworkEvents\n| where RemoteUrl matches regex @\"abuse\\.[a-zA-Z]\\d{2}-craigslist\\.org\"\n", "attributes": {"description": "Qakbot operators have been abusing the Craigslist messaging system to send malicious emails. These emails contain non-clickable links to malicious domains impersonating Craigslist, which the user is instructed to manually type into the address bar to access.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Qakbot/Qakbot%20email%20theft%20%281%29.yaml", "query_name": "Qakbot email theft (1)", "query": "DeviceFileEvents\n| where InitiatingProcessFileName =~ 'ping.exe' and InitiatingProcessCommandLine == 'ping.exe -t 127.0.0.1'\n    and InitiatingProcessParentFileName in~('msra.exe', 'mobsync.exe') and FolderPath endswith \".eml\"\n", "attributes": {"description": "Use this query to find email stealing activities ran by Qakbot that will use \"ping.exe -t 127.0.0.1\" to obfuscate subsequent actions.\nEmail theft that occurs might be exfiltrated to operators and indicates that the malware completed a large portion of its automated activity without interruption.\n", "techniques": NaN, "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Qakbot/Qakbot%20email%20theft.yaml", "query_name": "Qakbot email theft", "query": "DeviceFileEvents\n| where InitiatingProcessFileName =~ 'ping.exe'\n| where FileName endswith '.eml'\n", "attributes": {"description": "Use this query to find email stealing activities ran by Qakbot that will use \"ping.exe -t 127.0.0.1\" to obfuscate subsequent actions.\nEmail theft that occurs might be exfiltrated to operators and indicates that the malware completed a large portion of its automated activity without interruption.\n", "techniques": NaN, "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Qakbot/Qakbot%20reconnaissance%20activities.yaml", "query_name": "Qakbot reconnaissance activities", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName == InitiatingProcessCommandLine\n| where ProcessCommandLine has_any (\n\"whoami /all\",\"cmd /c set\",\"arp -a\",\"ipconfig /all\",\"net view /all\",\"nslookup -querytype=ALL -timeout=10\",\n\"net share\",\"route print\",\"netstat -nao\",\"net localgroup\")\n| summarize dcount(FileName), make_set(ProcessCommandLine) by DeviceId,bin(Timestamp, 1d), InitiatingProcessFileName, InitiatingProcessCommandLine\n| where dcount_FileName >= 8\n", "attributes": {"description": "Use this query to find reconnaissance and beaconing activities after code injection occurs.\nReconnaissance commands are consistent with the current version of Qakbot and occur automatically to exfiltrate system information. This data, once exfiltrated, will be used to prioritize human operated actions.\n", "techniques": NaN, "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/StrRAT%20malware/StrRAT-AV-Discovery.yaml", "query_name": "StrRAT-AV-Discovery", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName in~(\"java.exe\", \"javaw.exe\") and InitiatingProcessCommandLine has \"roaming\"\n| where FileName == 'cmd.exe' and  ProcessCommandLine has 'path antivirusproduct get displayname'\n", "attributes": {"description": "StrRAT is a Java-based remote access tool which steals browser credentials, logs keystrokes and take remote control of infected systems. It also has a module to download additional payload onto to the infected machine based on C2 server command. Additionally, this threat also has a ransomware encryption/decryption module which appends .crimson extension.\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/StrRAT%20malware/StrRAT-Email-Delivery.yaml", "query_name": "StrRAT-Email-Delivery", "query": "EmailUrlInfo\n| where UrlDomain has_any ('metroscaffingltg.co.uk',\n'pg-finacesolutions.co.uk',\n'jpfletcherconsultancy.co.uk',\n'buildersworlinc.co.uk',\n'bentlyconstbuild.co.uk',\n'alfredoscafeltd.co.uk',\n'zincocorporation.co.uk',\n'playerscircleinc.co.uk',\n'tg-cranedinc.co.uk',\n'adamridley.co.uk',\n'westcoasttrustedtaxis.co.uk',\n'sivospremiumclub.co.uk',\n'gossyexperience.co.uk',\n'jeffersonsandc.co.uk',\n'fillinaresortsltd.co.uk',\n'tk-consultancyltd.co.uk')\n", "attributes": {"description": "StrRAT is a Java-based remote access tool which steals browser credentials, logs keystrokes and take remote control of infected systems. It also has a module to download additional payload onto to the infected machine based on C2 server command. Additionally, this threat also has a ransomware encryption/decryption module which appends .crimson extension.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/StrRAT%20malware/StrRAT-Malware-Persistence.yaml", "query_name": "StrRAT-Malware-Persistence", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName in~(\"java.exe\",\"javaw.exe\")\n| where FileName == 'cmd.exe' and ProcessCommandLine has_all(\"schtasks /create\", \"tn Skype\")\n", "attributes": {"description": "StrRAT is a Java-based remote access tool which steals browser credentials, logs keystrokes and take remote control of infected systems. It also has a module to download additional payload onto to the infected machine based on C2 server command. Additionally, this threat also has a ransomware encryption/decryption module which appends .crimson extension.\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Sysrv-botnet/app-armor-stopped.yaml", "query_name": "app-armor-stopped", "query": "DeviceProcessEvents\n| where InitiatingProcessCommandLine  has \"/bin/bash /tmp/\" and ProcessCommandLine has \"service apparmor stop\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Sysrv botnet evolution.\nSysrv is a Go-based botnet that targets both Windows and Linux servers, and steals resources to mine cryptocurrency.\nThe following query finds instances of the attacker attempting to stop the AppArmor network security service on devices running Linux.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Sysrv-botnet/java-executing-cmd-to-run-powershell.yaml", "query_name": "java-executing-cmd-to-run-powershell", "query": "DeviceProcessEvents                         \n| where InitiatingProcessFileName == 'java.exe' and FileName == 'cmd.exe' \nand ProcessCommandLine has_all('powershell iex','DownloadString')\n", "attributes": {"description": "This query was originally published in the threat analytics report, Sysrv botnet evolution.\nSysrv is a Go-based botnet that targets both Windows and Linux servers, and steals resources to mine cryptocurrency.\nThe following query finds instances of the Java process being used to execute cmd.exe, and download and execute a PowerShell script.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Sysrv-botnet/kinsing-miner-download.yaml", "query_name": "kinsing-miner-download", "query": "DeviceProcessEvents\n| where ProcessCommandLine has_all('curl', '-o /etc/kinsing')\n", "attributes": {"description": "This query was originally published in the threat analytics report, Sysrv botnet evolution.\nSysrv is a Go-based botnet that targets both Windows and Linux servers, and steals resources to mine cryptocurrency.\nThe following query finds instances where the attacker commanded the Kinsing miner file to be downloaded on Linux devices.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Sysrv-botnet/oracle-webLogic-executing-powershell.yaml", "query_name": "oracle-webLogic-executing-powershell", "query": "union DeviceProcessEvents, DeviceFileEvents\n| where InitiatingProcessParentFileName =~ 'wlsvcX64.exe' and InitiatingProcessFileName =~ 'powershell.exe'\n", "attributes": {"description": "This query was originally published in the threat analytics report, Sysrv botnet evolution.\nSysrv is a Go-based botnet that targets both Windows and Linux servers, and steals resources to mine cryptocurrency.\nThe following query finds instances of Oracle WebLogic being exploited to run a PowerShell script that downloads payloads.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Sysrv-botnet/rce-on-vulnerable-server.yaml", "query_name": "rce-on-vulnerable-server", "query": "DeviceProcessEvents\n| where InitiatingProcessCommandLine has \"php-cgi.exe\"\n| where ProcessCommandLine has_all ('curl -fsSL', '/ldr.sh', 'wget -q -O')\n", "attributes": {"description": "This query was originally published in the threat analytics report, Sysrv botnet evolution.\nSysrv is a Go-based botnet that targets both Windows and Linux servers, and steals resources to mine cryptocurrency.\nThe following query finds instances of remote code execution on a vulnerable Linux server.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/Sysrv-botnet/tomcat-8-executing-powershell.yaml", "query_name": "tomcat-8-executing-powershell", "query": "DeviceProcessEvents\n| where InitiatingProcessParentFileName startswith 'tomcat'\n| where InitiatingProcessFileName in~(\"cmd.exe\", \"powershell.exe\") and InitiatingProcessCommandLine hasprefix '-enc '\nand ProcessCommandLine has_any ('cmd.exe','powershell.exe','sc.exe','schtasks.exe','WMIC.exe')\n", "attributes": {"description": "This query was originally published in the threat analytics report, Sysrv botnet evolution.\nSysrv is a Go-based botnet that targets both Windows and Linux servers, and steals resources to mine cryptocurrency.\nThe following query finds instances of Apache Tomcat 8 being exploited to execute encoded PowerShell commands.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/ZLoader/Malicious%20bat%20file.yaml", "query_name": "Malicious bat file", "query": "DeviceFileEvents\n| where FileName endswith '.bat'\n    and FolderPath has @'Program Files (x86)\\Sun Technology Network\\Oracle Java SE'\n", "attributes": {"description": "ZLoader was delivered in a campaign in late summer 2021. This campaign was tweeted by @MsftSecIntel on twitter.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/ZLoader/Payload%20Delivery.yaml", "query_name": "Payload Delivery", "query": "DeviceNetworkEvents\n| where InitiatingProcessFileName =~ 'powershell.exe'\n    and InitiatingProcessCommandLine has('Invoke-WebRequest') and InitiatingProcessCommandLine endswith '-OutFile tim.EXE'\n", "attributes": {"description": "ZLoader was delivered in a campaign in summer 2021 via malvertising. This campaign was tweeted about by @MsftSecIntel on twitter.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Campaigns/ZLoader/Suspicious%20Registry%20Keys.yaml", "query_name": "Suspicious Registry Keys", "query": "DeviceRegistryEvents\n| where RegistryValueData in('Flyintellect Inc.', 'Datalyst ou')\n", "attributes": {"description": "ZLoader was delivered in a campaign in late summer 2021 using malvertising to download malicious .msi files onto affected machines. This campaign was originally tweeted by @MsftSecIntel on Twitter.\nIn this campaign, the malicious .msi files create registry keys that use that attacker-created comapny names.\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Collection/Anomaly%20of%20MailItemAccess%20by%20Other%20Users%20Mailbox%20%5BNobelium%5D.yaml", "query_name": "Anomaly of MailItemAccess by Other Users Mailbox [Nobelium]", "query": "// Adjust this value to exclude historical activity as known good\nlet LookBack = 30d;\n// Adjust this value to change hunting timeframe\nlet TimeFrame = 14d;\n// Adjust this value to alter how many mailbox (other than their own) a user needs to access before being included in results\nlet UserThreshold = 1;\n// Adjust this value to alter how many mailbox folders in other's email accounts a users needs to access before being included in results.\nlet FolderThreshold = 5;\nlet relevantMailItems = materialize (\n    CloudAppEvents\n    | where Timestamp > ago(LookBack)\n    | where ActionType == \"MailItemsAccessed\"\n    | where RawEventData['ResultStatus'] == \"Succeeded\"\n    | extend UserId = tostring(RawEventData['UserId'])\n    | extend MailboxOwnerUPN = tostring(RawEventData['MailboxOwnerUPN'])\n    | where tolower(UserId) != tolower(MailboxOwnerUPN)\n    | extend Folders = RawEventData['Folders']\n    | where isnotempty(Folders)\n    | mv-expand parse_json(Folders)\n    | extend foldersPath = tostring(Folders.Path)  \n    | where isnotempty(foldersPath)\n    | extend ClientInfoString = RawEventData['ClientInfoString']\n    | extend MailBoxGuid = RawEventData['MailboxGuid']\n    | extend ClientIP = iif(IPAddress startswith \"[\", extract(\"\\\\[([^\\\\]]*)\", 1, IPAddress), IPAddress)\n    | project Timestamp, ClientIP, UserId, MailboxOwnerUPN, tostring(ClientInfoString), foldersPath, tostring(MailBoxGuid)    \n);\nlet relevantMailItemsBaseLine = \n    relevantMailItems\n    | where Timestamp between(ago(LookBack) ..  ago(TimeFrame))    \n    | distinct MailboxOwnerUPN, UserId;\nlet relevantMailItemsHunting = \n    relevantMailItems\n    | where Timestamp between(ago(TimeFrame) .. now())\n    | distinct ClientIP, UserId, MailboxOwnerUPN, ClientInfoString, foldersPath, MailBoxGuid; \nrelevantMailItemsBaseLine \n    | join kind=rightanti relevantMailItemsHunting\n    on MailboxOwnerUPN, UserId\n    | summarize FolderCount = dcount(tostring(foldersPath)),\n                UserCount = dcount(MailBoxGuid),\n                foldersPathSet = make_set(foldersPath),\n                ClientInfoStringSet = make_set(ClientInfoString), \n                ClientIPSet = make_set(ClientIP),\n                MailBoxGuidSet = make_set(MailBoxGuid),\n                MailboxOwnerUPNSet = make_set(MailboxOwnerUPN)\n            by UserId\n    | where UserCount > UserThreshold or FolderCount > FolderThreshold\n    | extend Reason = case( \n                            UserCount > UserThreshold and FolderCount > FolderThreshold, \"Both User and Folder Threshold Exceeded\",\n                            FolderCount > FolderThreshold and UserCount < UserThreshold, \"Folder Count Threshold Exceeded\",\n                            \"User Threshold Exceeded\"\n                            )\n    | sort by UserCount desc\n", "attributes": {"description": "This query looks for users accessing multiple other users' mailboxes, or accessing multiple folders in another user's mailbox.\nThis query is inspired by an Azure Sentinel detection.\nReference - https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/AnomolousUserAccessingOtherUsersMailbox.yaml\n", "techniques": NaN, "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Collection/HostExportingMailboxAndRemovingExport%5BSolarigate%5D.yaml", "query_name": "HostExportingMailboxAndRemovingExport[Solarigate]", "query": "// Adjust the timeframe to change the window events need to occur within to alert\nlet timeframe = 1h;\nDeviceProcessEvents\n  | where FileName  in~ (\"powershell.exe\", \"cmd.exe\")\n  | where ProcessCommandLine  contains 'New-MailboxExportRequest'\n  | project-rename NewMailBoxExpCmd = ProcessCommandLine  \n  | summarize by DeviceName , timekey = bin(Timestamp, timeframe), NewMailBoxExpCmd, AccountName \n  | join kind=inner (DeviceProcessEvents\n  | where FileName in~ (\"powershell.exe\", \"cmd.exe\")\n  | where ProcessCommandLine contains 'Remove-MailboxExportRequest'\n  | project-rename RemoveMailBoxExpCmd = ProcessCommandLine\n  | summarize by DeviceName, timekey = bin(Timestamp, timeframe), RemoveMailBoxExpCmd, AccountName) on DeviceName, timekey, AccountName\n  | extend commands = pack_array(NewMailBoxExpCmd, RemoveMailBoxExpCmd)  \n  | summarize by timekey, DeviceName, tostring(commands), AccountName\n  | project-reorder timekey, DeviceName, AccountName, ['commands']\n  | extend HostCustomEntity = DeviceName, AccountCustomEntity = AccountName\n", "attributes": {"description": "This hunting query looks for hosts exporting a mailbox from an on-prem Exchange server, followed by\nthat same host removing the export within a short time window. This pattern has been observed by attackers\nwhen exfiltrating emails from a target environment. A Mailbox export is unlikely to be a common command run so look for\nactivity from unexpected hosts and accounts.\nReference: https://www.volexity.com/blog/2020/12/14/dark-halo-leverages-solarwinds-compromise-to-breach-organizations/\nQuery insprired by Azure Sentinel detection https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/HostExportingMailboxAndRemovingExport.yaml\n", "techniques": NaN, "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Collection/MailItemsAccessedTimeSeries%5BSolarigate%5D.yaml", "query_name": "MailItemsAccessedTimeSeries[Solarigate]", "query": "let starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet scorethreshold = 1.5;\nlet percentthreshold = 50;\n// Preparing the time series data aggregated hourly count of MailItemsAccessd Operation in the form of multi-value array to use with time series anomaly function.\nlet TimeSeriesData =\n    CloudAppEvents \n    | where Timestamp   between (startofday(ago(starttime))..startofday(ago(endtime)))\n    | where ActionType =~ \"MailItemsAccessed\"\n    | where Application has \"Exchange\"\n    | extend RawEventData = parse_json(RawEventData)\n    | where RawEventData.ResultStatus == \"Succeeded\"  \n    | project Timestamp, ActionType, RawEventData.MailboxOwnerUPN    \n    | make-series Total=count() on Timestamp from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe;\nlet TimeSeriesAlerts =\n  TimeSeriesData\n  | extend (anomalies, score, baseline) = series_decompose_anomalies(Total, scorethreshold, -1, 'linefit')\n  | mv-expand Total to typeof(double), Timestamp to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n  | where anomalies > 0\n  | project Timestamp, Total, baseline, anomalies, score;\n  // Joining the flagged outlier from the previous step with the original dataset to present contextual information\n  // during the anomalyhour to analysts to conduct investigation or informed decisions.\n  TimeSeriesAlerts | where Timestamp > ago(2d)  \n  // Join against base logs since specified timeframe to retrive records associated with the hour of anomoly\n  | join (\n      CloudAppEvents \n        | where Timestamp > ago(2d)\n        | where ActionType =~ \"MailItemsAccessed\"\n        | where Application has \"Exchange\"\n        | extend RawEventData = parse_json(RawEventData)\n        | where RawEventData.ResultStatus == \"Succeeded\"  \n  ) on Timestamp\n", "attributes": {"description": "Identifies anomalous increases in Exchange mail items accessed operations.\nThe query leverages KQL built-in anomaly detection algorithms to find large deviations from baseline patterns.\nSudden increases in execution frequency of sensitive actions should be further investigated for malicious activity.\nManually change scorethreshold from 1.5 to 3 or higher to reduce the noise based on outliers flagged from the query criteria.\nRead more about MailItemsAccessed- https://docs.microsoft.com/microsoft-365/compliance/advanced-audit?view=o365-worldwide#mailitemsaccessed\nQuery insprired by Azure Sentinel detection https://github.com/Azure/Azure-Sentinel/blob/master/Detections/OfficeActivity/MailItemsAccessedTimeSeries.yaml\n", "techniques": NaN, "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/c2-bluekeep.yaml", "query_name": "c2-bluekeep", "query": "// Suggest setting Timestamp starting from September 6th\n// when the BlueKeep Metasploit module was released\nlet IPs = pack_array(\"109.176.117.11\", \"5.100.251.106\", \n\"217.23.5.20\", \"5.135.199.19\"); \nDeviceNetworkEvents\n| where Timestamp > ago(7d) \n| where RemoteIP in(IPs)\n", "attributes": {"description": "This query was originally published in the threat analytics report, Exploitation of CVE-2019-0708 (BlueKeep).\nCVE-2019-0708, also known as BlueKeep, is a critical remote code execution vulnerability involving RDP. Soon after its disclosure, the NSA issued a rare advisory about this vulnerability, out of concern that it could be used to quickly spread malware. Attackers have since used this vulnerability to install cryptocurrency miners on targets.\nMicrosoft has issued updates for this vulnerability, as well as guidance for protecting operating systems that we no longer support. Microsoft Defender ATP also contains behavioral detections for defending against this threat.\nThe following query locates devices that have communicated with attacker infrastructure associated with BlueKeep-related cryptomining.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2019-0708\nhttps://www.nsa.gov/News-Features/News-Stories/Article-View/Article/1865726/nsa-cybersecurity-advisory-patch-remote-desktop-services-on-legacy-versions-of/\nhttps://www.wired.com/story/bluekeep-hacking-cryptocurrency-mining/\nhttps://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2019-0708\nhttps://support.microsoft.com/help/4500705/customer-guidance-for-cve-2019-0708\nhttps://www.microsoft.com/security/blog/2019/11/07/the-new-cve-2019-0708-rdp-exploit-attacks-explained/\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/C2-NamedPipe.yaml", "query_name": "C2-NamedPipe", "query": "// maximum lookback time\nlet minTimeRange = ago(7d);\n// this is what should be constantly tweaked with default C2 framework names, search uses has_any (wildcard)\nlet badPipeNames = pack_array(\n    '\\\\psexec',                                     // PSexec default pipe\n    '\\\\paexec',                                     // PSexec default pipe\n    '\\\\remcom',                                     // PSexec default pipe\n    '\\\\csexec',                                     // PSexec default pipe\n    '\\\\isapi_http',                                 // Uroburos Malware Named Pipe\n    '\\\\isapi_dg',                                   // Uroburos Malware Named Pipe\n    '\\\\isapi_dg2',                                  // Uroburos Malware Named Pipe\n    '\\\\sdlrpc',                                     // Cobra Trojan Named Pipe http://goo.gl/8rOZUX\n    '\\\\ahexec',                                     // Sofacy group malware\n    '\\\\winsession',                                 // Wild Neutron APT malware https://goo.gl/pivRZJ\n    '\\\\lsassw',                                     // Wild Neutron APT malware https://goo.gl/pivRZJ\n    '\\\\46a676ab7f179e511e30dd2dc41bd388',           // Project Sauron https://goo.gl/eFoP4A\n    '\\\\9f81f59bc58452127884ce513865ed20',           // Project Sauron https://goo.gl/eFoP4A\n    '\\\\e710f28d59aa529d6792ca6ff0ca1b34',           // Project Sauron https://goo.gl/eFoP4A\n    '\\\\rpchlp_3',                                   // Project Sauron https://goo.gl/eFoP4A - Technical Analysis Input\n    '\\\\NamePipe_MoreWindows',                       // Cloud Hopper Annex B https://www.pwc.co.uk/cyber-security/pdf/cloud-hopper-annex-b-final.pdf, US-CERT Alert - RedLeaves https://www.us-cert.gov/ncas/alerts/TA17-117A\n    '\\\\pcheap_reuse',                               // Pipe used by Equation Group malware 77486bb828dba77099785feda0ca1d4f33ad0d39b672190079c508b3feb21fb0\n    '\\\\gruntsvc',                                   // Covenant default named pipe\n    '\\\\583da945-62af-10e8-4902-a8f205c72b2e',       // SolarWinds SUNBURST malware report https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n    '\\\\bizkaz',                                     // Snatch Ransomware https://thedfirreport.com/2020/06/21/snatch-ransomware/\n    '\\\\atctl',                                      // https://www.virustotal.com/#/file/a4ddb2664a6c87a1d3c5da5a5a32a5df9a0b0c8f2e951811bd1ec1d44d42ccf1/detection\n    '\\\\userpipe',                                   // ruag apt case\n    '\\\\iehelper',                                   // ruag apt case\n    '\\\\sdlrpc',                                     // project cobra https://www.gdatasoftware.com/blog/2015/01/23926-analysis-of-project-cobra\n    '\\\\comnap',                                     // https://www.gdatasoftware.com/blog/2015/01/23926-analysis-of-project-cobra\n    '\\\\lsadump',                                    // Cred Dump-Tools Named Pipes\n    '\\\\cachedump',                                  // Cred Dump-Tools Named Pipes\n    '\\\\wceservicepipe',                             // Cred Dump-Tools Named Pipes\n    '\\\\jaccdpqnvbrrxlaf',                           // PoshC2 default named pipe\n    '\\\\svcctl',                                     // CrackMapExec default named pipe\n    '\\\\csexecsvc'                                   // CSEXEC default named pipe\n    '\\\\status_',                                    // CS default named pipes https://github.com/Neo23x0/sigma/issues/253\n    '\\\\MSSE-',                                      // CobaltStrike default named pipe\n    '\\\\status_',                                    // CobaltStrike default named pipe\n    '\\\\msagent_',                                   // (target) CobaltStrike default named pipe\n    '\\\\postex_ssh_',                                // CobaltStrike default named pipe\n    '\\\\postex_',                                    // CobaltStrike default named pipe\n    '\\\\Posh'                                        // PoshC2 default named pipe\n);\nDeviceEvents\n| where ActionType == \"NamedPipeEvent\" and Timestamp > minTimeRange\n| extend ParsedFields=parse_json(AdditionalFields)\n| where ParsedFields.FileOperation == \"File created\"\n| where ParsedFields.PipeName has_any (badPipeNames)\n| project Timestamp, ActionType, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessFolderPath, InitiatingProcessCommandLine, ParsedFields.FileOperation, ParsedFields.PipeName\n", "attributes": {"description": "Detects the creation of a named pipe used by known APT malware.\nReference - https://docs.microsoft.com/openspecs/windows_protocols/ms-wpo/4de75e21-36fd-440a-859b-75accc74487c\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/check-for-shadowhammer-activity-download-domain.yaml", "query_name": "check-for-shadowhammer-activity-download-domain", "query": "DeviceNetworkEvents \n| where Timestamp > ago(30d)\n| where RemoteUrl == \"asushotfix.com\" or RemoteIP == \"141.105.71.116\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, ShadowHammer supply chain attack\nOperation ShadowHammer was an attack against ASUS computer hardware, using the company's own update infrastructure to deliver malware to the company's products. The campaign ran from June to November, 2018. ASUS has since responded with updates that protect their Live Update system, and diagnostic tools to check affected systems.\nThe following query checks for activity associated with the ShadowHammer download domain over the past 30 days.\nReferences:\nhttps://www.vice.com/en_us/article/pan9wn/hackers-hijacked-asus-software-updates-to-install-backdoors-on-thousands-of-computers\nhttps://www.asus.com/News/hqfgVUyZ6uyAyJe1\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/Connection%20to%20Rare%20DNS%20Hosts.yaml", "query_name": "Connection to Rare DNS Hosts", "query": "let LowCountThreshold = 10;\nlet MaxAge = ago(1d);\nDeviceNetworkEvents\n| where Timestamp > MaxAge\n| where isnotempty( RemoteUrl) and RemoteUrl contains \".\"\n| extend RemoteDomain = iff(RemoteUrl matches regex @'^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$', tolower(RemoteUrl), tostring(parse_url(RemoteUrl).Host))\n| top-nested 100000 of RemoteDomain by dcount(DeviceId) asc\n| where aggregated_RemoteDomain <= LowCountThreshold \n| join kind=rightsemi (\n    DeviceNetworkEvents\n    | where Timestamp > ago(7d)\n    | where isnotempty( RemoteUrl) and RemoteUrl contains \".\"\n    | extend RemoteDomain = iff(RemoteUrl matches regex @'^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$', tolower(RemoteUrl), tostring(parse_url(RemoteUrl).Host))\n) on RemoteDomain \n| extend DomainArray = split(RemoteDomain, '.')\n| extend SecondLevelDomain = strcat(tostring(DomainArray[-2]),'.', tostring(DomainArray[-1])), ThirdLevelDomain = strcat(tostring(DomainArray[-3]), '.', tostring(DomainArray[-2]),'.', tostring(DomainArray[-1]))\n| summarize ConnectionCount = count(), DistinctDevices = dcount(DeviceId) by SecondLevelDomain, ThirdLevelDomain, RemoteDomain\n| where DistinctDevices <= LowCountThreshold \n| top 10000 by DistinctDevices asc\n| order by ConnectionCount asc\n", "attributes": {"description": "This query will break down hostnames into their second and third level domain parts and analyze the volume of connections made to the destination to look for low count entries. Note that this query is likely to be rather noisy in many organziations and may benefit from analysis over time, anomaly detection, or perhaps machine learning.\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/Device%20network%20events%20w%20low%20count%20FQDN.yaml", "query_name": "Device network events w low count FQDN", "query": "DeviceNetworkEvents\n| where Timestamp > ago(1h)\n| where InitiatingProcessFileName !in~ ('iexplore.exe','chrome.exe','opera.exe','safari.exe') // Remove web browsers\n    and isnotempty(RemoteUrl)\n| extend FQDN = iff(RemoteUrl matches regex \"^([a-zA-Z0-9._-])+$\", tostring(RemoteUrl), parse_url(RemoteUrl).domain)\n| top-nested 100 of FQDN by dcount(DeviceId) asc\n| join kind=inner (\n    DeviceNetworkEvents\n    | where Timestamp > ago(1h)\n    | where isnotempty(RemoteUrl)\n    | extend FQDN = iff(RemoteUrl matches regex \"^([a-zA-Z0-9._-])+$\", tostring(RemoteUrl), parse_url(RemoteUrl).domain)\n) on FQDN\n| order by aggregated_FQDN asc\n", "attributes": {"description": "Device Network Events Involving Low Count FQDNs.\nThis query reduces network events to only those with the RemoteURL column populated,.\nThen parses the DNS name from the URL (if needed) and finds the least prevalent.\nFQDNs.  The result is then joined with DeviceNetworkEvents to highlight anomalous.\nNetwork communication.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/DNSPattern%20%5BNobelium%5D.yaml", "query_name": "DNSPattern [Nobelium]", "query": "let cloudApiTerms = dynamic([\"api\", \"east\", \"west\"]);\nlet timeFrame = ago(1d);\nlet relevantDeviceNetworkEvents = \n  DeviceNetworkEvents  \n  | where Timestamp >= timeFrame\n  | where RemoteUrl !has \"\\\\\" and RemoteUrl !has \"/\"\n  // performance filter\n  | where RemoteUrl has_any(cloudApiTerms)\n  | project-rename DomainName = RemoteUrl\n  | project Timestamp, DomainName, DeviceId, DeviceName;\nlet relevantDeviceEvents =   \n  DeviceEvents \n  | where Timestamp >= timeFrame\n   | where ActionType == \"DnsQueryResponse\"\n   // performance filter\n   | where AdditionalFields has_any(cloudApiTerms)\n   | extend query = extractjson(\"$.DnsQueryString\", AdditionalFields)  \n   | where isnotempty(query)\n   | project-rename DomainName = query\n   | project Timestamp, DomainName, DeviceId, DeviceName;\nlet relevantIdentityQueryEvents =\n  IdentityQueryEvents \n  | where Timestamp >= timeFrame\n  | where ActionType == \"DNS query\"\n  | where Protocol == \"Dns\"\n  // performance filter\n  | where QueryTarget has_any(cloudApiTerms)\n  | project-rename DomainName = QueryTarget   \n  | project Timestamp, DomainName, DeviceId = \"\", DeviceName;\nlet relevantData =\n  relevantIdentityQueryEvents\n  | union\n  relevantDeviceNetworkEvents  \n  | union\n  relevantDeviceEvents;\nlet tokenCreation =\n  relevantData\n  | extend domain_split = split(DomainName, \".\")\n  | where tostring(domain_split[-5]) != \"\" and tostring(domain_split[-6]) == \"\"\n  | extend sub_domain = tostring(domain_split[0])\n  | where sub_domain !contains \"-\"\n  | extend sub_directories = strcat(domain_split[-3], \" \", domain_split[-4])\n  | where sub_directories has_any(cloudApiTerms);\ntokenCreation\n  //Based on sample communications the subdomain is always between 20 and 30 bytes\n  | where strlen(domain_split) < 32 or strlen(domain_split) > 20\n  | extend domain = strcat(tostring(domain_split[-2]), \".\", tostring(domain_split[-1])) \n  | extend subdomain_no = countof(sub_domain, @\"(\\d)\", \"regex\")\n  | extend subdomain_ch = countof(sub_domain, @\"([a-z])\", \"regex\")\n  | where subdomain_no > 1\n  | extend percentage_numerical = toreal(subdomain_no) / toreal(strlen(sub_domain)) * 100\n  | where percentage_numerical < 50 and percentage_numerical > 5\n  | summarize rowcount = count(), make_set(DomainName), make_set(DeviceId), make_set(DeviceName), FirstSeen=min(Timestamp), LastSeen=max(Timestamp) by DomainName\n  | order by rowcount asc\n", "attributes": {"description": "This query looks for the DGA pattern of the domain associated with the Nobelium campaign, in order to find other domains with the same activity pattern.\nThis query is inspired by an Azure Sentinel detection.\nReference - https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Hunting%20Queries/DnsEvents/Solorigate-DNS-Pattern.yaml\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/EncodedDomainURL%20%5BNobelium%5D.yaml", "query_name": "EncodedDomainURL [Nobelium]", "query": "let timeFrame = ago(1d);\nlet relevantDeviceNetworkEvents = \n  DeviceNetworkEvents\n  | where Timestamp >= timeFrame\n  | where RemoteUrl !has \"\\\\\" and RemoteUrl !has \"/\"\n  | project-rename DomainName = RemoteUrl\n  | summarize by DomainName;\nlet relevantDeviceEvents =\n  DeviceEvents\n  | where Timestamp >= timeFrame\n  | where ActionType == \"DnsQueryResponse\"\n  | extend query = extractjson(\"$.DnsQueryString\", AdditionalFields)  \n  | where isnotempty(query)\n  | project-rename DomainName = query\n  | summarize by DomainName;\nlet relevantIdentityQueryEvents =\n  IdentityQueryEvents \n  | where Timestamp >= timeFrame\n  | where ActionType == \"DNS query\"\n  | where Protocol == \"Dns\"\n  | project-rename DomainName = QueryTarget\n  | summarize by DomainName;\nlet DnsEvents =\n  relevantIdentityQueryEvents\n  | union\n  relevantDeviceNetworkEvents  \n  | union\n  relevantDeviceEvents\n  | summarize by DomainName;\nlet dictionary = dynamic([\"r\",\"q\",\"3\",\"g\",\"s\",\"a\",\"l\",\"t\",\"6\",\"u\",\"1\",\"i\",\"y\",\"f\",\"z\",\"o\",\"p\",\"5\",\"7\",\"2\",\"d\",\"4\",\"9\",\"b\",\"n\",\"x\",\"8\",\"c\",\"v\",\"m\",\"k\",\"e\",\"w\",\"h\",\"j\"]);\nlet regex_bad_domains =\n   AADSignInEventsBeta\n   //Collect domains from tenant from signin logs\n   | where Timestamp >= timeFrame\n   | extend domain = tostring(split(AccountUpn, \"@\", 1)[0])\n   | where domain != \"\"\n   | summarize by domain\n   | extend split_domain = split(domain, \".\")\n   //This cuts back on domains such as na.contoso.com by electing not to match on the \"na\" portion\n   | extend target_string = iff(strlen(split_domain[0]) <= 2, split_domain[1], split_domain[0])\n   | extend target_string = split(target_string, \"-\")  | mv-expand target_string\n   //Rip all of the alphanumeric out of the domain name\n   | extend string_chars = extract_all(@\"([a-z0-9])\", tostring(target_string))\n   //Guid for tracking our data\n   | extend guid = new_guid()//Expand to get all of the individual chars from the domain\n   | mv-expand string_chars\n   | extend chars = tostring(string_chars)\n   //Conduct computation to encode the domain as per actor spec\n   | extend computed_char = array_index_of(dictionary, chars)\n   | extend computed_char = dictionary[(computed_char + 4) % array_length(dictionary)] \n   | summarize make_list(computed_char) by guid, domain\n   | extend target_encoded = tostring(strcat_array(list_computed_char, \"\"))\n   //These are probably too small, but can be edited (expect FP's when going too small)\n   | where strlen(target_encoded) > 5\n   | distinct target_encoded\n   | summarize make_set(target_encoded)\n   //Key to join to DNS\n   | extend key = 1;\nDnsEvents\n  | extend key = 1\n  //For each DNS query join the malicious domain list\n  | join kind=inner (\n      regex_bad_domains\n  ) on key\n  | project-away key\n  //Expand each malicious key for each DNS query observed\n  | mv-expand set_target_encoded\n  //IndexOf allows us to fuzzy match on the substring\n  | extend match = indexof(DomainName, set_target_encoded)\n  | where match > -1\n", "attributes": {"description": "Looks for a logon domain in the Azure AD logs,  encoded with the same DGA encoding used in the Nobelium campaign.\nSee Important steps for customers to protect themselves from recent nation-state cyberattacks for more on the Nobelium campaign (formerly known as Solorigate).\nThis query is inspired by an Azure Sentinel detection.\nReferences:\nhttps://blogs.microsoft.com/on-the-issues/2020/12/13/customers-protect-nation-state-cyberattacks/\nhttps://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Hunting%20Queries/DnsEvents/Solorigate-Encoded-Domain-URL.yaml\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/python-use-by-ransomware-macos.yaml", "query_name": "python-use-by-ransomware-macos", "query": "union DeviceFileEvents, DeviceProcessEvents  \n| where Timestamp >= ago(7d)  \n| where ProcessCommandLine contains \"EIKKEIKK\" and ProcessCommandLine contains \"python\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, EvilQuest signals the rise of Mac ransomware.\nAs of the time of this writing (October 2020), ransomware designed to target macOS is relatively rare. EvilQuest is one of the few examples of this kind of malware on the platform.\nThe query below can help locate an attempt to run Python in service of malicious activity by a remote operator. The command the query searches for is associated with, but not definitely indicative of, EvilQuest infections.\nOther queries related to EvilQuest ransomware can be found under the See also section below.\n", "techniques": NaN, "tactics": ["Execution", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/recon-with-rundll.yaml", "query_name": "recon-with-rundll", "query": "DeviceNetworkEvents\n| where InitiatingProcessFileName =~ \"rundll32.exe\"\n// Empty command line\n| where InitiatingProcessCommandLine has \"rundll32.exe\" and InitiatingProcessCommandLine !contains \" \" \nand InitiatingProcessCommandLine != \"\" \n| summarize DestinationIPCount = dcount(RemoteIP), make_set(RemoteIP), make_set(RemoteUrl), \nmake_set(RemotePort) by InitiatingProcessCommandLine, DeviceId, bin(Timestamp, 5m)\n", "attributes": {"description": "This query was originally published in the threat analytics report, Trickbot: Pervasive & underestimated.\nTrickbot is a very prevalent piece of malware with an array of malicious capabilities. Originally designed to steal banking credentials, it has since evolved into a modular trojan that can deploy other malware, disable security software, and perform command and control (C2) operations.\nTrickbot operators are known to use the legitimate Windows process rundll.exe to perform malicious activities, such as reconnaissance. Once a target is infected, the operator will drop a batch file that runs several commands and connects to a C2 server for further action.\nThe following query detects suspicious rundll.exe activity associated with Trickbot campaigns.\nSee Office applications launching wscript.exe to run JScript for another query related to Trickbot activity.\nReference - https://attack.mitre.org/software/S0266/\n", "techniques": NaN, "tactics": ["Discovery", "Collection", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/reverse-shell-ransomware-macos.yaml", "query_name": "reverse-shell-ransomware-macos", "query": "union DeviceFileEvents, DeviceProcessEvents\n| where Timestamp >= ago(7d)\n| where ProcessCommandLine has \"bash -i >& /dev/tcp/\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, EvilQuest signals the rise of Mac ransomware.\nAs of the time of this writing (October 2020), ransomware designed to target macOS is relatively rare. EvilQuest is one of the few examples of this kind of malware on the platform.\nThe query below can help locate a reverse shell established by an attacker. The command the query searches for is associated with, but not definitely indicative of, EvilQuest infections.\nOther queries related to EvilQuest ransomware can be found under the See also section below.\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Command%20and%20Control/Tor.yaml", "query_name": "Tor", "query": "DeviceNetworkEvents  \n| where Timestamp < ago(3d) and InitiatingProcessFileName in~ (\"tor.exe\", \"meek-client.exe\")\n// Returns MD5 hashes of files used by Tor, to enable you to block them.\n// We count how prevalent each file is (by machines) and show examples for some of them (up to 5 machine names per hash).\n| summarize MachineCount=dcount(DeviceName), MachineNames=makeset(DeviceName, 5) by InitiatingProcessMD5\n| order by MachineCount desc\n", "attributes": {"description": "This query looks for Tor client, or for a common Tor plugin called Meek.\nWe query for active Tor connections, but could have alternatively looked for active Tor runs (ProcessCreateEvents) or Tor downloads (DeviceFileEvents).\nTo read more about this technique, see:.\nTor: https://attack.mitre.org/wiki/Software/S0183#Techniques_Used.\nMeek plugin: https://attack.mitre.org/wiki/Software/S0175.\nMulti-hop proxy technique: https://attack.mitre.org/wiki/Technique/T1188.\nTags: #Tor, #MultiHopProxy, #CnC.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/Active%20Directory%20Sensitive%20Group%20Modifications.yaml", "query_name": "Active Directory Sensitive Group Modifications", "query": "// Detects changes in Tier 0 group memberships\n// Command leverages MDI schema\n// Execute from https://security.microsoft.com or through the M365D advanced hunting API\nlet Events = materialize (\nIdentityDirectoryEvents\n| where ActionType == 'Group Membership changed'\n| extend ActivityType = iff(isnotempty(tostring(AdditionalFields['TO.GROUP'])),\"Added Account\", \"Removed Account\")\n| where isnotempty(AccountSid)\n);\nlet Tier0Adds = (\nEvents\n| where ActivityType == \"Added Account\"\n| extend TargetGroup = tostring(AdditionalFields['TO.GROUP'])\n| extend TargetObject = iff(isempty(tostring(AdditionalFields['TARGET_OBJECT.USER'])), tostring(AdditionalFields['TARGET_OBJECT.GROUP']), tostring(AdditionalFields['TARGET_OBJECT.USER']))\n| extend TargetType = iff(isempty(tostring(AdditionalFields['TARGET_OBJECT.USER'])), \"Security Group\", \"User Account\")\n//| extend TargetObject = AdditionalFields['TARGET_OBJECT.USER']\n);\nlet Tier0Removes = (\nEvents\n| where ActivityType == \"Removed Account\"\n| extend TargetGroup = tostring(AdditionalFields['FROM.GROUP'])\n| extend TargetObject = iff(isempty(tostring(AdditionalFields['TARGET_OBJECT.USER'])),tostring(AdditionalFields['TARGET_OBJECT.GROUP']), tostring(AdditionalFields['TARGET_OBJECT.USER']))\n| extend TargetType = iff(isempty(tostring(AdditionalFields['TARGET_OBJECT.USER'])), \"Security Group\", \"User Account\")\n);\nlet Tier0Groups = datatable(TargetGroup:string)\n[\n'Enterprise Admins',\n'Domain Admin',\n'Domain Controllers'\n'Administrators',\n'Enterprise Key Admins',\n'Account Operators',\n'Organization Management',\n'Backup Operators',\n'RTCDomainServerAdmins',\n'ENTERPRISE DOMAIN CONTROLLERS',\n'Cert Publishers',\n'Schema Admins',\n'DnsAdmins',\n'Exchange Recipient Administrators',\n'Replicator',\n'Read-Only Domain Controllers',\n'Print Operators'\n];\nTier0Groups\n| join (union Tier0Adds, Tier0Removes) on TargetGroup\n| project Timestamp, ActionType, ActivityType,TargetType, ActorUpn=AccountUpn, TargetObject, TargetAccountUpn, TargetGroup\n// If you are setting up a detection rule in M365D, you'll need to add ReportId and AccountSid to the projected columns\n", "attributes": {"description": "This query shows all modifications to highly sensitive active directory groups (also known as Tier 0). An example of these groups include Domain Admins, Schema Admins and Enterprise Admins.\nMore info can be found here:\nhttps://docs.microsoft.com/security/compass/privileged-access-access-model#evolution-from-the-legacy-ad-tier-model\nhttps://docs.microsoft.com/windows-server/identity/ad-ds/plan/security-best-practices/appendix-c--protected-accounts-and-groups-in-active-directory\nThis advanced hunting query requires Defender for Identity be deployed due to it's reliance on the IdentityDirectoryEvents table.\n", "techniques": NaN, "tactics": ["Privilege escalation", "Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/cobalt-strike.yaml", "query_name": "cobalt-strike", "query": "// Check for specific alerts\nAlertInfo\n// Attempts to clear security event logs.\n| where Title in(\"Event log was cleared\", \n// List alerts flagging attempts to delete backup files.\n\"File backups were deleted\", \n// Potential Cobalt Strike activity - Note that other threat activity can also \n//trigger alerts for suspicious decoded content\n\"Suspicious decoded content\", \n// Cobalt Strike activity\n\"\\'Atosev\\' malware was detected\", \n\"\\'Ploty\\' malware was detected\", \n\"\\'Bynoco\\' malware was detected\")\n| extend AlertTime = Timestamp\n| join AlertEvidence on AlertId \n| distinct DeviceName, AlertTime, AlertId, Title\n| join DeviceLogonEvents on $left.DeviceName == $right.DeviceName\n// Creating 10 day Window surrounding alert activity\n| where Timestamp < AlertTime +5d and Timestamp > AlertTime - 5d \n// Projecting specific columns\n| project Title, DeviceName, DeviceId, Timestamp, LogonType, AccountDomain, \nAccountName, AccountSid, AlertTime, AlertId, RemoteIP, RemoteDeviceName\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ransomware continues to hit healthcare, critical services. There is also a related blog.\nIn April of 2020, security researchers observed multiple ransomware campaigns using the same set of techniques. The attackers would compromise a web-facing endpoint and employ tools such as Cobalt Strike to steal users' credentials.\nCobalt Strike is commercial software used to conduct simulated threat campaigns against a target; however, malicious actors also use Cobalt Strike in real attacks. The software has a large range of capabilities, including credential theft.\nThe following query identifies accounts that have logged on to compromised endpoints and have potentially had their credentials stolen.\nReferences:\nhttps://www.microsoft.com/security/blog/2020/04/28/ransomware-groups-continue-to-target-healthcare-critical-services-heres-how-to-reduce-risk/\nhttps://www.cobaltstrike.com/\nhttps://attack.mitre.org/software/S0154/\n", "techniques": NaN, "tactics": ["Initial access", "Credential Access", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/doppelpaymer-procdump.yaml", "query_name": "doppelpaymer-procdump", "query": "// Dumping of LSASS memory using procdump\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n// Command lines that include \"lsass\" and -accepteula or -ma flags used in procdump\n| where (ProcessCommandLine has \"lsass\" and (ProcessCommandLine has \"-accepteula\" or\nProcessCommandLine contains \"-ma\"))\n// Omits possible FPs where the full command is just \"procdump.exe lsass\"\nor (FileName in~ ('procdump.exe','procdump64.exe') and ProcessCommandLine has 'lsass')\n", "attributes": {"description": "This query was originally published in the threat analytics report, Doppelpaymer: More human-operated ransomware. There is also a related blog.\nDoppelPaymer is ransomware that is spread manually by human operators. These operators have exhibited extensive knowledge of system administration and common network security misconfigurations. For example, they use SysInternal utilities such as ProcDump to dump credentials from LSASS. They often use these stolen credentials to turn off security software, run malicious commands, and spread malware throughout an organization.\nThe following query detects ProcDump being used to dump credentials from LSASS.\nThe See also section below lists links to other queries associated with DoppelPaymer.\nReferences:\nhttps://msrc-blog.microsoft.com/2019/11/20/customer-guidance-for-the-dopplepaymer-ransomware/\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Trojan:Win32/DoppelPaymer!MTB&threatId=-2147205372\nhttps://docs.microsoft.com/sysinternals/downloads/procdump\nhttps://docs.microsoft.com/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection\n", "techniques": NaN, "tactics": ["Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/identify-accounts-logged-on-to-endpoints-affected-by-cobalt-strike.yaml", "query_name": "identify-accounts-logged-on-to-endpoints-affected-by-cobalt-strike", "query": "// Check for specific alerts\nAlertInfo\n// This checks over the previous 7 days -- alter Timestamp value for other periods\n| where Timestamp > ago(7d)\n// Attempts to clear security event logs.\n| where Title in(\"Event log was cleared\",\n// List alerts flagging attempts to delete backup files.\n\"File backups were deleted\",\n// Potential Cobalt Strike activity - Note that other threat activity can also trigger alerts for suspicious decoded content\n\"Suspicious decoded content\",\n// Cobalt Strike activity\n\"\\'Atosev\\' malware was detected\",\n\"\\'Bynoco\\' malware was detected\",\n\"\\'Cosipor\\' malware was detected\")\n| extend AlertTime = Timestamp\n| join AlertEvidence on AlertId\n| project DeviceId, AlertTime, AlertId, Title\n| join DeviceLogonEvents on DeviceId\n// Creating 10 day Window surrounding alert activity\n| where Timestamp < AlertTime +5d and Timestamp > AlertTime - 5d\n// Projecting specific columns\n| project Title, DeviceName, DeviceId, Timestamp, LogonType, AccountDomain,\nAccountName, AccountSid, AlertTime, AlertId, RemoteIP, RemoteDeviceName\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ransomware continues to hit healthcare, critical services.\nIt finds all user accounts that have logged on to an endpoint affected by Cobalt Strike, a penetration tool.\nAssume that all credentials on endpoints affected by Cobalt Strike were available to attackers and that all associated accounts are compromised. Note that attackers will not only dump credentials for accounts that have logged on to interactive or RDP sessions, but will also dump cached credentials and passwords for service accounts and scheduled tasks that are stored in the LSA Secrets section of the registry.\nReference - https://attack.mitre.org/software/S0154/\n", "techniques": NaN, "tactics": ["Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/lazagne.yaml", "query_name": "lazagne", "query": "// Find credential theft via SAM database export by LaZagne\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName =~ 'reg.exe'\n    and ProcessCommandLine has 'save'\n    and ProcessCommandLine has 'hklm'\n    and ProcessCommandLine has 'sam'\n| project DeviceId, Timestamp, InitiatingProcessId,\nInitiatingProcessFileName, ProcessId, FileName, ProcessCommandLine\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ryuk ransomware. There is also a related blog.\nRyuk is human-operated ransomware. Much like DoppelPaymer ransomware, Ryuk is spread manually, often on networks that are already infected with Trickbot.\nDuring a typical Ryuk campaign, an operator will use LaZagne, a credential theft tool, to access stored passwords for service accounts. The accounts are then used to jump from desktop clients to servers or domain controllers, allowing for better reconnaissance, faster movement, and a more severe impact on the target.\nThe following query detects credential theft by LaZagne.\nThe See also section below lists links to other queries associated with Ryuk ransomware.\nReferences:\nhttps://www.microsoft.com/security/blog/2020/03/05/human-operated-ransomware-attacks-a-preventable-disaster/\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Ransom:Win32/Ryuk&threatId=-2147232689\nhttps://www.microsoft.com/security/blog/2020/03/05/human-operated-ransomware-attacks-a-preventable-disaster/\nhttps://github.com/AlessandroZ/LaZagne\n", "techniques": NaN, "tactics": ["Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/logon-attempts-after-malicious-email.yaml", "query_name": "logon-attempts-after-malicious-email", "query": "//Find logons that occurred right after malicious email was received\nlet MaliciousEmail=EmailEvents\n| where ThreatTypes has_cs \"Malware\" \n| project TimeEmail = Timestamp, Subject, SenderFromAddress, AccountName = tostring(split(RecipientEmailAddress, \"@\")[0]);\nMaliciousEmail\n| join (\nIdentityLogonEvents\n| project LogonTime = Timestamp, AccountName, DeviceName\n) on AccountName \n| where (LogonTime - TimeEmail) between (0min.. 30min)\n| take 10\n", "attributes": {"description": "This query finds the 10 latest logons performed by email recipients within 30 minutes after they received known malicious emails. You can use this query to check whether the accounts of the email recipients have been compromised.\n", "techniques": NaN, "tactics": ["Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/Private%20Key%20Files.yaml", "query_name": "Private Key Files", "query": "DeviceFileEvents\n| where Timestamp > ago(7d)\n| where FileName endswith '.pfx' or FileName endswith '.pfn' or FileName endswith '.p12'\n", "attributes": {"description": "Private Key Files.\nThis query identifies file operation with files having.\nOne of the extensions commonly used to save a private.\nKey.  The risk is that if an attacker were to obtain.\nThe file, they could brute force any password on it.\nAnd potentially obtain a powerful certificate.  To do.\nThis, they would only need to obtain read access to.\nThe file.\nThe risk associated with these files is heavily.\nDetermined by the value of the certificate.  For example,.\nLoss of a self-signed certificate created by Adobe Acrobat.\nIs significantly less impactful than loss of a website.\nSSL certificate.\nRecommendation: Know where these files are, and if possible.\nBack them up and remove them.  You might also consider.\nCreating an informational alert.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/procdump-lsass-credentials.yaml", "query_name": "procdump-lsass-credentials", "query": "DeviceProcessEvents | where (FileName has_any (\"procdump.exe\", \"procdump64.exe\") and ProcessCommandLine has \"lsass\") or \n// Looking for Accepteula flag or Write a dump file with all process memory\n(ProcessCommandLine has \"lsass.exe\" and (ProcessCommandLine has \"-accepteula\" or ProcessCommandLine contains \"-ma\"))\n", "attributes": {"description": "This query was originally published in the threat analytics report, \"Exchange Server zero-days exploited in the wild\".\nIn early March 2021, Microsoft released patches for four different zero-day vulnerabilities affecting Microsoft Exchange Server. The vulnerabilities were being used in a coordinated attack. For more information on the vulnerabilities, visit the following links:\n1. CVE-2021-26855\n2. CVE-2021-26857\n3. CVE-2021-26858\n4. CVE-2021-27065\nThe following query looks for evidence of Procdump being used to dump credentials from LSASS, the Local Security Authentication Server. This might indicate an attacker has compromised user accounts.\nMore queries related to this threat can be found under the See also section of this page.\nReference - https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/\n", "techniques": NaN, "tactics": ["Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/wadhrama-credential-dump.yaml", "query_name": "wadhrama-credential-dump", "query": "// Find use of Image File Execution Options (IFEO) in conjunction\n// with a .bat file to dump credentials\nDeviceRegistryEvents\n| where Timestamp > ago(7d)\n| where RegistryKey has \"sethc\" or RegistryKey has \"utilman\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, RDP ransomware persists as Wadhrama.\nThe ransomware known as Wadhrama has been used in human-operated attacks that follow a particular pattern. The attackers often use Remote Desktop Protocol (RDP) to gain initial access to a device or network, exfiltrate credentials, and maintain persistance.\nThe following query checks for possible Wadhrama-related activity, by detecting the technique these attackers have used in the past to dump credentials.\nOther techniques used by the group associated with Wadhrama are listed under See also.\nReference - https://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Ransom:Win32/Wadhrama\n", "techniques": NaN, "tactics": ["Credential Access", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Credential%20Access/wdigest-caching.yaml", "query_name": "wdigest-caching", "query": "union DeviceRegistryEvents, DeviceProcessEvents\n// Find attempts to turn on WDigest credential caching\n| where RegistryKey contains \"wdigest\" and RegistryValueName == \"UseLogonCredential\" and \nRegistryValueData == \"1\" or \n// Find processes created with commandlines that attempt to turn on WDigest caching\nProcessCommandLine has \"WDigest\" and ProcessCommandLine has \"UseLogonCredential\" and \nProcessCommandLine has \"dword\" and ProcessCommandLine has \"1\"\n| project Timestamp, DeviceName, PreviousRegistryValueData,  \nRegistryKey, RegistryValueName, RegistryValueData, FileName, ProcessCommandLine, \nInitiatingProcessAccountName, InitiatingProcessFileName, \nInitiatingProcessCommandLine, InitiatingProcessParentFileName\n", "attributes": {"description": "This query was originally published in the threat analytics report, WDigest credential harvesting.\nWDigest is a legacy authentication protocol dating from Windows XP. While still used on some corporate networks, this protocol can be manipulated by attackers to dump system credentials.\nThe Microsoft Security Response Center published an overview of KB2871997, which addresses WDigest use on older platforms. More recent versions of Windows can be protected with a holistic security approach that follows the principle of least privilege.\nThe following query returns any attempts to turn WDigest credential caching on through the registry.\nReferences:\nhttps://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc778868(v=ws.10)?redirectedfrom=MSDN\nhttps://msrc-blog.microsoft.com/2014/06/05/an-overview-of-kb2871997/\nhttps://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997\nhttps://docs.microsoft.com/windows-server/identity/ad-ds/plan/security-best-practices/implementing-least-privilege-administrative-models\n", "techniques": NaN, "tactics": ["Credential Access", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/ADFSDomainTrustMods%5BNobelium%5D.yaml", "query_name": "ADFSDomainTrustMods[Nobelium]", "query": "let auditLookback = 1d;\n(union isfuzzy=true \n    (\n    CloudAppEvents\n    | where Timestamp > ago(auditLookback)\n    | where ActionType =~ \"Set federation settings on domain.\"\n    ),\n    (\n    CloudAppEvents\n    | where Timestamp > ago(auditLookback)\n    | where ActionType =~ \"Set domain authentication.\"\n    | extend modifiedProperties = parse_json(RawEventData).ModifiedProperties\n    | mvexpand modifiedProperties\n    | extend newDomainValue=tostring(parse_json(modifiedProperties).NewValue)\n    | where newDomainValue has \"Federated\"\n    )\n)\n| extend resultStatus = extractjson(\"$.ResultStatus\", tostring(RawEventData), typeof(string))\n| extend targetDisplayName = parse_json(RawEventData).Target[0].ID\n| project Timestamp, ActionType, InitiatingUserOrApp=AccountDisplayName, targetDisplayName, resultStatus, InitiatingIPAddress=IPAddress, UserAgent\n", "attributes": {"description": "This query will find when federation trust settings are changed for a domain or when the domain is changed from managed to federated authentication. Results will relate to when a new Active Directory Federated Service (ADFS) TrustedRealm object, such as a signing certificate, is added.\nModification to domain federation settings should be rare, so confirm the added or modified target domain/URL is legitimate administrative behavior.\nThe actor, Nobelium, was observed modifying domain trust settings to subvert existing mechanisms and cause the domain to accept authorization tokens signed with actor-owned certificates. See Customer Guidance on Recent Nation-State Cyber Attacks.\nTo understand why an authorized user may update settings for a federated domain in Office 365, Azure, or Intune, see Update or repair the settings of a federated domain in Office 365, Azure, or Intune.\nFor details on security realms that accept security tokens, see the ADFS Proxy Protocol (MS-ADFSPP) specification: 3.2.5.1.2.4 Security Realm Data.\nFor further information on AuditLogs, please see Azure AD audit activity reference.\nThis query is inspired by an Azure Sentinal detection.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://docs.microsoft.com/office365/troubleshoot/active-directory/update-federated-domain-office-365\nhttps://docs.microsoft.com/openspecs/windows_protocols/ms-adfspp/e7b9ea73-1980-4318-96a6-da559486664b\nhttps://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities\nhttps://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/ADFSDomainTrustMods.yaml\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/alt-data-streams.yaml", "query_name": "alt-data-streams", "query": "// Alternate Data Streams execution \nDeviceProcessEvents \n| where Timestamp > ago(7d) \n// Command lines used \n| where ProcessCommandLine startswith \"-q -s\" and ProcessCommandLine hasprefix \"-p\" \n// Removing IDE processes \nand not(FolderPath has_any(\"visual studio\", \"ide\")) \n| summarize make_set(ProcessCommandLine), make_set(FolderPath), \nmake_set(InitiatingProcessCommandLine) by DeviceId, bin(Timestamp, 1h)\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ransomware continues to hit healthcare, critical services. There is also a related blog.\nIn April of 2020, security researchers observed multiple ransomware campaigns using the same set of techniques.\nThe following query detects suspicious use of Alternate Data Streams (ADS), which may indicate an attempt to mask malicious activity. These campaigns have been known to deploy ransomware in-memory and exploit ADS.\nThe See also section below lists more queries related to techniques shared by these campaigns.\nReferences:\nhttps://www.microsoft.com/security/blog/2020/04/28/ransomware-groups-continue-to-target-healthcare-critical-services-heres-how-to-reduce-risk/\nhttps://docs.microsoft.com/sysinternals/downloads/streams\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/clear-system-logs.yaml", "query_name": "clear-system-logs", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName =~ \"fsutil.exe\"\nand ProcessCommandLine has \"usn\" and ProcessCommandLine has \"deletejournal\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ransomware continues to hit healthcare, critical services. There is also a related blog.\nIn April of 2020, security researchers observed multiple ransomware campaigns using the same set of techniques.\nThe following query detects attempts to use fsutil.exe to clear system logs and delete forensic artifacts.\nThe See also section below lists more queries related to techniques shared by these campaigns.\nReference - https://www.microsoft.com/security/blog/2020/04/28/ransomware-groups-continue-to-target-healthcare-critical-services-heres-how-to-reduce-risk/\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/deleting-data-w-cipher-tool.yaml", "query_name": "deleting-data-w-cipher-tool", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)  \n| where FileName =~ \"cipher.exe\"  \n// Looking for /w flag for deleting  \n| where ProcessCommandLine has \"/w\"  \n| summarize CommandCount = dcount(ProcessCommandLine), \nmake_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 1m)  \n// Looking for multiple drives in a short timeframe  \n| where CommandCount > 1\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ransomware continues to hit healthcare, critical services. There is also a related blog.\nIn April of 2020, security researchers observed multiple ransomware campaigns using the same set of techniques.\nThe following query detects the use of the tool cipher.exe to delete indicators of malicious activity right before encrypting a drive.\nThe See also section below lists more queries related to techniques shared by these campaigns.\nReference - https://www.microsoft.com/security/blog/2020/04/28/ransomware-groups-continue-to-target-healthcare-critical-services-heres-how-to-reduce-risk/\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/Discovering%20potentially%20tampered%20devices%20%5BNobelium%5D.yaml", "query_name": "Discovering potentially tampered devices [Nobelium]", "query": "// Times to be modified as appropriate\nlet timeAgo=1d;\nlet silenceTime=8h;\n// Get all silent devices and IPs from network events\nlet allNetwork=materialize(DeviceNetworkEvents\n| where Timestamp > ago(timeAgo)\nand isnotempty(LocalIP)\nand isnotempty(RemoteIP)\nand ActionType in (\"ConnectionSuccess\", \"InboundConnectionAccepted\")\nand LocalIP !in (\"127.0.0.1\", \"::1\")\n| project DeviceId, Timestamp, LocalIP, RemoteIP, ReportId);\nlet nonSilentDevices=allNetwork\n| where Timestamp > ago(silenceTime)\n| union (DeviceProcessEvents | where Timestamp > ago(silenceTime))\n| summarize by DeviceId;\nlet nonSilentIPs=allNetwork\n| where Timestamp > ago(silenceTime)\n| summarize by LocalIP;\nlet silentDevices=allNetwork\n| where DeviceId !in (nonSilentDevices)\nand LocalIP !in (nonSilentIPs)\n| project DeviceId, LocalIP, Timestamp, ReportId;\n// Get all remote IPs that were recently active\nlet addressesDuringSilence=allNetwork\n| where Timestamp > ago(silenceTime)\n| summarize by RemoteIP;\n// Potentially disconnected devices were connected but are silent\nsilentDevices\n| where LocalIP in (addressesDuringSilence)\n| summarize ReportId=arg_max(Timestamp, ReportId), Timestamp=max(Timestamp), LocalIP=arg_max(Timestamp, LocalIP) by DeviceId\n| project DeviceId, ReportId=ReportId1, Timestamp, LocalIP=LocalIP1\n", "attributes": {"description": "To evade security software and analyst tools, Nobelium malware enumerates the target system looking for certain running processes, loaded drivers, and registry keys, with the goal of disabling them.\nThe Microsoft Defender for Endpoint sensor is one of the processes the malware attempts to disable.\nMicrosoft Defender for Endpoint has built-in protections against many techniques attackers use to disable endpoint sensors ranging from hardened OS protection, anti-tampering policies, and detections for a variety of tampering attempts, including \"Attempt to stop Microsoft Defender for Endpoint sensor\", \"Tampering with Microsoft Defender for Endpoint sensor settings\", or \"Possible sensor tampering in memory\".\nSuccessfully disabling Microsoft Defender for Endpoint can prevent the system from reporting observed activities.\nHowever, the multitude of signals reported into Microsoft 365 Defender provides a unique opportunity to hunt for systems where the tampering technique used might have been successful.\nThe following advanced hunting query can be used to locate devices that should be reporting but aren't:\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/doppelpaymer-stop-services.yaml", "query_name": "doppelpaymer-stop-services", "query": "// Attempts to stop services and allow ransomware execution\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n| where InitiatingProcessFileName startswith \"psexe\" and FileName =~ \"powershell.exe\" and\nProcessCommandLine has \"stop-service\"\nand ProcessCommandLine has \"sql\" and ProcessCommandLine has \"msexchange\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Doppelpaymer: More human-operated ransomware. There is also a related blog.\nDoppelPaymer is ransomware that is spread manually by human operators. These operators have exhibited extensive knowledge of system administration and common network security misconfigurations. They often use stolen credentials from over-privileged service accounts to turn off security software, run malicious commands, and spread malware throughout an organization.\nThe following query detects attempts to stop security services.\nThe See also section below lists links to other queries associated with DoppelPaymer.\nReferences:\nhttps://msrc-blog.microsoft.com/2019/11/20/customer-guidance-for-the-dopplepaymer-ransomware/\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Trojan:Win32/DoppelPaymer!MTB&threatId=-2147205372\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/hiding-java-class-file.yaml", "query_name": "hiding-java-class-file", "query": "union DeviceFileEvents, DeviceProcessEvents\n| where ProcessCommandLine has \"attrib +h +s +r \" \nand ProcessCommandLine contains \".class\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Adwind utilizes Java for cross-platform impact.\nAdwind is a remote access tool (RAT) that takes advantage of the cross-platform capabilities of the Java framework. It can check which operating system a target is running and adapt accordingly, allowing it to successfully compromise both Windows and macOS devices.\nThe query below checks for attempts to disguise Java class files (i.e., complied code with a .class extension). Although the behavior detected by this query is typical of attacks that use Adwind malware, unrelated attacks may use the same or similar defense evasion techniques.\nSee Detecting a JAR attachment for an additional query that detects behavior associated with Adwind attacks.\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/locate-files-possibly-signed-by-fraudulent-ecc-certificates.yaml", "query_name": "locate-files-possibly-signed-by-fraudulent-ecc-certificates", "query": "DeviceFileCertificateInfo\n| where Timestamp > ago(30d)\n| where IsSigned == 1 and IsTrusted == 1 and IsRootSignerMicrosoft == 1\n| where SignatureType == \"Embedded\"\n| where Issuer !startswith \"Microsoft\" and Issuer !startswith \"Windows\"\n| project Timestamp, DeviceName,SHA1,Issuer,IssuerHash,Signer,SignerHash,\nCertificateCreationTime,CertificateExpirationTime,CrlDistributionPointUrls\n", "attributes": {"description": "This query was originally published in the threat analytics report, CVE-2020-0601 certificate validation vulnerability.\nThe Windows CryptoAPI Spoofing Vulnerability, CVE-2020-0601, can be exploited to spoof code-signing certificates. For example, an attacker could forge a certificate that lists Microsoft as the issuer. This would allow an attacker to disguise a malicious executable as legitimate.\nThe vulnerability was patched with the January 2020 Security Update.\nUse the following query to locate files containing ECC certificates that might have been forged using this vulnerability. The query identifies files that don't correctly identify the signer name, yet list Microsoft as the root signer.\nReferences:\nhttps://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2020-0601\nhttps://portal.msrc.microsoft.com/security-guidance/releasenotedetail/2020-Jan\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/MailPermissionsAddedToApplication%5BNobelium%5D.yaml", "query_name": "MailPermissionsAddedToApplication[Nobelium]", "query": "let auditLookback = 1d;\nCloudAppEvents\n| where Timestamp > ago(auditLookback)\n| where ActionType == \"Add delegated permission grant.\"\n| extend RawEventData = parse_json(RawEventData)\n| where RawEventData.ResultStatus =~ \"success\"\n| extend UserId = tostring(RawEventData.UserId)\n| extend UserAgent = parse_json(replace('-','',tostring(RawEventData.ExtendedPRoperties[0].Value))).UserAgent\n| extend properties = RawEventData.ModifiedProperties\n| mvexpand properties\n| extend Permissions = properties.NewValue\n| where Permissions has_any (\"Mail.Read\", \"Mail.ReadWrite\")\n| extend PermissionsAddedTo = tostring(RawEventData.Target[3].ID) // Get target of permissions\n| project-away properties, RawEventData\n| join kind=leftouter (CloudAppEvents\n    | where Timestamp > ago(auditLookback)\n    | where ActionType == \"Consent to application.\"\n    | where isnotempty(AccountDisplayName)\n    | extend RawEventData = parse_json(RawEventData)\n    | extend UserId = tostring(RawEventData.UserId)\n    | extend targetInfo = RawEventData.Target\n    | extend AppName = tostring(targetInfo[3].ID) // Find app name\n    | extend AppId = tostring(targetInfo[4].ID) // Find appId\n    | project ConsentTimestamp=Timestamp, UserId, AccountDisplayName, AppName, AppId\n) on UserId\n| extend ConsentTimestamp = todatetime(format_datetime(ConsentTimestamp, 'MM/dd/yyyy HH:mm')) // Ensure app consent happend close to the same time as the permissions were granted\n| extend PermsTimestamp = todatetime(format_datetime(Timestamp, 'MM/dd/yyyy HH:mm'))\n| where PermsTimestamp -2m <= ConsentTimestamp // ensure consent happened near permissions grant\n| where PermsTimestamp +2m >= ConsentTimestamp\n| project Timestamp, ActionType, InitiatingUser=AccountDisplayName, UserId, InitiatingIP=IPAddress, UserAgent, PermissionsAddedTo, AppName, AppId\n", "attributes": {"description": "This query will find applications that have been granted Mail.Read or Mail.ReadWrite permissions in which the corresponding user recently consented to. It can help identify applications that have been abused to gain access to user email.\nThe actor, Nobelium, was observed modifying existing tenant application permissions to allow them to read user email through the Microsoft Graph API. See Customer Guidance on Recent Nation-State Cyber Attacks.\nThis query is insprired by an Azure Sentinel detection.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/MailPermissionsAddedToApplication.yaml\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/PotentialMicrosoftDefenderTampering%5BSolarigate%5D.yaml", "query_name": "PotentialMicrosoftDefenderTampering[Solarigate]", "query": "let includeProc = dynamic([\"sc.exe\",\"net1.exe\",\"net.exe\", \"taskkill.exe\", \"cmd.exe\", \"powershell.exe\"]);\nlet action = dynamic([\"stop\",\"disable\", \"delete\"]);\nlet service1 = dynamic(['sense', 'windefend', 'mssecflt']);\nlet service2 = dynamic(['sense', 'windefend', 'mssecflt', 'healthservice']);\nlet params1 = dynamic([\"-DisableRealtimeMonitoring\", \"-DisableBehaviorMonitoring\" ,\"-DisableIOAVProtection\"]);\nlet params2 = dynamic([\"sgrmbroker.exe\", \"mssense.exe\"]);\nlet regparams1 = dynamic(['reg add \"HKLM\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows Defender\"', 'reg add \"HKLM\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows Advanced Threat Protection\"']);\nlet regparams2 = dynamic(['ForceDefenderPassiveMode', 'DisableAntiSpyware']);\nlet regparams3 = dynamic(['sense', 'windefend']);\nlet regparams4 = dynamic(['demand', 'disabled']);\nlet timeframe = 1d;\n DeviceProcessEvents\n  | where Timestamp >= ago(timeframe)\n  | where InitiatingProcessFileName in~ (includeProc)\n  | where (InitiatingProcessCommandLine has_any(action) and InitiatingProcessCommandLine has_any (service2) and InitiatingProcessParentFileName != 'cscript.exe')\n  or (InitiatingProcessCommandLine has_any (params1) and InitiatingProcessCommandLine has 'Set-MpPreference' and InitiatingProcessCommandLine has '$true') \n  or (InitiatingProcessCommandLine has_any (params2) and InitiatingProcessCommandLine has \"/IM\") \n  or (InitiatingProcessCommandLine has_any (regparams1) and InitiatingProcessCommandLine has_any (regparams2) and InitiatingProcessCommandLine has '/d 1') \n  or (InitiatingProcessCommandLine has_any(\"start\") and InitiatingProcessCommandLine has \"config\" and InitiatingProcessCommandLine has_any (regparams3) and InitiatingProcessCommandLine has_any (regparams4))\n  | extend Account = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName), Computer = DeviceName\n  | project Timestamp, Computer, Account, AccountDomain, ProcessName = InitiatingProcessFileName, ProcessNameFullPath = FolderPath, Activity = ActionType, CommandLine = InitiatingProcessCommandLine, InitiatingProcessParentFileName\n", "attributes": {"description": "Identifies potential service tampering related to Microsoft Defender services.\nQuery insprired by Azure Sentinel detection https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/PotentialMicrosoftDefenderTampering.yaml\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/qakbot-campaign-process-injection.yaml", "query_name": "qakbot-campaign-process-injection", "query": "DeviceProcessEvents\n| where FileName == \"esentutl.exe\"\n| where ProcessCommandLine has \"WebCache\"\n| where ProcessCommandLine has_any (\"V01\", \"/s\", \"/d\")\n| project ProcessCommandLine, InitiatingProcessParentFileName, \nDeviceId, Timestamp\n", "attributes": {"description": "This query was originally published in the threat analytics report, Qakbot blight lingers, seeds ransomware\nQakbot is malware that steals login credentials from banking and financial services. It has been deployed against small businesses as well as major corporations. Some outbreaks have involved targeted ransomware campaigns that use a similar set of techniques. Links to related queries are listed under See also.\nThe following query detects if Qakbot has injected code into the ping.exe process, to evade security and access credentials.\nReference - https://www.microsoft.com/security/blog/2017/11/06/mitigating-and-eliminating-info-stealing-qakbot-and-emotet-in-corporate-networks/\n", "techniques": NaN, "tactics": ["Defense evasion", "Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/qakbot-campaign-self-deletion.yaml", "query_name": "qakbot-campaign-self-deletion", "query": "DeviceProcessEvents \n| where FileName =~ \"ping.exe\"\n| where InitiatingProcessFileName =~ \"cmd.exe\"\n| where InitiatingProcessCommandLine has \"calc.exe\" and\nInitiatingProcessCommandLine has \"-n 6\" \nand InitiatingProcessCommandLine has \"127.0.0.1\"\n| project ProcessCommandLine, InitiatingProcessCommandLine,\nInitiatingProcessParentFileName, DeviceId, Timestamp\n", "attributes": {"description": "This query was originally published in the threat analytics report, Qakbot blight lingers, seeds ransomware\nQakbot is malware that steals login credentials from banking and financial services. It has been deployed against small businesses as well as major corporations. Some outbreaks have involved targeted ransomware campaigns that use a similar set of techniques. Links to related queries are listed under See also.\nThe following query detects if an instance of Qakbot has attempted to overwrite its original binary.\nReference - https://www.microsoft.com/security/blog/2017/11/06/mitigating-and-eliminating-info-stealing-qakbot-and-emotet-in-corporate-networks/\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Defense%20evasion/UpdateStsRefreshToken%5BSolorigate%5D.yaml", "query_name": "UpdateStsRefreshToken[Solorigate]", "query": "CloudAppEvents \n| where ActionType == \"Update StsRefreshTokenValidFrom Timestamp.\"\n| where RawEventData !has \"Directorysync\"\n| extend displayName = RawEventData.ModifiedProperties[0].Name  \n| where displayName == \"StsRefreshTokensValidFrom\"\n| extend oldValue = RawEventData.ModifiedProperties[0].OldValue\n| extend newValue = RawEventData.ModifiedProperties[0].NewValue\n| extend oldStsRefreshValidFrom = todatetime(parse_json(tostring(oldValue))[0])\n| extend newStsRefreshValidFrom = todatetime(parse_json(tostring(newValue))[0])\n| extend tokenMinutesAdded = datetime_diff('minute',newStsRefreshValidFrom,oldStsRefreshValidFrom)\n| extend tokenMinutesRemaining = datetime_diff('minute',Timestamp,newStsRefreshValidFrom)\n| extend Role = parse_json(RawEventData.Actor[-1]).ID\n| distinct AccountObjectId, AccountDisplayName, tostring(Role), IPAddress, IsAnonymousProxy, ISP, tokenMinutesAdded, tokenMinutesRemaining\n", "attributes": {"description": "This will show Active Directory Security Token Service (STS) refresh token modifications by Service Principals and Applications other than DirectorySync. Refresh tokens are used to validate identification and obtain access tokens. This event is most often generated when legitimate administrators troubleshoot frequent AAD user sign-ins but may also be generated as a result of malicious token extensions. Confirm that the activity is related to an administrator legitimately modifying STS refresh tokens and check the new token validation time period for high values.\nQuery insprired by Azure Sentinel detection https://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/StsRefreshTokenModification.yaml\n", "techniques": NaN, "tactics": ["Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/detect-jscript-file-creation.yaml", "query_name": "detect-jscript-file-creation", "query": "// Creation of any .jse file, including legitimate and malicious ones \nDeviceFileEvents \n| where Timestamp > ago(7d)\n| where FileName endswith \".jse\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Emulation-evading JavaScripts.\nAttackers in several ransomware campaigns have employed heavily obfuscated JavaScript code, in order to implant malware or execute malicious commands. The obfuscation is intended to help the code evade security systems and potentially escape sandbox environments.\nThe following query detects the creation of files with a .jse extension. Certain ransomware campaigns, such as Emotet, are known to employ encrypted JavaScript code that is saved to the target as .jse files.\nSee Detect potentially malicious .jse launch by File Explorer or Word for a similar technique.\nReference - https://www.microsoft.com/security/blog/2017/11/06/mitigating-and-eliminating-info-stealing-qakbot-and-emotet-in-corporate-networks/\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Doc%20attachment%20with%20link%20to%20download.yaml", "query_name": "Doc attachment with link to download", "query": "let minTimeRange = ago(7d);\nlet wordLinks = \n    DeviceEvents\n    // Filter on click on links from WinWord\n    | where Timestamp > minTimeRange and ActionType == \"BrowserLaunchedToOpenUrl\" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ \"winword.exe\"\n    | project ClickTime=Timestamp, DeviceId, DeviceName, ClickUrl=RemoteUrl;\nlet docAttachments = \n    DeviceFileEvents\n    | where Timestamp > minTimeRange \n\t\t\t// Query for common document file extensions\n            and (FileName endswith \".docx\" or FileName endswith \".docm\" or FileName endswith \".doc\")\n\t\t\t// Query for files saved from email clients such as the Office Outlook app or the Windows Mail app\n            and InitiatingProcessFileName in~ (\"outlook.exe\", \"hxoutlook.exe\")\n    | summarize AttachmentSaveTime=min(Timestamp) by AttachmentName=FileName, DeviceId;\nlet browserDownloads = \n    DeviceFileEvents\n    | where Timestamp > minTimeRange \n\t\t\t// Query for files created by common browsers\n            and InitiatingProcessFileName in~ (\"browser_broker.exe\", \"chrome.exe\", \"iexplore.exe\", \"firefox.exe\")\n            // Exclude JS files that are used for loading sites (but still query for JS files that are known to be downloaded)\n            and not (FileName endswith \".js\" and isempty(FileOriginUrl))\n    // Further filter to exclude file extensions that are less indicative of an attack (when there were already previously a doc attachment that included a link)\n    | where FileName !endswith \".partial\" and FileName !endswith \".docx\"\n    | summarize (Timestamp, SHA1) = argmax(Timestamp, SHA1) by FileName, DeviceId, FileOriginUrl;\n// Perf tip: start the joins from the smallest table (put it on the left-most side of the joins)\nwordLinks\n| join kind= inner (docAttachments) on DeviceId | where ClickTime - AttachmentSaveTime between (0min..3min)\n| join kind= inner (browserDownloads) on DeviceId | where Timestamp - ClickTime between (0min..3min) \n// Aggregating multiple \"attachments\" together - because oftentimes the same file is stored multiple times under different names\n| summarize Attachments=makeset(AttachmentName), AttachmentSaveTime=min(AttachmentSaveTime), ClickTime=min(ClickTime)\n    by // Downloaded file details\n        bin(Timestamp, 1tick), FileName, FileOriginUrl, ClickUrl, SHA1, DeviceName, DeviceId\n", "attributes": {"description": "This query looks for a Word document attachment, from which a link was clicked, and after which there was a browser download.\nThis query is not noisy, but most of its results are clean.\nIt can also hserve as reference for other queries on email attachments, on browser downloads or for queries that join multiple events by time.\nTags: #EmailAttachment, #WordLink, #BrowserDownload, #Phishing, #DedupFileCreate.\nImplementation comment #1: Matching events by time.\nMatching the 3 different events (saving attachment, clicking on link, downloading file) is done purely by time difference - so could sometimes link together unrelated events.\nDoing a more exact lookup would create a much more complex query due to.\nImplementation comment #2: Deduping DeviceFileEvents.\nOftentimes there are multiple DeviceFileEvents for a single file - e.g. if the file keeps being appended into before being closed.\nSo, we query only for the last reported file state to ignore intermediate file states.\nExplaining the underlying data:.\nBrowserLaunchedToOpenUrl event:.\nThis query uses the BrowserLaunchedToOpenUrl event, that includes clicks on http:// or https:// links (clicks outside of browsers), or on .lnk files.\nFor this event, RemoteUrl contains the opened URL.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Dropbox%20downloads%20linked%20from%20other%20site.yaml", "query_name": "Dropbox downloads linked from other site", "query": "DeviceFileEvents\n| where \n    Timestamp > ago(7d)\n    and FileOriginUrl startswith \"https://dl.dropboxusercontent.com/\"\n    and isnotempty(FileOriginReferrerUrl)\n    and FileOriginReferrerUrl !startswith \"https://www.dropbox.com/\" \n| project FileOriginReferrerUrl, FileName \n", "attributes": {"description": "This query looks for user content downloads from dropbox that originate from a link/redirect from a 3rd party site.\nFile sharing sites such as Dropbox are often used for hosting malware on a reputable site.\nRead more about download URL data and about this attack vector in this blog post:.\nHttps://techcommunity.microsoft.com/t5/Threat-Intelligence/Hunting-tip-of-the-month-Browser-downloads/td-p/220454.\nTags: #DownloadUrl, #Referer, #Dropbox.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Email%20link%20%2B%20download%20%2B%20SmartScreen%20warning.yaml", "query_name": "Email link + download + SmartScreen warning", "query": "let smartscreenAppWarnings =\n// Query for SmartScreen warnings of unknown executed applications\n    DeviceEvents\n    | where ActionType == \"SmartScreenAppWarning\"\n    | project WarnTime=Timestamp, DeviceName, WarnedFileName=FileName, WarnedSHA1=SHA1, ActivityId=extractjson(\"$.ActivityId\", AdditionalFields, typeof(string))\n    // Select only warnings that the user has decided to ignore and has executed the app.\n    | join kind=leftsemi (\n            DeviceEvents\n            | where ActionType == \"SmartScreenUserOverride\"\n            | project DeviceName, ActivityId=extractjson(\"$.ActivityId\", AdditionalFields, typeof(string)))\n         on DeviceName, ActivityId\n\t| project-away ActivityId;\n// Query for links opened from outlook, that are close in time to a SmartScreen warning\nlet emailLinksNearSmartScreenWarnings =\n    DeviceEvents\n    | where ActionType == \"BrowserLaunchedToOpenUrl\" and isnotempty(RemoteUrl) and InitiatingProcessFileName =~ \"outlook.exe\"\n    | extend WasOutlookSafeLink=(tostring(parse_url(RemoteUrl).Host) endswith \"safelinks.protection.outlook.com\")\n    | project DeviceName, MailLinkTime=Timestamp,\n        MailLink=iff(WasOutlookSafeLink, url_decode(tostring(parse_url(RemoteUrl)[\"Query Parameters\"][\"url\"])), RemoteUrl)\n    | join kind=inner smartscreenAppWarnings on DeviceName | where (WarnTime-MailLinkTime) between (0min..4min);\n// Add the browser download event to tie in all the dots\nDeviceFileEvents\n| where isnotempty(FileOriginUrl) and InitiatingProcessFileName in~ (\"chrome.exe\", \"browser_broker.exe\")\n| project FileName, FileOriginUrl, FileOriginReferrerUrl, DeviceName, Timestamp, SHA1\n| join kind=inner emailLinksNearSmartScreenWarnings on DeviceName\n| where (Timestamp-MailLinkTime) between (0min..3min) and (WarnTime-Timestamp) between (0min..1min)\n| project FileName, MailLink, FileOriginUrl, FileOriginReferrerUrl, WarnedFileName, DeviceName, SHA1, WarnedSHA1, Timestamp\n| distinct *\n", "attributes": {"description": "Look for links opened from outlook.exe, followed by a browser download and then a SmartScreen app warning that was ignored by the user.\nRead more about these events and this hunting approach in this post: https://techcommunity.microsoft.com/t5/forums/editpage/board-id/WDATPActor/message-id/34.\nData availability: SmartScreen events are available only on Windows 10 version 1703 and onwards.\nTags: #EmailLink, #BrowserDownload, #SmartScreen.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Gootkit-malware.yaml", "query_name": "Gootkit-malware", "query": "AlertInfo | where Title =~ \"Suspected delivery of Gootkit malware\"\n// Below section is to surface active follow-on Command and Control as a result of the above behavior. Comment out the below joins to see\n// only file create events where the malware may be present but has not yet been executed.\n////\n// Get alert evidence\n| join AlertEvidence on $left.AlertId == $right.AlertId\n// Look for C2\n| join DeviceNetworkEvents  on $left.DeviceId == $right.DeviceId\n| where InitiatingProcessFileName =~ \"wscript.exe\" and InitiatingProcessCommandLine has \".zip\" and InitiatingProcessCommandLine has \".js\"\n| summarize by RemoteUrl, RemoteIP , DeviceId, InitiatingProcessCommandLine, Timestamp, \nInitiatingProcessFileName, AlertId, Title, AccountName\n", "attributes": {"description": "This query was originally published on Twitter, by @MsftSecIntel.\nGootkit is malware that started life as a banking trojan, and has since extended its capabilities to allow for a variety of malicious activities.\nThe query helps find events related to Gootkit downloads and command-and-control behavior.\nReference - https://twitter.com/MsftSecIntel\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Open%20email%20link.yaml", "query_name": "Open email link", "query": "// Query for links opened from mail apps - if a detection occurred right afterwards. - MTP Schema\n// As there are many links opened from mails, to have a successful hunt we should have some filter or join with some other signal,\n// such as suspicious processes, network connections, etc.\n// Therefore, in this example, we query for alerts that might be related to links sent via email.\n// This could be indicative of a phishing or spear-phishing attacks.\n// Tags: #EmailLink, #Phishing, #GetNearbyAlerts\n// Explaining the underlying data:\n//     This query uses the BrowserLaunchedToOpenUrl event, that includes clicks on http:// or https:// links (clicks outside of browsers), or on .lnk files\n//     For this event, RemoteUrl contains the opened URL.\nlet minTimeRange = ago(7d);\nlet outlookLinks = \n    DeviceEvents\n    // Filter on click on links from outlook\n    | where Timestamp > minTimeRange and ActionType == \"BrowserLaunchedToOpenUrl\" and isnotempty(RemoteUrl)\n\t| where \n\t\t\t// outlook.exe is the Office Outlook app\n\t\t\tInitiatingProcessFileName =~ \"outlook.exe\" \n\t\t\t// RuntimeBroker.exe opens links for all apps from the Windows store, including the Windows Mail app (HxOutlook.exe).\n\t\t\t// However, it will also include some links opened from other apps.\t\t\t\n\t        or InitiatingProcessFileName =~ \"runtimebroker.exe\"\n    | project Timestamp, DeviceId, DeviceName, RemoteUrl, InitiatingProcessFileName, ParsedUrl=parse_url(RemoteUrl)\n    // When applicable, parse the link sent via email from the clicked O365 ATP SafeLink\n    | extend WasOutlookSafeLink=(tostring(ParsedUrl.Host) endswith \"safelinks.protection.outlook.com\")\n    | project Timestamp, DeviceId, DeviceName, WasOutlookSafeLink, InitiatingProcessFileName,\n            OpenedLink=iff(WasOutlookSafeLink, url_decode(tostring(ParsedUrl[\"Query Parameters\"][\"url\"])), RemoteUrl);\nlet alerts =\n    AlertInfo | join AlertEvidence on AlertId\n    | summarize (FirstDetectedActivity, Title)=argmin(Timestamp, Title) by AlertId, DeviceId\n    // Filter alerts that include events from before the queried time period\n    | where FirstDetectedActivity > minTimeRange;\n// Join the two together - looking for alerts that are right after an abnormal network logon\nalerts | join kind=inner (outlookLinks) on DeviceId | where FirstDetectedActivity - Timestamp between (0min..3min)\n// If there are multiple alerts close to a single click-on-link, aggregate them together to a single row\n// Note: bin(Timestamp, 1tick) is used because when summarizing by a datetime field, the default \"bin\" used is 1-hour.\n| summarize FirstDetectedActivity=min(FirstDetectedActivity), AlertTitles=makeset(Title) by OpenedLink, InitiatingProcessFileName, Timestamp=bin(Timestamp, 1tick), DeviceName, DeviceId, WasOutlookSafeLink\n", "attributes": {"description": "Query for links opened from mail apps - if a detection occurred right afterwards.\nAs there are many links opened from mails, to have a successful hunt we should have some filter or join with some other signal,.\nSuch as suspicious processes, network connections, etc.\nTherefore, in this example, we query for alerts that might be related to links sent via email.\nThis could be indicative of a phishing or spear-phishing attacks.\nTags: #EmailLink, #Phishing, #GetNearbyAlerts.\nExplaining the underlying data:.\nThis query uses the BrowserLaunchedToOpenUrl event, that includes clicks on http:// or https:// links (clicks outside of browsers), or on .lnk files.\nFor this event, RemoteUrl contains the opened URL.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Pivot%20from%20detections%20to%20related%20downloads.yaml", "query_name": "Pivot from detections to related downloads", "query": "let detectedDownloads =\n    DeviceEvents\n    | where ActionType == \"AntivirusDetection\" and isnotempty(FileOriginUrl)\n    | project Timestamp, FileOriginUrl, FileName, DeviceId,\n              ThreatName=tostring(parse_json(AdditionalFields).ThreatName)\n    // Filter out less severe threat categories on which we do not want to pivot\n    | where ThreatName !startswith \"PUA\"\n            and ThreatName !startswith \"SoftwareBundler:\" \n            and FileOriginUrl != \"about:internet\";\nlet detectedDownloadsSummary =\n    detectedDownloads\n    // Get a few examples for each detected Host:\n    // up to 4 filenames, up to 4 threat names, one full URL)\n    | summarize DetectedUrl=any(FileOriginUrl),\n                DetectedFiles=makeset(FileName, 4),\n                ThreatNames=makeset(ThreatName, 4)\n                by Host=tostring(parse_url(FileOriginUrl).Host);\n// Query for downloads from sites from which other downloads were detected by Windows Defender Antivirus\nDeviceFileEvents\n| where isnotempty(FileOriginUrl)\n| project FileName, FileOriginUrl, DeviceId, Timestamp,\n          Host=tostring(parse_url(FileOriginUrl).Host), SHA1 \n// Filter downloads from hosts serving detected files\n| join kind=inner(detectedDownloadsSummary) on Host\n// Filter out download file create events that were also detected.\n// This is needed because sometimes both of these events will be reported, \n// and sometimes only the AntivirusDetection event - depending on timing.\n| join kind=leftanti(detectedDownloads) on DeviceId, FileOriginUrl\n// Summarize a single row per host - with the machines count \n// and an example event for a missed download (select the last event)\n| summarize MachineCount=dcount(DeviceId), arg_max(Timestamp, *) by Host\n// Filter out common hosts, as they probably ones that also serve benign files\n| where MachineCount < 20\n| project Host, MachineCount, DeviceId, FileName, DetectedFiles, \n          FileOriginUrl, DetectedUrl, ThreatNames, Timestamp, SHA1\n| order by MachineCount desc \n", "attributes": {"description": "Pivot from downloads detected by Windows Defender Antivirus to other files downloaded from the same sites.\nTo learn more about the download URL info that is available and see other sample queries,.\nCheck out this blog post: https://techcommunity.microsoft.com/t5/Threat-Intelligence/Hunting-tip-of-the-month-Browser-downloads/td-p/220454.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/powercat-download.yaml", "query_name": "powercat-download", "query": "DeviceProcessEvents | where FileName has_any (\"cmd.exe\", \"powershell.exe\", \"PowerShell_ISE.exe\") | where ProcessCommandLine endswith \"powercat.ps1\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, \"Exchange Server zero-days exploited in the wild\".\nIn early March 2021, Microsoft released patches for four different zero-day vulnerabilities affecting Microsoft Exchange Server. The vulnerabilities were being used in a coordinated attack. For more information on the vulnerabilities, visit the following links:\n1. CVE-2021-26855\n2. CVE-2021-26857\n3. CVE-2021-26858\n4. CVE-2021-27065\nThe following query detects downloads of powercat, an exploitation tool for PowerShell. Although associated with these zero-day attacks, powercat is a multi-purpose tool that is also used by other groups of attackers.\nMore queries related to this threat can be found under the See also section of this page.\nReference - https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/\n", "techniques": NaN, "tactics": ["Execution", "Discovery", "Exfiltration", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Delivery/Qakbot%20Craigslist%20Domains.yaml", "query_name": "Qakbot Craigslist Domains", "query": "DeviceNetworkEvents\n| where RemoteUrl matches regex @\"abuse\\.[a-zA-Z]\\d{2}-craigslist\\.org\"\n", "attributes": {"description": "Qakbot operators have been abusing the Craigslist messaging system to send malicious emails. These emails contain non-clickable links to malicious domains impersonating Craigslist, which the user is instructed to manually type into the address bar to access.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Anomalous%20Device%20Models.yaml", "query_name": "Anomalous Device Models", "query": "// \nlet AnomalousModelCount = 5;\nDeviceInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| summarize ModelAppearanceCount=dcount(DeviceId) by Model\n| where ModelAppearanceCount < AnomalousModelCount", "attributes": {"description": "This query finds anomalous models discovered\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Can%20Be%20Onboarded%20Devices.yaml", "query_name": "Can Be Onboarded Devices", "query": "// Can Be Onboarded devices\nlet CanBeOnboarded = \"Can be onboarded\";\nDeviceInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| where OnboardingStatus == CanBeOnboarded", "attributes": {"description": "This query surfaces devices that were discovered by Microsoft Defender for Endpoint and can be onboarded\n", "techniques": [], "tactics": ["Resource Development", "Initial Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Commonality%20of%20Operating%20Systems.yaml", "query_name": "Commonality of Operating Systems", "query": "//\nDeviceInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| summarize dcount(DeviceId) by OSDistribution\n", "attributes": {"description": "This query provides the commonality of operating systems seen in the inventory\n", "techniques": [], "tactics": ["Resource Development"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Count%20and%20Percentage%20of%20DeviceType.yaml", "query_name": "Count and Percentage of DeviceType out of total inventory", "query": "let TotalDevices = toscalar(DeviceInfo\n| where Timestamp > ago(7d)\n| summarize arg_max(Timestamp, *) by DeviceId\n| summarize dcount(DeviceId));\nDeviceInfo\n| where Timestamp > ago(7d)\n| summarize arg_max(Timestamp, *) by DeviceId\n| summarize DevicesByDeviceType = dcount(DeviceId) by DeviceType\n| extend TotalDevices=TotalDevices\n| extend PercentageOfDeviceType =(DevicesByDeviceType * 100 ) / TotalDevices", "attributes": {"description": "This query presents statistics on count and percentage of DeviceType out of total inventory\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Devices%20By%20Specific%20DeviceType%20and%20DeviceSubtype.yaml", "query_name": "Devices By Specific DeviceType and DeviceSubtype", "query": "// Specify the wanted DeviceType and/or DeviceSubtype\nlet HuntedDeviceType = \"NetworkDevice\";\nlet HuntedDeviceSubtype = \"Router\";\nDeviceInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| where DeviceType == HuntedDeviceType and DeviceSubtype  == HuntedDeviceSubtype", "attributes": {"description": "This query finds devices by DeviceType and/or DeviceSubtype\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Devices%20In%20Subnet%20-%20IPAddressV4.yaml", "query_name": "Devices In Subnet - IPAddressV4", "query": "// Specify the relevant subnet in IpV4Range\nlet IpV4Range = \"172.22.138.0/24\";\nDeviceNetworkInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| mv-expand IPAddressEntry=todynamic(IPAddresses)\n| extend IPAddress=tostring(IPAddressEntry.IPAddress)\n| where ipv4_is_in_range(IPAddress, IpV4Range)", "attributes": {"description": "This query surfaces devices that are in a specific IPAddressV4 subnet\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Devices%20In%20Subnet%20-%20IPAddressV6.yaml", "query_name": "Devices In Subnet - IPAddressV6", "query": "// Specify the relevant subnet in IpV6Range\nlet IpV6Range = \"2001:4898::1050:1050/127\";\nDeviceNetworkInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| mv-expand IPAddressEntry=todynamic(IPAddresses)\n| extend IPAddress=tostring(IPAddressEntry.IPAddress)\n| where ipv6_is_match(IPAddress, IpV6Range)", "attributes": {"description": "This query surfaces devices that are in a specific IPAddressV6 subnet\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Most%20Common%20Services.yaml", "query_name": "Most Common Services", "query": "//\nDeviceTvmSoftwareVulnerabilities \n| where ingestion_time() > ago(7d)\n| summarize arg_max(DeviceId, *) by SoftwareVendor, SoftwareName\n| summarize DiscoveredOnDevicesCount = dcount(DeviceId) by SoftwareVendor, SoftwareName", "attributes": {"description": "This query provides the most common services discovered\n", "techniques": [], "tactics": ["Initial Access", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/NotOnboarded%20Devices%20by%20DeviceName%20Prefix.yaml", "query_name": "NotOnboarded Devices by DeviceName Prefix", "query": "//\nlet Onboarded = \"Onboarded\";\nlet DeviceNamePrefix = \"minint\";\nDeviceInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| where OnboardingStatus != \"Onboarded\"\n| where DeviceName startswith DeviceNamePrefix", "attributes": {"description": "This query searches for not onboarded devices with a specific prefix\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/NotOnboarded%20Devices%20by%20DeviceName%20Suffix.yaml", "query_name": "NotOnboarded Devices by DeviceName Suffix", "query": "//\nlet Onboarded = \"Onboarded\";\nlet DeviceNameSuffix = \"-pc\";\nDeviceInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| where OnboardingStatus != \"Onboarded\"\n| where DeviceName endswith DeviceNameSuffix", "attributes": {"description": "This query searches for not onboarded devices with a specific Suffix\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Seen%20Connected%20Networks.yaml", "query_name": "Seen Connected Networks", "query": "// \nDeviceNetworkInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| mv-expand todynamic(ConnectedNetworks)\n| where isnotempty( ConnectedNetworks.Name)\n| summarize by NetworkNames = tostring(ConnectedNetworks.Name)", "attributes": {"description": "This query uncovers seen connected networks\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Seen%20IPv4%20Network%20Subnets.yaml", "query_name": "Seen IPv4 Network Subnets", "query": "// \nDeviceNetworkInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| mv-expand todynamic(IPAddresses)\n| where isnotempty( IPAddresses.SubnetPrefix) and isnotempty( IPAddresses.IPAddress)\n| extend Subnet = format_ipv4_mask(tostring(IPAddresses.IPAddress), toint(IPAddresses.SubnetPrefix))\n| summarize by Subnet", "attributes": {"description": "This query uncovers seen IPAddressV4 network subnets\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Device%20Inventory/Seen%20IPv6%20Network%20Subnets.yaml", "query_name": "Seen IPv6 Network Subnets", "query": "// \nDeviceNetworkInfo\n| summarize arg_max(Timestamp, *) by DeviceId\n| mv-expand todynamic(IPAddresses)\n| where isnotempty( IPAddresses.SubnetPrefix) and isnotempty( IPAddresses.IPAddress)\n| extend Subnet = parse_ipv6_mask(tostring(IPAddresses.IPAddress), toint(IPAddresses.SubnetPrefix))\n| summarize by Subnet", "attributes": {"description": "This query uncovers seen IPAddressV6 network subnets\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/detect-nbtscan-activity.yaml", "query_name": "detect-nbtscan-activity", "query": "let nbtscan = pack_array(\"9af0cb61580dba0e380cddfe9ca43a3e128ed2f8\",\n\"90da10004c8f6fafdaa2cf18922670a745564f45\");\nunion DeviceProcessEvents , DeviceFileEvents \n| where Timestamp > ago(7d)\n| where FileName =~ \"nbtscan.exe\" or SHA1 in (nbtscan)\n| project FolderPath, FileName, InitiatingProcessAccountName,\nInitiatingProcessFileName, ProcessCommandLine, Timestamp\n", "attributes": {"description": "This query was originally published in the threat analytics report, Operation Soft Cell.\nOperation Soft Cell is a series of campaigns targeting users' call logs at telecommunications providers throughout the world. These attacks date from as early as 2012.\nOperation Soft Cell operators have been known to run nbtscan.exe, a legitimate MS-DOS command-line tool used to discover any NETBIOS nameservers on a local or remote TCP/IP network.\nThe following query detects any nbtscan activity on the system over the past seven days.\nReference - https://www.cybereason.com/blog/operation-soft-cell-a-worldwide-campaign-against-telecommunications-providers\n", "techniques": NaN, "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/Detect-Not-Active-AD-User-Accounts.yaml", "query_name": "Detect-Not-Active-AD-User-Accounts", "query": "IdentityLogonEvents \n| project Timestamp, AccountName, DeviceName, LogonType\n| where AccountName startswith \"XXX\" \n| summarize LastLogon = max(Timestamp) by AccountName, LogonType, DeviceName\n| where LastLogon < ago(14d)\n", "attributes": {"description": "// Detect Active Directory service accounts that are not active because their last logon was more than 14 days ago\n// Replace XXX on line 4 with the naming convention start of your Active Directory service accounts\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/detect-suspicious-commands-initiated-by-web-server-processes.yaml", "query_name": "detect-suspicious-commands-initiated-by-web-server-processes", "query": "// Suspicious commands launched by web server processes\nDeviceProcessEvents \n| where Timestamp > ago(7d)\n// Pivoting on parents or grand parents\nand (((InitiatingProcessParentFileName in(\"w3wp.exe\", \"beasvc.exe\",\n\"httpd.exe\") or InitiatingProcessParentFileName startswith \"tomcat\")\nor InitiatingProcessFileName in(\"w3wp.exe\", \"beasvc.exe\", \"httpd.exe\") or\nInitiatingProcessFileName startswith \"tomcat\"))\n    and FileName in~('cmd.exe','powershell.exe')\n| where ProcessCommandLine contains '%temp%'\n    or ProcessCommandLine has 'wget'\n    or ProcessCommandLine has 'whoami'\n    or ProcessCommandLine has 'certutil'\n    or ProcessCommandLine has 'systeminfo'\n    or ProcessCommandLine has 'ping'\n    or ProcessCommandLine has 'ipconfig'\n    or ProcessCommandLine has 'timeout'\n| summarize any(Timestamp), any(Timestamp), any(FileName),\nmakeset(ProcessCommandLine), any(InitiatingProcessFileName),\nany(InitiatingProcessParentFileName) by DeviceId\n", "attributes": {"description": "This query was originally published in the threat analytics report, Operation Soft Cell.\nOperation Soft Cell is a series of campaigns targeting users' call logs at telecommunications providers throughout the world. These attacks date from as early as 2012.\nOperation Soft Cell operators sometimes use legitimate web server processes to launch commands, especially for network discovery and user/owner discovery. The following query detects activity of this kind.\nReference - https://www.cybereason.com/blog/operation-soft-cell-a-worldwide-campaign-against-telecommunications-providers\n", "techniques": NaN, "tactics": ["Execution", "Defense evasion", "Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/DetectTorRelayConnectivity.yaml", "query_name": "DetectTorRelayConnectivity", "query": "let TorRelayData = (\n    externaldata (Nickname:string,Fingerprint:string,EntryAddress:string,IPAddress:string,Port:string,AddressType:string,Hostname:string,CountryCode:string,IsRunning:bool,LastChangedIPData:string)\n    [h@'https://torinfo.blob.core.windows.net/public/TorRelayIPs.csv'] with (ignoreFirstRecord=true,format=\"csv\")\n    | where AddressType == \"IPv4\"\n);\nTorRelayData\n| join kind=inner DeviceNetworkEvents on $left.IPAddress == $right.RemoteIP\n| join kind=inner (DeviceInfo | distinct DeviceId, PublicIP) on DeviceId\n| project Timestamp, DeviceId, LocalPublicIP = PublicIP, LocalIP, RemoteIP, TorIP = IPAddress, Hostname, CountryCode, ActionType, InitiatingProcessFileName, InitiatingProcessFolderPath\n", "attributes": {"description": "This advanced hunting query detects processes communicating with known Tor relay IP addresses.\nThe public URL in the query is updated daily at 12PM and 12AM UTC.\nCSV source is the Tor Project API, obtained with: https://github.com/Dylan-J/Tor-Project-Statistics\n", "techniques": NaN, "tactics": ["Discovery", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/DetectTorrentUse.yaml", "query_name": "DetectTorrentUse", "query": "DeviceNetworkEvents \n| where Timestamp > ago(7d)\n| where RemoteUrl has \"torrent\" or RemoteUrl has \"vuze\" or RemoteUrl has \"azureus\" or RemoteUrl endswith \".tor\" or InitiatingProcessFileName has \"torrent\" or InitiatingProcessFileName has \"vuze\" or InitiatingProcessFileName contains \"azureus\" \n| project Timestamp, ReportId, DeviceId, DeviceName, InitiatingProcessFileName, RemoteUrl , RemoteIP , RemotePort  \n", "attributes": {"description": "Custom detection to find use of torrenting software or browsing related to torrents.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/Discover%20hosts%20doing%20possible%20network%20scans.yaml", "query_name": "Discover hosts doing possible network scans", "query": "let remotePortCountThreshold = 10; // Please change the min value, for a host reaching out to remote ports on a remote IP, that you consider to be threshold for a suspicious behavior \nDeviceNetworkEvents\n| where Timestamp > ago(1d) and RemoteIP startswith \"172.16\" or RemoteIP startswith \"192.168\" \n| summarize\n    by DeviceName, RemoteIP, RemotePort, InitiatingProcessFileName\n| summarize RemotePortCount=dcount(RemotePort) by DeviceName, RemoteIP, InitiatingProcessFileName\n| where RemotePortCount > remotePortCountThreshold\n", "attributes": {"description": "Looking for high volume queries against a given RemoteIP, per DeviceName, RemotePort and Process.\nPlease change the Timestamp window according your preference/objective, as also the subnet ranges that you want to analyze against.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/doppelpaymer.yaml", "query_name": "doppelpaymer", "query": "// Finds Net commands used to locate high-value accounts\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n| where  FileName == \"net.exe\"\n// Create a set for the command lines\n| summarize makeset(ProcessCommandLine) by DeviceId, bin(Timestamp, 5m)\n// Other process launches by Net in that same timeframe\n| where (set_ProcessCommandLine has \"admin\"\nand set_ProcessCommandLine has_any(\"domain\", \"enterprise\", \"backup operators\"))\nand set_ProcessCommandLine has \"group\" and set_ProcessCommandLine contains \"/do\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Doppelpaymer: More human-operated ransomware. There is also a related blog.\nDoppelPaymer is ransomware that is spread manually by human operators. These operators have exhibited extensive knowledge of system administration and common network security misconfigurations. For example, they may use net.exe to run reconnaissance and find service accounts to target. They often use stolen credentials from over-privileged service accounts to turn off security software, run malicious commands, and spread malware throughout an organization.\nThe following query detects the net.exe reconnaissance method described above.\nThe See also section below lists links to other queries associated with DoppelPaymer.\nReferences:\nhttps://msrc-blog.microsoft.com/2019/11/20/customer-guidance-for-the-dopplepaymer-ransomware/\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Trojan:Win32/DoppelPaymer!MTB&threatId=-2147205372\n", "techniques": NaN, "tactics": ["Discovery", "Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/Enumeration%20of%20users%20%26%20groups%20for%20lateral%20movement.yaml", "query_name": "Enumeration of users & groups for lateral movement", "query": "DeviceProcessEvents \n| where Timestamp > ago(14d) \n| where FileName == 'net.exe' and AccountName != \"\" and ProcessCommandLine !contains '\\\\'  and ProcessCommandLine !contains '/add' \n| where (ProcessCommandLine contains ' user ' or ProcessCommandLine contains ' group ') and (ProcessCommandLine contains ' /do' or ProcessCommandLine contains ' /domain') \n| extend Target = extract(\"(?i)[user|group] (\\\"*[a-zA-Z0-9-_ ]+\\\"*)\", 1, ProcessCommandLine) | filter Target  != '' \n| project AccountName, Target, ProcessCommandLine, DeviceName, Timestamp  \n| sort by AccountName, Target\n", "attributes": {"description": "The query finds attempts to list users or groups using Net commands.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/MultipleLdaps.yaml", "query_name": "MultipleLdaps", "query": "let Thershold = 10;\nlet BinTime = 1m;\nIdentityQueryEvents\n| where ActionType == \"LDAP query\"\n| parse Query with * \"Search Scope: \" SearchScope \", Base Object:\" BaseObject \", Search Filter: \" SearchFilter\n| summarize NumberOfLdapQueries = count(), NumberOfDistinctLdapQueries = dcount(SearchFilter) by DeviceName, bin(Timestamp, BinTime)\n| where NumberOfDistinctLdapQueries > Thershold \n", "attributes": {"description": "Detect multiple Active Directory LDAP queries made in bin time\nReplace 10 on line 1 with your desired thershold\nReplace 1m on line 2 with your desired bin time\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/MultipleSensitiveLdaps.yaml", "query_name": "MultipleSensitiveLdaps", "query": "let SensitiveObjects = \"[\\\"Administrators\\\", \\\"Domain Controllers\\\", \\\"Domain Admins\\\", \\\"Account Operators\\\", \\\"Backup Operators\\\", \\\"DnsAdmin\\\", \\\"Enterprise Admins\\\", \\\"Group Policy Creator Owners\\\"]\";\nlet ASREP_ROASTING = \"userAccountControl:1.2.840.113556.1.4.803:=4194304\";\nlet ASREP_ROASTING1 = \"userAccountControl|4194304\";\nlet ASREP_ROASTING2 = \"userAccountControl&4194304\";\nlet KERBEROASTING = \"serviceprincipalname=*\";\nlet Thershold = 10;\nlet BinTime = 1m;\nlet SensitiveQueries = (\nIdentityQueryEvents\n| where ActionType == \"LDAP query\"\n| parse Query with * \"Search Scope: \" SearchScope \", Base Object:\" BaseObject \", Search Filter: \" SearchFilter\n| where SensitiveObjects contains QueryTarget or SearchFilter contains \"admincount=1\");\nlet Roasting = (\nIdentityQueryEvents\n| where ActionType == \"LDAP query\"\n| parse Query with * \"Search Scope: \" SearchScope \", Base Object:\" BaseObject \", Search Filter: \" SearchFilter\n| where SearchFilter contains ASREP_ROASTING or\nSearchFilter contains ASREP_ROASTING1 or\nSearchFilter contains ASREP_ROASTING2 or\nSearchFilter contains KERBEROASTING);\nunion SensitiveQueries, Roasting\n| summarize NumberOfLdapQueries = count(), NumberOfDistinctLdapQueries = dcount(SearchFilter) by DeviceName, bin(Timestamp, BinTime)\n| where NumberOfDistinctLdapQueries > Thershold \n", "attributes": {"description": "Detect multiple sensitive Active Directory LDAP queries made in bin time\nSensitive queries defined as Roasting or sensitive objects queries\nReplace 10 on line 6 with your desired thershold\nReplace 1m on line 7 with your desired bin time\nThis LDAP query cover Rubeus, Kerberoast, BloodHound tools\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/PasswordSearch.yaml", "query_name": "PasswordSearch", "query": "let PersonObject = \"objectCategory=person\";\nlet UserClass = \"objectClass=user\";\nlet SamAccountUser = \"samAccountType=805306368\";\nlet Description = \"description=*pass*\";\nlet Comment = \"comment=*pass*\";\nIdentityQueryEvents\n| where ActionType == \"LDAP query\"\n| parse Query with * \"Search Scope: \" SearchScope \", Base Object:\" BaseObject \", Search Filter: \" SearchFilter\n| where (SearchFilter contains Description or SearchFilter contains Comment) and\n(SearchFilter contains PersonObject or SearchFilter contains UserClass or SearchFilter contains SamAccountUser)\n", "attributes": {"description": "Detect Active Directory LDAP queries that search for users with comment or description that contains the string \"pass\" that might suggest for the user password\nThis LDAP query cover MetaSploit - enum_ad_user_comments tool\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/qakbot-campaign-esentutl.yaml", "query_name": "qakbot-campaign-esentutl", "query": "DeviceProcessEvents\n| where FileName == \"esentutl.exe\"\n| where ProcessCommandLine has \"WebCache\"\n| where ProcessCommandLine has_any (\"V01\", \"/s\", \"/d\")\n| project ProcessCommandLine, \nInitiatingProcessParentFileName, DeviceId, Timestamp\n", "attributes": {"description": "This query was originally published in the threat analytics report, Qakbot blight lingers, seeds ransomware\nQakbot is malware that steals login credentials from banking and financial services. It has been deployed against small businesses as well as major corporations. Some outbreaks have involved targeted ransomware campaigns that use a similar set of techniques. Links to related queries are listed under See also.\nThe following query detects possible use of the system process, esentutl.exe, to look through a user's browser history and steal cookies.\nReference - https://www.microsoft.com/security/blog/2017/11/06/mitigating-and-eliminating-info-stealing-qakbot-and-emotet-in-corporate-networks/\n", "techniques": NaN, "tactics": ["Credential Access", "Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/qakbot-campaign-outlook.yaml", "query_name": "qakbot-campaign-outlook", "query": "DeviceFileEvents\n| where FolderPath hasprefix \"EmailStorage\"\n| where FolderPath has \"Outlook\"\n| project FileName, FolderPath, InitiatingProcessFileName,\nInitiatingProcessCommandLine, DeviceId, Timestamp\n", "attributes": {"description": "This query was originally published in the threat analytics report, Qakbot blight lingers, seeds ransomware\nQakbot is malware that steals login credentials from banking and financial services. It has been deployed against small businesses as well as major corporations. Some outbreaks have involved targeted ransomware campaigns that use a similar set of techniques. Links to related queries are listed under See also.\nThe following query detects attempts to access files in the local path that contain Outlook emails.\nReference - https://www.microsoft.com/security/blog/2017/11/06/mitigating-and-eliminating-info-stealing-qakbot-and-emotet-in-corporate-networks/\n", "techniques": NaN, "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/Roasting.yaml", "query_name": "Roasting", "query": "let ASREP_ROASTING = \"userAccountControl:1.2.840.113556.1.4.803:=4194304\";\nlet ASREP_ROASTING1 = \"userAccountControl|4194304\";\nlet ASREP_ROASTING2 = \"userAccountControl&4194304\";\nlet KERBEROASTING = \"serviceprincipalname=*\";\nlet LDAP_PORT = 389;\nlet ExcludeNtAuthorityProcess = true;\nlet AzureAtpLdap = (\nIdentityQueryEvents\n| where ActionType == \"LDAP query\"\n| parse Query with * \"Search Scope: \" SearchScope \", Base Object:\" BaseObject \", Search Filter: \" SearchFilter\n| where SearchFilter contains ASREP_ROASTING or\nSearchFilter contains ASREP_ROASTING1 or\nSearchFilter contains ASREP_ROASTING2 or\nSearchFilter contains KERBEROASTING\n| extend Time = bin(Timestamp, 1s)\n| extend DeviceNameWithoutDomain = tolower(tostring(split(DeviceName, '.')[0])));\nlet MDAtpNetworkToProcess = (\nDeviceNetworkEvents\n| extend DeviceNameWithoutDomain = tolower(tostring(split(DeviceName, '.')[0]))\n| where RemotePort == LDAP_PORT\n| extend Time = bin(Timestamp, 1s)\n| extend isExclude = iff( ExcludeNtAuthorityProcess and InitiatingProcessAccountDomain == \"nt authority\" , true, false));\nAzureAtpLdap\n| join kind=leftouter (\nMDAtpNetworkToProcess ) on DeviceNameWithoutDomain, Time \n| where isExclude == false or isnull(isExclude)\n", "attributes": {"description": "Detect Active Directory LDAP queries that search for Kerberoasting (SPNs) or accounts with Kerberos preauthentication not required from Azure ATP, and try to get the process initiated the LDAP query from MDATP.\nReplace 389 on line 5 with LDAP port in your environment\nReplace true on line 6 to false if you want to include Nt Authority process\nThis LDAP query cover Rubeus, Kerberoast, BloodHound tools\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/SensitiveLdaps.yaml", "query_name": "SensitiveLdaps", "query": "let SensitiveObjects = \"[\\\"Administrators\\\", \\\"Domain Controllers\\\", \\\"Domain Admins\\\", \\\"Account Operators\\\", \\\"Backup Operators\\\", \\\"DnsAdmin\\\", \\\"Enterprise Admins\\\", \\\"Group Policy Creator Owners\\\"]\";\nIdentityQueryEvents\n| where ActionType == \"LDAP query\"\n| parse Query with * \"Search Scope: \" SearchScope \", Base Object:\" BaseObject \", Search Filter: \" SearchFilter\n| where SensitiveObjects contains QueryTarget or SearchFilter contains \"admincount=1\"\n", "attributes": {"description": "Detect Active Directory LDAP queries that search for sensitive objects in the organization\nThis LDAP query cover BloodHound tool\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/SMB%20shares%20discovery.yaml", "query_name": "SMB shares discovery", "query": "DeviceNetworkEvents\n| where RemotePort == 445 and Timestamp > ago(7d) \n    // Exclude Kernel processes, as they are too noisy in this query\n    and InitiatingProcessId !in (0, 4)\n| summarize RemoteIPCount=dcount(RemoteIP) by DeviceName, InitiatingProcessFileName, InitiatingProcessId, InitiatingProcessCreationTime\n| where RemoteIPCount > 10\n", "attributes": {"description": "Query for processes that accessed more than 10 IP addresses over port 445 (SMB) - possibly scanning for network shares.\nTo read more about Network Share Discovery, see: https://attack.mitre.org/wiki/Technique/T1135.\nTags: #SMB, #NetworkScanning, #UniqueProcessId.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/SuspiciousEnumerationUsingAdfind%5BNobelium%5D.yaml", "query_name": "SuspiciousEnumerationUsingAdfind[Nobelium]", "query": "let startdate = 10d;\nlet lookupwindow = 2m;\nlet threshold = 3; //number of commandlines in the set below\nlet DCADFSServersList = dynamic ([\"DCServer01\", \"DCServer02\", \"ADFSServer01\"]); // Enter a reference list of hostnames for your DC/ADFS servers\nlet tokens = dynamic([\"objectcategory\",\"domainlist\",\"dcmodes\",\"adinfo\",\"trustdmp\",\"computers_pwdnotreqd\",\"Domain Admins\", \"objectcategory=person\", \"objectcategory=computer\", \"objectcategory=*\"]);\nDeviceProcessEvents\n| where Timestamp between (ago(startdate) .. now())\n//| where DeviceName in (DCADFSServersList) // Uncomment to limit it to your DC/ADFS servers list if specified above or any pattern in hostnames (startswith, matches regex, etc).\n| where ProcessCommandLine  has_any (tokens)\n| where ProcessCommandLine matches regex \"(.*)>(.*)\"\n| summarize Commandlines = make_set(ProcessCommandLine), LastObserved=max(Timestamp) by bin(Timestamp, lookupwindow), AccountName, DeviceName, InitiatingProcessFileName, FileName\n| extend Count = array_length(Commandlines)\n| where Count > threshold\n", "attributes": {"description": "Attackers can use Adfind which is administrative tool to gather information about domain controllers or ADFS servers. They may also rename executables with other benign tools on the system.\nThe below query will look for Adfind usage in command line arguments irrespective of executable name in short span of time. You can limit query this to your DC and ADFS servers.\nBelow references talk about suspicious use of adfind by adversaries.\n1. AdFind Recon\n2. Navigating the MAZE: Tactics, Techniques and Procedures Associated With MAZE Ransomware Incidents\n3. Analyzing Solorigate, the compromised DLL file that started a sophisticated cyberattack, and how Microsoft Defender helps protect customers\nThis query is inspired by a Azure Sentinel detection.\n", "techniques": NaN, "tactics": ["Execution", "Discovery", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/URL%20Detection.yaml", "query_name": "URL Detection", "query": "let partialRemoteUrlToDetect = \"microsoft.com\"; // Change this to a URL you'd like to find machines connecting to\nDeviceNetworkEvents  \n| where Timestamp > ago(7d)\nand RemoteUrl has partialRemoteUrlToDetect // Can be changed to \"contains\" operator as explained above\n| project Timestamp, DeviceName, DeviceId, ReportId\n| top 100 by Timestamp desc\n", "attributes": {"description": "This query finds network communication to specific URL.\nPlease note that in line #7 it filters RemoteUrl using has operator, which looks for a \"whole term\" and runs faster.\nExample: RemoteUrl has \"microsoft\" matches \"www.microsoft.com\" but not \"microsoftonline.com\".\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Discovery/VulnComputers.yaml", "query_name": "VulnComputers", "query": "let ComputerObject = \"objectCategory=computer\";\nlet ComputerClass = \"objectClass=computer\";\nlet SamAccountComputer = \"sAMAccountType=805306369\";\nlet OperatingSystem = \"operatingSystem=\";\nIdentityQueryEvents\n| where ActionType == \"LDAP query\"\n| parse Query with * \"Search Scope: \" SearchScope \", Base Object:\" BaseObject \", Search Filter: \" SearchFilter\n| where (SearchFilter contains ComputerObject or SearchFilter contains ComputerClass or SearchFilter contains SamAccountComputer) and\n SearchFilter contains OperatingSystem\n", "attributes": {"description": "Detect Active Directory LDAP queries that try to find operating systems that are vulnerable to specific vulnerabilities\nThis LDAP query cover MetaSploit - enum_ad_computers tool\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Email%20Queries/Appspot%20Phishing%20Abuse.yaml", "query_name": "Appspot Phishing Abuse", "query": "EmailUrlInfo\n// Detect URLs with a subdomain on appspot.com\n| where UrlDomain matches regex @'\\b[\\w\\-]+-dot-[\\w\\-\\.]+\\.appspot\\.com\\b'\n// Enrich results with sender and recipient data\n| join kind=inner EmailEvents on $left.NetworkMessageId==$right.NetworkMessageId\n// Phishing attempts from Appspot related campaigns typically contain the recipient's email address in the URI\n// Example 1: https://example-dot-example.appspot.com/#recipient@domain.com\n// Example 2: https://example-dot-example.appspot.com/index.html?user=recipient@domain.com\n| where Url has RecipientEmailAddress\n    // Some phishing campaigns pass recipient email as a Base64 encoded string in the URI\n    or Url has base64_encode_tostring(RecipientEmailAddress)\n| project-away Timestamp1, NetworkMessageId1, ReportId1 \n", "attributes": {"description": "This query helps surface phishing campaigns associated with Appspot abuse. These emails frequently contain phishing links that utilize the recipients' own email address as a unique identifier in the URI.\nThis campaign was published on Twitter by @MsftSecIntel at this link: https://twitter.com/MsftSecIntel/status/1374148156301004800\nReference - https://twitter.com/MsftSecIntel\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Email%20Queries/JNLP-File-Attachment.yaml", "query_name": "JNLP-File-Attachment", "query": "EmailAttachmentInfo\n| where FileName endswith \".jnlp\"\n", "attributes": {"description": "JNLP file extensions are an uncommon file type often used to deliver malware.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Email%20Queries/PhishingEmailUrlRedirector%20%281%29.yaml", "query_name": "PhishingEmailUrlRedirector (1)", "query": "EmailUrlInfo\n//This regex identifies emails containing the \"T-Dot\" redirector pattern in the URL\n| where Url matches regex @\"s?\\:\\/\\/(?:www\\.)?t\\.(?:[\\w\\-\\.]+\\/+)+(?:r|redirect)\\/?\\?\" \n    //This regex narrows in on emails that contain the known malicious domain pattern in the URL from the most recent campaigns\n    and Url matches regex @\"[a-zA-Z]\\-[a-zA-Z]{2}\\.(xyz|club|shop)\"\n", "attributes": {"description": "This query was originally published on Twitter, by @MsftSecIntel.\nThe query helps detect emails associated with the open redirector URL campaign. The campaign's URLs begin with the distinct pattern, hxxps://t[.]domain[.]tld/r/?. Attackers use URL redirection to manipulate users into visiting a malicious website or to evade detection.\nReference - https://twitter.com/MsftSecIntel\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Email%20Queries/PhishingEmailUrlRedirector.yaml", "query_name": "PhishingEmailUrlRedirector", "query": "EmailUrlInfo\n| where Url matches regex @\"s?\\:\\/\\/(?:www\\.)?t\\.(?:[\\w\\-\\.]+\\/+)+(?:r|redirect)\\/?\\?\"\n", "attributes": {"description": "This query was originally published on Twitter, by @MsftSecIntel.\nThe query helps detect emails associated with the open redirector URL campaign. The campaign's URLs begin with the distinct pattern, hxxps://t[.]domain[.]tld/r/?. Attackers use URL redirection to manipulate users into visiting a malicious website or to evade detection.\nReference - https://twitter.com/MsftSecIntel\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Email%20Queries/referral-phish-emails.yaml", "query_name": "referral-phish-emails", "query": "let EmailAddresses = pack_array\n('zreffertalt.com.com','zreffesral.com.com','kzreffertal.com.com',\n'wzreffertal.com.com','refferal.comq','refferal.net','zreffertal.com.com',\n'zrefferal.com.com','refferasl.com.com','zreffesral.com','zrefsfertal.com.com',\n'irefferal.com','refferasl.co','zrefferal.com');\nEmailEvents\n| where SenderMailFromDomain in (EmailAddresses)\n| extend RecipientDomain = extract(\"[^@]+$\", 0, RecipientEmailAddress)\n| where SenderFromDomain == RecipientDomain\n| join EmailUrlInfo on $left.NetworkMessageId == $right.NetworkMessageId\n", "attributes": {"description": "The \"Referral\" infrastructure is a point-in-time set of infrastructure associated with spoofed emails that imitate SharePoint and other legitimate products to conduct credential phishing. The operator is also known to use legitimate URL infrastructure such as Google, Microsoft, and Digital Ocean to host their phishing pages.\n", "techniques": NaN, "tactics": ["Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/Base64%20Detector%20and%20Decoder.yaml", "query_name": "Base64 Detector and Decoder", "query": "DeviceProcessEvents \n| extend SplitLaunchString = split(ProcessCommandLine, \" \")\n| mvexpand SplitLaunchString\n| where SplitLaunchString matches regex \"^[A-Za-z0-9+/]{50,}[=]{0,2}$\"\n| extend Base64 = tostring(SplitLaunchString)\n| extend DecodedString = base64_decodestring(Base64)\n| where isnotempty(DecodedString)\n", "attributes": {"description": "This query will identify strings in process command lines which match Base64 encoding format, extract the string to a column called Base64, and decode it in a column called DecodedString.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/Base64encodePEFile.yaml", "query_name": "Base64encodePEFile", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where ProcessCommandLine contains \"TVqQAAMAAAAEAAA\"\n| top 1000 by Timestamp\n", "attributes": {"description": "Finding base64 encoded PE files header seen in the command line parameters.\nTags: #fileLess  #powershell.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/Bitsadmin%20Activity.yaml", "query_name": "Bitsadmin Activity", "query": "DeviceProcessEvents\n| where \n    (FileName =~ \"bitsadmin.exe\" or column_ifexists('ProcessVersionInfoOriginalFileName','ColumnNotAvailable') =~ 'bitsadmin.exe')\n    and ProcessCommandLine has_any ('/Transfer','/AddFile', '/AddFileSet','/AddFileWithRanges')\n| extend \n    ParsedCommandLine = parse_command_line(ProcessCommandLine,'windows')\n| extend     \n    RemoteUrl = tostring(ParsedCommandLine[-2]),\n    LocalFile= tostring(ParsedCommandLine[-1]),\n    Direction = iff(ProcessCommandLine has \"/Upload\", 'Upload', 'Download')\n| project-reorder \n    Timestamp,\n    DeviceId,\n    DeviceName,\n    Direction,\n    RemoteUrl,\n    LocalFile,\n    InitiatingProcessFolderPath,\n    InitiatingProcessAccountDomain,\n    InitiatingProcessAccountName,\n    InitiatingProcessSHA256,\n    ProcessCommandLine\n", "attributes": {"description": "Background Intelligent Transfer Service (BITS) is a way to reliably download files from webservers or SMB servers. \nThis service is commonly used for legitimate purposes, but can also be used as part of a malware downloader. \nAdditionally, bitsadmin can be used to upload files and therefore can be used for data exfiltration. This\nquery will identify use of bitsadmin.exe for either purpose and will identify directionality file transfer\ndirectionality.\n", "techniques": NaN, "tactics": ["Persistence", "CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/check-for-shadowhammer-activity-implant.yaml", "query_name": "check-for-shadowhammer-activity-implant", "query": "// Event types that may be associated with the implant or container\nunion DeviceProcessEvents , DeviceNetworkEvents , DeviceFileEvents , DeviceImageLoadEvents \n| where Timestamp > ago(30d)\n// File SHAs for implant and container\n| where InitiatingProcessSHA1 in(\"e01c1047001206c52c87b8197d772db2a1d3b7b4\",\n\"e005c58331eb7db04782fdf9089111979ce1406f\", \"69c08086c164e58a6d0398b0ffdcb957930b4cf2\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, ShadowHammer supply chain attack\nOperation ShadowHammer was an attack against ASUS computer hardware, using the company's own update infrastructure to deliver malware to the company's products. The campaign ran from June to November, 2018. ASUS has since responded with updates that protect their Live Update system, and diagnostic tools to check affected systems.\nThe following query checks for activity associated with the ShadowHammer implant or container over the past 30 days.\nReferences:\nhttps://www.vice.com/en_us/article/pan9wn/hackers-hijacked-asus-software-updates-to-install-backdoors-on-thousands-of-computers\nhttps://www.asus.com/News/hqfgVUyZ6uyAyJe1\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/Detect%20Encoded%20Powershell.yaml", "query_name": "Detect Encoded Powershell", "query": "DeviceProcessEvents\n| where ProcessCommandLine matches regex @'(\\s+-((?i)encod?e?d?c?o?m?m?a?n?d?|e|en|enc|ec)\\s).*([A-Za-z0-9+/]{50,}[=]{0,2})'\n| extend DecodedCommand = replace(@'\\x00','', base64_decode_tostring(extract(\"[A-Za-z0-9+/]{50,}[=]{0,2}\",0 , ProcessCommandLine)))\n", "attributes": {"description": "This query will detect encoded powershell based on the parameters passed during process creation. This query will also work if the PowerShell executable is renamed or tampered with since detection is based solely on a regex of the launch string.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/Detect%20PowerShell%20v2%20Downgrade.yaml", "query_name": "Detect PowerShell v2 Downgrade", "query": "DeviceImageLoadEvents\n| where InitiatingProcessFileName =~ 'powershell.exe'\n    and FileName in~ ('system.management.automation.ni.dll','System.Management.Automation.dll')\n    and FolderPath matches regex @\"[12]\\.(\\d)+\\.(\\d)+\\.(\\d)+\"\n", "attributes": {"description": "This query looks for processes that load an older version of the system.management.automation libraries. While not inherently malicious, downgrading to PowerShell version 2\ncan enable an attacker to bypass some of the protections afforded by modern PowerShell. It is worth noting that some tools and scripts perform this to enable\nbackwards compatibility, so the technique is not inherently malicious. You will likely need to filter the processes within your environment that legitimately use this\ncapability for this to be effective.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-anomalous-process-trees.yaml", "query_name": "detect-anomalous-process-trees", "query": "let timeframe = 48h;\n// Define of which processes you want to generate process tree\nlet _selected_processes = dynamic([\"winword.exe\",\"excel.exe\",\"powerpnt.exe\",\"acrord32.exe\", \"FoxitPhantomPDF.exe\",\"MicrosoftPdfReader.exe\",\"SumatraPDF.exe\"]); \n// First, generate the process tree and store it in the cache.\n// Renaming fields accordingly to generate a tree up to 7th level\n// In each step, project only the required fields to optimize resource usage\nlet _process_tree_data= materialize \n( DeviceProcessEvents\n    | where Timestamp > ago(timeframe)\n    | where InitiatingProcessFileName in~ (_selected_processes )\n    | project DeviceId,DeviceName, \n              InitiatingProcessG3ParentFileName=FileName,InitiatingProcessG3ParentSHA1=SHA1,InitiatingProcessG3ParentId=ProcessId, InitiatingProcessG3ParentCommandLine=ProcessCommandLine,InitiatingProcessG3ParentCreationTime=todatetime(ProcessCreationTime),\n              InitiatingProcessG4ParentFileName=InitiatingProcessFileName,InitiatingProcessG4ParentSHA1=InitiatingProcessSHA1,InitiatingProcessG4ParentId=InitiatingProcessId,InitiatingProcessG4ParentCommandLine=InitiatingProcessCommandLine, InitiatingProcessG4ParentCreationTime=todatetime(InitiatingProcessCreationTime)\n    // Start iteration\n    // 1st iteration of join. From now on, query all processes, rename fields, and join accordingly\n    | join kind=leftouter (\n                DeviceProcessEvents\n                    | where Timestamp > ago(timeframe)\n                    | project DeviceId, InitiatingProcessG2ParentFileName=FileName,InitiatingProcessG2ParentFolderPath=FolderPath,InitiatingProcessG2ParentSHA1=SHA1, InitiatingProcessG2ParentId=ProcessId,  InitiatingProcessG2ParentCommandLine=ProcessCommandLine, InitiatingProcessG2ParentCreationTime=todatetime(ProcessCreationTime), \n                       InitiatingProcessG3ParentFileName=InitiatingProcessFileName,InitiatingProcessG3ParentFolderPath=InitiatingProcessFolderPath,InitiatingProcessG3ParentSHA1=InitiatingProcessSHA1, InitiatingProcessG3ParentId=InitiatingProcessId,  InitiatingProcessG3ParentCommandLine=InitiatingProcessCommandLine, InitiatingProcessG3ParentCreationTime=todatetime(InitiatingProcessCreationTime)\n                     ) \n                     on DeviceId , InitiatingProcessG3ParentFileName, InitiatingProcessG3ParentId, InitiatingProcessG3ParentCreationTime\n        // 2nd iteration of join.\n        | join kind=leftouter (\n                    DeviceProcessEvents\n                        | where Timestamp > ago(timeframe)\n                        | project DeviceId, InitiatingProcessG1ParentFileName=FileName,InitiatingProcessG1ParentFolderPath=FolderPath,InitiatingProcessG1ParentSHA1=SHA1, InitiatingProcessG1ParentId=ProcessId,  InitiatingProcessG1ParentCommandLine=ProcessCommandLine, InitiatingProcessG1ParentCreationTime=todatetime(ProcessCreationTime), \n                        InitiatingProcessG2ParentFileName=InitiatingProcessFileName,InitiatingProcessG2ParentFolderPath=InitiatingProcessFolderPath,InitiatingProcessG2ParentSHA1=InitiatingProcessSHA1, InitiatingProcessG2ParentId=InitiatingProcessId,  InitiatingProcessG2ParentCommandLine=InitiatingProcessCommandLine, InitiatingProcessG2ParentCreationTime=todatetime(InitiatingProcessCreationTime)\n                        ) \n                        on DeviceId , InitiatingProcessG2ParentFileName , InitiatingProcessG2ParentId, InitiatingProcessG2ParentCreationTime\n            // 3rd iteration of join.\n            | join kind=leftouter (\n                        DeviceProcessEvents\n                            | where Timestamp > ago(timeframe)\n                            | project DeviceId, InitiatingProcessParentFileName=FileName,InitiatingProcessParentFolderPath=FolderPath,InitiatingProcessParentSHA1=SHA1, InitiatingProcessParentId=ProcessId,  InitiatingProcessParentCommandLine=ProcessCommandLine, InitiatingProcessParentCreationTime=ProcessCreationTime, \n                            InitiatingProcessG1ParentFileName=InitiatingProcessFileName,InitiatingProcessG1ParentFolderPath=InitiatingProcessFolderPath,InitiatingProcessG1ParentSHA1=InitiatingProcessSHA1, InitiatingProcessG1ParentId=InitiatingProcessId,  InitiatingProcessG1ParentCommandLine=InitiatingProcessCommandLine, InitiatingProcessG1ParentCreationTime=todatetime(InitiatingProcessCreationTime)\n                            ) \n                            on DeviceId , InitiatingProcessG1ParentFileName , InitiatingProcessG1ParentId, InitiatingProcessG1ParentCreationTime\n                // 4th iteration of join\n                | join kind=leftouter (\n                            DeviceProcessEvents\n                                | where Timestamp > ago(timeframe)\n                                | project DeviceId, InitiatingProcessFileName=FileName,InitiatingProcessSHA1=SHA1, InitiatingProcessId=ProcessId,  InitiatingProcessCommandLine=ProcessCommandLine, InitiatingProcessCreationTime=ProcessCreationTime, \n                                InitiatingProcessParentFileName=InitiatingProcessFileName,InitiatingProcessParentSHA1=InitiatingProcessSHA1, InitiatingProcessParentId=InitiatingProcessId,  InitiatingProcessParentCommandLine=InitiatingProcessCommandLine, InitiatingProcessParentCreationTime=InitiatingProcessCreationTime\n                                ) \n                                on DeviceId , InitiatingProcessParentFileName , InitiatingProcessParentId, InitiatingProcessParentCreationTime\n                    // 5th iteration of join\n                    | join kind=leftouter (\n                                DeviceProcessEvents\n                                    | where Timestamp > ago(timeframe)\n                                    | project Timestamp, DeviceId, FileName,SHA1, ProcessId, ProcessCommandLine, ProcessCreationTime, \n                                    InitiatingProcessFileName,InitiatingProcessSHA1, InitiatingProcessId, InitiatingProcessCommandLine, InitiatingProcessCreationTime\n                                    ) \n                                    on DeviceId , InitiatingProcessFileName , InitiatingProcessId, InitiatingProcessCreationTime\n);\n// Use the cached results and find the rare patterns based on process names.\n_process_tree_data\n|summarize count() by FileName,InitiatingProcessFileName,InitiatingProcessParentFileName,InitiatingProcessG1ParentFileName,InitiatingProcessG2ParentFileName,InitiatingProcessG3ParentFileName,InitiatingProcessG4ParentFileName\n| where count_ < 10 // If the count of a pattern is less than 10, it is anomalous. Threshold can be changed.\n// Now, join the anomalous patterns with the original results to get the details. \n| join kind=inner _process_tree_data on FileName,InitiatingProcessFileName,InitiatingProcessParentFileName,InitiatingProcessG1ParentFileName,InitiatingProcessG2ParentFileName,InitiatingProcessG3ParentFileName,InitiatingProcessG4ParentFileName\n// Now, join the anomalous patterns with the original results to get the details. \n|project Timestamp=case(isnotempty(Timestamp),Timestamp,isnotempty(InitiatingProcessParentCreationTime),InitiatingProcessParentCreationTime,isnotempty(InitiatingProcessG1ParentCreationTime),InitiatingProcessG1ParentCreationTime,\n    isnotempty(InitiatingProcessG2ParentCreationTime),InitiatingProcessG2ParentCreationTime,isnotempty(InitiatingProcessG3ParentCreationTime),InitiatingProcessG3ParentCreationTime,InitiatingProcessG4ParentCreationTime),\n    count_ , DeviceId, DeviceName, \n    InitiatingProcessG4ParentFileName,InitiatingProcessG3ParentFileName,InitiatingProcessG2ParentFileName,InitiatingProcessG1ParentFileName,InitiatingProcessParentFileName,InitiatingProcessFileName,FileName,\n    InitiatingProcessG4ParentCommandLine, InitiatingProcessG3ParentCommandLine, InitiatingProcessG2ParentCommandLine, InitiatingProcessG1ParentCommandLine, InitiatingProcessCommandLine, ProcessCommandLine,\n    InitiatingProcessG4ParentId,  InitiatingProcessG4ParentCreationTime,\n    InitiatingProcessG3ParentId, InitiatingProcessG3ParentFolderPath ,InitiatingProcessG3ParentSHA1,  InitiatingProcessG3ParentCreationTime,\n    InitiatingProcessG2ParentId,InitiatingProcessG2ParentFolderPath,InitiatingProcessG2ParentSHA1, InitiatingProcessG2ParentCreationTime,\n    InitiatingProcessG1ParentId,InitiatingProcessG1ParentFolderPath,InitiatingProcessG1ParentSHA1,  InitiatingProcessG1ParentCreationTime,\n    InitiatingProcessParentId, InitiatingProcessParentFolderPath,InitiatingProcessParentSHA1, InitiatingProcessParentCommandLine ,InitiatingProcessParentCreationTime,\n    InitiatingProcessId, InitiatingProcessSHA1,  InitiatingProcessCreationTime,\n    ProcessId, SHA1,  ProcessCreationTime\n| order by Timestamp, DeviceName, InitiatingProcessG4ParentCreationTime , InitiatingProcessG3ParentCreationTime , InitiatingProcessG2ParentCreationTime , InitiatingProcessG1ParentCreationTime , InitiatingProcessCreationTime\n", "attributes": {"description": "This query generates process trees of given processes and performs anomaly detection on the process trees. It generates process trees up to 7th level.\nThe query can be used as a template to perform anomaly detection on specific processes like winword.exe, powerpnt.exe, w3wp.exe, etc. The query runs without any performance issues in large environments.\nDetailed explanation can be found here\nReference - https://mergene.medium.com/detecting-threats-with-process-tree-analysis-without-machine-learning-838d85f78b2c\n", "techniques": NaN, "tactics": ["Initial access", "Execution", "Persistence", "Discovery", "Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-bluekeep-related-mining.yaml", "query_name": "detect-bluekeep-related-mining", "query": "// Suggest setting Timestamp starting from September 6th\n// when the BlueKeep Metasploit module was released\nDeviceFileEvents\n| where Timestamp > ago(7d)\n| where FolderPath endswith \"spool\\\\svchost.exe\"\nor SHA1==\"82288c2dc5c63c1c57170da91f9979648333658e\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Exploitation of CVE-2019-0708 (BlueKeep).\nCVE-2019-0708, also known as BlueKeep, is a critical remote code execution vulnerability involving RDP. Soon after its disclosure, the NSA issued a rare advisory about this vulnerability, out of concern that it could be used to quickly spread malware. Attackers have since used this vulnerability to install cryptocurrency miners on targets.\nMicrosoft has issued updates for this vulnerability, as well as guidance for protecting operating systems that we no longer support. Microsoft Defender ATP also contains behavioral detections for defending against this threat.\nThe following query locates devices where the known coin miner payload was dropped.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2019-0708\nhttps://www.nsa.gov/News-Features/News-Stories/Article-View/Article/1865726/nsa-cybersecurity-advisory-patch-remote-desktop-services-on-legacy-versions-of/\nhttps://www.wired.com/story/bluekeep-hacking-cryptocurrency-mining/\nhttps://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2019-0708\nhttps://support.microsoft.com/help/4500705/customer-guidance-for-cve-2019-0708\nhttps://www.microsoft.com/security/blog/2019/11/07/the-new-cve-2019-0708-rdp-exploit-attacks-explained/\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-doublepulsar-execution.yaml", "query_name": "detect-doublepulsar-execution", "query": "//DoublePulsar execution\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n| where SHA1 == \"be855cd1bfc1e1446a3390c693f29e2a3007c04e\" or\n(ProcessCommandLine contains \"targetport\" and ProcessCommandLine contains \"targetip\" and\n(ProcessCommandLine contains \"payload\" or ProcessCommandLine contains \"verifybackdoor\"))\n", "attributes": {"description": "This query was originally published in the threat analytics report, Motivated miners.\nDoublepulsar is a backdoor developed by the National Security Agency (NSA). First disclosed in 2017, it is now used by many malicious actors. Software patches are available.\nThe following query detects possible DoublePulsar execution events.\nSee Detect web server exploitation by DoublePulsar for a query that detects behaviors associated with campaigns that use DoublePulsar.\nReferences:\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Trojan:Win32/DoublePulsar&threatId=-2147239036\nhttps://www.scmagazine.com/home/security-news/cybercrime/doublepulsar-malware-spreading-rapidly-in-the-wild-following-shadow-brokers-dump/\nhttps://support.microsoft.com/help/4013389/title\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-exploitation-of-cve-2018-8653.yaml", "query_name": "detect-exploitation-of-cve-2018-8653", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\nand InitiatingProcessFileName =~ \"svchost.exe\"\nand InitiatingProcessCommandLine contains \"WinHttpAutoProxySvc\"\nand FileName !~ \"pacjsworker.exe\"\nand FileName !~ \"svchost.exe\"\nand FileName !~ \"WerFault.exe\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, CVE-2018-8653 scripting engine vulnerability.\nCVE-2018-8653 is a remote code execution vulnerability found in the scripting engine for several releases of Internet Explorer. An attacker exploiting this CVE could use a malicious webpage to gain the same access rights as the currently logged-in user -- which is particularly problematic if the user is an administrator.\nMicrosoft has since addressed this vulnerability.\nThe following queries detect possible exploitation of this CVE.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2018-8653\nhttps://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2018-8653\n", "techniques": NaN, "tactics": ["Initial access", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-malicious-rar-extraction.yaml", "query_name": "detect-malicious-rar-extraction", "query": "DeviceProcessEvents\n| where FileName == \"cmd.exe\"\n| where ProcessCommandLine contains @\"set path=%ProgramFiles(x86)%\\WinRAR;C:\\Program Files\\WinRAR;\"\n| where ProcessCommandLine contains @\"cd /d %~dp0 & rar.exe e -o+ -r -inul*.rar\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, CVE-2018-15982 exploit attacks.\nCVE-2018-15982 is an exploit of Adobe Flash Player, that allows for remote execution of arbitrary code. It has since been patched.\nActors have been observed using this vulnerability in targeted attacks. Exploits for CVE-2018-15982 have also been included in several exploit kits.\nIn some initial attacks exploiting CVE-2018-15982, attackers sent targets spear-phishing emails. The emails would include an attached RAR archive, which contained a lure document, as well as a second archive disguised as a .jpg file. Opening the document would automatically run an embedded Flash ActiveX control. This, in turn, would call a script containing the exploit. The exploit's ability to run arbitrary code would be employed to unpack and run a payload from the second archive. The payload is a backdoor used both to achieve persistance and for command and control.\nThe following query detects possible instances of a payload being extracted by the exploit.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2018-15982\nhttps://helpx.adobe.com/security/products/flash-player/apsb18-42.html\n", "techniques": NaN, "tactics": ["Initial access", "Execution", "Persistence", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-malicious-use-of-msiexec-mimikatz.yaml", "query_name": "detect-malicious-use-of-msiexec-mimikatz", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where InitiatingProcessFileName =~ \"msiexec.exe\"\n//Mimikatz commands\nand (ProcessCommandLine contains \"privilege::\" \nor ProcessCommandLine has \"sekurlsa\" \nor ProcessCommandLine contains \"token::\") \n", "attributes": {"description": "This query was originally published in the threat analytics report, Msiexec abuse.\nMsiexec.exe is a Windows component that installs files with the .msi extension. These kinds of files are Windows installer packages, and are used by a wide array of legitimate software. However, malicious actors can re-purpose msiexec.exe for living-off-the-land attacks, where they use legitimate system binaries on the compromised device to perform attacks.\nThe following query detects activity associated with misuse of msiexec.exe, particularly alongside mimikatz, a common credential dumper and privilege escalation tool.\nReference - https://www.varonis.com/blog/what-is-mimikatz/\n", "techniques": NaN, "tactics": ["Execution", "Privilege escalation", "Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-malicious-use-of-msiexec-msiexec.yaml", "query_name": "detect-malicious-use-of-msiexec", "query": "//Find possible download and execution using Msiexec\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n//MSIExec\n| where FileName =~ \"msiexec.exe\" and \n//With domain in command line\n(ProcessCommandLine has \"http\" and ProcessCommandLine has \"return\")//Find PowerShell running files from the temp folder\n", "attributes": {"description": "This query was originally published in the threat analytics report, Msiexec abuse.\nMsiexec.exe is a Windows component that installs files with the .msi extension. These kinds of files are Windows installer packages, and are used by a wide array of legitimate software. However, malicious actors can re-purpose msiexec.exe for living-off-the-land attacks, where they use legitimate system binaries on the compromised device to perform attacks.\nThe following query detects activity associated with misuse of msiexec.exe, particularly alongside mimikatz, a common credential dumper and privilege escalation tool.\nReference - https://www.varonis.com/blog/what-is-mimikatz/\n", "techniques": NaN, "tactics": ["Execution", "Privilege escalation", "Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-malicious-use-of-msiexec-powershell.yaml", "query_name": "detect-malicious-use-of-msiexec-powershell", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n//Looking for PowerShell\n| where FileName =~ \"powershell.exe\"\n//Looking for %temp% in the command line indicating deployment \nand ProcessCommandLine contains \"%temp%\"//Find credential theft attempts using Msiexec to run Mimikatz commands\n", "attributes": {"description": "This query was originally published in the threat analytics report, Msiexec abuse.\nMsiexec.exe is a Windows component that installs files with the .msi extension. These kinds of files are Windows installer packages, and are used by a wide array of legitimate software. However, malicious actors can re-purpose msiexec.exe for living-off-the-land attacks, where they use legitimate system binaries on the compromised device to perform attacks.\nThe following query detects activity associated with misuse of msiexec.exe, particularly alongside mimikatz, a common credential dumper and privilege escalation tool.\nReference - https://www.varonis.com/blog/what-is-mimikatz/\n", "techniques": NaN, "tactics": ["Execution", "Privilege escalation", "Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-office-apps-spawn-msdt-CVE-2022-30190.yaml", "query_name": "detect-office-applications-spawning-msdt-CVE-2022-30190", "query": "// Office products spawning MSDT\nDeviceProcessEvents\n| where InitiatingProcessFileName in~ (\"winword.exe\", \"excel.exe\", \"outlook.exe\", \"powerpnt.exe\")\nand FileName =~\"msdt.exe\"\n", "attributes": {"description": "This query detects possible abuse of ms-msdt MSProtocol URI scheme to load and execute malicious code via Microsoft Support Diagnostic Tool Vulnerability (CVE-2022-30190).\nThe following query detects when Microsoft Office software spawns an instance of the MSDT utility, msdt.exe.\nReferences:\nhttps://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-30190\nhttps://msrc-blog.microsoft.com/2022/05/30/guidance-for-cve-2022-30190-microsoft-support-diagnostic-tool-vulnerability/\nhttps://www.huntress.com/blog/microsoft-office-remote-code-execution-follina-msdt-bug\nhttps://attack.mitre.org/techniques/T1221/\n", "techniques": ["T1221"], "tactics": ["Defense Evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-office-products-spawning-wmic.yaml", "query_name": "detect-office-products-spawning-wmic", "query": "// Office products spawning WMI\nDeviceProcessEvents\n| where InitiatingProcessFileName in~ (\"winword.exe\", \"excel.exe\", \"outlook.exe\")\nand FileName =~\"wmic.exe\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ursnif (Gozi) continues to evolve.\nWindows Management Instrumentation, or WMI, is a legitimate Microsoft framework used to obtain management data and perform administrative tasks on remote devices. However, attackers can also use WMI to gather information about a target or hijack control of a device. The MITRE ATT&CK framework includes WMI among its list of common enterprise attack techniques.\nThe following query detects when Microsoft Office software spawns an instance of the WMI command-line utility, wmic.exe.\nReferences:\nhttps://docs.microsoft.com/windows/win32/wmisdk/about-wmi\nhttps://attack.mitre.org/techniques/T1047/\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-suspicious-mshta-usage.yaml", "query_name": "detect-suspicious-mshta-usage", "query": "// mshta.exe script launching processes\nDeviceProcessEvents \n| where Timestamp > ago(7d)\nand InitiatingProcessFileName =~ 'mshta.exe'\nand InitiatingProcessCommandLine contains '<script>'\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ursnif (Gozi) continues to evolve.\nMicrosoft HTML Applications, or HTAs, are executable files that use the same technologies and models as Internet Explorer, but do not run inside of a web browser.\nMshta.exe is a Windows utility that provides a host for HTA files to run in. Although it has legitimate uses, attackers can use mshta.exe to run malicious Javascript or VBScript commands. The MITRE ATT&CK framework includes Mshta among its list of enterprise attack techniques.\nThe following query detects when mshta.exe has been run, which might include illegitimate usage by attackers.\nReferences:\nhttps://docs.microsoft.com/previous-versions/ms536496(v=vs.85)\nhttps://attack.mitre.org/techniques/T1170/\n", "techniques": NaN, "tactics": ["Execution", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/detect-web-server-exploit-doublepulsar.yaml", "query_name": "detect-web-server-exploit-doublepulsar", "query": "DeviceProcessEvents\n| where Timestamp >= ago(7d)\n| where\n// \"Grandparent\" process is Oracle WebLogic or some process loading Confluence\nInitiatingProcessParentFileName == \"beasvc.exe\" or\nInitiatingProcessFileName == \"beasvc.exe\"\nor InitiatingProcessCommandLine contains \"//confluence\"\n// Calculate for Base64 in Commandline\n| extend Caps = countof(ProcessCommandLine, \"[A-Z]\", \"regex\"),\nTotal = countof(ProcessCommandLine, \".\", \"regex\")\n| extend Ratio = todouble(Caps) / todouble(Total)\n| where\n(\n    FileName in~ (\"powershell.exe\" , \"powershell_ise.exe\") // PowerShell is spawned\n    // Omit known clean processes\n    and ProcessCommandLine !startswith \"POWERSHELL.EXE  -C \\\"GET-WMIOBJECT -COMPUTERNAME\"\n    and ProcessCommandLine !contains \"ApplicationNo\"\n    and ProcessCommandLine !contains \"CustomerGroup\"\n    and ProcessCommandLine !contains \"Cosmos\"\n    and ProcessCommandLine !contains \"Unrestricted\"\n    and\n    (\n        ProcessCommandLine contains \"$\" // PowerShell variable declaration\n        or ProcessCommandLine contains \"-e \" // Alias for \"-EncodedCommand\" parameter\n        or ProcessCommandLine contains \"encodedcommand\"\n        or ProcessCommandLine contains \"wget\"\n        //or ( Ratio > 0.4 and Ratio < 1.0) // Presence of Base64 strings\n    )\n)\nor\n(\n    FileName =~ \"cmd.exe\" // cmd.exe is spawned\n    and ProcessCommandLine contains \"@echo\" and\n    ProcessCommandLine contains \">\" // Echoing commands into a file\n)\nor\n(\n    FileName =~ \"certutil.exe\" // CertUtil.exe abuse\n    and ProcessCommandLine contains \"-split\"\n    // the \"-split\" parameter is required to write files to the disk\n)\n| project\n       Timestamp,\n       InitiatingProcessCreationTime ,\n       DeviceId ,\n       Grandparent_PID = InitiatingProcessParentId,\n       Grandparent = InitiatingProcessParentFileName,\n       Parent_Account = InitiatingProcessAccountName,\n       Parent_PID = InitiatingProcessId,\n       Parent = InitiatingProcessFileName ,\n       Parent_Commandline = InitiatingProcessCommandLine,\n       Child_PID = ProcessId,\n       Child = FileName ,\n       Child_Commandline = ProcessCommandLine\n", "attributes": {"description": "This query was originally published in the threat analytics report, Motivated miners.\nDoublepulsar is a backdoor developed by the National Security Agency (NSA). First disclosed in 2017, it is now used by many malicious actors. Software patches are available.\nThe following query detects activity broadly associated with campaigns that use DoublePulsar to exploit web servers.\nSee Detect DoublePulsar execution for a query that detects possible DoublePulsar execution events.\nReferences:\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Trojan:Win32/DoublePulsar&threatId=-2147239036\nhttps://www.scmagazine.com/home/security-news/cybercrime/doublepulsar-malware-spreading-rapidly-in-the-wild-following-shadow-brokers-dump/\nhttps://support.microsoft.com/help/4013389/title\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/exchange-iis-worker-dropping-webshell.yaml", "query_name": "exchange-iis-worker-dropping-webshell", "query": "DeviceFileEvents\n| where InitiatingProcessFileName == 'w3wp.exe' | where InitiatingProcessCommandLine contains \"MSExchange\"\n| where FolderPath has_any (\"\\\\wwwroot\\\\\", \"HttpProxy\\\\owa\\\\\",\"\\\\Temporary ASP.NET Files\\\\\")\n| where not(FolderPath has_any(\"\\\\tmp\\\\\",\"\\\\dl3\\\\\"))\n| where FolderPath !endswith \".log\" | where FolderPath !endswith \".json\"\n| where FolderPath !endswith \".ini\"\n| where FolderPath !endswith \".vb\"\n| where FolderPath !endswith '.tmp'\n| where FolderPath !endswith '.xml'\n| where FolderPath !endswith '.js'\n", "attributes": {"description": "This query was originally published in the threat analytics report, \"Exchange Server zero-days exploited in the wild\".\nIn early March 2021, Microsoft released patches for four different zero-day vulnerabilities affecting Microsoft Exchange Server. The vulnerabilities were being used in a coordinated attack. For more information on the vulnerabilities, visit the following links:\n1. CVE-2021-26855\n2. CVE-2021-26857\n3. CVE-2021-26858\n4. CVE-2021-27065\nThe following query checks for the IIS worker process in Exchange Server dropping files that appear to be the web shells and other threat artifacts observed in known attacks.\nMore queries related to this threat can be found under the See also section of this page.\nReference - https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/\n", "techniques": NaN, "tactics": ["Execution", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/ExecuteBase64DecodedPayload.yaml", "query_name": "ExecuteBase64DecodedPayload", "query": "DeviceProcessEvents \n| where Timestamp > ago(14d) \n| where ProcessCommandLine contains \".decode('base64')\"\n        or ProcessCommandLine contains \".b64decode(\"\n        or ProcessCommandLine contains \"base64 --decode\"\n        or ProcessCommandLine contains \".decode64(\" \n| project Timestamp , DeviceName , FileName , FolderPath , ProcessCommandLine , InitiatingProcessCommandLine \n| top 100 by Timestamp \n", "attributes": {"description": "Process executed from binary hidden in Base64 encoded file.  Encoding malicious software is a.\nTechnique to obfuscate files from detection.\nThe first and second ProcessCommandLine component is looking for Python decoding base64.\nThe third ProcesssCommandLine component is looking for the Bash/sh commandline base64 decoding tool.\nThe fourth one is looking for Ruby decoding base64.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/File%20Copy%20and%20Execution.yaml", "query_name": "File Copy and Execution", "query": "let ToleranceInSeconds = 5;\nDeviceNetworkEvents\n| where LocalPort == 445 and isnotempty(RemoteIP)\n| join kind = inner DeviceLogonEvents on DeviceId\n| where Timestamp1 between (Timestamp .. datetime_add('second',ToleranceInSeconds,Timestamp)) and RemoteIP endswith RemoteIP1\n| join kind=inner (\n    DeviceFileEvents\n    | where ActionType in ('FileModified','FileCreated') and (InitiatingProcessFileName =~ 'System' or InitiatingProcessFolderPath endswith \"ntoskrnl.exe\")\n) on DeviceId\n| where Timestamp2 between (Timestamp .. datetime_add('second',ToleranceInSeconds,Timestamp))\n| join kind=inner DeviceProcessEvents on DeviceId, FolderPath\n| where Timestamp3 between (Timestamp .. datetime_add('second',ToleranceInSeconds,Timestamp))\n| project Timestamp, DeviceName, RemoteIP, RemotePort, AccountDomain, AccountName, AccountSid, Protocol, LogonId, RemoteDeviceName, IsLocalAdmin, FileName, FolderPath, SHA1, SHA256, MD5, ProcessCommandLine\n", "attributes": {"description": "This query identifies files that are copied to a device over SMB, then executed within a\nspecified threshold. Default is 5 seconds, but is configurable by tweaking the value for\nToleranceInSeconds.\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Lateral movement", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/jse-launched-by-word.yaml", "query_name": "jse-launched-by-word", "query": "// Find potentially malicious .jse launch by File Explorer or Word \nDeviceProcessEvents \n| where Timestamp > ago(7d) \n| where InitiatingProcessFileName in~ (\"explorer.exe\",\"winword.exe\") \nand FileName =~ \"wscript.exe\"\nand ProcessCommandLine contains \".jse\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Emulation-evading JavaScripts.\nAttackers in several ransomware campaigns have employed heavily obfuscated JavaScript code, in order to implant malware or execute malicious commands. The obfuscation is intended to help the code evade security systems and potentially escape sandbox environments.\nThe following query detects when Word or File Explorer have launched files with a .jse extension. Attackers involved in various human-operated campaigns have been known to embed a heavily obfuscated JavaScript file in malicious Word docs. The loader is used to download and install the banking trojan, Trickbot.\nSee Detect .jse file creation events for a similar technique.\nReference - https://www.microsoft.com/security/blog/2020/03/05/human-operated-ransomware-attacks-a-preventable-disaster/\n", "techniques": NaN, "tactics": ["Initial access", "Execution", "Defense evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/launch-questd-w-osascript.yaml", "query_name": "launch-questd-w-osascript", "query": "union DeviceFileEvents, DeviceProcessEvents  \n| where Timestamp >= ago(7d)  \n| where ProcessCommandLine has \"osascript -e do shell script \\\"launchctl load\" and  \nProcessCommandLine contains \"questd\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, EvilQuest signals the rise of Mac ransomware.\nAs of the time of this writing (October 2020), ransomware designed to target macOS is relatively rare. EvilQuest is one of the few examples of this kind of malware on the platform.\nThe query below can detect events associated with the launch of the EvilQuest executable, questd, from the shell.\nOther queries related to EvilQuest ransomware can be found under the See also section below.\n", "techniques": NaN, "tactics": ["Execution", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/locate-shlayer-payload-decryption-activity.yaml", "query_name": "locate-shlayer-payload-decryption-activity", "query": "// Find use of the Shlayer OpenSSL command to decode and decrypt a payload\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName =~ \"openssl\"\nand ProcessCommandLine has \"-base64\" and\nProcessCommandLine has \"-out\"  and\nProcessCommandLine has \"-nosalt\"\nand ProcessCommandLine has_any(\"-aes256\", \"-aes-256\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, OSX/Shlayer sustains adware push.\nShlayer is adware that spies on users' search terms, and redirects network traffic to serve the user attacker-controlled search results containing ads.\nThe following query locates activity associated with the Shlayer payload decrypter.\nReference - https://www.intego.com/mac-security-blog/osxshlayer-new-mac-malware-comes-out-of-its-shell/\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/locate-shlayer-payload-decrytion-activity.yaml", "query_name": "locate-shlayer-payload-decrytion-activity", "query": "// Find use of the Shlayer OpenSSL command to decode and decrypt a payload\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName =~ \"openssl\"\nand ProcessCommandLine has \"-base64\" and\nProcessCommandLine has \"-out\"  and\nProcessCommandLine has \"-nosalt\"\nand ProcessCommandLine has_any(\"-aes256\", \"-aes-256\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, OSX/Shlayer sustains adware push.\nShlayer is adware that spies on users' search terms, and redirects network traffic to serve the user attacker-controlled search results containing ads.\nThe following query locates activity associated with the Shlayer payload decrypter.\nReference - https://www.intego.com/mac-security-blog/osxshlayer-new-mac-malware-comes-out-of-its-shell/\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/locate-surfbuyer-downloader-decoding-activity.yaml", "query_name": "locate-surfbuyer-downloader-decoding-activity", "query": "// Find SurfBuyer command to decode a file and save it into a /tmp folder using a certain file name\nDeviceProcessEvents\n// Check for activity over the past 7 days\n| where Timestamp > ago(7d)\n| where ProcessCommandLine has \"base64\" and ProcessCommandLine has \"/tmp/e_\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, OSX/SurfBuyer adware campaign.\nIt will return results if a shell script has furtively attempted to decode and save a file to a /tmp folder.\nIf discovered on your system, this kind of activity might be associated with SurfBuyer, which is adware that installs a browser extension to take control of several major web browsers, including Safari, Google Chrome, and Firefox.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/Malware_In_recyclebin.yaml", "query_name": "Malware_In_recyclebin", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where FileName in~('cmd.exe','ftp.exe','schtasks.exe','powershell.exe','rundll32.exe','regsvr32.exe','msiexec.exe')\n| where ProcessCommandLine contains \":\\\\recycler\"\n| project Timestamp, DeviceName, ProcessCommandLine, InitiatingProcessFileName\n", "attributes": {"description": "Finding attackers hiding malware in the recycle bin.\nRead more here: https://azure.microsoft.com/blog/how-azure-security-center-helps-reveal-a-cyberattack/.\nTags: #execution #SuspiciousPath.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/Masquerading%20system%20executable.yaml", "query_name": "Masquerading system executable", "query": "let nonSystemProcesses = \n    DeviceProcessEvents \n    | where Timestamp > ago(7d) //Adjust your desired date range here and set the data/time picker to 30 days \n    | where FolderPath !startswith @\"C:\\Windows\\system32\\\" and FolderPath !startswith @\"C:\\Windows\\SysWOW64\\\" and isnotempty(MD5)\n    and FileName !in~ (\"MpSigStub.exe\",\"GACUtil_20.exe\");\n//Get a list of MD5s of all procceses run from system32 or SysWOW64\nlet systemProcessHashes = \n    DeviceProcessEvents \n    | where Timestamp > ago(30d) //Keep this at 30 days so it uses all available data to compile the list of hashes\n    | where FolderPath startswith @\"C:\\Windows\\system32\\\" or FolderPath startswith @\"C:\\Windows\\SysWOW64\\\" and isnotempty(MD5) \n    and FileName !in~ (\"fileacl.exe\",\"WerFault.exe\")\n    | summarize LegitFolderPath=makeset(tolower(FolderPath)) by MD5, LegitFileName=FileName;\n//Join the two tables on MD5, where the filenames do not match\nsystemProcessHashes | join kind=inner (nonSystemProcesses) on MD5 | where tolower(LegitFileName)!=tolower(FileName)\n| project Timestamp, DeviceName, FileName, FolderPath, LegitFileName, LegitFolderPath, MD5, ProcessCommandLine, AccountName, InitiatingProcessFileName, InitiatingProcessParentFileName, ReportId, DeviceId\n| top 100 by Timestamp desc\n", "attributes": {"description": "Finds legitimate system32 or syswow64 executables being run under a different name and in a different location.\nThe rule will require tuning for your environment.\nMITRE: Masquerading https://attack.mitre.org/techniques/T1036.\nGet a list of all processes run, except those run from system32 or SysWOW64.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/office-apps-launching-wscipt.yaml", "query_name": "office-apps-launching-wscipt", "query": "DeviceProcessEvents \n| where InitiatingProcessFileName in~('winword.exe', 'excel.exe', 'outlook.exe') \n| where FileName =~ \"wscript.exe\" and ProcessCommandLine has \".jse\" \n", "attributes": {"description": "This query was originally published in the threat analytics report, Trickbot: Pervasive & underestimated.\nTrickbot is a very prevalent piece of malware with an array of malicious capabilities. Originally designed to steal banking credentials, it has since evolved into a modular trojan that can deploy other malware, disable security software, and perform command-and-control (C2) operations.\nTrickbot is frequently spread through email. An attacker will send a target a message with an attachment containing a malicious macro. If the target enables the macro, it will write a JScript Encoded (JSE) file to disk (JScript is a Microsoft dialect of ECMAScript). The JSE file will then be launched using wscript.exe to perform a variety of malicious tasks, particularly reconnaissance.\nThe following query detects when Office applications have launched wscript.exe to run a JSE file.\nSee Detect rundll.exe being used for reconnaissance and command-and-control for another query related to Trickbot activity.\nReference - https://attack.mitre.org/software/S0266/\n", "techniques": NaN, "tactics": ["Lateral movement", "Collection", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/Possible%20Ransomware%20Related%20Destruction%20Activity.yaml", "query_name": "Possible Ransomware Related Destruction Activity", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where (FileName =~ 'vssadmin.exe' and ProcessCommandLine has \"delete shadows\" and ProcessCommandLine has \"/all\" and ProcessCommandLine has \"/quiet\" ) // Clearing shadow copies\n    or (FileName =~ \"WMIC.exe\" and ProcessCommandLine has \"shadowcopy delete\") // WMIC to delete shadow copies\n    or (FileName =~ 'cipher.exe' and ProcessCommandLine contains \"/w\") // Wiping drive free space\n    or (FileName =~ 'schtasks.exe' and ProcessCommandLine has \"/change\" and ProcessCommandLine has @\"\\Microsoft\\Windows\\SystemRestore\\SR\" and ProcessCommandLine has \"/disable\") // Disabling system restore task\n    or (FileName =~ 'fsutil.exe' and ProcessCommandLine has \"usn\" and ProcessCommandLine has \"deletejournal\" and ProcessCommandLine has \"/d\") // Deleting USN journal\n    or (FileName =~ 'icacls.exe' and ProcessCommandLine has @'\"C:\\*\"' and ProcessCommandLine contains '/grant Everyone:F') // Attempts to re-ACL all files on the C drive to give everyone full control\n    or (FileName =~ 'powershell.exe' and (\n            ProcessCommandLine matches regex @'\\s+-((?i)encod?e?d?c?o?m?m?a?n?d?|e|en|enc|ec)\\s+' and replace(@'\\x00','', base64_decode_tostring(extract(\"[A-Za-z0-9+/]{50,}[=]{0,2}\",0 , ProcessCommandLine))) matches regex @\".*(Win32_Shadowcopy).*(.Delete\\(\\)).*\"\n        ) or ProcessCommandLine matches regex @\".*(Win32_Shadowcopy).*(.Delete\\(\\)).*\"\n    ) // This query looks for PowerShell-based commands used to delete shadow copies\n", "attributes": {"description": "This query identifies common processes run by ransomware\nmalware to destroy volume shadow copies or clean free\nspace on a drive to prevent a file from being recovered\npost-encryption.  To reduce false positives, results are\nfiltered to only actions taken when the initiating\nprocess was launched from a suspicious directory.  If\nyou don't mind false positives, consider removing the\nlast where clause.\nSpecial thanks to Captain for additional inputs\n", "techniques": NaN, "tactics": ["Execution", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/PowerShell%20downloads.yaml", "query_name": "PowerShell downloads", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName in~ (\"powershell.exe\", \"powershell_ise.exe\")\n| where ProcessCommandLine has \"Net.WebClient\"\n   or ProcessCommandLine has \"DownloadFile\"\n   or ProcessCommandLine has \"Invoke-WebRequest\"\n   or ProcessCommandLine has \"Invoke-Shellcode\"\n   or ProcessCommandLine has \"http\"\n   or ProcessCommandLine has \"IEX\"\n   or ProcessCommandLine has \"Start-BitsTransfer\"\n   or ProcessCommandLine has \"mpcmdrun.exe\"\n| project Timestamp, DeviceName, InitiatingProcessFileName, FileName, ProcessCommandLine\n| top 100 by Timestamp\n", "attributes": {"description": "Finds PowerShell execution events that could involve a download.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/powershell-activity-after-email-from-malicious-sender.yaml", "query_name": "powershell-activity-after-email-from-malicious-sender", "query": "//Find PowerShell activities right after email was received from malicious sender\nlet x=EmailEvents\n| where SenderFromAddress =~ \"MaliciousSender@example.com\"\n| project TimeEmail = Timestamp, Subject, SenderFromAddress, AccountName = tostring(split(RecipientEmailAddress, \"@\")[0]);\nx\n| join (\nDeviceProcessEvents\n| where FileName =~ \"powershell.exe\"\n//| where InitiatingProcessParentFileName =~ \"outlook.exe\"\n| project TimeProc = Timestamp, AccountName, DeviceName, InitiatingProcessParentFileName, InitiatingProcessFileName, FileName, ProcessCommandLine\n) on AccountName \n| where (TimeProc - TimeEmail) between (0min.. 30min)\n", "attributes": {"description": "Malicious emails often contain documents and other specially crafted attachments that run PowerShell commands to deliver additional payloads. If you are aware of emails coming from a known malicious sender, you can use this query to list and review PowerShell activities that occurred within 30 minutes after an email was received from the sender .\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/powershell-version-2.0-execution.yaml", "query_name": "powershell-version-2.0-execution", "query": "DeviceProcessEvents\n| where FileName in~ (\"powershell.exe\", \"powershell_ise.exe\")\n| where ProcessCommandLine has \"-v 2\"\n   or ProcessCommandLine has \"-v 2.0\"\n   or ProcessCommandLine has \"-version 2\"\n   or ProcessCommandLine has \"-version 2.0\"\n", "attributes": {"description": "Find the execution of PowerShell Version 2.0, eather to discover legacy scripts using version 2 or to find attackers trying to hide from script logging and AMSI.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/PowershellCommand%20-%20uncommon%20commands%20on%20machine.yaml", "query_name": "PowershellCommand - uncommon commands on machine", "query": "let DeviceId = \"474908f457a1dc4c1fab568f808d5f77bf3bb951\";\nlet timestamp = datetime(2018-06-09T02:23:26.6832917Z);\n// Query for Powershell cmdlets\nlet powershellCommands =\n    DeviceEvents\n    | where ActionType == \"PowerShellCommand\"\n    // Extract the powershell command name from the Command field in the AdditionalFields JSON column\n    | project PowershellCommand=extractjson(\"$.Command\", AdditionalFields, typeof(string)), InitiatingProcessCommandLine, InitiatingProcessParentFileName, Timestamp, DeviceId\n    | where PowershellCommand !endswith \".ps1\" and PowershellCommand !endswith \".exe\";\n// Filter Powershell cmdlets executed on relevant machine and time period\npowershellCommands | where DeviceId == DeviceId and Timestamp between ((timestamp-5min) .. 10min)\n// Filter out common powershell cmdlets\n| join kind=leftanti (powershellCommands | summarize MachineCount=dcount(DeviceId) by PowershellCommand | where MachineCount > 20) on PowershellCommand\n", "attributes": {"description": "Find which uncommon Powershell Cmdlets were executed on that machine in a certain time period.\nThis covers all Powershell commands executed in the Powershell engine by any process.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/PowershellCommand%20footprint.yaml", "query_name": "PowershellCommand footprint", "query": "let powershellCommandName = \"Invoke-RickAscii\";\nDeviceEvents\n| where ActionType == \"PowerShellCommand\"\n// This filter improves query performance, as it avoids needing to parse Command from all rows and only then applying a filter\n| where AdditionalFields contains powershellCommandName\n// Extract the powershell command name from the Command field in the AdditionalFields JSON column\n| project PowershellCommand=extractjson(\"$.Command\", AdditionalFields, typeof(string)), InitiatingProcessCommandLine, InitiatingProcessParentFileName, Timestamp, DeviceId\n// Do an exact case-insensitive match on the command name field\n| where PowershellCommand =~ powershellCommandName\n", "attributes": {"description": "Find all machines running a given Powersehll cmdlet.\nThis covers all Powershell commands executed in the Powershell engine by any process.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/python-based-attacks-on-macos.yaml", "query_name": "python-based-attacks-on-macos", "query": "DeviceProcessEvents\n| where InitiatingProcessParentFileName in (\"Microsoft Word\", \"Microsoft Excel\")\n| where FileName =~ \"Python\"\n| where ProcessCommandLine matches regex \"[A-Za-z0-9]{50}\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Python abuse on macOS\nThe Python programming language comes bundled with macOS. In threat intelligence gathered from macOS endpoints, we have observed numerous attacks run with EmPyre, a Python-based post-exploitation framework similar to PowerShell Empire for Windows.\nThe following query checks for Microsoft Office documents that run Python scripts.\nReference - https://www.powershellempire.com/\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/qakbot-campaign-suspicious-javascript.yaml", "query_name": "qakbot-campaign-suspicious-javascript", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName == \"cmd.exe\"\n| where FileName == \"cscript.exe\"\n| where InitiatingProcessCommandLine has \"start /MIN\"\n| where ProcessCommandLine has \"E:javascript\"\n| project ProcessCommandLine, \nInitiatingProcessCommandLine, DeviceId, Timestamp\n", "attributes": {"description": "This query was originally published in the threat analytics report, Qakbot blight lingers, seeds ransomware\nQakbot is malware that steals login credentials from banking and financial services. It has been deployed against small businesses as well as major corporations. Some outbreaks have involved targeted ransomware campaigns that use a similar set of techniques. Links to related queries are listed under See also.\nThe following query detects possible attempts by Qakbot to execute malicious Javascript code.\nReference - https://www.microsoft.com/security/blog/2017/11/06/mitigating-and-eliminating-info-stealing-qakbot-and-emotet-in-corporate-networks/\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/reverse-shell-nishang-base64.yaml", "query_name": "reverse-shell-nishang-base64", "query": "DeviceProcessEvents\n| where FileName in(\"powershell.exe\",\"powershell_ise.exe\") and ProcessCommandLine contains \"-e\"\n| mvexpand SS = split(ProcessCommandLine, \" \")\n| where SS matches regex \"[A-Za-z0-9+/]{50,}[=]{0,2}\"\n| extend DecodeString = base64_decodestring(tostring(SS))\n| extend FinalString = replace(\"\\\\0\", \"\", DecodeString)\n| where FinalString has \"tcpclient\" and FinalString contains \"$\" and (FinalString contains \"invoke\" or FinalString contains \"iex\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, \"Exchange Server zero-days exploited in the wild\".\nIn early March 2021, Microsoft released patches for four different zero-day vulnerabilities affecting Microsoft Exchange Server. The vulnerabilities were being used in a coordinated attack. For more information on the vulnerabilities, visit the following links:\n1. CVE-2021-26855\n2. CVE-2021-26857\n3. CVE-2021-26858\n4. CVE-2021-27065\nThe following query finds evidence of Base64-encoded commands used by the Nishang penetration testing framework to load a reverse TCP shell. This might indicate an attacker has remote access to the device.\nMore queries related to this threat can be found under the See also section of this page.\nReference - https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/reverse-shell-nishang.yaml", "query_name": "reverse-shell-nishang", "query": "DeviceProcessEvents | where FileName has_any (\"cmd.exe\", \"powershell.exe\", \"PowerShell_ISE.exe\") \n| where ProcessCommandLine contains \"$client = New-Object System.Net.Sockets.TCPClient\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, \"Exchange Server zero-days exploited in the wild\".\nIn early March 2021, Microsoft released patches for four different zero-day vulnerabilities affecting Microsoft Exchange Server. The vulnerabilities were being used in a coordinated attack. For more information on the vulnerabilities, visit the following links:\n1. CVE-2021-26855\n2. CVE-2021-26857\n3. CVE-2021-26858\n4. CVE-2021-27065\nThe following query finds evidence of a reverse shell being loaded using a technique associated with the Nishang penetration testing framework. This might indicate an attacker has remote access to the device.\nMore queries related to this threat can be found under the See also section of this page.\nReference - https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/sql-server-abuse.yaml", "query_name": "sql-server-abuse", "query": "DeviceProcessEvents \n| where Timestamp  >= ago(10d)\n| where InitiatingProcessFileName in~ (\"sqlservr.exe\", \"sqlagent.exe\", \n\"sqlps.exe\", \"launchpad.exe\")\n| summarize tostring(makeset(ProcessCommandLine)) \nby DeviceId, bin(Timestamp, 2m)\n| where\nset_ProcessCommandLine has \"certutil\" or \nset_ProcessCommandLine has \"netstat\" or \nset_ProcessCommandLine has \"ping\" or \nset_ProcessCommandLine has \"sysinfo\" or \nset_ProcessCommandLine has \"systeminfo\" or \nset_ProcessCommandLine has \"taskkill\" or \nset_ProcessCommandLine has \"wget\" or \nset_ProcessCommandLine has \"whoami\" or \nset_ProcessCommandLine has \"Invoke-WebRequest\" or \nset_ProcessCommandLine has \"Copy-Item\" or \nset_ProcessCommandLine has \"WebClient\" or \nset_ProcessCommandLine has \"advpack.dll\" or \nset_ProcessCommandLine has \"appvlp.exe\" or \nset_ProcessCommandLine has \"atbroker.exe\" or \nset_ProcessCommandLine has \"bash.exe\" or \nset_ProcessCommandLine has \"bginfo.exe\" or \nset_ProcessCommandLine has \"bitsadmin.exe\" or \nset_ProcessCommandLine has \"cdb.exe\" or \nset_ProcessCommandLine has \"certutil.exe\" or \nset_ProcessCommandLine has \"cl_invocation.ps1\" or \nset_ProcessCommandLine has \"cl_mutexverifiers.ps1\" or \nset_ProcessCommandLine has \"cmstp.exe\" or \nset_ProcessCommandLine has \"csi.exe\" or \nset_ProcessCommandLine has \"diskshadow.exe\" or \nset_ProcessCommandLine has \"dnscmd.exe\" or \nset_ProcessCommandLine has \"dnx.exe\" or \nset_ProcessCommandLine has \"dxcap.exe\" or \nset_ProcessCommandLine has \"esentutl.exe\" or \nset_ProcessCommandLine has \"expand.exe\" or \nset_ProcessCommandLine has \"extexport.exe\" or \nset_ProcessCommandLine has \"extrac32.exe\" or \nset_ProcessCommandLine has \"findstr.exe\" or \nset_ProcessCommandLine has \"forfiles.exe\" or \nset_ProcessCommandLine has \"ftp.exe\" or \nset_ProcessCommandLine has \"gpscript.exe\" or \nset_ProcessCommandLine has \"hh.exe\" or \nset_ProcessCommandLine has \"ie4uinit.exe\" or \nset_ProcessCommandLine has \"ieadvpack.dll\" or \nset_ProcessCommandLine has \"ieaframe.dll\" or \nset_ProcessCommandLine has \"ieexec.exe\" or \nset_ProcessCommandLine has \"infdefaultinstall.exe\" or \nset_ProcessCommandLine has \"installutil.exe\" or \nset_ProcessCommandLine has \"makecab.exe\" or \nset_ProcessCommandLine has \"manage-bde.wsf\" or \nset_ProcessCommandLine has \"mavinject.exe\" or \nset_ProcessCommandLine has \"mftrace.exe\" or \nset_ProcessCommandLine has \"microsoft.workflow.compiler.exe\" or \nset_ProcessCommandLine has \"mmc.exe\" or \nset_ProcessCommandLine has \"msbuild.exe\" or \nset_ProcessCommandLine has \"msconfig.exe\" or \nset_ProcessCommandLine has \"msdeploy.exe\" or \nset_ProcessCommandLine has \"msdt.exe\" or \nset_ProcessCommandLine has \"mshta.exe\" or \nset_ProcessCommandLine has \"mshtml.dll\" or \nset_ProcessCommandLine has \"msiexec.exe\" or \nset_ProcessCommandLine has \"msxsl.exe\" or \nset_ProcessCommandLine has \"odbcconf.exe\" or \nset_ProcessCommandLine has \"pcalua.exe\" or \nset_ProcessCommandLine has \"pcwrun.exe\" or \nset_ProcessCommandLine has \"pcwutl.dll\" or \nset_ProcessCommandLine has \"pester.bat\" or \nset_ProcessCommandLine has \"presentationhost.exe\" or \nset_ProcessCommandLine has \"pubprn.vbs\" or \nset_ProcessCommandLine has \"rcsi.exe\" or \nset_ProcessCommandLine has \"regasm.exe\" or \nset_ProcessCommandLine has \"register-cimprovider.exe\" or \nset_ProcessCommandLine has \"regsvcs.exe\" or \nset_ProcessCommandLine has \"regsvr32.exe\" or \nset_ProcessCommandLine has \"replace.exe\" or \nset_ProcessCommandLine has \"rundll32.exe\" or \nset_ProcessCommandLine has \"runonce.exe\" or \nset_ProcessCommandLine has \"runscripthelper.exe\" or \nset_ProcessCommandLine has \"schtasks.exe\" or \nset_ProcessCommandLine has \"scriptrunner.exe\" or \nset_ProcessCommandLine has \"setupapi.dll\" or \nset_ProcessCommandLine has \"shdocvw.dll\" or \nset_ProcessCommandLine has \"shell32.dll\" or \nset_ProcessCommandLine has \"slmgr.vbs\" or \nset_ProcessCommandLine has \"sqltoolsps.exe\" or \nset_ProcessCommandLine has \"syncappvpublishingserver.exe\" or \nset_ProcessCommandLine has \"syncappvpublishingserver.vbs\" or \nset_ProcessCommandLine has \"syssetup.dll\" or \nset_ProcessCommandLine has \"te.exe\" or \nset_ProcessCommandLine has \"tracker.exe\" or \nset_ProcessCommandLine has \"url.dll\" or \nset_ProcessCommandLine has \"verclsid.exe\" or \nset_ProcessCommandLine has \"vsjitdebugger.exe\" or \nset_ProcessCommandLine has \"wab.exe\" or \nset_ProcessCommandLine has \"winrm.vbs\" or \nset_ProcessCommandLine has \"wmic.exe\" or \nset_ProcessCommandLine has \"xwizard.exe\" or \nset_ProcessCommandLine has \"zipfldr.dll\"\n| sort by DeviceId  , Timestamp asc\n", "attributes": {"description": "This query was originally published in the threat analytics report, SQL Server abuse.\nSQL Server offers a vast array of tools for automating tasks, exporting data, and running scripts. These legitimate tools can be repurposed by attackers. Because there are so many powerful commands an attacker might exploit, hunting for malicious activity involving SQL Server can be complicated.\nThis query detects instances of a SQL Server process launching a shell to run one or more suspicious commands.\nReference - https://docs.microsoft.com/sql/relational-databases/security/securing-sql-server?view=sql-server-ver15\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/umworkerprocess-creating-webshell.yaml", "query_name": "umworkerprocess-creating-webshell", "query": "DeviceFileEvents\n| where InitiatingProcessFileName == \"UMWorkerProcess.exe\" \n| where FileName !in~(\"CacheCleanup.bin\", \"cleanup.bin\")\n| where FileName !endswith \".txt\"\n| where FileName !endswith \".LOG\" \n| where FileName !endswith \".cfg\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, \"Exchange Server zero-days exploited in the wild\".\nIn early March 2021, Microsoft released patches for four different zero-day vulnerabilities affecting Microsoft Exchange Server. The vulnerabilities were being used in a coordinated attack. For more information on the vulnerabilities, visit the following links:\n1. CVE-2021-26855\n2. CVE-2021-26857\n3. CVE-2021-26858\n4. CVE-2021-27065\nThe following query detects unusual file content being created by UMWorkerProcess, the Exchange Unified Messaging service. This might indicated that CVE-2021-26858 is being exploited to generate a web shell.\nMore queries related to this threat can be found under the See also section of this page.\nReference - https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/umworkerprocess-unusual-subprocess-activity.yaml", "query_name": "umworkerprocess-unusual-subprocess-activity", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName == \"UMWorkerProcess.exe\"\n| where FileName !in~(\"wermgr.exe\", \"WerFault.exe\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, \"Exchange Server zero-days exploited in the wild\".\nIn early March 2021, Microsoft released patches for four different zero-day vulnerabilities affecting Microsoft Exchange Server. The vulnerabilities were being used in a coordinated attack. For more information on the vulnerabilities, visit the following links:\n1. CVE-2021-26855\n2. CVE-2021-26857\n3. CVE-2021-26858\n4. CVE-2021-27065\nThe following query surfaces when unusual subprocesses were launched by MWorkerProcess, the Exchange Unified Messaging service. This might indicate exploitation of CVE-2021-26857 to run arbitrary code.\nMore queries related to this threat can be found under the See also section of this page.\nReference - https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/\n", "techniques": NaN, "tactics": ["Execution", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Execution/Webserver%20Executing%20Suspicious%20Applications.yaml", "query_name": "Webserver Executing Suspicious Applications", "query": "DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where InitiatingProcessFileName in~ ('w3wp.exe', 'httpd.exe') // 'sqlservr.exe')\n| where FileName in~ ('cmd.exe', 'powershell.exe', 'cscript.exe', 'wscript.exe', 'net.exe', 'net1.exe', 'ping.exe', 'whoami.exe')\n| summarize instances = count() by ProcessCommandLine, FolderPath, DeviceName, DeviceId \n| order by instances asc\n", "attributes": {"description": "This query looks for common webserver process names and identifies any processes launched using a scripting language (cmd, powershell, wscript, cscript), common initial profiling commands (net \\ net1 \\ whoami \\ ping \\ ipconfig),or admin commands (sc).  Note that seeing thisactivity doesn't immediately mean you have a breach, though you might consider  reviewing and honing the where clause to fit your specific web applications.\nThose who don't mind false positives should consider also adding database process names to this list as well (i.e. sqlservr.exe) to identify potential abuse of xp_cmdshell.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/7-zip-prep-for-exfiltration.yaml", "query_name": "7-zip-prep-for-exfiltration", "query": "DeviceProcessEvents | where FileName == \"7z.exe\" | where ProcessCommandLine contains \"ProgramData\\\\pst\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, \"Exchange Server zero-days exploited in the wild\".\nIn early March 2021, Microsoft released patches for four different zero-day vulnerabilities affecting Microsoft Exchange Server. The vulnerabilities were being used in a coordinated attack. For more information on the vulnerabilities, visit the following links:\n1. CVE-2021-26855\n2. CVE-2021-26857\n3. CVE-2021-26858\n4. CVE-2021-27065\nThe following query detects 7-zip activity associated with this threat. 7-ZIP is a legitimate tool used for file archiving; however, unusual 7-ZIP activity combined with other evidence might indicate that an attacker is compressing data for exfiltration.\nMore queries related to this threat can be found under the See also section of this page.\nReference - https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/Anomaly%20of%20MailItemAccess%20by%20GraphAPI%20%5BNobelium%5D.yaml", "query_name": "Anomaly of MailItemAccess by GraphAPI [Nobelium]", "query": "let starttime = 30d;\nlet STDThreshold = 2.5;\nlet allMailAccsessByGraphAPI = CloudAppEvents\n| where   ActionType == \"MailItemsAccessed\"\n| where Timestamp between (startofday(ago(starttime))..now())\n| where isnotempty(RawEventData['ClientAppId'] ) and RawEventData['AppId'] has \"00000003-0000-0000-c000-000000000000\"\n| extend ClientAppId = tostring(RawEventData['ClientAppId'])\n| extend OperationCount = toint(RawEventData['OperationCount'])\n| project Timestamp,OperationCount , ClientAppId;\nlet calculateNumberOfMailPerDay = allMailAccsessByGraphAPI\n| summarize NumberOfMailPerDay =sum(toint(OperationCount)) by ClientAppId,format_datetime(Timestamp, 'y-M-d');\nlet calculteAvgAndStdev=calculateNumberOfMailPerDay\n| summarize avg=avg(NumberOfMailPerDay),stev=stdev(NumberOfMailPerDay) by ClientAppId;\ncalculteAvgAndStdev  | join calculateNumberOfMailPerDay on ClientAppId\n| sort by ClientAppId\n|  where NumberOfMailPerDay > avg + STDThreshold * stev\n| project ClientAppId,Timestamp,NumberOfMailPerDay,avg,stev \n", "attributes": {"description": "This query looks for anomalies in mail item access events made by Graph API. It uses standard deviation to determine if the number of events is anomalous. The query returns all clientIDs where the amount of mail sent per day was larger than value given by the formula, 'average + STDThreshold(2.5)*(standard deviation)'.\nSee The MailItemsAccessed mailbox auditing action.\nReference - https://docs.microsoft.com/microsoft-365/compliance/mailitemsaccessed-forensics-investigations?view=o365-worldwide#the-mailitemsaccessed-mailbox-auditing-action\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/codeRepoExfil.yaml", "query_name": "Code Repo Exfiltration", "query": "let filesThreshold = 10;\nlet lookback = 1d;\nlet sourceDomainList = pack_array(\"github\", \"visualstudio\", \"gitlab\", \"bitbucket\", \"osdn\"); //code repo url's\nlet excludeTargetDomainList = pack_array(\"office.net\",\"visualstudio\",\"github\",\"gitlab\",\"azure\",\"dynamics\",\"teams\",\"sharepoint\"); //exclude list for the target domain\nCloudAppEvents\n| where Timestamp > ago(lookback)\n| where ApplicationId == 11161\n| where  ActionType =~ \"FileUploadedToCloud\"\n| project Timestamp, AccountObjectId, AccountDisplayName, extension = RawEventData.FileExtension, origin = RawEventData.OriginatingDomain, target = RawEventData.TargetDomain, file = RawEventData.ObjectId\n| extend file = tostring(parse_path(tostring(file)).Filename)\n| where extension =~ \"zip\" //filterting for zipped repos\n| where origin has_any (sourceDomainList)\n| where not(target has_any(excludeTargetDomainList))\n| summarize uploadedFiles = dcount(file), files = make_set(file, 128) by AccountObjectId, AccountDisplayName\n| where uploadedFiles > filesThreshold\n", "attributes": {"description": "Looks for accounts that uploaded multiple code repositories to external web domain.  \n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/Data%20copied%20to%20other%20location%20than%20C%20drive.yaml", "query_name": "Data copied to other location than C drive", "query": "DeviceFileEvents\n| where ActionType == \"FileCreated\"\n| extend extension= extract(@\".*(\\..*)$\",1,FileName)\n| where extension !in (\".ps1\",\".bat\",\".cmd\")\n| extend DriveLetterOrShare=split(FolderPath,':')[0]\n| where DriveLetterOrShare != 'C'\n| project tostring(DriveLetterOrShare), FolderPath, FileName, DeviceId, DeviceName, ReportId, Timestamp, ShareName, IsAzureInfoProtectionApplied, SensitivityLabel, SensitivitySubLabel, InitiatingProcessFileName, InitiatingProcessAccountUpn, InitiatingProcessCommandLine\n", "attributes": {"description": "Check all created files.\nThat does not have extension ps1, bat or cmd to avoid IT Pro scripts.\nThat are not copied to C:\\ to detect all file share, external drive, data partition that are not allowed, etc.\nThis could help to detect malicious insider/user that has unencrypted data partition and that are using it to exfiltrate data even while removable devices & cloud storage is blocked.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/detect-archive-exfiltration-to-competitor.yaml", "query_name": "detect-archive-exfiltration-to-competitor", "query": "EmailEvents\n| where RecipientEmailAddress contains \"competitor\"\nand AttachmentCount >=1\n| join (\nEmailAttachmentInfo\n//| where isnotempty(SHA256)\n)on NetworkMessageId\n| join (\nDeviceFileEvents\n| where InitiatingProcessFileName in (\"7z.exe\", \"7zG.exe\", \"AxCrypt.exe\", \"BitLocker.exe\", \"Diskcryptor.exe\", \"GNUPrivacyGuard.exe\", \"GPG4Win.exe\", \"PeaZip.exe\", \"VeraCrypt.exe\", \"WinRAR.exe\", \"WinZip.exe\")\n| project FileName, SHA256\n) on FileName\n", "attributes": {"description": "This query can be used to detect instances of a malicious insider creating a file archive and then emailing that archive to an external \"competitor\" organization.\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/detect-exfiltration-after-termination.yaml", "query_name": "detect-exfiltration-after-termination", "query": "// Look for any activity for terminated employee creating a DeviceNetworkEvents after they announced termination or resignation\nlet TermAccount = 'departing.employee'; //Enter the departing employee's username\nlet ReleaseTime = datetime(\"01/16/2022 00:00:00\"); //Enter the date the resignation or termination was announced\nDeviceNetworkEvents\n| where InitiatingProcessAccountName =~ TermAccount\n| where Timestamp  > ReleaseTime\n//| project Timestamp , DeviceName, InitiatingProcessAccountName\n| sort by Timestamp  desc\n| join \nDeviceFileEvents on InitiatingProcessAccountName\n| where FileName endswith \".docx\" or FileName endswith \".pptx\" or FileName endswith \".xlsx\" or FileName endswith \".pdf\"\n| join DeviceNetworkInfo on DeviceId\n| where ConnectedNetworks !contains '\"Category\":\"Domain\"'  //Looking for remote, non-domain networks\n| summarize TotalFiles=count() by bin(5Minutebin=Timestamp, 5m), InitiatingProcessAccountName\n|where TotalFiles >1000 // adjust accordingly\n| project TotalFiles,5Minutebin,InitiatingProcessAccountName\n", "attributes": {"description": "This query can be used to explore any instances where a terminated individual (i.e. one who has an impending termination date but has not left the company) downloads a large number of files from a non-Domain network address.\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/detect-steganography-exfiltration.yaml", "query_name": "detect-steganography-exfiltration", "query": "let stegProcesses= view() {\nlet stegnames = pack_array (\"camouflage\",\"crypture\", \"hidensend\", \"openpuff\",\"picsel\",\"slienteye\",\"steg\",\"xiao\");\nlet ProcessQuery = view()\n{\nDeviceProcessEvents\n| where Timestamp > ago(30d)\n| where ProcessCommandLine has_any (stegnames)\n};\nlet FileQuery = view(){\nDeviceFileEvents\n| where FileName has_any (stegnames)\n};\nunion ProcessQuery, FileQuery\n| project StegProcessTimestamp=Timestamp, DeviceName, InitiatingProcessAccountName, FileName, InitiatingProcessFileName, InitiatingProcessParentFileName, InitiatingProcessCommandLine};\nlet WebMailUsage=view(){\n// This query finds network communication to specific webmail URL\nlet webmailURLs = pack_array (\"mail.google.com\", \"mail.yahoo.com\", \"mail.protonmail.com\"); // Change or append additional webmail URLs\nDeviceNetworkEvents \n| where Timestamp > ago(30d)\nand RemoteUrl contains webmailURLs};\nWebMailUsage\n| join stegProcesses on DeviceName\n| where (Timestamp - StegProcessTimestamp) between (0min..30min)\n|project StegProcessTimestamp,Timestamp,RemoteUrl,DeviceName,InitiatingProcessAccountName,FileName\n", "attributes": {"description": "This query can be used to detect instances of malicious users who attempt to create steganographic images and then immediately browse to a webmail URL.  This query would require additional investigation to determine whether the co-occurrance of generating a steganographic image and browsing to a webmail URL is an indication of a malicious event.\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/exchange-powershell-snapin-loaded.yaml", "query_name": "exchange-powershell-snapin-loaded", "query": "DeviceProcessEvents | where FileName has_any (\"cmd.exe\", \"powershell.exe\", \"PowerShell_ISE.exe\") \n| where ProcessCommandLine contains \"Add-PSSnapin Microsoft.Exchange.Powershell.Snapin\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, \"Exchange Server zero-days exploited in the wild\".\nIn early March 2021, Microsoft released patches for four different zero-day vulnerabilities affecting Microsoft Exchange Server. The vulnerabilities were being used in a coordinated attack. For more information on the vulnerabilities, visit the following links:\n1. CVE-2021-26855\n2. CVE-2021-26857\n3. CVE-2021-26858\n4. CVE-2021-27065\nThe following query finds evidence of an Exchange PowerShell snap-in being loaded. This can indicate an attempt to exfiltrate data.\nMore queries related to this threat can be found under the See also section of this page.\nReference - https://msrc-blog.microsoft.com/2021/03/02/multiple-security-updates-released-for-exchange-server/\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/Files%20copied%20to%20USB%20drives.yaml", "query_name": "Files copied to USB drives", "query": "let UsbDriveMount = DeviceEvents\n| where ActionType==\"UsbDriveMounted\"\n| extend ParsedFields=parse_json(AdditionalFields)\n| project DeviceId, DeviceName, DriveLetter=ParsedFields.DriveLetter, MountTime=Timestamp,\nProductName=ParsedFields.ProductName,SerialNumber=ParsedFields.SerialNumber,Manufacturer=ParsedFields.Manufacturer\n| order by DeviceId asc, MountTime desc;\nlet FileCreation = DeviceFileEvents\n| where InitiatingProcessAccountName != \"system\"\n| where ActionType == \"FileCreated\"\n| where FolderPath !startswith \"C:\\\\\"\n| where FolderPath !startswith \"\\\\\"\n| project ReportId,DeviceId,InitiatingProcessAccountDomain,\nInitiatingProcessAccountName,InitiatingProcessAccountUpn,\nFileName, FolderPath, SHA256, Timestamp, SensitivityLabel, IsAzureInfoProtectionApplied\n| order by DeviceId asc, Timestamp desc;\nFileCreation | lookup kind=inner (UsbDriveMount) on DeviceId\n| where FolderPath startswith DriveLetter\n| where Timestamp >= MountTime\n| partition by ReportId ( top 1 by MountTime )\n| order by DeviceId asc, Timestamp desc\n", "attributes": {"description": "This query lists files copied to USB external drives with USB drive information based on FileCreated events associated with most recent USBDriveMount events befor file creations. But be aware that Advanced Hunting is not monitoring all the file types.\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/MailItemsAccessed%20Throttling%20%5BNobelium%5D.yaml", "query_name": "MailItemsAccessed Throttling [Nobelium]", "query": "let starttime = 1d;\nCloudAppEvents\n| where Timestamp between (startofday(ago(starttime))..now())\n| where ActionType == \"MailItemsAccessed\"\n| extend isThrottled=RawEventData['OperationProperties'][1]\n| where isnotempty(RawEventData['ClientAppId'] ) and isThrottled has \"True\" and RawEventData['AppId'] has \"00000003-0000-0000-c000-000000000000\"//GrapAPI Id\n| project Timestamp, RawEventData['OrganizationId'],AccountObjectId,UserAgent\n", "attributes": {"description": "The MailItemsAccessed action is part of the new Advanced Audit functionality of Microsoft 365 Defender. It's part of Exchange mailbox auditing and is enabled by default for users that have an Office 365 or Microsoft 365 E5 license, or for organizations with a Microsoft 365 E5 Compliance add-on subscription.\nIf more than 1,000 MailItemsAccessed audit records are generated in less than 24 hours, Exchange Online will stop generating auditing records for MailItemsAccessed activity. When a mailbox is throttled, MailItemsAccessed activity will not be logged for 24 hours after the mailbox was throttled. If this occurs, there's a potential that mailbox could have been compromised during this period. The recording of MailItemsAccessed activity will be resumed following a 24-hour period.\nThe query is looking for MailItemsAccessed Throttling events where the operation is done by a ClientApplication.\nSee The MailItemsAccessed mailbox auditing action.\nReference - https://docs.microsoft.com/microsoft-365/compliance/mailitemsaccessed-forensics-investigations?view=o365-worldwide#the-mailitemsaccessed-mailbox-auditing-action\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/Map%20external%20devices%20%281%29.yaml", "query_name": "Map external devices (1)", "query": "// Query #2: map uncommon storage devices across the org\n// This is a noisy query - but it can serve as reference for working with this event\nDeviceEvents\n| where ActionType == \"PnpDeviceConnected\"\n| extend parsed=parse_json(AdditionalFields)\n| extend\n    DeviceDescription=tostring(parsed.DeviceDescription),\n    ClassName=tostring(parsed.ClassName)\n| where\n    ClassName in (\"DiskDrive\", \"CDROM\")\n    or ClassName contains \"nas\"\n    or ClassName contains \"SCSI\"\n    or (ClassName == \"USB\" and DeviceDescription contains \"storage\")\n| summarize ComputerCount=dcount(DeviceName) by ClassName, DeviceDescription\n| where ComputerCount < 5\n", "attributes": {"description": "Action \"PnpDeviceConnected\" reports the connection of any plug and play device.\nRead more online on event 6416: https://docs.microsoft.com/windows/security/threat-protection/auditing/event-6416.\nQuery #1: look for rare one-time devices connected to a specific machine.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/Map%20external%20devices.yaml", "query_name": "Map external devices", "query": "let DeviceNameParam = \"<replace this with full computer name>\";\n// Query for device connection events\nlet devices =\n    DeviceEvents\n    | where ActionType == \"PnpDeviceConnected\"\n    | extend parsed=parse_json(AdditionalFields)\n    | project \n        DeviceDescription=tostring(parsed.DeviceDescription),\n        ClassName=tostring(parsed.ClassName),\n        DeviceId=tostring(parsed.VendorIds),\n        VendorIds=tostring(parsed.VendorIds),\n        DeviceName, Timestamp ;\n// Filter devices seen on the suspected machine\ndevices | where DeviceName == DeviceNameParam\n// Get some stats on the device connections to that machine\n| summarize TimesConnected=count(), FirstTime=min(Timestamp), LastTime=max(Timestamp) by DeviceId, DeviceDescription, ClassName, VendorIds, DeviceName\n// Optional filter - looking for devices used in only within 24h\n| where LastTime - FirstTime < 1d\n// Filter out (antijoin) devices that are common in the organization.\n// We use here multiple identifiers, including a pseudo-unique device ID.\n// So, a specific disk-on-key device which model is common in the org will still be shown in the results,\n// while built-in software devices (often have constant device ID) as well as common network devices (e.g. printer queues) will be excluded.\n| join kind=leftanti \n  (devices | summarize Machines=dcount(DeviceName) by DeviceId, DeviceDescription, VendorIds | where Machines > 5)\n  on DeviceId, DeviceDescription, VendorIds\n", "attributes": {"description": "Action \"PnpDeviceConnected\" reports the connection of any plug and play device.\nRead more online on event 6416: https://docs.microsoft.com/windows/security/threat-protection/auditing/event-6416.\nQuery #1: look for rare one-time devices connected to a specific machine.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/OAuth%20Apps%20accessing%20user%20mail%20via%20GraphAPI%20%5BNobelium%5D.yaml", "query_name": "OAuth Apps accessing user mail via GraphAPI [Nobelium]", "query": "CloudAppEvents \n| where Timestamp >= ago(1h) \n| where ActionType == \"MailItemsAccessed\" \n| where RawEventData has \"00000003-0000-0000-c000-000000000000\" // performance \n| where RawEventData has \"ClientAppId\" \n| extend rawData = parse_json(RawEventData) \n| extend AppId = tostring(parse_json(rawData.AppId)) \n| where AppId == \"00000003-0000-0000-c000-000000000000\"         // graph API \n| extend OAuthAppId = tostring(parse_json(rawData.ClientAppId)) // extract OAuthAppId \n| summarize by OAuthAppId \n", "attributes": {"description": "This query helps you review all OAuth applications accessing user mail via Graph. It could return a significant number of results depending on how many applications are deployed in the environment.\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/OAuth%20Apps%20reading%20mail%20both%20via%20GraphAPI%20and%20directly%20%5BNobelium%5D.yaml", "query_name": "OAuth Apps reading mail both via GraphAPI and directly [Nobelium]", "query": "// Look for OAuth apps reading mail both via GraphAPI, and directly (not via GraphAPI) \n// (one method may be legitimate and one suspect?) \nlet appsReadingMailDirectly = CloudAppEvents \n| where Timestamp >= ago(1h) \n| where ActionType == \"MailItemsAccessed\" \n| where RawEventData has \"AppId\" \n| extend rawData = parse_json(RawEventData) \n| extend AppId = tostring(parse_json(rawData.AppId)) \n| where AppId != \"00000003-0000-0000-c000-000000000000\" \n| summarize by AppId \n| project-rename OAuthAppId = AppId; \nlet appsReadingMailViaGraphAPI = CloudAppEvents \n| where Timestamp >= ago(1h) \n| where ActionType == \"MailItemsAccessed\" \n| where RawEventData has \"ClientAppId\" \n| where RawEventData has \"00000003-0000-0000-c000-000000000000\" // performance check \n| extend rawData = parse_json(RawEventData) \n| extend AppId = tostring(parse_json(rawData.AppId)) \n| extend OAuthAppId = tostring(parse_json(rawData.ClientAppId)) // extract OAuthAppId \n| where AppId == \"00000003-0000-0000-c000-000000000000\" \n| summarize by OAuthAppId; \n// Applications reading mail both directly and via GraphAPI  \n// (one method may be legitimate and one suspect?) \nappsReadingMailDirectly \n| join kind = inner appsReadingMailViaGraphAPI \non OAuthAppId \n| project OAuthAppId \n", "attributes": {"description": "As described in previous guidance, Nobelium may re-purpose legitimate existing OAuth Applications in the environment to their own ends. However, malicious activity patterns may be discernable from  legitimate ones.\nThe following query returns OAuth Applications that access mail both directly and via Graph, allowing review of whether such dual access methods follow expected use patterns.\nReference - https://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/OAuth%20Apps%20reading%20mail%20via%20GraphAPI%20anomaly%20%5BNobelium%5D.yaml", "query_name": "OAuth Apps reading mail via GraphAPI anomaly [Nobelium]", "query": "//Look for OAuth App reading mail via GraphAPI -- that did not read mail via graph API in prior week \nlet appMailReadActivity = (timeframeStart:datetime, timeframeEnd:datetime) { \nCloudAppEvents \n| where Timestamp between (timeframeStart .. timeframeEnd) \n| where ActionType == \"MailItemsAccessed\" \n| where RawEventData has \"00000003-0000-0000-c000-000000000000\" // performance check \n| extend rawData = parse_json(RawEventData) \n| extend AppId = tostring(parse_json(rawData.AppId)) \n| extend OAuthAppId = tostring(parse_json(rawData.ClientAppId)) // extract OAuthAppId \n| summarize by OAuthAppId \n}; \nappMailReadActivity(ago(1d),now())                           // detection period \n| join kind = leftanti appMailReadActivity(ago(7d),ago(2d))  // baseline period \non OAuthAppId \n", "attributes": {"description": "Use this query to review OAuth applications whose behaviour has changed as compared to a prior baseline period. The following query returns OAuth Applications accessing user mail via Graph that did not do so in the preceding week.\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/Password%20Protected%20Archive%20Creation.yaml", "query_name": "Password Protected Archive Creation", "query": "DeviceProcessEvents\n| where ProcessCommandLine matches regex @\"\\s[aukfAUKF]\\s.*\\s-p\"  // Basic filter to look for launch string\n| extend SplitLaunchString = split(ProcessCommandLine, ' ') // Split on the space\n| where array_length(SplitLaunchString) >= 5 and SplitLaunchString[1] in~ ('a','u','k','f') // look for calls to archive or update an archive specifically as the first argument\n| mv-expand SplitLaunchString // cross apply the array\n| where SplitLaunchString startswith \"-p\"  // -p is the password switch and is immediately followed by a password without a space\n| extend ArchivePassword = substring(SplitLaunchString, 2, strlen(SplitLaunchString))\n| project-reorder ProcessCommandLine, ArchivePassword // Promote these fields to the left\n", "attributes": {"description": "One common technique leveraged by attackers is using archiving applications to package up files for exfiltration. In many cases, these archives are usually protected with a password to make analysis more difficult.  This query identifies applications which leverage a command line pattern which matches the 7zip and WinRAR command line executables to create or update an archive when a password is specified.  By detecting based on the command line we can avert attempts to dodge detection by renaming the application.\nHappy hunting!\n", "techniques": NaN, "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exfiltration/Possible%20File%20Copy%20to%20USB%20Drive.yaml", "query_name": "Possible File Copy to USB Drive", "query": "let DeviceNameToSearch = ''; // DeviceName to search for. Leave blank to search all devices.\nlet TimespanInSeconds = 900; // Period of time between device insertion and file copy\nlet Connections =\nDeviceEvents\n| where (isempty(DeviceNameToSearch) or DeviceName =~ DeviceNameToSearch) and ActionType == \"PnpDeviceConnected\"\n| extend parsed = parse_json(AdditionalFields)\n| project DeviceId,ConnectionTime = Timestamp, DriveClass = tostring(parsed.ClassName), UsbDeviceId = tostring(parsed.DeviceId), ClassId = tostring(parsed.DeviceId), DeviceDescription = tostring(parsed.DeviceDescription), VendorIds = tostring(parsed.VendorIds)\n| where DriveClass == 'USB' and DeviceDescription == 'USB Mass Storage Device';\nDeviceFileEvents\n| where (isempty(DeviceNameToSearch) or DeviceName =~ DeviceNameToSearch) and FolderPath !startswith \"c\" and FolderPath !startswith @\"\\\"\n| join kind=inner Connections on DeviceId\n| where datetime_diff('second',Timestamp,ConnectionTime) <= TimespanInSeconds\n", "attributes": {"description": "This query searches for file copies which occur within a period of time (by default 15 min) to volumes other than the C drive or UNC shares. By default, this query will\nsearch all devices. A single device can be specified by entering the DeviceName in the DeviceNameToSearch variable. Additionally, to change the period of time from when\nthe USB device was inserted, adjust the TimespanInSeconds value.\nHappy hunting!\n", "techniques": NaN, "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/AcroRd-Exploits.yaml", "query_name": "AcroRd-Exploits", "query": " \n// Search for persistence in Statup folder that's done by Adobe Acrobat Reader.\n// Normally, this behavior is not expected.\nDeviceFileEvents \n| where\n    InitiatingProcessFileName =~ \"acrord32.exe\"\n    and FolderPath contains \"\\\\Start Menu\\\\Programs\\\\Startup\"  \n| project FolderPath, DeviceName, Timestamp, FileName, InitiatingProcessCommandLine, SHA1", "attributes": {"description": "The following query look for suspicious behaviors observed by the samples analyzed in the report.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/CVE-2021-36934%20usage%20detection.yaml", "query_name": "CVE-2021-36934 usage detection", "query": "let startTime = now(-7d);\nlet endTime = now();\nDeviceProcessEvents\n| where Timestamp between (startTime..endTime)\n| where ProcessCommandLine contains \"HKLM\"\n| where AccountName != \"system\"\n", "attributes": {"description": "Assuming that you have a machine that is properly BitLocker'ed, then\nthe machine will need to be running to extract the SAM and SYSTEM\nfiles.\nThis first query looks for any access to the HKLM that happens via a command\nor script that is not executed by system.\nThe second query looks for usage of reg or regedit by anyone who is not system.\n", "techniques": NaN, "tactics": ["Privilege escalation", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/CVE-2022-22965%20Network%20Activity.yaml", "query_name": "CVE-2022-22965 Network Activity", "query": "DeviceNetworkEvents\n| where Timestamp > ago(7d)\n| where ActionType =~ \"NetworkSignatureInspected\"\n| where AdditionalFields contains \".jsp?cmd=\"\n| summarize makeset(AdditionalFields, 5), min(Timestamp), max(Timestamp) by DeviceId, DeviceName\n", "attributes": {"description": "The following query surface network activity associated with exploitation of CVE-2022-22965.\n", "techniques": NaN, "tactics": ["Privilege escalation", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/CVE-2022-26134-Confluence.yaml", "query_name": "Suspicious Tomcat Confluence Process Launch", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName hasprefix \"tomcat\" and InitiatingProcessCommandLine has \"confluence\"\n| where (ProcessCommandLine has_any(\"certutil\", \"whoami\", \"nltest\", \" dir \", \"curl\", \"ifconfig\", \"cat \", \"net user\",\n\"net time /domain\",\"tasklist\",\"-c ls\",\"ipconfig\",\"arp\",\"ping\",\"net view\",\"net group\",\"netstat\", \"wmic datafile\"))\nor (FileName =~ \"powershell.exe\" and ProcessCommandLine hasprefix \"-e\") \n", "attributes": {"description": "The query checks for suspicious Tomcat process launches associated with likely exploitation of Confluence - CVE-2022-26134\nRead more here:.\nhttps://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html\nhttps://nvd.nist.gov/vuln/detail/CVE-2022-26134\nTags: #exploit #CVE-2022-26134\n", "techniques": ["T1203"], "tactics": ["Execution", "Privilege Escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/Electron-CVE-2018-1000006.yaml", "query_name": "Electron-CVE-2018-1000006", "query": "DeviceProcessEvents \n| where Timestamp > ago(14d) \n| where FileName in~ (\"code.exe\", \"skype.exe\", \"slack.exe\", \"teams.exe\") \n| where InitiatingProcessFileName in~ (\"iexplore.exe\", \"runtimebroker.exe\", \"chrome.exe\") \n| where ProcessCommandLine has \"--gpu-launcher\"  \n| summarize FirstEvent=min(Timestamp), LastEvent=max(Timestamp) by DeviceName, ProcessCommandLine, FileName, InitiatingProcessFileName\n", "attributes": {"description": "The query checks process command lines arguments and parent/child combinations to find machines where there have been.\nAttempts to exploit the Protocol Handler Vulnerability of Electron framework CVE-2018-1000006.\nElectron is a common framework used by many popular applications (e.g. Skype, Teams, Slack, VSCode) which expose protocol handlers.\nWhich can trigger a remote code execution vulnerability via a browser vector (e.g. Chrome, Internet Explorer, Edge).\nCVE: CVE-2018-1000006.\nRead more here:.\nHttps://electronjs.org/blog/protocol-handler-fix.\nHttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1000006.\nHttps://www.exploit-db.com/exploits/43899.\nHttps://hackernoon.com/exploiting-electron-rce-in-exodus-wallet-d9e6db13c374.\nTags: #exploit #CVE-2018-1000006 #Electron.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/Flash-CVE-2018-4848.yaml", "query_name": "Flash-CVE-2018-4848", "query": "DeviceNetworkEvents \n| where Timestamp > ago(14d) \n| where InitiatingProcessFileName =~ \"cmd.exe\" and InitiatingProcessParentFileName =~ \"excel.exe\" \n| where RemoteUrl endswith \".kr\" \n| project Timestamp, DeviceName, RemoteIP, RemoteUrl  \n| top 100 by Timestamp\n", "attributes": {"description": "This query checks for specific processes and domain TLD used in the CVE-2018-4878 flash 0day exploit attack reported by KrCERT.\nCVE: CVE-2018-4878.\nRead more here:.\nHttps://www.krcert.or.kr/data/secNoticeView.do?bulletin_writing_sequence=26998.\nHttps://helpx.adobe.com/security/products/flash-player/apsa18-01.html.\nHttp://blog.talosintelligence.com/2018/02/group-123-goes-wild.html.\nHttp://blog.morphisec.com/flash-exploit-cve-2018-4878-spotted-in-the-wild-massive-malspam-campaign.\nTags: #exploit #CVE-2018-4878 #0day #Korea #Flash.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/Linux-DynoRoot-CVE-2018-1111.yaml", "query_name": "Linux-DynoRoot-CVE-2018-1111", "query": "DeviceProcessEvents\n| where InitiatingProcessCommandLine contains \"/etc/NetworkManager/dispatcher.d/\"\n    and InitiatingProcessCommandLine contains \"-dhclient\"\n    and isnotempty(ProcessCommandLine)\n    and FileName !endswith \".exe\"\n| project Timestamp, DeviceName , FileName, ProcessCommandLine, InitiatingProcessCommandLine \n", "attributes": {"description": "The query checks process command lines arguments and parent/child combinations to find machines where there have been.\nAttempts to exploit a DHCP remote code command injection CVE-2018-1111.\nDynoRoot is a remote command injection present in a script included by the DHCP client in Red Hat Enterprise Linux 6 and 7.\nUsing it, a malicious attacker could use this flaw to execute arbitrary commands with root privileges.\nCVE: CVE-2018-1111.\nRead more here:.\nHttps://access.redhat.com/security/cve/cve-2018-1111.\nHttps://www.cvedetails.com/cve/CVE-2018-1111.\nTags: #exploit #CVE-2018-1111 #DynoRoot.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/MosaicLoader.yaml", "query_name": "MosaicLoader", "query": "DeviceRegistryEvents \n| where ((ActionType == \"RegistryValueSet\") and (RegistryKey startswith @\"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows Defender\\\\Exclusions\\\\Paths\" \nor RegistryKey startswith @\"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\Extensions\"\nor RegistryKey startswith @\"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\Processes\"))\n", "attributes": {"description": "This hunting query looks Malware Hides Itself Among Windows Defender Exclusions to Evade Detection\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/print-pooler-service-suspicious-file-creation.yaml", "query_name": "Windows Spooler Service Suspicious File Creation", "query": "DeviceFileEvents\n| where Timestamp > ago(7d)\n| where ActionType == \"FileCreated\"\n| where FileName endswith \".dll\"\n| where FolderPath startswith \"C:\\\\WINDOWS\\\\SYSTEM32\\\\SPOOL\\\\drivers\\\\x64\\\\\\3\\\\\"\n   or FolderPath startswith \"C:\\\\WINDOWS\\\\SYSTEM32\\\\SPOOL\\\\drivers\\\\x64\\\\\\4\\\\\"\n", "attributes": {"description": "The query digs in Windows print spooler drivers folder for any file creations,\nMANY OF THE FILES THAT SHOULD COME UP HERE MAY BE LEGIT. Suspicious DLL is load from Spooler Service backup folder. \nThis behavior is used from PoC Exploit of CVE-2021-34527, CVE-2021-1675 or CVE-2022-21999.\n", "techniques": ["t1574"], "tactics": ["Privilege escalation", "Lateral movement", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/printnightmare-cve-2021-1675%20usage%20detection%20%281%29.yaml", "query_name": "printnightmare-cve-2021-1675 usage detection (1)", "query": "DeviceNetworkEvents\n| where Timestamp > ago(7d)\n| where LocalPort == 445\n| summarize RemoteIPCount=dcount(RemoteIP) by DeviceName, InitiatingProcessFileName, InitiatingProcessId, InitiatingProcessCreationTime\n", "attributes": {"description": "First query digs in print spooler drivers folder for any file creations,\nMANY OF THE FILES THAT SHOULD COME UP HERE MAY BE LEGIT. Unsigned files\nor ones that don't have any relations to printers that you are using are\nsuspicious.\nSecond query that can be used for finding client machines that\ncould be operating print servers or file servers is also included here.\nAs additional mitigation for the exploit you might want to block the\nincoming traffic to the SMB or EPMAP Ports (445) if you need to keep the\nspooler service running to print from clients.\n", "techniques": NaN, "tactics": ["Privilege escalation", "Lateral movement", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/printnightmare-cve-2021-1675%20usage%20detection.yaml", "query_name": "printnightmare-cve-2021-1675 usage detection", "query": "DeviceFileEvents\n| where Timestamp > ago(7d)\n| where ActionType == \"FileCreated\"\n| where FolderPath startswith \"C:\\\\WINDOWS\\\\SYSTEM32\\\\SPOOL\\\\drivers\"\n", "attributes": {"description": "First query digs in print spooler drivers folder for any file creations,\nMANY OF THE FILES THAT SHOULD COME UP HERE MAY BE LEGIT. Unsigned files\nor ones that don't have any relations to printers that you are using are\nsuspicious.\nSecond query that can be used for finding client machines that\ncould be operating print servers or file servers is also included here.\nAs additional mitigation for the exploit you might want to block the\nincoming traffic to the SMB or EPMAP Ports (445) if you need to keep the\nspooler service running to print from clients.\n", "techniques": NaN, "tactics": ["Privilege escalation", "Lateral movement", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/SolarWinds%20-CVE-2021-35211.yaml", "query_name": "SolarWinds -CVE-2021-35211", "query": "let IPs = pack_array(\"98.176.196.89\", \"68.235.178.32\", \n\"208.113.35.58\",\"144.34.179.162\",\"97.77.97.58\"); \nDeviceNetworkEvents\n| where RemotePort == 443\n| where Protocol == \"Tcp\" and ActionType == \"ConnectionSuccess\"\n| where Timestamp > ago(7d) \n| where RemoteIP in(IPs)\n", "attributes": {"description": "//Check for network connections with SolarWInds IP's based on DeviceNetworkEvents## Query\n", "techniques": NaN, "tactics": ["Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/VMWare-LPE-2022-22960.yaml", "query_name": "VMWare-LPE-2022-22960", "query": "DeviceProcessEvents\n| where InitiatingProcessCommandLine has (\"/opt/vmware/certproxy/bing/certproxyService.sh\", \"/horizon/scripts/exportCustomGroupUsers.sh\", \"/horizon/scripts/extractUserIdFromDatabase.sh\")\n    or FileName has (\"certproxyService.sh\", \"exportCustomGroupUsers.sh\", \"extractUserIdFromDatabase.sh \")\n| project Timestamp, DeviceName , FileName, ProcessCommandLine, InitiatingProcessCommandLine \n", "attributes": {"description": "The query checks process command being placed into the script; CVE-2022-22960 allows a user to write to it and be executed as root.\nThis vulnerability of VMware Workspace ONE Access, Identity Manager and vRealize Automation contain a privilege escalation vulnerability due to improper permissions in support scripts.\nCVE: CVE-2022-22960.\nRead more here:.\nhttps://www.cisa.gov/uscert/ncas/alerts/aa22-138b\nhttps://www.vmware.com/security/advisories/VMSA-2022-0011.html\nTags: #exploit #CVE-2022-22960\n", "techniques": ["T1204", "T1548"], "tactics": ["Execution", "Privilege Escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/winrar-cve-2018-20250-ace-files.yaml", "query_name": "winrar-cve-2018-20250-ace-files", "query": "//Query for .ace files\nDeviceFileEvents\n| where Timestamp > ago(7d)\n//Look for ACE files\n| where FileName endswith \".ace\"\n//Exclude clean ACE files used by Trend Micro\n| where FolderPath !contains @'\\Trend Micro'\n", "attributes": {"description": "This query was originally published in the threat analytics report, WinRAR CVE-2018-20250 exploit\nWinRAR is a third-party file compressing application. Versions 5.61 and earlier contained a flaw that could be exploited by an attacker to read and write to an arbitrary path on the target's system. This could be used to run arbitrary code, overwrite system files, or access sensitive information. This vulnerability was designated CVE-2018-20250, and it is associated an outdated version of the legacy ACE compression library, 'unacev2.dll'.\nThe following query detects possible CVE-2020-20250 exploitation by looking for files with the .ace extension.\nReference - https://nvd.nist.gov/vuln/detail/CVE-2018-20250\n", "techniques": NaN, "tactics": ["Execution", "Lateral movement", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/winrar-cve-2018-20250-file-creation.yaml", "query_name": "winrar-cve-2018-20250-file-creation", "query": "//Query for WinRAR file creation in the Startup folder\nDeviceFileEvents\n| where Timestamp > ago(7d)\n//Look for WinRAR as the initiating process or a commandline that has \".rar\" \n| where (InitiatingProcessFileName =~ \"winrar.exe\" \nor InitiatingProcessCommandLine contains \".rar\") \n//Check for the file in the Startup folder\nand FolderPath contains \"Programs\\\\Startup\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, WinRAR CVE-2018-20250 exploit\nWinRAR is a third-party file compressing application. Versions 5.61 and earlier contained a flaw that could be exploited by an attacker to read and write to an arbitrary path on the target's system. This could be used to run arbitrary code, overwrite system files, or access sensitive information. This vulnerability was designated CVE-2018-20250, and it is associated an outdated version of the legacy ACE compression library, 'unacev2.dll'.\nThe following query detects possible CVE-2020-20250 exploitation by looking for files created in the Startup folder.\nReference - https://nvd.nist.gov/vuln/detail/CVE-2018-20250\n", "techniques": NaN, "tactics": ["Execution", "Lateral movement", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/Print%20Spooler%20RCE/Spoolsv%20Spawning%20Rundll32.yaml", "query_name": "Spoolsv Spawning Rundll32", "query": "DeviceProcessEvents\n| where InitiatingProcessParentFileName has \"spoolsv.exe\"\n| where InitiatingProcessFileName =~ \"rundll32.exe\"\n| where isempty(InitiatingProcessCommandLine) or InitiatingProcessCommandLine endswith \"rundll32.exe\" //either commandline is empty or just \"rundll32.exe\"\n| where FileName !in~ (\"WerFault.exe\")\n", "attributes": {"description": "Look for the spoolsv.exe launching rundll32.exe with an empty command line\n", "techniques": NaN, "tactics": ["Privilege escalation", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/Print%20Spooler%20RCE/Suspicious%20DLLs%20in%20spool%20folder.yaml", "query_name": "Suspicious DLLs in spool folder", "query": "DeviceFileEvents\n| where FolderPath contains @\"\\system32\\spool\\drivers\\x64\\3\\\"\n| where FileName endswith \".dll\"\n| where ActionType in (\"FileCreated\", \"FileRenamed\")\n| join kind=inner DeviceImageLoadEvents on DeviceId,DeviceName,FileName,InitiatingProcessFileName\n| where Timestamp1 >= Timestamp and FolderPath1 contains @\"\\system32\\spool\\drivers\\x64\\3\\Old\" \n", "attributes": {"description": "Look for the creation of suspicious DLL files spawned in the \\spool\\ folder along with DLLs that were recently loaded afterwards from \\Old.\n", "techniques": NaN, "tactics": ["Privilege escalation", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/Print%20Spooler%20RCE/Suspicious%20files%20in%20spool%20folder.yaml", "query_name": "Suspicious files in spool folder", "query": "DeviceFileEvents\n| where FolderPath has @\"System32\\spool\\drivers\"\n| project DeviceName,Timestamp,ActionType,FolderPath,FileName,SHA1\n", "attributes": {"description": "Monitor for creation of suspicious files in the /spools/driver/ folder. This is a broad-based search that will surface any creation or modification of files in the folder targeted by this exploit. False Positives for legitimate driver activity (when that activity should be present) in this folder are possible\n", "techniques": NaN, "tactics": ["Privilege escalation", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Exploits/Print%20Spooler%20RCE/Suspicious%20Spoolsv%20Child%20Process.yaml", "query_name": "Suspicious Spoolsv Child Process", "query": "// Look for file load events for spoolsv\nDeviceImageLoadEvents\n| where Timestamp > ago(7d)\n| where InitiatingProcessFileName =~ \"spoolsv.exe\"\n| where FolderPath has @\"spool\\drivers\"\n| extend LoadFileTime = Timestamp\n| distinct DeviceId, LoadFileTime, FileName, SHA256\n// Join process data associated with spoolsv launching suspicious processes after image load\n| join DeviceProcessEvents on $left.DeviceId == $right.DeviceId\n| where Timestamp > ago(7d)\n| where Timestamp < LoadFileTime +5m\n| where InitiatingProcessFileName =~ \"spoolsv.exe\"\n| where ProcessIntegrityLevel =~ 'SYSTEM'\n| where (FileName1 in~(\"gpupdate.exe\", \"whoami.exe\", \"nltest.exe\", \"taskkill.exe\",\n            \"wmic.exe\", \"taskmgr.exe\", \"sc.exe\", \"findstr.exe\", \"curl.exe\", \"wget.exe\", \"certutil.exe\", \"bitsadmin.exe\", \"accesschk.exe\",\n            \"wevtutil.exe\", \"bcdedit.exe\", \"fsutil.exe\", \"cipher.exe\", \"schtasks.exe\", \"write.exe\", \"wuauclt.exe\") or \n// Processes with specific FPs removed          \n(FileName1 =~ \"net.exe\" and ProcessCommandLine !has \"start\") or \n(FileName1 =~ \"cmd.exe\" and not(ProcessCommandLine has_any(\".spl\", \"route add\", \"program files\"))) or \n(FileName1 =~ \"netsh.exe\" and not(ProcessCommandLine has_any(\"add portopening\", \"rule name\")))) or\n(FileName1 =~ \"powershell.exe\" and ProcessCommandLine!has \".spl\") or\n(FileName1 =~ \"rundll32.exe\" and ProcessCommandLine != \"\" and ProcessCommandLine !contains \" \")\n", "attributes": {"description": "Surfaces suspicious spoolsv.exe behavior likely related to CVE-2021-1675\n", "techniques": NaN, "tactics": ["Privilege escalation", "Exploit"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Fun/EmojiHunt.yaml", "query_name": "EmojiHunt", "query": "DeviceProcessEvents\n| distinct DeviceName\n| extend fakeescape=replace(\"%5f\", \"_\", replace(\"%2d\", \"-\", url_encode(DeviceName)))\n| where fakeescape != DeviceName\n", "attributes": {"description": "Did you know you can use Emojis in Windows?.\nRead more here: https://davidzych.com/abusing-emoji-in-windows.\nCheck-out who in your organization has renamed his or her computer to a Pizza or to a smiling poop.\nYou might be amused by the results, or perhaps angry if one of your systems or scripts was broken by this...\nNote: this query will also return some machines with non-English charcters that are not Emojis.\nCredit for this query goes to miflower - thanks for bringing joy to our lives! :).\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Fun/Make%20FolderPath%20Vogon%20Poetry.yaml", "query_name": "Make FolderPath Vogon Poetry", "query": "let MakeFolderPathVogonPoetry = (SourceData:(DeviceName:string, FolderPath:string)) {\n    let Verses = pack_array(\n        'My life was spent with PATH', \n        'Looking upon a barren PATH',\n        'Whilst in the distance I saw a PATH',\n        'Gazing at the PATH',\n        'It was quite the dreary PATH',\n        'As I sat alone in the PATH',\n        'It was such a beautiful PATH',\n        'Though I could choose only one PATH',\n        'While I longed for my PATH',\n        'I would never find PATH again',\n        'I hunt in PATH',\n        'The PATH my guide',\n        'The memory of PATH sings in my blood',\n        'I seize the PATH',\n        'I carry it to my PATH',\n        'And I lay my PATH at your feet'\n    );    \n    let PhraseCount = toscalar(array_length(Verses));\n    let CleanedSourceData = (\n        SourceData\n        | take 10000\n        | where isnotempty( FolderPath) and (FolderPath startswith \"/\" or FolderPath startswith \"c:\\\\\")\n        | project DeviceName, FolderPath\n    );\n    let RandRow = rand(toscalar(CleanedSourceData | count));\n    CleanedSourceData\n    | serialize \n    | where row_number() == RandRow\n    | extend Path = iff(FolderPath startswith \"/\", split(FolderPath, '/'), split(FolderPath, '\\\\'))\n    | where array_length( Path ) > 2\n    | mvexpand Path to typeof(string)\n    | where isnotempty(Path)\n    | extend Rand = toint(rand(PhraseCount))\n    | extend VerseTemplate = tostring(Verses[Rand])\n    | extend Verse = strcat(substring(VerseTemplate,0,indexof(VerseTemplate, 'PATH')), Path, substring(VerseTemplate, (indexof(VerseTemplate, 'PATH') + 4), (strlen(VerseTemplate) -  indexof(VerseTemplate, 'PATH') + 4))) \n    | serialize \n    | project DeviceName, FolderPath, Verse\n};\nDeviceProcessEvents\n| invoke MakeFolderPathVogonPoetry()\n", "attributes": {"description": "This is a completely stupid and pointless query that makes Vogon poetry out\nof a random FolderPath from the table you pass it.  You can change\nDeviceProcessEvents for any table as long as it has a column named DeviceName\nand a column called FolderPath.  Feel free to check in more verses :)\nDon't know what Vogon poetry is?  You have a research assignment: http://tinyurl.com/y8ueqchl\n", "techniques": NaN, "tactics": ["Creates Poetry"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Alert%20Events%20from%20Internal%20IP%20Address.yaml", "query_name": "Alert Events from Internal IP Address", "query": "let PivotTime = datetime(2021-01-02 20:57:02); //Fill out time\nlet TimeRangeStart = PivotTime-15m; // 15 Minutes Prior to Pivot Time\nlet TimeRangeEnd = PivotTime+15m; // 15 Minutes After Pivot Time\nlet IPAddress = \"172.16.40.8\";  // internal IP address to search\n// Locate DeviceIds associated with IP\nlet FindDeviceIdbyIP = DeviceNetworkInfo\n| where Timestamp between ((TimeRangeStart) ..TimeRangeEnd) \n\tand IPAddresses contains strcat(\"\\\"\", IPAddress, \"\\\"\") \n\tand NetworkAdapterStatus == \"Up\"\n| project DeviceName, DeviceId, Timestamp, IPAddresses;\n// Query Alerts matching DeviceIds\nFindDeviceIdbyIP \n| join kind=rightsemi AlertEvidence on DeviceId\n| join AlertInfo on AlertId\n// Summarizes alerts by AlertId with min and max event times\n| summarize Title=any(Title), min(Timestamp), max(Timestamp), DeviceName=any(DeviceName) by AlertId\n", "attributes": {"description": "Determines DeviceId from internal IP address and outputs all alerts in events table associated to the DeviceId.\nExample use case is Firewall determines Internal IP with suspicious network activity. Query WDATP based on date/time and Internal IP and see associated alerts for the endpoint.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/AppLocker%20Policy%20Design%20Assistant.yaml", "query_name": "AppLocker Policy Design Assistant", "query": "let FolderDepthLimit = 5;\nlet AliasPath = (SourcePath:(FolderPath:string, FileName:string))\n{\nSourcePath\n    | extend AliasPath = tolower(\n            case(\n                //Modern style profile\n                FolderPath startswith 'c:\\\\users\\\\', strcat('%UserProfile%', substring(FolderPath, indexof(FolderPath,'\\\\',11), strlen(FolderPath) - 11)),\n                //Legacy style profile\n                FolderPath startswith 'c:\\\\documents and settings\\\\', strcat('%UserProfile%', substring(FolderPath, indexof(FolderPath,'\\\\',27), strlen(FolderPath) - 27)),\n                //Windir\n                FolderPath contains @':\\Windows\\', strcat('%windir%', substring(FolderPath, 10)),\n                //ProgramData\n                FolderPath contains @':\\programdata\\', strcat('%programdata%', substring(FolderPath, 14)),\n                // ProgramFiles\n                FolderPath contains @':\\Program Files\\', strcat('%ProgramFiles%', substring(FolderPath, 16)),\n                // Program Files (x86)\n                FolderPath contains @':\\Program Files (x86)\\', strcat('%ProgramFilesx86%', substring(FolderPath, 22)),\n                //Other\n                FolderPath)\n        )\n};\nDeviceProcessEvents\n| where isnotempty(FolderPath) and FolderPath !startswith '/' //AppLocker is not supported on Linux \\ Mac and we need a FolderPath\n| invoke AliasPath() // Alias the path for consistency\n| extend Folder = substring(AliasPath, 0, strlen(AliasPath) - strlen(FileName) - 1) // Trim the FileName\n| where Folder !startswith @'%windir%' and Folder !startswith @'%programfiles%' and Folder !startswith @'%programfilesx86%' // Remove folders that are included in AppLocker by default\n| extend SplitFolderPath = split(Folder, '\\\\') // Break the folder down by folders\n| extend PathDepth = range(1,FolderDepthLimit,1) // create a range to break the path into depths\n| mvexpand PathDepth to typeof(int) // mvexpand\n| where PathDepth < array_length(SplitFolderPath) // Determine if the current depth is greater than the number of folders in the path\n| extend SubPath = strcat_array(array_slice(SplitFolderPath, 0, PathDepth), '\\\\') // Reassemble the subpath based on the number of folders\n| summarize ProcessCount = count(), DistinctMachines = dcount(DeviceId), DistinctProcesses = dcount(SHA256), DistinctFileNames = dcount(FileName) by SubPath \n| order by DistinctMachines desc // Order by the number of distinct machines in descending order\n", "attributes": {"description": "One of the challenges in making an AppLocker policy is knowing where applications\nlaunch from.  This query normalizes process launch paths through aliasing, then\ncounts the number of processes launched from that path, how many distinct machines it\nwas launched on, and how many distinct file names \\ hashes these processes had.  The\npath is broken into subfolders to help simplify analysis.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Baseline%20Comparison.yaml", "query_name": "Baseline Comparison", "query": "let GoodHosts=pack_array('supposedlygoodhost.mydomain','ithinkitsgoodserver.mydomain');\n// List of suspected bad hosts - populate with bad machines, must be FQDNs\nlet SuspectedBadHosts=pack_array('compromisedhost.mydomain', 'lateralmovementhost.mydomain');\n// How far back should the baseline be built from?\nlet GoodTimeRange=30d;\n// How far back should the bad machines be looked at?\nlet SuspectedBadTimeRange=30d;\n// Comment return sets that you do not want returned, by default file creation and image loads and registry events are disabled\nlet ReturnSets=pack_array(\n    'Alert',\n    'Connected Networks',\n//    'File Creation'\n//    'Image Loads',\n    'Logon',\n    'Network Communication',\n    'Process Creation',\n    'PowerShell Command',\n//    'Registry Event'\n    'Raw IP Communication'\n);\n// -------------End of variables, changing below this line will change query logic----------\n// Function to get a mapping of machine IDs given a list of computer names\nlet GetDeviceId=(InDeviceName: dynamic) {\n    DeviceInfo\n    | where DeviceName in~ (InDeviceName)\n    | distinct DeviceName, DeviceId\n};\n// Function to consolidate all machine IDs into a single set\nlet ConsolidateDeviceId=(T:(DeviceId: string)) {\n    T\n    | summarize makeset(DeviceId)\n};\n// Function to get network communications given a list of computer names and how far back to look\nlet GetNetworkEvents=(InDeviceId: dynamic, LeftTimestamp: datetime) {\n    DeviceNetworkEvents\n    | where \"Network Communication\" in (ReturnSets)\n    | where Timestamp > LeftTimestamp\n    | where DeviceId in~ (InDeviceId)\n    | where isnotempty(RemoteUrl)\n    | summarize Timestamp=max(Timestamp), count() by RemoteUrl, DeviceId\n    | extend UrlSplit=split(RemoteUrl, \".\") // Split the levels of the URL\n    // If there is only one level (for an internal communication that uses your DNS search suffix), then only use that level\n    // Otherwise combine the top two levels and use those as the URLRoot\n    | extend UrlRoot=iff(UrlSplit[-2] == \"\", UrlSplit[0], strcat(tostring(UrlSplit[-2]), \".\", tostring(UrlSplit[-1])))\n    | summarize Timestamp=max(Timestamp), Count=sum(count_), AdditionalData=makeset(RemoteUrl, 5) by UrlRoot, DeviceId\n    | project Timestamp, Entity=UrlRoot, Count, AdditionalData=tostring(AdditionalData), DeviceId, DataType=\"Network Communication\"\n};\n// Function to get process creates given a list of computer names and how far back to look\nlet GetProcessCreates=(InDeviceId: dynamic, LeftTimestamp: datetime) {\n    DeviceProcessEvents\n    | where \"Process Creation\" in (ReturnSets)\n    | where Timestamp > LeftTimestamp\n    | where DeviceId in~ (InDeviceId)\n    // Replace known path for mpam files as they are dynamically named and likely to be unique on each machine\n    | extend FileName=iff(FolderPath matches regex @\"([A-Z]:\\\\Windows\\\\ServiceProfiles\\\\NetworkService\\\\AppData\\\\Local\\\\Temp\\\\mpam-)[a-z0-9]{7,8}\\.exe\", \"mpam-RANDOM.exe\", FileName)\n    // Replace known path for AM delta patch files as they jump frequently and not likely to be exact on each machine\n    | extend FileName=iff(FolderPath matches regex @\"([A-Z]:\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\AM_Delta_Patch_)[0-9\\.]+\\.exe\", \"AM_Delta_Patch_Version.exe\", FileName)\n    | summarize Timestamp=max(Timestamp), Count=count(), AdditionalData=makeset(FolderPath) by FileName, DeviceId\n    // Replace various mbam executables that are semiunique-generated with some text to help reduce noise\n    | project Timestamp, Entity=FileName, Count, AdditionalData=tostring(AdditionalData), DeviceId, DataType=\"Process Creation\"\n};\n// Function to get powershell commands given a list of computer names and how far back to look\nlet GetPSCommands=(InDeviceId: dynamic, LeftTimestamp: datetime) {\n    DeviceEvents\n    | where \"PowerShell Command\" in (ReturnSets)\n    | where Timestamp > LeftTimestamp\n    | where DeviceId in~ (InDeviceId)\n    | where ActionType == 'PowerShellCommand'\n    // Remove two different signatures for scripts being executed which cause a lot of noise\n    // The first signature matches scripts generated as part of testing execution policy\n    // The second signature matches scripts generated by SCCM\n    | where not(AdditionalFields matches regex @\"Script_[0-9a-f]{20}\" and InitiatingProcessFileName =~ 'monitoringhost.exe')\n    | where not(AdditionalFields matches regex @\"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\.ps1\" and InitiatingProcessFileName =~ 'powershell.exe')\n    | summarize Timestamp=max(Timestamp), count(), IPFN_Set=makeset(InitiatingProcessFileName) by AdditionalFields, DeviceId\n    | project Timestamp, Entity=tostring(extractjson(\"$.Command\", AdditionalFields)), Count=count_, AdditionalData=tostring(IPFN_Set), DeviceId, DataType=\"PowerShell Command\"\n};\n// Function to get file creations given a list of computer names and how far back to look\nlet GetFileCreates=(InDeviceId: dynamic, LeftTimestamp: datetime) {\n    DeviceFileEvents\n    | where \"File Creation\" in (ReturnSets)\n    | where Timestamp > LeftTimestamp\n    | where DeviceId in~ (InDeviceId)\n    // Remove temporary files created by office products\n    | where not(FileName matches regex @\"~.*\\.(doc[xm]?|ppt[xm]?|xls[xm]?|dotm|rtf|xlam|lnk)\")\n    // Replace two different signatures for PS scripts being created which cause a lot of noise\n    | extend iff(FileName matches regex @\"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\.ps1\" or\n                 FileName matches regex @\"[0-9a-z]{8}\\.[0-9a-z]{3}\\.ps1\", \"RANDOM.ps1\", FileName)\n    | summarize Timestamp=max(Timestamp), FP_Set=makeset(FolderPath), count() by FileName, DeviceId\n    | project Timestamp, Entity=FileName, Count=count_, AdditionalData=tostring(FP_Set), DeviceId, DataType=\"File Creation\"\n};\n// Function to get logon events given a list of computer names and how far back to look\nlet GetDeviceLogonEvents=(InDeviceId: dynamic, LeftTimestamp: datetime) {\n    DeviceLogonEvents\n    | where \"Logon\" in (ReturnSets)\n    | where Timestamp > LeftTimestamp\n    | where DeviceId in~ (InDeviceId)\n    // Remove logons made by WDM or UMFD\n    | where AccountDomain !in ('font driver host', 'window manager')\n    | summarize Timestamp=max(Timestamp), Count=count(), LT_Set=makeset(LogonType) by AccountName, AccountDomain, DeviceId\n    | project Timestamp, Entity=iff(AccountDomain == \"\", AccountName, strcat(AccountDomain, @\"\\\", AccountName)), Count, AdditionalData=tostring(LT_Set), DeviceId, DataType=\"Logon\"\n};\n// Function to get registry events given a list of computer names and how far back to look\nlet GetDeviceRegistryEvents=(InDeviceId: dynamic, LeftTimestamp: datetime) {\n    DeviceRegistryEvents\n    | where \"Registry Event\" in (ReturnSets)\n    | where Timestamp > LeftTimestamp\n    | where DeviceId in~ (InDeviceId)\n    | extend RegistryKey=iff(RegistryKey matches regex @\"HKEY_CURRENT_USER\\\\S-[^\\\\]+\\\\\", replace(@\"(HKEY_CURRENT_USER\\\\)S-[^\\\\]+\\\\\", @\"\\1SID\\\\\", RegistryKey), RegistryKey)\n    | summarize Timestamp=max(Timestamp), RVD_Set=makeset(RegistryValueData), Count=count() by DeviceId, RegistryKey\n    | project Timestamp, Entity=RegistryKey, Count, AdditionalData=tostring(RVD_Set), DeviceId, DataType=\"Registry Event\"\n};\n// Function to get connected networks given a list of computer names and how far back to look\nlet GetConnectedNetworks=(InDeviceId: dynamic, LeftTimestamp: datetime) {\n    DeviceNetworkInfo\n    | where \"Connected Networks\" in (ReturnSets)\n    | where Timestamp > LeftTimestamp\n    | where DeviceId in~ (InDeviceId)\n    | summarize Timestamp=max(Timestamp), Count=count() by DeviceId, ConnectedNetworks\n    | project Timestamp, Entity=tostring(extractjson(\"$[0].Name\", ConnectedNetworks)), Count, AdditionalData=ConnectedNetworks, DeviceId, DataType=\"Connected Networks\"\n};\n// Function to get image load events given a list of computer names and how far back to look\nlet GetImageLoads=(InDeviceId: dynamic, LeftTimestamp: datetime) {\n    DeviceImageLoadEvents\n    | where \"Image Loads\" in (ReturnSets)\n    | where Timestamp > LeftTimestamp\n    | where DeviceId in~ (InDeviceId)\n    | summarize Timestamp=max(Timestamp), Set_FN=makeset(InitiatingProcessFileName), Count=count() by DeviceId, FolderPath\n    // Replace various native windows DLL's that are guid-generated with some text to help reduce noise\n    | extend Entity=replace(@\"([wW]indows\\\\assembly\\\\NativeImages.*\\\\)[0-9a-f]{32}\", @\"\\1GUID\", FolderPath)\n    | project Timestamp, Entity, Count, AdditionalData=tostring(Set_FN), DeviceId, DataType=\"Image Loads\"\n};\n// Function to get raw IP address network communications given a list of computer names and how far back to look\nlet GetRawIPCommunications=(InDeviceId: dynamic, LeftTimestamp: datetime) {\n    DeviceNetworkEvents\n    | where 'Raw IP Communication' in (ReturnSets)\n    | where Timestamp > LeftTimestamp\n    | where DeviceId in~ (InDeviceId)\n    // Replace all v4 to v6 addresses with their v4 equivalent\n    | extend RemoteIP=replace(\"^::ffff:\", \"\", RemoteIP)\n    | summarize Timestamp=max(Timestamp), Set_RPort=makeset(RemotePort), Set_LPort=makeset(LocalPort), Set_FN=makeset(InitiatingProcessFileName), Set_URL=makeset(RemoteUrl), Count=count() by DeviceId, RemoteIP\n    // Only include any IP addresses that do not have a resolved URL as resolved URLs are handled in network communications\n    | where tostring(Set_URL) == '[\"\"]'\n    // Do not include machines that are only doing WUDO\n    | where tostring(Set_RPort) != '[7680]' and tostring(Set_RPort) != '[7680]'\n    | project Timestamp, Entity=RemoteIP, Count, AdditionalData=tostring(Set_FN), DeviceId, DataType='Raw IP Communication'\n};\n// Calculate the left event time for \"good\" machines\nlet GoodLeftTimestamp=ago(GoodTimeRange);\n// Calculate the left event time for suspected bad machines\nlet SuspectedBadLeftTimestamp=ago(SuspectedBadTimeRange);\n// Calculate the machine IDs for \"good\" machines\nlet GoodHostNameMapping=GetDeviceId(GoodHosts);\n// Reduce all of the good machine IDs into a single variable\nlet GoodHostDeviceId=toscalar(ConsolidateDeviceId(GoodHostNameMapping));\n// Calculate the machine IDs for suspected bad machines\nlet SuspectedBadHostNameMapping=GetDeviceId(SuspectedBadHosts);\n// Reduce all of the suspected bad machine IDs into a single variable\nlet SuspectedBadHostDeviceId=toscalar(ConsolidateDeviceId(SuspectedBadHostNameMapping));\n// Calculate the delta in network events, keeping the bad ones\nlet NetworkDelta=GetNetworkEvents(SuspectedBadHostDeviceId, SuspectedBadLeftTimestamp)\n| join kind=leftanti (\n    GetNetworkEvents(GoodHostDeviceId, GoodLeftTimestamp)\n) on Entity;\n// Calculate the delta in process create events, keeping the bad ones\nlet ProcessDelta=GetProcessCreates(SuspectedBadHostDeviceId, SuspectedBadLeftTimestamp)\n| join kind=leftanti (\n    GetProcessCreates(GoodHostDeviceId, GoodLeftTimestamp)\n) on Entity;\n// Calculate the delta in powershell events, keeping the bad ones\nlet PSDelta=GetPSCommands(SuspectedBadHostDeviceId, SuspectedBadLeftTimestamp)\n| join kind=leftanti (\n    GetPSCommands(GoodHostDeviceId, GoodLeftTimestamp)\n) on Entity;\n// Calculate the delta in file create events, keeping the bad ones\nlet FileDelta=GetFileCreates(SuspectedBadHostDeviceId, SuspectedBadLeftTimestamp)\n| join kind=leftanti (\n    GetFileCreates(GoodHostDeviceId, GoodLeftTimestamp)\n) on Entity;\n// Calculate the delta in logon events, keeping the bad ones\nlet LogonDelta=GetDeviceLogonEvents(SuspectedBadHostDeviceId, SuspectedBadLeftTimestamp)\n| join kind=leftanti (\n    GetDeviceLogonEvents(GoodHostDeviceId, GoodLeftTimestamp)\n) on Entity;\n// Calculate the delta in registry events, keeping the bad ones\nlet RegistryDelta=GetDeviceRegistryEvents(SuspectedBadHostDeviceId, SuspectedBadLeftTimestamp)\n| join kind=leftanti (\n    GetDeviceRegistryEvents(GoodHostDeviceId, GoodLeftTimestamp)\n) on Entity;\n// Calculate the delta in connected network events, keeping the bad ones\nlet ConnectedNetworkDelta=GetConnectedNetworks(SuspectedBadHostDeviceId, SuspectedBadLeftTimestamp)\n| join kind=leftanti (\n    GetConnectedNetworks(GoodHostDeviceId, GoodLeftTimestamp)\n) on Entity;\n// Calculate the delta in image load events, keeping the bad ones\nlet ImageLoadDelta=GetImageLoads(SuspectedBadHostDeviceId, SuspectedBadLeftTimestamp)\n| join kind=leftanti (\n    GetImageLoads(GoodHostDeviceId, GoodLeftTimestamp)\n) on Entity;\n// Calculate the delta in raw IP address communications, keeping the bad ones\nlet RawIPCommunicationDelta=GetRawIPCommunications(SuspectedBadHostDeviceId, SuspectedBadLeftTimestamp)\n| join kind=leftanti (\n    GetRawIPCommunications(GoodHostDeviceId, GoodLeftTimestamp)\n) on Entity;\n// Get the alerts for the bad machines (no delta, we care about all alerts)\nlet Alerts=AlertInfo | join AlertEvidence on AlertId\n| where \"Alert\" in (ReturnSets)\n| where Timestamp > SuspectedBadLeftTimestamp\n| where DeviceId in (SuspectedBadHostDeviceId)\n| summarize Timestamp=max(Timestamp), Count=count() by Title, DeviceId, FileName, RemoteUrl\n| project Timestamp, Entity=Title, Count, AdditionalData=coalesce(FileName, RemoteUrl), DeviceId, DataType=\"Alert\";\n// String everything together\nlet ResultDataWithoutMachineCount=union NetworkDelta, ProcessDelta, PSDelta, FileDelta, Alerts, LogonDelta, RegistryDelta,\n      ConnectedNetworkDelta, ImageLoadDelta, RawIPCommunicationDelta\n// Join back against the machine info so the Computer Names can be reassociated\n| join kind=leftouter (\n        SuspectedBadHostNameMapping\n) on DeviceId\n// Remove duplicated column\n| project-away DeviceId1;\n// This is the start of the final result set that is shown\n// Calculate the number of machines that each entity/datatype pair have and join that data back into the data to add\n// an additional column for the number of bad machines\nResultDataWithoutMachineCount\n| join kind=leftouter (\n    ResultDataWithoutMachineCount\n    | summarize BadMachinesCount=dcount(DeviceId) by Entity, DataType\n) on Entity, DataType\n// Remove duplicated columns\n| project-away Entity1, DataType1\n// and sort by Machine, DataType, Entity\n| order by BadMachinesCount desc, DeviceId asc, DataType asc, Entity asc\n//| where BadMachinesCount > 1\n", "attributes": {"description": "Baseline Comparison.\nAuthor: miflower.\nThe purpose of this query is to perform a comparison between \"known good\" machines and suspected bad machines.\nThe original concept for this query was born due to reapplying the same 'whitelist' filters over and over.\nIt brings deltas between a baseline and another machine quickly to the analyst's view.\nThis query supports multiple suspected bad machines and multiple \"known good\" machines.\nIt also supports providing a timeframe for how far back in time to build a baseline as well as how far back in time to evaluate the suspected bad machines.\nEach of the links provided by DeviceId/DeviceName will go to the most recent entry for whatever entity is listed.\nAverage results for the pre-defined settings below with a single good host and a single bad host on a 'huge' tenant (300k+ machines):.\nCompute Time: ~10-20 seconds.\nResult Set Size: ~500 rows.\nThe workflow is as follows:.\n1. Establish Variables that are editable on a per-query basis.\n2. Define functions for reuse.\n3. Calculate DeviceIds for all machines in scope.\n4. Derive deltas using the aforementioned functions.\n5. Union together all results into a single view.\nThe following datasets are returned:.\n1. Alerts on the suspected bad machines (ignores known good machines, because...they're alerts, additional data has the triggered file).\n2. Connected Networks (from DeviceNetworkInfo table, additional data has full Connected Network details).\n3. File Creations (disabled by default due to volume, enable at your own risk, additional data has initiating processes).\n4. Image Loads (disabled by default due to volume, enable at your own risk, additional data has initiating processes).\n5. Logon (derived from DeviceLogonEvents for the unique users logged on, additional data has logon types).\n6. Network communication (grouped by 2nd level-domain, ie 'microsoft.com' in 'www.microsoft.com' and 'web.microsoft.com', additional data has the full list of URLs).\n7. Process creation (additional data has the full paths of the files).\n8. Powershell Commands (grouped by the cmdlet that was ran, additional data has the processes that ran the cmdlet).\n9. Reigstry Events (disabled by default due to volume, grouped by the registry key, additional data has the value data).\n10. Raw IP Connection Events (additional data has the initiating processes).\nList of \"known good\" hosts - populate with your baseline, must be FQDNs.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Crashing%20Applications.yaml", "query_name": "Crashing Applications", "query": "DeviceProcessEvents\n| where Timestamp > ago(1d)\n| where FileName =~ 'werfault.exe'\n| project CrashTime = Timestamp, DeviceId, WerFaultCommand = ProcessCommandLine, CrashProcessId = extract(\"-p ([0-9]{1,5})\", 1, ProcessCommandLine) \n| join kind= inner hint.strategy=shuffle DeviceProcessEvents on DeviceId\n| where CrashProcessId == ProcessId and Timestamp between (datetime_add('day',-1,CrashTime) .. CrashTime)\n| project-away ActionType\n| project-rename ProcessStartTimestamp = Timestamp\n", "attributes": {"description": "This query identifies crashing processes based on parameters passed\nto werfault.exe and attempts to find the associated process launch\nfrom DeviceProcessEvents.\n", "techniques": NaN, "tactics": ["Execution", "Misconfiguration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Detect%20Azure%20RemoteIP.yaml", "query_name": "Detect Azure RemoteIP", "query": "let AzureSubnets = toscalar (\n    externaldata (xml:string)\n    [\n        @'https://download.microsoft.com/download/0/1/8/018E208D-54F8-44CD-AA26-CD7BC9524A8C/PublicIPs_20200824.xml'\n    ]\n    with (format=\"txt\")\n    | extend Subnet = tostring(parse_xml(xml).IpRange.['@Subnet'])\n    | where isnotempty(Subnet)\n    | summarize make_set(Subnet)\n);\nlet IsItAzure = (SourceData:(RemoteIP:string)) {\n    SourceData\n    | extend AzureSubnet = AzureSubnets\n    | mv-expand AzureSubnet to typeof(string)\n    | extend IsAzure = ipv4_is_in_range(RemoteIP, AzureSubnet)\n    | summarize IsAzure = max(IsAzure) by RemoteIP\n};\n// BEGIN SAMPLE QUERY //\nDeviceNetworkEvents\n| take 10000\n// END SAMPLE QUERY\n| invoke IsItAzure()\n", "attributes": {"description": "This query is a function that consumes the publicly available Azure IP address list and checks a list of remote IP addresses against it to see if they are Azure IP addresses or not.\nTo use this, replace the demo portion of the query (DeviceNetworkEvents | take 10000) with your query with the column name of the IP address to check named RemoteIP. The function will add a new column to the end called IsAzure denoting if the IP address range is in the published list or not.\nPlease note that over time the URL to the Azure IP address list may need to be updated.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Device%20Count%20by%20DNS%20Suffix.yaml", "query_name": "Device Count by DNS Suffix", "query": "DeviceInfo\n| where isnotempty(OSPlatform)\n| summarize arg_max(Timestamp, DeviceName) by DeviceId\n| extend DeviceMachineName = split(DeviceName, '.')[0]\n| extend DeviceDomain = substring(DeviceName, strlen(DeviceMachineName) + 1, strlen(DeviceName) - strlen(DeviceMachineName) - 1)\n| summarize count() by DeviceDomain\n", "attributes": {"description": "This query will count the number of devices in Defender ATP based\non their DNS suffix.  For a full list of devices with the DNS\nsuffix, comment out or remove the last line.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Device%20uptime%20calculation.yaml", "query_name": "Device uptime calculation", "query": "DeviceInfo \n| order by DeviceId, Timestamp desc\n| extend FinalSignal = (prev(DeviceId,1) != DeviceId) or (prev(LoggedOnUsers,1) != LoggedOnUsers) or (prev(Timestamp,1,now(1d)) - Timestamp > 16m)\n| extend StartSignal = (next(DeviceId,1) != DeviceId) or (next(LoggedOnUsers,1) != LoggedOnUsers) or (Timestamp - next(Timestamp,1,0) > 16m)\n| where FinalSignal or StartSignal\n| extend LastTimestamp=iff(FinalSignal,Timestamp,prev(Timestamp,1))\n| where StartSignal\n| extend ParsedFields=parse_json(LoggedOnUsers)[0]\n| extend DurationAtLeast= format_timespan(LastTimestamp-Timestamp,'dd.hh:mm:ss')\n| project Timestamp,LastTimestamp,DurationAtLeast,DeviceName,DomainName=ParsedFields.DomainName,UserName=ParsedFields.UserName\n", "attributes": {"description": "This query calculates device uptime based on periodic DeviceInfo which is recorded every 15 minutes regardless of device's network connectivity and uploaded once device gets online. If its interval is over 16 minutes, we can consider device is turned off.Calculated uptime may include up to 30 minutes gap. Devices may be turned on up to 15 minutes earlier than the \"timestamp\", and may be turned off up to 15 minutes later than the \"LastTimestamp\".  When the single independent DeviceInfo without any sequential DeviceInfo within 16 minutes before or after is recorded, \"DurationAtLeast\" will be displayed as \"00.00:00:00\".\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Command and control"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Endpoint%20Agent%20Health%20Status%20Report.yaml", "query_name": "Endpoint Agent Health Status Report", "query": "DeviceTvmSecureConfigurationAssessment\n| where ConfigurationId in ('scid-91', 'scid-2000', 'scid-2001', 'scid-2002', 'scid-2003', 'scid-2010', 'scid-2011', 'scid-2012', 'scid-2013', 'scid-2014', 'scid-2016')\n| extend Test = case(\n    ConfigurationId == \"scid-2000\", \"SensorEnabled\",\n    ConfigurationId == \"scid-2001\", \"SensorDataCollection\",\n    ConfigurationId == \"scid-2002\", \"ImpairedCommunications\",\n    ConfigurationId == \"scid-2003\", \"TamperProtection\",\n    ConfigurationId == \"scid-2010\", \"AntivirusEnabled\",\n    ConfigurationId == \"scid-2011\", \"AntivirusSignatureVersion\",\n    ConfigurationId == \"scid-2012\", \"RealtimeProtection\",\n    ConfigurationId == \"scid-91\", \"BehaviorMonitoring\",\n    ConfigurationId == \"scid-2013\", \"PUAProtection\",\n    ConfigurationId == \"scid-2014\", \"AntivirusReporting\",\n    ConfigurationId == \"scid-2016\", \"CloudProtection\",\n    \"N/A\"),\n    Result = case(IsApplicable == 0, \"N/A\", IsCompliant == 1, \"GOOD\", \"BAD\")\n| extend packed = pack(Test, Result)\n| summarize Tests = make_bag(packed), DeviceName = any(DeviceName) by DeviceId\n| evaluate bag_unpack(Tests)\n", "attributes": {"description": "This query will provide a report of many of the best practice configurations for Defender ATP deployment. Special Thanks to Gilad Mittelman for the initial inspiration and concept.\nAny tests which are reporting \"BAD\" as a result imply that the associated capability is not configured per best practice recommendation.\n", "techniques": NaN, "tactics": ["Misconfiguration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Events%20surrounding%20alert%20%281%29.yaml", "query_name": "Events surrounding alert (1)", "query": "// Modified query: instead of copy-pasting the timestamp, get the timestamp of some event you can filter - MTP Schema\n// In this example, take the time of the first detected event in an alert.\n// We filter on alertId - which you can get from all our APIs (SIEM, Graph API, PowerBI, DeviceAlertEvents table) or from the UI (the last part of the link to the alert page)\nlet alertId = \"636641078490537577_-1905871543\";\nlet alert = AlertInfo | join AlertEvidence on AlertId | where AlertId == alertId | summarize AlertFirstTimestamp=min(Timestamp) by DeviceId;\nlet DeviceId = toscalar(alert | project DeviceId);\nlet timestamp = toscalar(alert | project AlertFirstTimestamp);\nlet lookupPeriod = 10m;\nDeviceLogonEvents\n| where Timestamp between ((timestamp - lookupPeriod) .. lookupPeriod)\n        and DeviceId == DeviceId\n        and LogonType == \"Network\"\n", "attributes": {"description": "This query looks for events that are near in time to a detected event.\nIt shows how you could avoid typing exact timestamps, and replace it with a simple query to get the timestamp of your pivot event (e.g. a detected event).\nThis is useful when you have queries that you run often - e.g. as part of your regular investigation of an alert.\nOriginal query: filter for network logon events right before some timestamp.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Events%20surrounding%20alert%20%282%29.yaml", "query_name": "Events surrounding alert (2)", "query": "// This query looks for events that are near in time to a detected event.\n// It shows how you could avoid typing exact timestamps, and replace it with a simple query to get the timestamp of your pivot event (e.g. a detected event).\n// This is useful when you have queries that you run often - e.g. as part of your regular investigation of an alert.\n// Original query: filter for network logon events right before some timestamp\nlet DeviceId = \"474908f457a1dc4c1fab568f808d5f77bf3bb951\";\nlet timestamp = datetime(2018-06-09T02:23:26.6832917Z);\nlet lookupPeriod = 10m;\nDeviceLogonEvents\n| where Timestamp between ((timestamp - lookupPeriod) .. lookupPeriod)\n        and DeviceId == DeviceId\n        and LogonType == \"Network\"\n", "attributes": {"description": "This query looks for events that are near in time to a detected event.\nIt shows how you could avoid typing exact timestamps, and replace it with a simple query to get the timestamp of your pivot event (e.g. a detected event).\nThis is useful when you have queries that you run often - e.g. as part of your regular investigation of an alert.\nOriginal query: filter for network logon events right before some timestamp.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Events%20surrounding%20alert%20%283%29.yaml", "query_name": "Events surrounding alert (3)", "query": "// Modified query: instead of copy-pasting the timestamp, get the timestamp of some event you can filter\n// In this example, take the time of the first detected event in an alert.\n// We filter on alertId - which you can get from all our APIs (SIEM, Graph API, PowerBI, DeviceAlertEvents table) or from the UI (the last part of the link to the alert page)\nlet alertId = \"636641078490537577_-1905871543\";\nlet alert = AlertInfo | join AlertEvidence on AlertId | where AlertId == alertId | summarize AlertFirstTimestamp=min(Timestamp) by DeviceId;\nlet DeviceId = toscalar(alert | project DeviceId);\nlet timestamp = toscalar(alert | project AlertFirstTimestamp);\nlet lookupPeriod = 10m;\nDeviceLogonEvents\n| where Timestamp between ((timestamp - lookupPeriod) .. lookupPeriod)\n        and DeviceId == DeviceId\n        and LogonType == \"Network\"\n", "attributes": {"description": "This query looks for events that are near in time to a detected event.\nIt shows how you could avoid typing exact timestamps, and replace it with a simple query to get the timestamp of your pivot event (e.g. a detected event).\nThis is useful when you have queries that you run often - e.g. as part of your regular investigation of an alert.\nOriginal query: filter for network logon events right before some timestamp.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Events%20surrounding%20alert.yaml", "query_name": "Events surrounding alert", "query": "let DeviceId = \"474908f457a1dc4c1fab568f808d5f77bf3bb951\";\nlet timestamp = datetime(2018-06-09T02:23:26.6832917Z);\nlet lookupPeriod = 10m;\nDeviceLogonEvents\n| where Timestamp between ((timestamp - lookupPeriod) .. lookupPeriod)\n        and DeviceId == DeviceId\n        and LogonType == \"Network\"\n", "attributes": {"description": "This query looks for events that are near in time to a detected event.\nIt shows how you could avoid typing exact timestamps, and replace it with a simple query to get the timestamp of your pivot event (e.g. a detected event).\nThis is useful when you have queries that you run often - e.g. as part of your regular investigation of an alert.\nOriginal query: filter for network logon events right before some timestamp.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Failed%20Logon%20Attempt.yaml", "query_name": "Failed Logon Attempt", "query": "DeviceLogonEvents\n| where DeviceName in (\"DeviceName1\",\"DeviceName2\")\n| where ActionType == \"LogonFailed\"\n| summarize LogonFailures=count() by DeviceName, LogonType, InitiatingProcessCommandLine\n| where LogonFailures > 3\n| project LogonFailures, DeviceName, LogonType, InitiatingProcessCommandLine\n| sort by LogonFailures desc\n", "attributes": {"description": "Sample query to detect If there are more then 3 failed logon authentications on high value assets.\nUpdate DeviceName to reflect your high value assets.\nFor questions @MiladMSFT on Twitter or milad.aslaner@microsoft.com.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/File%20footprint%20%281%29.yaml", "query_name": "File footprint (1)", "query": "// Query # 2 - Shows you a list of distinct IP addresses and DNS names the endpoint had network communication with through a specific file. \n// Use this list to whitelist/blacklist IP addresses or understand if there are communication with IP you are not aware of.\n// Update the filename to the name you wish to investigate network communication.\nlet filename = \"FILENAME GOES HERE\";\n// Builds table for distinct URLs based off filename\nDeviceNetworkEvents \n| where InitiatingProcessFileName =~ filename and ( isnotempty(RemoteIP) or isnotempty(RemoteUrl) )\n| project DNS=RemoteUrl, IP=RemoteIP\n| distinct IP, DNS\n", "attributes": {"description": "Query #1 - Find the machines on which this file was seen.\nTODO - set file hash to be a SHA1 hash of your choice...\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/File%20footprint.yaml", "query_name": "File footprint", "query": "let fileHash = \"e152f7ce2d3a4349ac583580c2caf8f72fac16ba\";\nfind in (DeviceFileEvents, DeviceProcessEvents, DeviceEvents, DeviceRegistryEvents, DeviceNetworkEvents, DeviceImageLoadEvents)\nwhere SHA1 == fileHash or InitiatingProcessSHA1 == fileHash\nproject DeviceName, ActionType, FileName, InitiatingProcessFileName, Timestamp, SHA1, InitiatingProcessSHA1\n| project DeviceName, ActionType, Timestamp, \n          FileName = iff(SHA1 == fileHash, FileName, InitiatingProcessFileName),\n          MatchedSide=iff(SHA1 == fileHash, iff(InitiatingProcessSHA1 == fileHash, \"Both\", \"Child\"), \"Parent\")\n| summarize makeset(ActionType), FirstTimestamp=min(Timestamp), (LastTimestamp, LastActionType)=arg_max(Timestamp, ActionType) by FileName, MatchedSide, DeviceName\n| top 1000 by LastTimestamp desc\n| sort by DeviceName, LastTimestamp desc\n", "attributes": {"description": "Query #1 - Find the machines on which this file was seen.\nTODO - set file hash to be a SHA1 hash of your choice...\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Firewall%20Policy%20Design%20Assistant.yaml", "query_name": "Firewall Policy Design Assistant", "query": "let EphemeralRangeStart = 49152;\nlet IncludeInboundRemoteIPs = false;\nlet AliasPath = (SourcePath:(FolderPath:string, FileName:string))\n{\nSourcePath\n    | extend AliasPath = tolower(\n            case(\n                //Modern style profile\n                FolderPath startswith 'c:\\\\users\\\\', strcat('%UserProfile%', substring(FolderPath, indexof(FolderPath,'\\\\',11), strlen(FolderPath) - 11)),\n                //Legacy style profile\n                FolderPath startswith 'c:\\\\documents and settings\\\\', strcat('%UserProfile%', substring(FolderPath, indexof(FolderPath,'\\\\',27), strlen(FolderPath) - 27)),\n                //Windir\n                FolderPath contains @':\\Windows\\', strcat('%windir%', substring(FolderPath, 10)),\n                //ProgramData\n                FolderPath contains @':\\programdata\\', strcat('%programdata%', substring(FolderPath, 14)),\n                // ProgramFiles\n                FolderPath contains @':\\Program Files\\', strcat('%ProgramFiles%', substring(FolderPath, 16)),\n                // Program Files (x86)\n                FolderPath contains @':\\Program Files (x86)\\', strcat('%ProgramFilesx86%', substring(FolderPath, 22)),\n                //Other\n               FolderPath)\n        )\n};\nlet ServerConnections =\n    DeviceNetworkEvents\n    | where ActionType in ('InboundConnectionAccepted','ListeningConnectionCreated')\n        and RemoteIPType != 'Loopback' \n        and LocalIP != RemoteIP \n        and RemoteIP !startswith '169.254' \n        and LocalPort < EphemeralRangeStart\n    | distinct DeviceId, InitiatingProcessFolderPath, LocalPort;\nunion (\n    DeviceNetworkEvents\n    | where ActionType in ('InboundConnectionAccepted','ListeningConnectionCreated','ConnectionSuccess','ConnecitonFound','ConnectionRequest')\n        and RemoteIPType != 'Loopback' \n        and LocalIP != RemoteIP \n        and RemoteIP !startswith '169.254' \n        and LocalPort < EphemeralRangeStart\n    | join kind=leftsemi ServerConnections on DeviceId, InitiatingProcessFolderPath, LocalPort\n    | project-rename FolderPath = InitiatingProcessFolderPath, FileName = InitiatingProcessFileName\n    | invoke AliasPath()\n    | extend Directionality = 'Inbound', Port = LocalPort, RemoteIP = iff(IncludeInboundRemoteIPs == true, RemoteIP,'')\n),(\n    DeviceNetworkEvents\n    | where ActionType in ('ConnectionSuccess','ConnecitonFound','ConnectionRequest') \n        and RemoteIPType != 'Loopback' \n        and LocalIP != RemoteIP \n        and RemoteIP !startswith '169.254' \n        and LocalPort >= EphemeralRangeStart\n    | join kind=leftanti ServerConnections on DeviceId, InitiatingProcessFolderPath, LocalPort\n    | project-rename FolderPath = InitiatingProcessFolderPath, FileName = InitiatingProcessFileName\n    | invoke AliasPath()\n    | extend Directionality = 'Outbound', Port = RemotePort\n)\n| summarize ConnectionCount = count(), DistinctMachines = dcount(DeviceId), Ports = makeset(Port), RemoteIPs = makeset(RemoteIP) by Directionality, AliasPath\n", "attributes": {"description": "This query helps you design client firewall rules based on data stored within DeviceNetworkEvents. Folder paths are alias'ed to help represent the\nfiles making or receiving network connections without dealing with duplication from path variance due to different root drive letter or user profile\nassociation.\nTo make the report easy to read, inbound remote IP addresses are not calculated by default (this can be changed by setting the value of IncludeInboundRemoteIPs to true).\nAlso, the ephemeral range is defaulted to 49152 to help eliminate false detections.\n", "techniques": NaN, "tactics": ["Misconfiguration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%281%29.yaml", "query_name": "insider-threat-detection-queries (1)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Zip/Encrypt Sensitive File\n//\n//This is using a very basic indicator of a \"Confidential\" document in that it must be stored in a folder named Confidential or Restricted\n//Using the Information Protection tags (DeviceFileEvents: SensitivityLabel) might be a more appropriate \n DeviceFileEvents \n| where\n    InitiatingProcessFileName in (\"7z.exe\", \"7zG.exe\", \"AxCrypt.exe\", \"BitLocker.exe\", \"Diskcryptor.exe\", \"GNUPrivacyGuard.exe\", \"GPG4Win.exe\", \"PeaZip.exe\", \"VeraCrypt.exe\", \"WinRAR.exe\", \"WinZip.exe\")\n    and FolderPath matches regex \".*Confidential|Restricted.*\" \n| project Timestamp, InitiatingProcessAccountName, FileName, FolderPath, InitiatingProcessFileName, DeviceName\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2810%29.yaml", "query_name": "insider-threat-detection-queries (10)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Email to Competitor\n//\nlet competitorDomains = pack_array(\"competitor\", \"company2\");\nEmailEvents\n| where RecipientEmailAddress has_any (competitorDomains)\n| project TimeEmail = Timestamp, Subject, SenderFromAddress, RecipientEmailAddress, AccountName = tostring(split(SenderFromAddress, \"@\")[0]);\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2811%29.yaml", "query_name": "insider-threat-detection-queries (11)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//SSH Connection from untrusted Subnet\n//\n//Look for SSH connections *not* initiated from the \"Management\" subnet \nlet subnet = \"xx.xx.xx.0\"; // Adjust for your \"Trusted\" or \"Management\" subnet\nDeviceNetworkEvents \n| where RemotePort == 22 and LocalIP !contains (subnet)\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2812%29.yaml", "query_name": "insider-threat-detection-queries (12)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n// Concealment (Create/Delete Backdoor Account)\nDeviceEvents\n| where ActionType == \"UserAccountCreated\"\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2813%29.yaml", "query_name": "insider-threat-detection-queries (13)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Use of Suspicious Executable\n//\n// Replace and extend with any desired .exes\nlet SuspiciousEXEs = pack_array (\"dnscat2.exe\", \"dnscat.exe\");\nDeviceProcessEvents\n| where ProcessCommandLine has_any (SuspiciousEXEs) or FileName has_any (SuspiciousEXEs)\n| project Timestamp, DeviceName, InitiatingProcessFileName, InitiatingProcessParentFileName, ProcessCommandLine, InitiatingProcessCommandLine\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2814%29.yaml", "query_name": "insider-threat-detection-queries (14)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Open Scanner Software\n//\n// Replace and extend with any desired .exes\nlet ScannerEXEs = pack_array (\"WFS.exe\");\nDeviceProcessEvents\n| where ProcessCommandLine has_any (ScannerEXEs) or FileName has_any (ScannerEXEs)\n| project Timestamp, DeviceName, InitiatingProcessFileName, InitiatingProcessParentFileName, ProcessCommandLine, InitiatingProcessCommandLine\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2815%29.yaml", "query_name": "insider-threat-detection-queries (15)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//After-Hours Login\n//\n//Change the StartTime and EndTime to reflect typical working hours\n//This query needs some adjustments, as the default for a datetime object with no date is to only query \"today\"\nlet StartTime = datetime(\"8:00:00 AM\");\nlet EndTime = datetime(\"5:00:00 PM\");\nDeviceLogonEvents\n| where InitiatingProcessAccountName != \"system\"\n| where Timestamp between ((EndTime) .. StartTime)\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2816%29.yaml", "query_name": "insider-threat-detection-queries (16)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//High Volume File Copy Operation\n//\n//Copy large number of files (over 100) within a 5 minute timespan\n//Unfortunately there does not appear to be an easy way to determine that a file originated from a network share\nDeviceFileEvents\n| where FileName endswith \".docx\" or FileName endswith \".pptx\" or FileName endswith \".xlsx\" or FileName endswith \".pdf\"\n| summarize TotalFiles=count() by bin(Timestamp, 5m), InitiatingProcessAccountName \n|where TotalFiles >100\n| project TotalFiles,Timestamp,InitiatingProcessAccountName \n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2817%29.yaml", "query_name": "insider-threat-detection-queries (17)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Service Account Use\n//\nlet ServiceAccountPrefix = pack_array(       // Declare Account Prefix to identify Service Accounts\n    '_',\n    'svc',\n    'service'\n);\nlet InteractiveTypes = pack_array(           // Declare Interactive logon type names\n    'Interactive',\n    'CachedInteractive',\n    'Unlock',\n    'RemoteInteractive',\n    'CachedRemoteInteractive',\n    'CachedUnlock'\n);\nlet WhitelistedAccounts = pack_array(\n      'WhitelistAccount1',\n      'WhitelistAccount2'\n);                                              // List of accounts that match criteria but are able to logon interactively\nDeviceLogonEvents                               // Get all logon events...\n| where AccountName !in~ (WhitelistedAccounts)  // ...where it is not a whitelisted account...\n| where ActionType == \"LogonSuccess\"            // ...and the logon was successful...\n| where AccountName !contains \"$\"               // ...and not a machine logon. . .\n| where AccountName startswith ServiceAccountPrefix                // ...and not a machine logon. . .\n| where LogonType in (InteractiveTypes)         // Determine if the logon is interactive (True=1,False=0)...\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2818%29.yaml", "query_name": "insider-threat-detection-queries (18)", "query": "//Reference: https://github.com/microsoft/Microsoft-threat-protection-Hunting-Queries/blob/master/Lateral%20Movement/ServiceAccountsPerformingRemotePS.txt\n// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Outbound Email with Attachments of Interest\n//\n// This snippet looks for anyone sending code as an attachment based on\n// extension.  A more advanced version would use depend on DLP to determine\n// attachment type and indicate as a potential field in EmailAttachmentInfo\n//\n// whitelist any senders\nlet okaySenders = dynamic([\"postmaster@finnet.onmicrosoft.com\"]);\n//\nlet eattach = EmailAttachmentInfo\n| where SenderFromAddress !in (okaySenders)\n| project Timestamp, FileName, SenderFromAddress, NetworkMessageId\n// add list of extensions relevant to your organization\n| where FileName endswith \".cs\" or\n        FileName endswith \".c\" or\n        FileName endswith \".h\" or\n        FileName endswith \".hpp\" or\n        FileName endswith \".hxx\" or\n        FileName endswith \".cpp\" or\n        FileName endswith \".hh\" or\n        FileName endswith \".cpp\" or\n        FileName endswith \".cc\" or\n        FileName endswith \".cxx\" or\n        FileName endswith \".py\";\n// get the emails associated with attachements\neattach\n| join EmailEvents on NetworkMessageId\n// Remove (or change) this line for email direction\n| where DeliveryLocation == \"On-premises/external\"\n//\n// report stats\n// include this line if you want just summary of how often it occurs\n//| summarize outbound_emails_with_attachments=count()\n// or include this line if you want to know per sender\n//| summarize outbound_emails_with_attachments=count() by SenderFromAddress\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%2819%29.yaml", "query_name": "insider-threat-detection-queries (19)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//Backdoor Account Usage\n//\n//Look for newly created local accounts that log in within 30 minutes\nDeviceEvents\n| where ActionType == \"UserAccountCreated\"\n| project DeviceId , AccountName, Start=Timestamp\n| join kind=inner\n    (\n    DeviceLogonEvents \n    | project AccountName, DeviceId, End=Timestamp\n    ) on AccountName \n| where (End - Start) between (0min.. 30min)\n//Reference https://github.com/microsoft/Microsoft-threat-protection-Hunting-Queries/blob/master/Persistence/Create%20account.txt \n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%282%29.yaml", "query_name": "insider-threat-detection-queries (2)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Use of Steganography Application\n//\n// Extend stegnames array with know steganography tools\n// We could also use the known hash for steganography tools and use those hashes in this table\nlet stegnames = pack_array (\"camouflage\",\"crypture\", \"hidensend\", \"openpuff\",\"picsel\",\"slienteye\",\"steg\",\"xiao\");\nlet ProcessQuery = view(){\nDeviceProcessEvents \n| where ProcessCommandLine has_any (stegnames)\n};\nlet FileQuery = view(){\nDeviceFileEvents\n| where FileName has_any (stegnames)\n};\nunion ProcessQuery, FileQuery\n| project Timestamp, DeviceName, InitiatingProcessAccountName, FileName, InitiatingProcessFileName, InitiatingProcessParentFileName, InitiatingProcessCommandLine\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%283%29.yaml", "query_name": "insider-threat-detection-queries (3)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Screenshots\n//\nlet PRINT_THRESHOLD = 3;  // adjust accordingly\n//-----\nDeviceProcessEvents \n| where FileName in (\"SnippingTool.exe\", \"ScreenSketch.exe\") //and Timestamp > ago(20d)\n| summarize count(AccountName) by AccountName\n| where count_AccountName > PRINT_THRESHOLD\n| sort by count_AccountName desc\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%284%29.yaml", "query_name": "insider-threat-detection-queries (4)", "query": "//Secondary Query\n//This eventtype exists, but seems to be a bit noisy\nDeviceEvents\n| where ActionType startswith \"ScreenshotTaken\"\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%285%29.yaml", "query_name": "insider-threat-detection-queries (5)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Personal Email Account\n//\n//This query searches for connections to specific webmail URLs\nlet webmailURLs = pack_array (\"mail.google.com\", \"mail.yahoo.com\", \"mail.protonmail.com\"); // Change or append additional webmail URLs\nDeviceNetworkEvents \n| where Timestamp > ago(30d)\nand RemoteUrl has_any (webmailURLs)\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%286%29.yaml", "query_name": "insider-threat-detection-queries (6)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Access after Termination\n//\n// Look for any activity by a terminated employee account creating a\n// DeviceNetworkEvents after they were released\nlet TermAccount = 'FORMER_EMPLOYEE_NAME';  // Could also use SID\nlet ReleaseTime = datetime(\"01/16/2022 00:00:00\");\n//\nDeviceNetworkEvents \n| where InitiatingProcessAccountName =~ TermAccount\n| where Timestamp  > ReleaseTime\n| project Timestamp , DeviceName, InitiatingProcessAccountName\n| sort by Timestamp  desc\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%287%29.yaml", "query_name": "insider-threat-detection-queries (7)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Download Large File Volume over VPN\n//\nDeviceFileEvents\n| where FileName endswith \".docx\" or FileName endswith \".pptx\" or FileName endswith \".xlsx\" or FileName endswith \".pdf\"\n| join DeviceNetworkInfo on DeviceId \n| where ConnectedNetworks !contains '\"Category\":\"Domain\"'\n| summarize TotalFiles=count() by bin(Timestamp, 5m), InitiatingProcessAccountName \n|where TotalFiles >100\n| project TotalFiles,Timestamp,InitiatingProcessAccountName\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%288%29.yaml", "query_name": "insider-threat-detection-queries (8)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Usage of Source Control Management (SCM) Tool\n//\n//Update SCMTools with any additional SCM software specific to an organization.\nlet SCMTools = pack_array (\"git.exe\", \"svn.exe\", \"hg.exe\");\nDeviceProcessEvents\n| where FileName has_any (SCMTools) \nor ProcessCommandLine  has_any (SCMTools) \n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries%20%289%29.yaml", "query_name": "insider-threat-detection-queries (9)", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Browse to Job Search website\n//\n// This query finds network communication to specific job search related URL\nlet partialRemoteUrlToDetect = pack_array (\n\"careerbuilder.com\",\n\"career\",\n\"glassdoor.com\",\n\"indeed.com\",\n\"internship\",\n\"job\",\n\"linkdin.com\",\n\"monster.com\",\n\"recruit\",\n\"resume\",\n\"simplyhired.com\"); \nDeviceNetworkEvents  \n| where Timestamp > ago(30d)\nand RemoteUrl has_any (partialRemoteUrlToDetect)\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/insider-threat-detection-queries.yaml", "query_name": "insider-threat-detection-queries", "query": "// --------------------------------------------------------------------------------------------------------------------------- //\n//\n//Local Administrator\n//\nDeviceLogonEvents\n| where IsLocalAdmin ==0\n| where InitiatingProcessAccountName != \"system\"\n", "attributes": {"description": "Intent:\n- Use MTP capability to look for insider threat potential risk indicators\n- Indicators would then serve as the building block for insider threat risk modeling in subsequent tools\nDefinition of Insider Threat:\n\"The potential for an individual who has or had authorized access to an organization's assets to use their access, either maliciously or unintentionally, to act in a way that could negatively affect the organization.\"\nThis collection of queries describes the different indicators that could be used to model and look for patterns suggesting an increased risk of an individual becoming a potential insider threat.\nNote: no single indicator should be used as a lone determinant of insider threat activity, but should be part of an overall program to understand the increased risk to your organization's critical assets. This in turn is used to feed an investigation by a formal insider threat program to look at the context associated with the whole person to understand the implication of a set of indicators.\n", "techniques": NaN, "tactics": ["Initial access", "Persistence", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Linux%20Agent%20Age%20Report.yaml", "query_name": "Linux Agent Age Report", "query": "let LinuxAgentVersions = \nexternaldata (data:string)[\"https://packages.microsoft.com/rhel/8/prod/\"]\n| parse kind=regex data with @'.*\">' Filename:string '</a>' Timestamp:datetime \" \" Size:int \n| where Filename startswith \"mdatp_\"\n| parse Filename with \"mdatp_\" Version:string \".x86_64.rpm\"\n| extend SoftwareVersion = strcat(Version, \".0\")\n// The below line should NOT be considered a statement of support, but rather a rough estimate. Uncomment to use.\n//| extend IsSupported = Timestamp > ago(270d), RemainingSupportInDays = 270 - datetime_diff('day', now(), Timestamp) \n| project-away data;\nDeviceTvmSoftwareInventory\n| where SoftwareName == \"defender_for_linux\"\n| project DeviceId, DeviceName, SoftwareVersion\n| lookup kind=leftouter (LinuxAgentVersions) on $left.SoftwareVersion == $right.SoftwareVersion\n", "attributes": {"description": "This query uses the public MDE GitHub repo as a source to estimate the time that an agent build remains supported\nbased on the time it was uploaded. Please note that the timestamps used in this query are meant to estimate the\nsupport period and will likely not represent the actual expiration of the package which will be based on the build.\nIf you would like an estimate of support, uncomment the extend statement to get an idea of what is \\ is not \nsupported and an idea of how long support will remain for current agents.\nThis query currently only supports GA builds, not preview builds.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Machine%20info%20from%20IP%20address%20%281%29.yaml", "query_name": "Machine info from IP address (1)", "query": "// Query #2:\n// same as query #1 (get machines that have used a given local IP address at a given time), but also query for the logged on user\nlet pivotTimeParam = datetime(2018-07-15 19:51:00);\nlet ipAddressParam = \"192.168.1.5\";\nlet matchingMachines = \n    DeviceNetworkInfo\n    | where Timestamp between ((pivotTimeParam-15m) ..30m) and IPAddresses contains strcat(\"\\\"\", ipAddressParam, \"\\\"\") and NetworkAdapterStatus == \"Up\"\n    //// Optional - add filters to make sure machine is part of the relevant network (and not using that IP address as part of another private network).\n    //// For example:\n    // and ConnectedNetworks contains \"corp.contoso.com\"\n    // and IPv4Dhcp == \"10.164.3.12\"\n    // and DefaultGateways contains \"\\\"10.164.3.1\\\"\"\n    | project DeviceName, Timestamp, IPAddresses, TimeDifference=abs(Timestamp-pivotTimeParam);\nDeviceInfo\n| where Timestamp between ((pivotTimeParam-15m) ..30m)\n| project DeviceName, Timestamp, LoggedOnUsers \n| join kind=inner (matchingMachines) on DeviceName, Timestamp\n| project Timestamp, DeviceName, LoggedOnUsers, TimeDifference, IPAddresses\n// In case multiple machines have reported from that IP address arround that time, start with the ones reporting closest to pivotTimeParam\n| sort by TimeDifference asc\n", "attributes": {"description": "The following queries pivot from an IP address assigned to a machine to the relevant machine or logged-on users.\nTo read more about it, check out this post: https://techcommunity.microsoft.com/t5/What-s-New/Advanced-hunting-now-includes-network-adapters-information/m-p/224402#M74.\nQuery #1: get machines that have used a given local IP address at a given time - as configured on their network adapters.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Machine%20info%20from%20IP%20address%20%282%29.yaml", "query_name": "Machine info from IP address (2)", "query": "// Query #3: get machines that have used a given *public* IP address at a given time - as seen in their communications with the WDATP cloud\nlet pivotTimeParam = datetime(2018-07-15 19:51:00);\nlet ipAddressParam = \"192.168.1.5\";\nDeviceInfo\n| where Timestamp between ((pivotTimeParam-15m) .. 30m) and PublicIP == ipAddressParam\n| project DeviceName, LoggedOnUsers, Timestamp, TimeDifference=abs(Timestamp-pivotTimeParam)\n// In case multiple machines have reported from that IP address arround that time, start with the ones reporting closest to pivotTimeParam\n| sort by TimeDifference asc\n", "attributes": {"description": "The following queries pivot from an IP address assigned to a machine to the relevant machine or logged-on users.\nTo read more about it, check out this post: https://techcommunity.microsoft.com/t5/What-s-New/Advanced-hunting-now-includes-network-adapters-information/m-p/224402#M74.\nQuery #1: get machines that have used a given local IP address at a given time - as configured on their network adapters.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Machine%20info%20from%20IP%20address%20%283%29.yaml", "query_name": "Machine info from IP address (3)", "query": "// Query #4: Get machines that have used a given IP address, looking up on both local and external addresses.\n//           This includes IP addresses seen locally in their network adapters configuration or ones used to access the WDATP cloud.\nlet pivotTimeParam = datetime(2018-07-15 19:51:00);\nlet ipAddressParam = \"192.168.1.5\";\nDeviceNetworkInfo\n| where Timestamp between ((pivotTimeParam-15m) ..30m) and IPAddresses contains strcat(\"\\\"\", ipAddressParam, \"\\\"\") and NetworkAdapterStatus == \"Up\"\n| project DeviceName, Timestamp, Source=\"NetworkAdapterInfo\" \n| union (DeviceInfo | where Timestamp between ((pivotTimeParam-15m) .. 30m) and PublicIP == ipAddressParam | project DeviceName, Timestamp, Source=\"Public IP address\")\n| extend TimeDifference=abs(Timestamp-pivotTimeParam)\n| sort by TimeDifference asc\n", "attributes": {"description": "The following queries pivot from an IP address assigned to a machine to the relevant machine or logged-on users.\nTo read more about it, check out this post: https://techcommunity.microsoft.com/t5/What-s-New/Advanced-hunting-now-includes-network-adapters-information/m-p/224402#M74.\nQuery #1: get machines that have used a given local IP address at a given time - as configured on their network adapters.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Machine%20info%20from%20IP%20address.yaml", "query_name": "Machine info from IP address", "query": "let pivotTimeParam = datetime(2018-07-15 19:51:00);\nlet ipAddressParam = \"192.168.1.5\";\nDeviceNetworkInfo\n| where Timestamp between ((pivotTimeParam-15m) ..30m) and IPAddresses contains strcat(\"\\\"\", ipAddressParam, \"\\\"\") and NetworkAdapterStatus == \"Up\"\n//// Optional - add filters to make sure machine is part of the relevant network (and not using that IP address as part of another private network).\n//// For example:\n// and ConnectedNetworks contains \"corp.contoso.com\"\n// and IPv4Dhcp == \"10.164.3.12\"\n// and DefaultGateways contains \"\\\"10.164.3.1\\\"\"\n| project DeviceName, Timestamp, IPAddresses, TimeDifference=abs(Timestamp-pivotTimeParam)\n// In case multiple machines have reported from that IP address arround that time, start with the ones reporting closest to pivotTimeParam\n| sort by TimeDifference asc\n", "attributes": {"description": "The following queries pivot from an IP address assigned to a machine to the relevant machine or logged-on users.\nTo read more about it, check out this post: https://techcommunity.microsoft.com/t5/What-s-New/Advanced-hunting-now-includes-network-adapters-information/m-p/224402#M74.\nQuery #1: get machines that have used a given local IP address at a given time - as configured on their network adapters.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/MD%20AV%20Signature%20and%20Platform%20Version.yaml", "query_name": "MD AV Signature and Platform Version", "query": "let avmodetable = DeviceTvmSecureConfigurationAssessment\n| where ConfigurationId == \"scid-2010\" and isnotnull(Context)\n| extend avdata=parsejson(Context)\n| extend AVMode = iif(tostring(avdata[0][0]) == '0', 'Active' , iif(tostring(avdata[0][0]) == '1', 'Passive' ,iif(tostring(avdata[0][0]) == '4', 'EDR Blocked' ,'Unknown')))\n| project DeviceId, AVMode;\nDeviceTvmSecureConfigurationAssessment\n| where ConfigurationId == \"scid-2011\" and isnotnull(Context)\n| extend avdata=parsejson(Context)\n| extend AVSigVersion = tostring(avdata[0][0])\n| extend AVEngineVersion = tostring(avdata[0][1])\n| extend AVSigLastUpdateTime = tostring(avdata[0][2])\n| extend AVProductVersion = tostring(avdata[0][3]) \n| project DeviceId, DeviceName, OSPlatform, AVSigVersion, AVEngineVersion, AVSigLastUpdateTime, AVProductVersion, IsCompliant, IsApplicable\n| join avmodetable on DeviceId\n| project-away DeviceId1\n", "attributes": {"description": "This query will identify the Microsoft Defender Antivirus Engine version and Microsoft Defender Antivirus Security Intelligence version (and timestamp), Product update version (aka Platform Update version) as well as the Microsoft Defender Antivirus Mode on the endpoint (Active, Passive, etc.).\n", "techniques": NaN, "tactics": ["Vulnerability", "Misconfiguration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/MITRE%20-%20Suspicious%20Events.yaml", "query_name": "MITRE - Suspicious Events", "query": "let weights = dynamic({\"Low\":1, \"Medium\":3, \"High\":5}); //Assign weights to the risk levels\n//Low risk events\nlet lowRiskEvents =\n    DeviceProcessEvents \n    | where\n        (FileName =~ \"powershell.exe\" and ProcessCommandLine has \"-command\") //T1086 PowerShell\n        or\n        (FileName =~ \"powershell.exe\" and ProcessCommandLine contains \"-nop\") //T1086 PowerShell\n        or\n        (FileName =~ \"schtasks.exe\" and ProcessCommandLine has \"create\") //T1053 Scheduled Task\n        or\n        (FileName =~ \"installutil.exe\") //T1118 InstallUtil\n        or\n        (FileName =~ \"msbuild.exe\") //T1127 Trusted Developer Utilities\n        or\n        (FileName =~ \"nbtstat.exe\") //T1016 System Network Configuration Discovery\n        or\n        (FileName == \"mshta.exe\") //T1170 Mshta\n        or\n        (FileName =~ \"netsh.exe\") //T1089 Disabling Security Tools, T1063 Security Software Discovery\n        or\n        (FileName == \"net.exe\" and ProcessCommandLine has \" start \") //T1007 System Service Discovery\n    | extend Weight = toint((weights[\"Low\"]));\n//Medium risk events\nlet mediumRiskEvents =\n    DeviceProcessEvents \n    | where\n        (FileName =~ \"regsvcs.exe\") //T1121 Regsvcs/Regasm\n        or\n        (FileName =~ \"arp.exe\" and ProcessCommandLine has \"-a\") //T1016 System Network Configuration Discovery\n        or\n        (FileName =~ \"ipconfig.exe\" and ProcessCommandLine has \"all\") //T1016 System Network Configuration Discovery\n        or\n        (FileName startswith \"psexe\") //T1035 Service Execution\n        or\n        (FileName == \"net.exe\" and ProcessCommandLine has \" share \") //T1135 Network Share Discovery\n        or\n        (FileName =~ \"netsh.exe\" and ProcessCommandLine has \"interface show\") //T1016 System Network Configuration Discovery\n    | extend Weight = toint((weights[\"Medium\"]));\n//Higher risk events\nlet highRiskEvents =\n    DeviceProcessEvents \n    | where\n        (FileName =~ \"net.exe\" and ProcessCommandLine has \"config\") //T1016 System Network Configuration Discovery\n        or\n        (FileName =~ \"net.exe\" and ProcessCommandLine has \"time\") //T1124 System Time Discovery\n        or \n        (FileName =~ \"w32tm.exe\" and ProcessCommandLine has \"/tz\") //T1124 System Time Discovery\n        or\n        (FileName == \"cmstp.exe\") //T1191 CMSTP\n        or\n        (FileName =~ \"netsh.exe\" and (ProcessCommandLine has \"portproxy\" or ProcessCommandLine has \"p\")) //T1090 Connection Proxy\n    | extend Weight = toint((weights[\"High\"]));\nunion kind=outer lowRiskEvents, mediumRiskEvents, highRiskEvents\n| project Timestamp, DeviceName, FileName, ProcessCommandLine, InitiatingProcessCommandLine, Weight\n| summarize Start_Time=min(Timestamp), End_Time=max(Timestamp), Weight_Sum=sum(Weight), Processes=makeset(FileName), Commands=makeset(ProcessCommandLine) by DeviceName\n| where Weight_Sum > 30\n| sort by Weight_Sum desc \n", "attributes": {"description": "Description:.\nThe query looks for several different MITRE techniques, grouped by risk level.\nA weighting is applied to each risk level and a total score calculated per machine.\nTechniques can be added/removed as required.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Network%20footprint%20%281%29.yaml", "query_name": "Network footprint (1)", "query": "// Query 2 shows you any network communication that happened from endpoints through a specific file to an Remote IP or Remote URL\n//Ensure to update RemoteIP, RemoteURL and InitatingProcessFileName\n// For questions @MiladMSFT on Twitter or milad.aslaner@microsoft.com by email\nlet IP = \"IP ADDRESS GOES HERE\";\nlet DNS = \"DNS ENTRY GOES HERE\";\nlet FILENAME = \"FILENAME GOES HERE\";\nDeviceNetworkEvents\n| where (RemoteIP == IP or RemoteUrl endswith DNS) and InitiatingProcessFileName =~ FILENAME\n| project Timestamp, DeviceName, ActionType, RemoteIP, RemoteUrl, InitiatingProcessFileName, InitiatingProcessCommandLine\n", "attributes": {"description": "Query 1 shows you any network communication happened from endpoints to a specific Remote IP or Remote URL.\nEnsure to update RemoteIP and RemoteURL variable.\nFor questions @MiladMSFT on Twitter or milad.aslaner@microsoft.com by email.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Network%20footprint%20%282%29.yaml", "query_name": "Network footprint (2)", "query": "// Query 3 allows you to find network communication to an IP or URL in the DeviceNetworkEvents table, as well as in DeviceEvents for other events (SmartScreen, launch browser with URL, more)\n// Ensure to update RemoteIP and RemoteURL variable.\nfind in (DeviceEvents, DeviceNetworkEvents)\nwhere RemoteIP == \"IP ADDRESS GOES HERE\" or RemoteUrl =~ \"URL GOES HERE\"\nproject DeviceName, ActionType, FileName, Timestamp\n", "attributes": {"description": "Query 1 shows you any network communication happened from endpoints to a specific Remote IP or Remote URL.\nEnsure to update RemoteIP and RemoteURL variable.\nFor questions @MiladMSFT on Twitter or milad.aslaner@microsoft.com by email.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Network%20footprint%20%283%29.yaml", "query_name": "Network footprint (3)", "query": "// Query 4 Search for specific network communication of a Remote IP or URL that also discovers related file creation events\n// Ensure to update RemoteIP and RemoteURL variable.\nDeviceFileEvents\n| where FileOriginUrl == \"IP ADDRESS GOES HERE\" or FileOriginUrl contains \"URL GOES HERE\" or FileOriginReferrerUrl contains \"URL GOES HERE\"\n| project DeviceName, Timestamp, FileName, FileOriginUrl, FileOriginIP, FileOriginReferrerUrl, SHA1\n", "attributes": {"description": "Query 1 shows you any network communication happened from endpoints to a specific Remote IP or Remote URL.\nEnsure to update RemoteIP and RemoteURL variable.\nFor questions @MiladMSFT on Twitter or milad.aslaner@microsoft.com by email.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Network%20footprint.yaml", "query_name": "Network footprint", "query": "DeviceNetworkEvents\n| where RemoteIP == \"IP ADDRESS GOES HERE\"\nor RemoteUrl endswith \"DNS ENTRY GOES HERE\"\n| project Timestamp, DeviceName, ActionType, RemoteIP, RemoteUrl, InitiatingProcessFileName, InitiatingProcessCommandLine\n", "attributes": {"description": "Query 1 shows you any network communication happened from endpoints to a specific Remote IP or Remote URL.\nEnsure to update RemoteIP and RemoteURL variable.\nFor questions @MiladMSFT on Twitter or milad.aslaner@microsoft.com by email.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Network%20info%20of%20machine.yaml", "query_name": "Network info of machine", "query": "let DeviceIdParam = \"c0bfefec0bfefec0bfefec0bfefec0bfefecafe\";\nlet pivotTimeParam = datetime(2018-07-15T19:51);\nDeviceNetworkInfo\n// Query for reports sent +-15 minutes around the time we are interested in\n| where Timestamp between ((pivotTimeParam-15m) .. 30m) and DeviceId == DeviceIdParam and NetworkAdapterStatus == \"Up\"\n// IPAddresses contains a list of the IP addresses configured on the network adapter, their subnets, and more.\n// Here we expand the list so that each value gets a separate row. All the other columns in the row, such as MacAddress, are duplicated.\n| mvexpand parse_json(IPAddresses)\n| project IPAddress=IPAddresses.IPAddress, AddressType=IPAddresses.AddressType, NetworkAdapterType, TunnelType, MacAddress, \nConnectedNetworks, Timestamp, TimeDifference=abs(Timestamp-pivotTimeParam)\n// In case multiple machines have reported from that IP address arround that time, start with the ones reporting closest to pivotTimeParam\n| sort by TimeDifference asc, NetworkAdapterType, MacAddress\n", "attributes": {"description": "Get information about the netwotk adapters of the given computer in the given time.\nThis could include the configured IP addresses, DHCP servers, DNS servers, and more.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Phish%20and%20Malware%20received%20by%20user%20vs%20total%20amount%20of%20email.yaml", "query_name": "Phish and Malware received by user vs total amount of email", "query": "let UserToAnalyze=\"john.doe@contoso.com\";\nEmailEvents\n| where RecipientEmailAddress==UserToAnalyze\n| project RecipientEmailAddress, ThreatTypes\n| evaluate pivot(ThreatTypes)\n| sort by RecipientEmailAddress asc\n", "attributes": {"description": "How much phish and malware emails vs good emails received the user in the given timeframe.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/Services.yaml", "query_name": "Services", "query": "DeviceRegistryEvents  \n| where RegistryKey has @\"SYSTEM\\CurrentControlSet\\Services\"\n| extend ServiceName=tostring(split(RegistryKey, @\"\\\")[4])\n| project Timestamp, DeviceName, ServiceName, ActionType, InitiatingProcessAccountName, InitiatingProcessFileName, InitiatingProcessFolderPath, InitiatingProcessCommandLine, InitiatingProcessMD5, InitiatingProcessParentFileName\n| top 100 by Timestamp desc \n", "attributes": {"description": "Gets the service name from the registry key.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/System%20Guard%20Security%20Level%20Baseline.yaml", "query_name": "System Guard Security Level Baseline", "query": "let TargetSecurityLevel = 700;\nDeviceEvents\n| where Timestamp >= ago(7d)\n| where ActionType == \"DeviceBootAttestationInfo\"\n| extend AdditionalFieldData = parse_json(AdditionalFields)\n| project DeviceName, ReportTime = todatetime(AdditionalFieldData.ReportValidityStartTime), CurrentSecurityLevel = toint(AdditionalFieldData.SystemGuardSecurityLevel), AdditionalFieldData.ReportValidityStartTime\n| where CurrentSecurityLevel < TargetSecurityLevel\n| summarize arg_max(ReportTime, CurrentSecurityLevel) by DeviceName\n", "attributes": {"description": "Establishes a baseline SystemGuardSecurityLevel and show the devices that are below that baseline.\nSee https://techcommunity.microsoft.com/t5/Microsoft-Defender-ATP/How-insights-from-system-attestation-and-advanced-hunting-can/ba-p/969252 for full details on this query.\nAnd Device Boot Attestation Info and feel free to ping @DepletionMode or @flyingbluemonki on twitter.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/System%20Guard%20Security%20Level%20Drop.yaml", "query_name": "System Guard Security Level Drop", "query": "let SecurityLevels = DeviceEvents\n| where Timestamp >= ago(7d)\n| where ActionType == \"DeviceBootAttestationInfo\"\n| extend AdditionalFieldData = parse_json(AdditionalFields)\n| project DeviceId, Timestamp, SystemGuardSecurityLevel = toint(AdditionalFieldData.SystemGuardSecurityLevel), ReportId\n| where isnotnull(SystemGuardSecurityLevel);\n// Step 2: Get the *latest* record for *each* machine from the SecurityLevels table\nlet LatestLevelsPerMachine = SecurityLevels\n // This is going to be the most recent event\n| summarize arg_max(Timestamp, SystemGuardSecurityLevel) by DeviceId\n| project DeviceId, LatestSystemGuardSecurityLevel=SystemGuardSecurityLevel, LatestEventTime=Timestamp;\n// Step 3: Join the two tables together where the LatestSystemGuardSecurityLevel is LESS than the SystemGuardSecurityLevel \nlet MachinesExhibitingSecurityLevelDrop = LatestLevelsPerMachine\n| join (\n SecurityLevels\n) on DeviceId\n| project-away DeviceId1\n| where LatestSystemGuardSecurityLevel < SystemGuardSecurityLevel \n| summarize arg_max(Timestamp, LatestSystemGuardSecurityLevel, SystemGuardSecurityLevel, LatestEventTime, ReportId) by DeviceId;\nMachinesExhibitingSecurityLevelDrop\n", "attributes": {"description": "Goal: Find machines in the last N days where the SystemGuardSecurityLevel value NOW is less than it was BEFORE.\nStep 1: Get a list of all security levels in the system where the level is not null.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/General%20queries/wifikeys.yaml", "query_name": "wifikeys", "query": "DeviceProcessEvents \n| where Timestamp > ago(7d)\n| where ProcessCommandLine startswith \"netsh.exe\"\n| where ProcessCommandLine has \"key=clear\"\n| project Timestamp, DeviceName, InitiatingProcessFileName, FileName, ProcessCommandLine\n| top 100 by Timestamp\n", "attributes": {"description": "List commands the exposed WIFI Keys.\n@mattiasborg82.\nBlog.sec-labs.com.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Impact/backup-deletion.yaml", "query_name": "backup-deletion", "query": "AlertInfo\n| where Timestamp > ago(7d) \n| where Title == \"File backups were deleted\" \n", "attributes": {"description": "This query was originally published in the threat analytics report, Ransomware continues to hit healthcare, critical services. There is also a related blog.\nIn April of 2020, security researchers observed multiple ransomware campaigns using the same set of techniques.\nThe following query returns alerts raised when backup files were deleted.\nThe See also section below lists more queries related to techniques shared by these campaigns.\nReference - https://www.microsoft.com/security/blog/2020/04/28/ransomware-groups-continue-to-target-healthcare-critical-services-heres-how-to-reduce-risk/\n", "techniques": NaN, "tactics": ["Defense evasion", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Impact/ransom-note-creation-macos.yaml", "query_name": "ransom-note-creation-macos", "query": "union DeviceFileEvents, DeviceProcessEvents  \n| where Timestamp >= ago(7d)  \n| where ProcessCommandLine has \"say \\\\\\\"Your files are encrypted\\\\\\\" waiting until completion false\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, EvilQuest signals the rise of Mac ransomware.\nAs of the time of this writing (October 2020), ransomware designed to target macOS is relatively rare. EvilQuest is one of the few examples of this kind of malware on the platform.\nThe query below can detect the creation of a ransom note according to the typical methods of EvilQuest operators. The command the query searches for is associated with, but not definitely indicative of, EvilQuest infections.\nOther queries related to EvilQuest ransomware can be found under the See also section below.\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Impact/turn-off-system-restore.yaml", "query_name": "turn-off-system-restore", "query": "DeviceProcessEvents  \n| where Timestamp > ago(7d)  \n//Pivoting for rundll32  \nand InitiatingProcessFileName =~ 'rundll32.exe'   \n//Looking for empty command line   \nand InitiatingProcessCommandLine !contains \" \" and InitiatingProcessCommandLine != \"\"  \n//Looking for schtasks.exe as the created process  \nand FileName in~ ('schtasks.exe')  \n//Disabling system restore   \nand ProcessCommandLine has 'Change' and ProcessCommandLine has 'SystemRestore' \nand ProcessCommandLine has 'disable'\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ransomware continues to hit healthcare, critical services. There is also a related blog.\nIn April of 2020, security researchers observed multiple ransomware campaigns using the same set of techniques.\nThe following query detects attempts to stop System Restore, which would prevent the user from recovering data by going back to a restore point.\nThe See also section below lists more queries related to techniques shared by these campaigns.\nReference - https://www.microsoft.com/security/blog/2020/04/28/ransomware-groups-continue-to-target-healthcare-critical-services-heres-how-to-reduce-risk/\n", "techniques": NaN, "tactics": ["Defense evasion", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Impact/wadhrama-data-destruction.yaml", "query_name": "wadhrama-data-destruction", "query": "// Find use of WMIC to delete backups before ransomware execution\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName =~ \"wmic.exe\"\n| where ProcessCommandLine has \"shadowcopy\" and ProcessCommandLine has \"delete\"\n| project DeviceId, Timestamp, InitiatingProcessFileName, FileName,\nProcessCommandLine, InitiatingProcessIntegrityLevel, InitiatingProcessParentFileName\n", "attributes": {"description": "This query was originally published in the threat analytics report, RDP ransomware persists as Wadhrama.\nThe ransomware known as Wadhrama has been used in human-operated attacks that follow a particular pattern. The attackers often use Remote Desktop Protocol (RDP) to gain initial access to a device or network, exfiltrate credentials, and maintain persistance.\nThe following query checks for possible Wadhrama-related activity, by detecting any use of Windows Management Instrumentation command-line utility, or WMIC, to delete local backups. The attackers often delete all local backups on an infected device before actually running the ransomware.\nOther techniques used by the group associated with Wadhrama are listed under See also.\nReference - https://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Ransom:Win32/Wadhrama\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/Check%20for%20Maalware%20Baazar%20%28abuse.ch%29%20hashes%20in%20your%20mail%20flow.yaml", "query_name": "Check for Maalware Baazar (abuse.ch) hashes in your mail flow", "query": "let abuse_sha256 = (externaldata(sha256_hash: string )\n[@\"https://bazaar.abuse.ch/export/txt/sha256/recent/\"]\nwith (format=\"txt\"))\n| where sha256_hash !startswith \"#\"\n| project sha256_hash;\nabuse_sha256\n| join (EmailAttachmentInfo \n| where Timestamp > ago(1d) \n) on $left.sha256_hash == $right.SHA256\n| project Timestamp,SenderFromAddress ,RecipientEmailAddress,FileName,FileType,SHA256,ThreatTypes,DetectionMethods\n", "attributes": {"description": "Check if file hashes published in the recent abuse.ch feed are found in your mail flow scanned by Office 365 ATP.\n", "techniques": NaN, "tactics": ["Initial access", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/detect-bluekeep-exploitation-attempts.yaml", "query_name": "detect-bluekeep-exploitation-attempts", "query": "DeviceNetworkEvents\n| where InitiatingProcessFileName =~ \"spoolsv.exe\"\n| where RemotePort == \"3389\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Exploitation of CVE-2019-0708 (BlueKeep).\nCVE-2019-0708, also known as BlueKeep, is a critical remote code execution vulnerability involving RDP. Soon after its disclosure, the NSA issued a rare advisory about this vulnerability, out of concern that it could be used to quickly spread malware. Attackers have since used this vulnerability to install cryptocurrency miners on targets.\nMicrosoft has issued updates for this vulnerability, as well as guidance for protecting operating systems that we no longer support. Microsoft Defender ATP also contains behavioral detections for defending against this threat.\nThe following query detects devices with RDP connections that could be exploitation attempts.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2019-0708\nhttps://www.nsa.gov/News-Features/News-Stories/Article-View/Article/1865726/nsa-cybersecurity-advisory-patch-remote-desktop-services-on-legacy-versions-of/\nhttps://www.wired.com/story/bluekeep-hacking-cryptocurrency-mining/\nhttps://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2019-0708\nhttps://support.microsoft.com/help/4500705/customer-guidance-for-cve-2019-0708\nhttps://www.microsoft.com/security/blog/2019/11/07/the-new-cve-2019-0708-rdp-exploit-attacks-explained/\n", "techniques": NaN, "tactics": ["Initial access", "Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/detect-mailsniper.yaml", "query_name": "detect-mailsniper", "query": "let dateRange = ago(10d);\n//\nlet whoamiProcess = DeviceProcessEvents\n| where ProcessCreationTime >= dateRange\n| where FileName =~ 'whoami.exe' and InitiatingProcessParentFileName =~ 'powershell.exe'\n| project DeviceId, whoamiTime = ProcessCreationTime, whoamiProcessName = FileName, \nwhoamiParentName = InitiatingProcessParentFileName, whoamiParentPID = InitiatingProcessParentId;\n//\nlet netProcess = DeviceProcessEvents \n| where ProcessCreationTime >= dateRange\n| where FileName =~ 'net.exe' and InitiatingProcessParentFileName =~ 'powershell.exe'\n| project DeviceId, netTime = ProcessCreationTime, ProcessCreationTime = FileName, \nnetParentName = InitiatingProcessParentFileName, netParentPID = InitiatingProcessParentId;\n//\nlet mailServerEvents = DeviceNetworkEvents\n| where Timestamp >= dateRange\n| where InitiatingProcessFileName =~ 'powershell.exe'\n| where RemoteUrl contains 'onmicrosoft.com'\nor RemoteUrl contains 'outlook.com'\n| project DeviceId, mailTime = Timestamp, mailProcessName = InitiatingProcessFileName, \nmailPID = InitiatingProcessId;\n//\nmailServerEvents\n| join netProcess on DeviceId \n| where netParentPID == mailPID and netParentName == mailProcessName \n| join whoamiProcess on DeviceId \n| where whoamiParentPID == mailPID and whoamiParentName == mailProcessName \n| where netTime < mailTime + 4h and netTime > mailTime - 4h\n| where whoamiTime < mailTime + 4h and whoamiTime > mailTime - 4h\n| project DeviceId, EstimatedIncidentTime = mailTime, ProcessName = mailProcessName, \nProcessID = mailPID\n", "attributes": {"description": "This query was originally published in the threat analytics report, MailSniper Exchange attack tool.\nMailSniper is a tool that targets Microsoft Exchange Server. The core function is to connect to Exchange Server and search through emails. In support of this, it can perform reconnaissance, collection, exfiltration, and credential theft. MailSniper is used both by red teams running penetration tests, and by malicious actors.\nMicrosoft Defender Security Center may record the following alerts during and after an attack:\n1. Global mail search on Exchange using MailSniper\n2. Exchange mailbox or mail folder search using MailSniper\n3. Enumeration of Active Directory usernames using MailSniper\n4. Enumeration of the Exchange GAL using MailSniper\n5. Access to Exchange inboxes using MailSniper\n6. Password spraying using MailSniper\n7. Enumeration of domains and user accounts using MailSniper\nThe following query detects activity commonly associated with attacks run with MailSniper.\nReference - https://github.com/dafthack/MailSniper\n", "techniques": NaN, "tactics": ["Initial access", "Credential Access", "Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/files-from-malicious-sender.yaml", "query_name": "files-from-malicious-sender", "query": "//Get prevalence of files sent by a malicious sender in your organization\nEmailAttachmentInfo\n| where SenderFromAddress =~ \"MaliciousSender@example.com\"\n| where isnotempty(SHA256)\n| join (\nDeviceFileEvents\n| project FileName, SHA256\n) on SHA256\n", "attributes": {"description": "This query checks devices for the presence of files that have been sent by a known malicious sender. To use this query, replace the email address with the address of the known malicious sender.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/identify-potential-missed-phishing-email-campaigns.yaml", "query_name": "SuspiciousUrlClicked", "query": "EmailEvents \n| where SenderFromDomain != \"corporatedomain.com\" \n| summarize dcount(RecipientEmailAddress) by SenderFromAddress, NetworkMessageId, AttachmentCount, SendTime = Timestamp \n| where dcount_RecipientEmailAddress > 50\n", "attributes": {"description": "Identify emails that were send from an address external to your company and where email was send to more then 50 distinct corporate users.\nUpdate corporatedomain.com to your corporate domain to have it excluded.\nUpdate 50 if you want to adjust the distinct user count.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/jar-attachments.yaml", "query_name": "jar-attachments", "query": "let mailsHTML = EmailAttachmentInfo\n| where FileType startswith \"Jar\"\n| distinct NetworkMessageId;\nEmailEvents\n| where NetworkMessageId in (mailsHTML) and AttachmentCount > 0\n", "attributes": {"description": "This query was originally published in the threat analytics report, Adwind utilizes Java for cross-platform impact.\nAdwind is a remote access tool (RAT) that takes advantage of the cross-platform capabilities of the Java framework. It can check which operating system a target is running and adapt accordingly, allowing it to successfully compromise both Windows and macOS devices.\nThe query below must be run in Microsoft 365 Defender. This query detects events where a single Java archive, or JAR file, was attached to an incoming email. Since Adwind is distributed as a JAR file, this can help detect the initial access stage of a Adwind attack. Note that, although the behavior detected by this query is typical of attacks that use Adwind malware, unrelated attacks may use the same or similar techniques. Also note that JAR attachments are not necessarily or even often malware, and that further research will be needed to determine if query results are associated with malicious behavior.\nSee Hiding a Java class file for an additional query that detects behavior associated with Adwind attacks.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/Non_intended_user_logon.yaml", "query_name": "Non_intended_user_logon", "query": "let relevant_computers=\nDeviceInfo\n| where MachineGroup == \"My_MachineGroup\" \n| summarize make_list(DeviceName);\nlet relevant_users=\nIdentityInfo\n| where EmailAddress endswith \"@allowed.users\"\n| summarize make_list(AccountName);\nDeviceLogonEvents\n| where Timestamp > ago(1d)\n| where DeviceName in (relevant_computers)\n| where AccountName !in (relevant_users)\n| project DeviceName, AccountName\n", "attributes": {"description": "Under some circumstances it is only allowed that users\nfrom country X logon to devices from country X.\nThis query finds logon from users from other countries than X.\nThe query requires a property to identify the users from\ncountry X. In this example a specific Email Address.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/PhishingEmailUrlRedirector.yaml", "query_name": "PhishingEmailUrlRedirector", "query": "EmailUrlInfo\n| where Url matches regex @\"s?\\:\\/\\/(?:www\\.)?t\\.(?:[\\w\\-\\.]+\\/+)+(?:r|redirect)\\/?\\?\"\n", "attributes": {"description": "This query was originally published on Twitter, by @MsftSecIntel.\nThe query helps detect emails associated with a campaign that has used open redirector URLs. The campaign's URLs begin with the distinct pattern, hxxps://t. Attackers use URL redirection to manipulate users into visiting a malicious website or to evade detection.\nReference - https://twitter.com/MsftSecIntel\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/SuspiciousUrlClicked.yaml", "query_name": "SuspiciousUrlClicked", "query": "// Some URL are wrapped with a safelink\n// Let's get the the unwrapped url and clicks \nAlertInfo\n| where ServiceSource == \"Office 365 ATP\"\n| join (\n        AlertEvidence\n        | where EntityType ==\"Url\"\n        | project AlertId, RemoteUrl \n    )\n    on AlertId\n| join (\n        AlertEvidence\n        | where EntityType ==\"MailMessage\"\n        | project AlertId, NetworkMessageId \n    )\n    on AlertId\n// Get the unique NetworkMessageId for the email containing the Url\n| distinct RemoteUrl, NetworkMessageId\n| join EmailEvents on NetworkMessageId\n// Get the email RecipientEmailAddress and ObjectId from the email \n| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId\n| join kind = inner IdentityInfo on $left.RecipientObjectId  == $right.AccountObjectId \n// get the UserSid of the Recipient\n| distinct RemoteUrl, NetworkMessageId, RecipientEmailAddress , RecipientObjectId, OnPremSid \n// Get the Url click event on the recipient device.\n| join kind = inner  \n    (DeviceEvents \n    | where ActionType == \"BrowserLaunchedToOpenUrl\"| where isnotempty(RemoteUrl) \n    | project UrlDeviceClickTime = Timestamp , UrlClickedByUserSid = RemoteUrl, \n                InitiatingProcessAccountSid, DeviceName, DeviceId, InitiatingProcessFileName\n    ) \n   on $left.OnPremSid == $right.InitiatingProcessAccountSid and $left.RemoteUrl == $right.UrlClickedByUserSid\n| distinct UrlDeviceClickTime, RemoteUrl, NetworkMessageId, RecipientEmailAddress, RecipientObjectId, \n    OnPremSid, UrlClickedByUserSid, DeviceName, DeviceId, InitiatingProcessFileName \n| sort by UrlDeviceClickTime desc \n", "attributes": {"description": "This query correlates Office 365 Advanced Threat Protection (ATP) signals and Azure Active Directory (Azure AD) identity data to find the relevant endpoint event BrowerLaunchedToOpen in Microsoft Defender ATP.\nThis event reflects relevant clicks on the malicious URL in the spear-phishing email recognized by Office 365 ATP.\n", "techniques": NaN, "tactics": ["Initial access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Initial%20access/User%20navigation%20to%20redirected%20URL.yaml", "query_name": "User navigation to redirected URL", "query": "DeviceEvents\n| where ActionType == \"BrowserLaunchedToOpenUrl\"\n| extend ParsedUrl = parse_url(RemoteUrl)\n| extend ParameterKeys = bag_keys(ParsedUrl.['Query Parameters'])\n| mv-apply ParameterKeys to typeof(string) on (\n    where ParameterKeys in~ ('url','redirect','external-link','proxy')\n    | extend ParameterValue = tostring(ParsedUrl.['Query Parameters'].[ParameterKeys])\n    | where ParameterValue startswith \"http\"\n    | extend RedirectedUrl = url_decode(ParameterValue)\n    | extend ParsedRedirectUrl = parse_url(RedirectedUrl)\n)\n| extend \n    OriginalDomain = ParsedUrl.Host, \n    RedirectedDomain = tostring(ParsedRedirectUrl.Host)\n| where \n    OriginalDomain !~ RedirectedDomain \n    and OriginalDomain !endswith '.safelinks.protection.outlook.com'\n| extend \n    oTLD = tostring(split(OriginalDomain, '.')[-1]), \n    oSLD = tostring(split(OriginalDomain, '.')[-2]),\n    rTLD = tostring(split(RedirectedDomain, '.')[-1]), \n    rSLD = tostring(split(RedirectedDomain, '.')[-2])\n| extend \n    OriginalSLD = strcat(oSLD, '.', oTLD), \n    RedirectedSLD = strcat(rSLD, '.', rTLD)\n| project-reorder \n    OriginalDomain, \n    RedirectedDomain, \n    OriginalSLD, \n    RedirectedSLD, \n    RemoteUrl, \n    RedirectedUrl\n", "attributes": {"description": "This query identifies when a user clicks a link that opens a browser to navigate to a URL\nwhich uses redirection. It then filters out any redirections to URLs in the same DNS namespace\nas the originating URL. Redirection identification is done based on URL query parameters \noutlined in the following article: https://www.bleepingcomputer.com/news/security/snapchat-amex-sites-abused-in-microsoft-365-phishing-attacks/\n", "techniques": ["T1566.002"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/Account%20brute%20force%20%281%29.yaml", "query_name": "Account brute force (1)", "query": "// Query #2: Look for machines failing to log-on to multiple machines or using multiple accounts\n// Note - RemoteDeviceName is not available in all remote logon attempts\nDeviceLogonEvents\n| where isnotempty(RemoteDeviceName)\n| extend Account=strcat(AccountDomain, \"\\\\\", AccountName)\n| summarize \n    Successful=countif(ActionType == \"LogonSuccess\"),\n    Failed = countif(ActionType == \"LogonFailed\"),\n    FailedAccountsCount = dcountif(Account, ActionType == \"LogonFailed\"),\n    SuccessfulAccountsCount = dcountif(Account, ActionType == \"LogonSuccess\"),\n    FailedComputerCount = dcountif(DeviceName, ActionType == \"LogonFailed\"),\n    SuccessfulComputerCount = dcountif(DeviceName, ActionType == \"LogonSuccess\")\n    by RemoteDeviceName\n| where\n    Successful > 0 and\n    ((FailedComputerCount > 100 and FailedComputerCount > SuccessfulComputerCount) or\n        (FailedAccountsCount > 100 and FailedAccountsCount > SuccessfulAccountsCount))\n", "attributes": {"description": "Query #1: Look for public IP addresses that failed to logon to a computer multiple times, using multiple accounts, and eventually succeeded.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/Account%20brute%20force.yaml", "query_name": "Account brute force", "query": "DeviceLogonEvents\n| where isnotempty(RemoteIP) \n    and AccountName !endswith \"$\"\n    and RemoteIPType == \"Public\"\n| extend Account=strcat(AccountDomain, \"\\\\\", AccountName)\n| summarize \n    Successful=countif(ActionType == \"LogonSuccess\"),\n    Failed = countif(ActionType == \"LogonFailed\"),\n    FailedAccountsCount = dcountif(Account, ActionType == \"LogonFailed\"),\n    SuccessfulAccountsCount = dcountif(Account, ActionType == \"LogonSuccess\"),\n    FailedAccounts = makeset(iff(ActionType == \"LogonFailed\", Account, \"\"), 5),\n    SuccessfulAccounts = makeset(iff(ActionType == \"LogonSuccess\", Account, \"\"), 5)\n    by DeviceName, RemoteIP, RemoteIPType\n| where Failed > 10 and Successful > 0 and FailedAccountsCount > 2 and SuccessfulAccountsCount == 1\n", "attributes": {"description": "Query #1: Look for public IP addresses that failed to logon to a computer multiple times, using multiple accounts, and eventually succeeded.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/detect-suspicious-rdp-connections.yaml", "query_name": "detect-suspicious-rdp-connections", "query": "// Find unusual processes on Windows 7 or Windows Server 2008 machines with\n// outbound connections to TCP port 3389\nlet listMachines = DeviceInfo\n| where OSVersion == \"6.1\" //Win7 and Srv2008\n| distinct DeviceId;\nDeviceNetworkEvents\n| where RemotePort == 3389\n| where Protocol == \"Tcp\" and ActionType == \"ConnectionSuccess\"\n| where InitiatingProcessFileName !in~  //filter some legit programs\n(\"mstsc.exe\",\"RTSApp.exe\", \"RTS2App.exe\",\"RDCMan.exe\",\"ws_TunnelService.exe\",\"RSSensor.exe\"\n\"RemoteDesktopManagerFree.exe\",\"RemoteDesktopManager.exe\",\"RemoteDesktopManager64.exe\",\n\"mRemoteNG.exe\",\"mRemote.exe\",\"Terminals.exe\",\"spiceworks-finder.exe\",\n\"FSDiscovery.exe\",\"FSAssessment.exe\")\n| join listMachines on DeviceId\n| project Timestamp, DeviceId, DeviceName, RemoteIP, InitiatingProcessFileName, \nInitiatingProcessFolderPath, InitiatingProcessSHA1\n| summarize conn=count() by DeviceId, InitiatingProcessFileName, bin(Timestamp, 1d)\n", "attributes": {"description": "This query was originally published in the threat analytics report, Exploitation of CVE-2019-0708 (BlueKeep).\nCVE-2019-0708, also known as BlueKeep, is a critical remote code execution vulnerability involving RDP. Soon after its disclosure, the NSA issued a rare advisory about this vulnerability, out of concern that it could be used to quickly spread malware. Attackers have since used this vulnerability to install cryptocurrency miners on targets.\nMicrosoft has issued updates for this vulnerability, as well as guidance for protecting operating systems that we no longer support. Microsoft Defender ATP also contains behavioral detections for defending against this threat.\nThe following query locates Windows 7 or Windows Server 2008 machines initiating outbound connections to internal or public IP addresses on TCP port 3389. It filters out common RDP programs and scanning tools and shows the number of connections per machine. It can identify machines with relatively intense outbound network activity on the common RDP port (TCP/3389). You can use it to find processes that might be scanning for possible targets or exhibiting worm-like behavior.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2019-0708\nhttps://www.nsa.gov/News-Features/News-Stories/Article-View/Article/1865726/nsa-cybersecurity-advisory-patch-remote-desktop-services-on-legacy-versions-of/\nhttps://www.wired.com/story/bluekeep-hacking-cryptocurrency-mining/\nhttps://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2019-0708\nhttps://support.microsoft.com/help/4500705/customer-guidance-for-cve-2019-0708\nhttps://www.microsoft.com/security/blog/2019/11/07/the-new-cve-2019-0708-rdp-exploit-attacks-explained/\n", "techniques": NaN, "tactics": ["Initial access", "Discovery", "Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/Device%20Logons%20from%20Unknown%20IPs.yaml", "query_name": "Device Logons from Unknown IPs", "query": "DeviceLogonEvents\n| where RemoteIPType == \"Public\"\n| join kind=leftanti (\n    DeviceNetworkInfo\n    | project NetworkInfo = todynamic(IPAddresses )\n    | mvexpand NetworkInfo\n    | project IpAddress = tostring(parse_json(NetworkInfo).IPAddress)\n    | distinct IpAddress\n) on $left.RemoteIP == $right.IpAddress // Removes any IP addresses assigned to a device\n| join kind=leftanti (\n    IdentityLogonEvents\n    | where ISP != \"INTERNAL_NETWORK\"\n) on $left.RemoteIP == $right.IPAddress // Remove any IP addresses identified as internal by Microsoft Cloud App Security\n| summarize EarliestEvent = min(Timestamp), LatestEvent = max(Timestamp), Instances = count(), DistinctMachines = dcount(DeviceId) by AccountDomain, AccountName, LogonType, RemoteIP, ActionType\n", "attributes": {"description": "Device Logons from Unknown IP Addresses.\nThis query identifies device logons from IP addresses not associated with any machine in Defender ATP.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/doppelpaymer-psexec.yaml", "query_name": "doppelpaymer-psexec", "query": "// PsExec creating files on remote machines\nDeviceProcessEvents\n| where Timestamp > ago(7d)\n| where InitiatingProcessFileName startswith \"psexe\"\n| summarize CommandCount = dcount(ProcessCommandLine), makeset(ProcessCommandLine),\nmakeset(FileName) by DeviceId, bin(Timestamp, 1d)\n| where CommandCount > 2\n| where set_ProcessCommandLine has \"copy\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, Doppelpaymer: More human-operated ransomware. There is also a related blog.\nDoppelPaymer is ransomware that is spread manually by human operators. These operators have exhibited extensive knowledge of system administration and common network security misconfigurations. They often use stolen credentials from over-privileged service accounts to turn off security software, run malicious commands, and spread malware throughout an organization. More specifically, they use common remote execution tools, such as PsExec, to move laterally and distribute ransomware.\nThe following query detects suspicious usage of PsExec to create files on a remote device.\nThe See also section below lists links to other queries associated with DoppelPaymer.\nReferences:\nhttps://msrc-blog.microsoft.com/2019/11/20/customer-guidance-for-the-dopplepaymer-ransomware/\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Trojan:Win32/DoppelPaymer!MTB&threatId=-2147205372\nhttps://docs.microsoft.com/sysinternals/downloads/psexec\n", "techniques": NaN, "tactics": ["Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/ImpersonatedUserFootprint.yaml", "query_name": "ImpersonatedUserFootprint", "query": "AlertInfo\n| where ServiceSource == \"Azure ATP\"\n| where Title == \"Suspected overpass-the-hash attack (Kerberos)\"\n| extend AlertTime = Timestamp \n| join \n    (\n        AlertEvidence \n            | where EntityType == \"User\"\n    ) \n    on AlertId \n| distinct AlertTime,AccountSid \n| join kind=leftouter  \n    (\n        DeviceLogonEvents\n        | where LogonType == \"Network\" and ActionType == \"LogonSuccess\"\n        | extend LogonTime = Timestamp \n    )\n    on AccountSid \n| where LogonTime between (AlertTime .. (AlertTime + 2h))\n| project DeviceId , AlertTime , AccountName , AccountSid \n", "attributes": {"description": "Azure ATP raises alert on suspicious Kerberos ticket, pointing to a potential overpass-the-hash attack.\nOnce attackers gain credentials for a user with higher privileges, they will use the stolen credentials to sign into other devices and move laterally.\nThis query finds related sign-in events following overpass-the-hash attack to trace the footprint of the impersonated user.\n", "techniques": NaN, "tactics": ["Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/Network%20Logons%20with%20Local%20Accounts.yaml", "query_name": "Network Logons with Local Accounts", "query": "DeviceLogonEvents\n| where Timestamp > ago(30d)\n| where AccountDomain == DeviceName and isnotempty( RemoteIP) and RemoteIP !in ('::1','-', '0.0.0.0') and RemoteIP !startswith \"127.\"\n| summarize LogonAttempts = count(), DistinctMachines = dcount(DeviceId), Successes = countif(ActionType == 'Success'), RemoteDeviceName = any(RemoteDeviceName)  by RemoteIP, Protocol, LogonType, AccountName\n| order by Successes desc, LogonAttempts desc\n", "attributes": {"description": "This query looks for a large number of network-based authentications using local credentials coming from a single source IP address. High counts of logons involving a large number of distinct machines may identify an attacker beachhead within an enterprise.\n", "techniques": NaN, "tactics": ["Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/Non-local%20logons%20with%20-500%20account.yaml", "query_name": "Non-local logons with -500 account", "query": "DeviceLogonEvents\n| where AccountSid endswith '-500' and parse_json(AdditionalFields).IsLocalLogon != true\n| join kind=leftanti IdentityLogonEvents on AccountSid // Remove the domain's built-in admin acccount\n", "attributes": {"description": "Non-local logons with the built-in administrator (-500) account.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/remote-file-creation-with-psexec.yaml", "query_name": "remote-file-creation-with-psexec", "query": "// Find PsExec creating multiple files on remote machines in a 10-minute window\nDeviceFileEvents\n| where Timestamp > ago(7d)\n// Looking for PsExec by accepteula command flag\n| where InitiatingProcessCommandLine has \"accepteula\"\n// Remote machines and file is exe\n| where FolderPath has \"\\\\\\\\\" and FileName endswith \".exe\"\n| extend Exe = countof(InitiatingProcessCommandLine, \".exe\")\n// Checking to see if command line has 2 .exe or .bat\n| where InitiatingProcessCommandLine !has \".ps1\" and Exe > 1 or\nInitiatingProcessCommandLine has \".bat\"\n// Exclusions: Remove the following line to widen scope of AHQ\n| where not(InitiatingProcessCommandLine has_any(\"batch\", \"auditpol\",\n\"script\", \"scripts\", \"illusive\", \"rebootrequired\"))\n| summarize FileCount = dcount(FolderPath), make_set(SHA1), make_set(FolderPath),\nmake_set(FileName), make_set(InitiatingProcessCommandLine) by DeviceId,\nTimeWindow=bin(Timestamp, 10m), InitiatingProcessFileName\n| where FileCount > 4\n", "attributes": {"description": "This query was originally published in the threat analytics report, Ryuk ransomware. There is also a related blog.\nRyuk is human-operated ransomware. Much like DoppelPaymer ransomware, Ryuk is spread manually, often on networks that are already infected with Trickbot.\nRyuk operators use PsExec to manually spread the ransomware to other devices.\nThe following query detects remote file creation events that might indicate an active attack.\nThe See also section below lists links to other queries associated with Ryuk ransomware.\nReferences:\nhttps://www.microsoft.com/security/blog/2020/03/05/human-operated-ransomware-attacks-a-preventable-disaster/\nhttps://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Ransom:Win32/Ryuk&threatId=-2147232689\nhttps://www.microsoft.com/security/blog/2020/03/05/human-operated-ransomware-attacks-a-preventable-disaster/\nhttps://docs.microsoft.com/sysinternals/downloads/psexec\n", "techniques": NaN, "tactics": ["Lateral movement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Lateral%20Movement/ServiceAccountsPerformingRemotePS.yaml", "query_name": "ServiceAccountsPerformingRemotePS", "query": "let InteractiveTypes = pack_array(                                  // Declare Interactive logon type names\n    'Interactive',\n    'CachedInteractive',\n    'Unlock',\n    'RemoteInteractive',\n    'CachedRemoteInteractive',\n    'CachedUnlock'\n);\nlet WhitelistedCmdlets = pack_array(                                // List of whitelisted commands that don't provide a lot of value\n    'prompt',\n    'Out-Default',\n    'out-lineoutput',\n    'format-default',\n    'Set-StrictMode',\n    'TabExpansion2'\n);\nlet WhitelistedAccounts = pack_array('FakeWhitelistedAccount');     // List of accounts that are known to perform this activity in the environment and can be ignored\nDeviceLogonEvents                                                         // Get all logon events...\n| where AccountName !in~ (WhitelistedAccounts)                      // ...where it is not a whitelisted account...\n| where ActionType == \"LogonSuccess\"                                // ...and the logon was successful...\n| where AccountName !contains \"$\"                                   // ...and not a machine logon.\n| where AccountName !has \"winrm va_\"                                // WinRM will have pseudo account names that match this if there is an explicit permission for an admin to run the cmdlet, so assume it is good.\n| extend IsInteractive=(LogonType in (InteractiveTypes))            // Determine if the logon is interactive (True=1,False=0)...\n| summarize HasInteractiveLogon=max(IsInteractive)                  // ...then bucket and get the maximum interactive value (0 or 1)...\n            by AccountName                                          // ... by the AccountNames\n| where HasInteractiveLogon == 0                                    // ...and filter out all accounts that had an interactive logon.\n// At this point, we have a list of accounts that we believe to be service accounts\n// Now we need to find RemotePS sessions that were spawned by those accounts\n// Note that we look at all powershell cmdlets executed to form a 29-day baseline to evaluate the data on today\n| join kind=rightsemi (                                             // Start by dropping the account name and only tracking the...\n\tDeviceEvents                                                      // ...\n\t| where ActionType == 'PowerShellCommand'                       // ...PowerShell commands seen...\n\t| where InitiatingProcessFileName =~ 'wsmprovhost.exe'          // ...whose parent was wsmprovhost.exe (RemotePS Server)...\n    | extend AccountName = InitiatingProcessAccountName             // ...and add an AccountName field so the join is easier\n) on AccountName\n// At this point, we have all of the commands that were ran by service accounts\n| extend Command = tostring(extractjson('$.Command', AdditionalFields))   // Extract the actual PowerShell command that was executed\n| where Command !in (WhitelistedCmdlets)                            // Remove any values that match the whitelisted cmdlets\n| summarize (Timestamp, ReportId)=argmax(Timestamp, ReportId),      // Then group all of the cmdlets and calculate the min/max times of execution...\n    makeset(Command), count(), min(Timestamp) by                    // ...as well as creating a list of cmdlets ran and the count..\n    AccountName, DeviceName, DeviceId                            // ...and have the commonality be the account, DeviceName and DeviceId\n// At this point, we have machine-account pairs along with the list of commands run as well as the first/last time the commands were ran\n| order by AccountName asc                                          // Order the final list by AccountName just to make it easier to go through\n| where min_Timestamp > ago(1d)                                     // Included to restrict the scope for the custom detection page\n", "attributes": {"description": "Service Accounts Performing Remote PowerShell.\nAuthor: miflower.\nThe purpose behind this detection is for finding service accounts that are performing remote powershell sessions.\nThere are two phases to the detection: Identify service accounts, Find remote PS cmdlets being ran by these accounts.\nTo accomplish this, we utilize DeviceLogonEvents and DeviceEvents to find cmdlets ran that meet the criteria.\nOne of the main advantages of this method is that only requires server telemetry, and not the attacking client.\nThe first phase relies on the DeviceLogonEvents to determine whether an account is a service account or not, consider the following accounts with logons:.\nRandom_user has DeviceLogonEvents with type 2, 3, 7, 10, 11 & 13.\nRandom_service_account 'should' only have DeviceLogonEvents with type 3,4 or 5.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Network/Defender%20for%20Endpoint%20Telemetry.yaml", "query_name": "Defender for Endpoint Telemetry", "query": "let TargetURLs = dynamic(['winatp-gw-cus.microsoft.com', 'winatp-gw-eus.microsoft.com', 'winatp-gw-weu.microsoft.com',\n    'winatp-gw-neu.microsoft.com', 'winatp-gw-uks.microsoft.com', 'winatp-gw-ukw.microsoft.com', 'winatp-gw-usgv.microsoft.com',\n    'winatp-gw-usgt.microsoft.com', 'eu.vortex-win.data.microsoft.com', 'us.vortex-win.data.microsoft.com',\n    'uk.vortex-win.data.microsoft.com', 'events.data.microsoft.com', 'settings-win.data.microsoft.com', 'eu-v20.events.data.microsoft.com',\n    'uk-v20.events.data.microsoft.com', 'us-v20.events.data.microsoft.com', 'us4-v20.events.data.microsoft.com',\n    'us5-v20.events.data.microsoft.com', 'ctldl.windowsupdate.com']);\nDeviceNetworkEvents\n//scope here by MachineGroup, etc.\n| where isnotempty(RemoteUrl)\n| extend Domain = case(RemoteUrl contains \"//\", parse_url(RemoteUrl).Host, RemoteUrl)\n| where Domain in(TargetURLs)\n| summarize Connections = dcount(DeviceId) by ActionType, bin(Timestamp, 1d)\n| render linechart\n", "attributes": {"description": "View Defender for Endpoint telemetry URLs and their connection status, view trendline over 30 days.\nUse to investigate possible telemetry and/or connectivity issues.\nJesse.esquivel@microsoft.com.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Accessibility%20Features.yaml", "query_name": "Accessibility Features", "query": "let minTime = ago(7d);\nlet accessibilityProcessNames = dynamic([\"utilman.exe\",\"osk.exe\",\"magnify.exe\",\"narrator.exe\",\"displayswitch.exe\",\"atbroker.exe\",\"sethc.exe\", \"helppane.exe\"]);\n// Query for debuggers attached using a Registry setting to the accessibility processes\nlet attachedDebugger =\n    DeviceRegistryEvents\n    | where Timestamp > minTime\n    and RegistryKey startswith @\"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\\"\n    and RegistryValueName =~ \"debugger\"\n\t// Parse the debugged process name from the registry key\n    | parse RegistryKey with @\"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\\" FileName\n    | where FileName in~ (accessibilityProcessNames) and isnotempty(RegistryValueData)\n    | project Technique=\"AttachedDebugger\", FileName, AttachedDebuggerCommandline=RegistryValueData, InitiatingProcessCommandLine, Timestamp, DeviceName;\n// Query for overwrites of the accessibility files\nlet fileOverwiteOfAccessibilityFiles =\n    DeviceFileEvents\n    | where Timestamp > minTime\n        and FileName in~ (accessibilityProcessNames)\n        and FolderPath contains @\"Windows\\System32\" \n    | project Technique=\"OverwriteFile\", Timestamp, DeviceName, FileName, SHA1, InitiatingProcessCommandLine;\n// Query for unexpected hashes of processes with names matching the accessibility processes.\n// Specifically, query for hashes matching cmd.exe and powershell.exe, as these MS-signed general-purpose consoles are often used with this technique.\nlet executedProcessIsPowershellOrCmd =\n    DeviceProcessEvents \n    | project Technique=\"PreviousOverwriteFile\", Timestamp, DeviceName, FileName, SHA1 \n    | where Timestamp > minTime\n    | where FileName in~ (accessibilityProcessNames)\n    | join kind=leftsemi(\n        DeviceProcessEvents  \n        | where Timestamp > ago(14d) and (FileName =~ \"cmd.exe\" or FileName =~ \"powershell.exe\")\n        | summarize MachinesCount = dcount(DeviceName) by SHA1  \n        | where MachinesCount > 5\n        | project SHA1\n    ) on SHA1;\n// Union all results together. \n// An outer union is used because the schemas are a bit different between the tables - and we want to get the superset of all tables combined.\nattachedDebugger\n| union kind=outer fileOverwiteOfAccessibilityFiles\n| union kind=outer executedProcessIsPowershellOrCmd\n", "attributes": {"description": "This query looks for persistence or priviledge escalation done using Windows Accessibility features.\nIt covers some of the techniques that could be used to utilize these features for malicious purposes,.\nIncluding attaching a debugger using a registry config or overwriting these files.\nNote: some developers might use such hacks for all sort of troubleshooting and testing purposes,.\nBut this better be prohibited, as it allows any account with access to the machine to run processes as SYSTEM.\nRead more here: https://attack.mitre.org/wiki/Technique/T1015.\nTags: #AccessibilityFeatures, #StickyKeys, #ImageFileExecutionOptions, #Debugger, #PriviledgeEscalation, #Persistence.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/AddedCredentialFromContryXAndSigninFromCountryY.yaml", "query_name": "AddedCredentialFromContryXAndSigninFromCountryY", "query": "let timewindow = 1d;\nlet addedApps = (\nCloudAppEvents\n| where Application == \"Office 365\"\n| where ActionType in (\"Add service principal credentials.\", \"Update application - Certificates and secrets management \")\n| project AddedTimestamp = Timestamp , AppName = tostring(RawEventData.Target[3].ID), CountryCode );\nAADSpnSignInEventsBeta\n| join addedApps on $left.ServicePrincipalName == $right.AppName\n| where CountryCode != Country and AddedTimestamp + timewindow > Timestamp\n", "attributes": {"description": "Added credential from country X and Signed-In from country Y in a pecific time window:\nThis query tries to find all applications that credentials were added to them from country X while the application's identity Signed-In from country Y in a specific time window.\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Create%20account%20%281%29.yaml", "query_name": "Create account (1)", "query": "\n// Query #2: Query for accounts created on machines onboarded with Sense.\n// Create account event is noisy, so we need to join it with some other signal.\n// E.g. In this query we look for accounts created which name resembles \"administrator\".\n//      Using account names similar to known common account names is a common way to be evade the human analyst eye.\nDeviceEvents\n| where ActionType == \"UserAccountCreated\"\n// To look for account names similar to administrator, we'll simply query for the prefix and suffix,\n// because these letters matter most to the human perception: https://en.wikipedia.org/wiki/Typoglycemia\n// Calculating distance functions is possible but will be much more complicated - \n// and looking for prefix and suffix should work in this case pretty well.\n| where AccountName startswith \"ad\" and AccountName endswith \"or\" and AccountName !~ \"administrator\"\n// Note: For the UserAccountCreated event we do not know the details of the process / account that was used to create this new account.\n| project AccountName, AccountDomain, DeviceName, Timestamp\n| limit 100", "attributes": {"description": "User accounts may be created to achieve persistence on a machine.\nRead more here: https://attack.mitre.org/wiki/Technique/T1136.\nTags: #CreateAccount.\nQuery #1: Query for users being created using \"net user\" command.\n\"net user\" commands are noisy, so needs to be joined with another signal -.\nE.g. in this example we look for use of uncommon & undocumented commandline switches (e.g. /ad instead of /add).\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Create%20account.yaml", "query_name": "Create account", "query": "DeviceProcessEvents\n// Pro-tip: \n// There are many different ways to run a process from a file - e.g. by using full path, env. variables, ~1 annotation, more...\n// So, to find executions of a known filename, better filter on the filename (and possibly on folder path) than on the commandline.\n| where FileName in~ (\"net.exe\", \"net1.exe\") and Timestamp > ago(3d)\n// Parse the user name from the commandline.\n// To have case-insensitive parsing use the i flag, to have non-greedy match (e.g. CreatedUser as short as possible), specify U flag:\n// \"kind=regex flags=i\"\n| parse kind=regex flags=iU ProcessCommandLine with * \"user \" CreatedUser \" \" * \"/ad\"\n// Filter rows where user could not be parsed - e.g. because it was not a user command, or the /add commandline switch was not specified.\n| where isnotempty(CreatedUser)\n// Every net.exe executed will run net1.exe with the same commandline.\n// in this where clause we remove such rows, as they duplicate the number of results we have without adding any value.\n| where not (FileName =~ \"net1.exe\" and InitiatingProcessFileName =~ \"net.exe\" and replace(\"net\", \"net1\", InitiatingProcessCommandLine) =~ ProcessCommandLine)\n// If /domain is specified, so the user is created on the domain controller.\n// Also, any prefix that's longer than 1 char will also do the same, e.g. /do, /dom, /doma, ....\n| extend CreatedOnLocalMachine=(ProcessCommandLine !contains \"/do\")\n| where ProcessCommandLine !contains \"/add\" or (CreatedOnLocalMachine == 0 and ProcessCommandLine !contains \"/domain\")\n| summarize MachineCount=dcount(DeviceName) by CreatedUser, CreatedOnLocalMachine, InitiatingProcessFileName, FileName, ProcessCommandLine, InitiatingProcessCommandLine \n", "attributes": {"description": "User accounts may be created to achieve persistence on a machine.\nRead more here: https://attack.mitre.org/wiki/Technique/T1136.\nTags: #CreateAccount.\nQuery #1: Query for users being created using \"net user\" command.\n\"net user\" commands are noisy, so needs to be joined with another signal -.\nE.g. in this example we look for use of uncommon & undocumented commandline switches (e.g. /ad instead of /add).\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/CredentialsAddAfterAdminConsentedToApp%5BNobelium%5D.yaml", "query_name": "CredentialsAddAfterAdminConsentedToApp[Nobelium]", "query": "CloudAppEvents\n| where Application == \"Office 365\"\n| where ActionType == \"Consent to application.\"\n| where RawEventData.ModifiedProperties[0].Name == \"ConsentContext.IsAdminConsent\" and RawEventData.ModifiedProperties[0].NewValue == \"True\"\n| extend spnID = tostring(RawEventData.Target[3].ID)\n| parse RawEventData.ModifiedProperties[4].NewValue with * \"=> [[\" dummpy \"Scope: \" After \"]]\" *\n| extend PermissionsGranted = split(After, \"]\",0)\n| project ConsentTime = Timestamp , AccountDisplayName , spnID , PermissionsGranted\n| join (\n CloudAppEvents\n | where Application == \"Office 365\"\n | where ActionType == \"Add service principal credentials.\" or ActionType == \"Update application - Certificates and secrets management \"\n | extend spnID = tostring(RawEventData.Target[3].ID) \n | project AddSecretTime = Timestamp, AccountDisplayName , spnID \n ) on spnID \n| where ConsentTime < AddSecretTime and AccountDisplayName <> AccountDisplayName1\n", "attributes": {"description": "Credentials were added to an application by UserA, after the application was granted admin consent rights by UserB\nThe Nobelium activity group has been observed adding credentials (x509 keys or password credentials) for one or more legitimate OAuth Applications or Service Principals, usually with existing Mail.Read or Mail.ReadWrite permissions, which grants the ability to read mail content from Exchange Online via Microsoft Graph or Outlook REST. Examples include mail archiving applications.\nSee Customer Guidance on Recent Nation-State Cyber Attacks for more on the Nobelium campaign (formerly known as Solorigate).\nSee Grant tenant-wide admin consent to an application for how to add admin consent to an application.\nMore Nobelium-related queries can be found listed under the See also section of this document.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://docs.microsoft.com/azure/active-directory/manage-apps/grant-admin-consent\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/detect-prifou-pua.yaml", "query_name": "detect-prifou-pua", "query": "union DeviceFileEvents, DeviceProcessEvents \n| where Timestamp > ago(7d)\n// Prifou launched by ironSource bundler\n| where ProcessCommandLine has \"/mhp \" and ProcessCommandLine has \"/mnt \" \nand ProcessCommandLine has \"/mds \"\n// InstallCore launch commands\nor (ProcessCommandLine has \"/mnl\" and ProcessCommandLine has \"rsf\")\n// Chromium installation\nor ProcessCommandLine has \"bundlename=chromium\"\nor FileName == \"prefjsonfn.txt\"\n| project SHA1, ProcessCommandLine, FileName, InitiatingProcessFileName,\nInitiatingProcessCommandLine, InitiatingProcessSHA1\n", "attributes": {"description": "This query was originally published in the threat analytics report, ironSource PUA & unwanted apps impact millions.\nIronSource provides software bundling tools for many popular legitimate apps, such as FileZilla. However, some of ironSource's bundling tools are considered PUA, because they exhibit potentially unwanted behavior. One component of these tools, detected by Microsoft as Prifou, silently transmits system information from the user. It also installs an outdated version of Chromium browser with various browser extensions, resets the user's home page, changes their search engine settings, and forces Chromium and itself to launch at startup.\nThe following query can be used to locate unique command-line strings used by ironSource bundlers to launch Prifou, as well as commands used by Prifou to install Chromium.\n", "techniques": NaN, "tactics": ["Persistence", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/localAdminAccountLogon.yaml", "query_name": "localAdminAccountLogon", "query": "DeviceLogonEvents\n| where IsLocalAdmin == 1\n and AccountDomain == DeviceName\n", "attributes": {"description": "This query looks for local admin account used to logon into the computer.\nThis can help to detect malicious insiders that were able to add a local account to the local admin group offline.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/LocalAdminGroupChanges.yaml", "query_name": "LocalAdminGroupChanges", "query": "let ADAZUsers =  IdentityInfo \n| extend DirectoryDomain = AccountDomain \n| extend DirectoryAccount = AccountName \n| distinct DirectoryDomain , DirectoryAccount , OnPremSid , CloudSid, AccountUpn, GivenName, Surname;\n // check for any new created or modified local accounts \nlet NewUsers =  DeviceEvents\n| where ActionType contains \"UserAccountCreated\"  // or ActionType contains \"UserAccountModified\"\n| extend lUserAdded = AccountName\n| extend NewUserSID = AccountSid\n| extend laccountdomain = AccountDomain\n| distinct NewUserSID, lUserAdded,laccountdomain;\n// Check for any local group changes and enrich the data with the account name obtained from the previous query\nDeviceEvents \n| where ActionType == 'UserAccountAddedToLocalGroup' \n| extend AddedAccountSID = tostring(parse_json(AdditionalFields).MemberSid)\n| extend LocalGroup = AccountName\n| extend LocalGroupSID = AccountSid\n| extend Actor = trim(@\"[^\\w]+\",InitiatingProcessAccountName)\n// limit to local administrators group\n//  | where LocalGroupSID contains \"S-1-5-32-544\"\n| join kind= leftouter    (NewUsers)\non $left.AddedAccountSID == $right.NewUserSID\n| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, lUserAdded , Actor, ActionType , laccountdomain \n| join kind= leftouter        (ADAZUsers)\non $left.AddedAccountSID == $right.OnPremSid\n| extend UserAdded = iff(isnotempty(lUserAdded),strcat(laccountdomain,\"\\\\\", lUserAdded), strcat(DirectoryDomain,\"\\\\\", DirectoryAccount))\n| project Timestamp, DeviceName, LocalGroup,LocalGroupSID, AddedAccountSID, UserAdded , Actor, ActionType  \n| where DeviceName !contains Actor \n// Provide details on actors that added users\n// | summarize count()  by Actor \n// | join ADAZUsers\n// on $left.Actor == $right.DirectoryAccount \n// | render piechart \n", "attributes": {"description": "Author: alex verboon @alexverboon.\nBlogpost: https://www.verboon.info/2020/09/hunting-for-local-group-membership-changes.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/multipleAADAdminsRemovals.yaml", "query_name": "Multiple AAD Admin Removals", "query": "let removedAccountsThreshold = 1;\nlet lookback = 12h;\nCloudAppEvents\n| where Timestamp > ago(lookback)\n| where ApplicationId == 11161 // filter relevant events category\n| where ActionType in~ (\"Remove member from role.\", \"Remove eligible member from role.\")\n| project RawEventData\n| where RawEventData.Actor !has \"MS-PIM\"\n| mv-expand modifiedPropery = RawEventData.ModifiedProperties\n| where isnotempty(modifiedPropery)\n| extend propertyName = modifiedPropery.Name\n| where propertyName =~ \"Role.DisplayName\"\n| extend roleName = modifiedPropery.OldValue\n| where roleName in (\"Company Administrator\", \"Global Administrator\") // Add more roles you found interesting here\n| where RawEventData.Actor has \"User\" // Validate the actor of the oepration is a user and not service principal\n| extend Actor = tostring(RawEventData.Actor[0].ID), removedUserUpn = tostring(RawEventData.Target[3].ID)\n| summarize removedAccounts = dcount(removedUserUpn), make_set(removedUserUpn) by Actor\n| where removedAccounts > removedAccountsThreshold", "attributes": {"description": "Looks for multiple users that had their admin role removed by a single user within a certain period. \n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/NewAppOrServicePrincipalCredential%5BNobelium%5D.yaml", "query_name": "NewAppOrServicePrincipalCredential[Nobelium]", "query": "// New access credential added to application or service principal\nlet auditLookback = 1d;\nCloudAppEvents\n| where Timestamp > ago(auditLookback)\n| where ActionType in (\"Add service principal.\", \"Add service principal credentials.\", \"Update application  Certificates and secrets management \")\n| extend RawEventData = parse_json(RawEventData)\n| where RawEventData.ResultStatus =~ \"success\"\n// Select only users or applications initiating the credential changes\n| extend ActorDetails = RawEventData.Actor\n| mvexpand ActorDetails\n| where ActorDetails has \"@\"\n| extend targetDetails = parse_json(ActivityObjects[1])\n| extend targetId = targetDetails.Id\n| extend targetType = targetDetails.Type\n| extend targetDisplayName = targetDetails.Name\n| extend keyEvents = RawEventData.ModifiedProperties\n| where keyEvents has \"KeyIdentifier=\" and keyEvents has \"KeyUsage=Verify\"\n| mvexpand keyEvents\n| where keyEvents.Name =~ \"KeyDescription\"\n| parse keyEvents.NewValue with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| parse keyEvents.OldValue with * \"KeyIdentifier=\" keyIdentifierOld:string \",KeyType\" *\n| where keyEvents.OldValue == \"[]\" or keyIdentifier != keyIdentifierOld\n| where keyUsage == \"Verify\"\n| project-away keyEvents\n| project Timestamp, ActionType, InitiatingUserOrApp=AccountDisplayName, InitiatingIPAddress=IPAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier\n", "attributes": {"description": "This query will find when a new credential is added to an application or service principal.\nThe Nobelium activity group was able to gain sufficient access to add credentials to existing applications with mail read permissions. They used that access to exfiltrate email.\nSee Customer Guidance on Recent Nation-State Cyber Attacks for more on the Nobelium campaign (formerly known as Solorigate).\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or Azure AD audit activity reference.\nFor further information on AuditLogs please see Azure AD audit activity reference.\nThis query was inspired by an Azure Sentinel detection.\nReferences:\nhttps://msrc-blog.microsoft.com/2020/12/13/customer-guidance-on-recent-nation-state-cyber-attacks/\nhttps://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nhttps://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities\nhttps://github.com/Azure/Azure-Sentinel/blob/master/Detections/AuditLogs/NewAppOrServicePrincipalCredential.yaml\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/Possible%20webshell%20drop.yaml", "query_name": "Possible webshell drop", "query": "let MaxFileOperations = 3; // This will attempt to hide WebDAV publish operations by looking for file operations less than 'x' in a 5 minute period\nlet MaxAge = ago(7d); // This is how far back the query will search\nlet ExtensionList = pack_array('asp','aspx','aar','ascx','ashx','asmx','c','cfm','cgi','jsp','jspx','php','pl');//,'exe','dll','js','jar','py','ps1','psm1','cmd','psd1','java','wsf','vbs') Commented ones may cause false positive detection - add at will\nlet IncludeTemp = false; // whether to include files that contain \\temp\\ in their path\nlet PossibleShells = DeviceFileEvents \n| where Timestamp  > MaxAge \n    and InitiatingProcessFileName in~('w3wp.exe','httpd.exe') \n    and (IncludeTemp or FolderPath  !contains @'\\temp\\')\n    and ActionType in ('FileCreated', 'FileRenamed', 'FileModified')\n| extend extension = tolower(tostring(split(FileName,'.')[-1]))\n    , TimeBin = bin(Timestamp, 5m)\n| where extension in (ExtensionList);\nPossibleShells\n| summarize count() by DeviceId, TimeBin\n| where MaxFileOperations == -1 or count_ < MaxFileOperations\n| join kind=rightsemi PossibleShells on DeviceId, TimeBin\n", "attributes": {"description": "This query looks for files created by IIS or Apache matching common web page content extensions which\ncan be used to execute arbitrary code.\nThe query uses a throtlling mechanism in an attempt to avoid false positive detections for WebDAV or\nother web-based content management which might run under the context of the webserver process. Consider\nincreasing the value of MaxFileOperations based on your false positive detection tolerance, or set it\nto -1 to disable this feature.\nAdditional extensions of interest are listed after ExtensionList. Again, consider including \\ excluding\nthese extensions based on your organization's use and tolerance of potential false positive detections.\n", "techniques": NaN, "tactics": ["Initial access", "Execution", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/qakbot-campaign-registry-edit.yaml", "query_name": "qakbot-campaign-registry-edit", "query": "DeviceRegistryEvents\n| where ActionType == \"RegistryValueSet\"\n| where InitiatingProcessFileName == \"explorer.exe\"\n| where RegistryValueData has @\"AppData\\Roaming\\Microsoft\" and\nRegistryValueData has \"$windowsupdate\"\n| where RegistryKey has @\"CurrentVersion\\Run\"\n| project RegistryKey, RegistryValueData, DeviceId, Timestamp\n", "attributes": {"description": "This query was originally published in the threat analytics report, Qakbot blight lingers, seeds ransomware\nQakbot is malware that steals login credentials from banking and financial services. It has been deployed against small businesses as well as major corporations. Some outbreaks have involved targeted ransomware campaigns that use a similar set of techniques. Links to related queries are listed under See also.\nThe following query detects registry entries that may indicate that an operator is trying to establish persistence for the Qakbot binary.\nReference - https://www.microsoft.com/security/blog/2017/11/06/mitigating-and-eliminating-info-stealing-qakbot-and-emotet-in-corporate-networks/\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/riskySignInToDeviceRegistration.yaml", "query_name": "Risky Sign-in with Device Registration", "query": "let registeredDevices=CloudAppEvents\n| where ActionType =~ \"Add registered owner to device.\"  \n| where isnotempty(RawEventData.ObjectId) and isnotempty(RawEventData.ModifiedProperties[0].NewValue) and isnotempty(RawEventData.Target[1].ID) and isnotempty(RawEventData.ModifiedProperties[1].NewValue)\n| where AccountDisplayName =~ \"Device Registration Service\" \n| extend AccountUpn = tostring(RawEventData.ObjectId) \n| extend AccountObjectId = tostring(RawEventData.Target[1].ID) \n| extend DeviceObjectId = tostring(RawEventData.ModifiedProperties[0].NewValue) \n| extend DeviceDisplayName = tostring(RawEventData.ModifiedProperties[1].NewValue) \n| project DeviceRegistrationTimestamp=Timestamp,ReportId,AccountUpn,AccountObjectId,DeviceObjectId,DeviceDisplayName; \nlet registeringUser= \nregisteredDevices \n| distinct AccountObjectId; \nlet hasRegisteringUser = isnotempty(toscalar(registeringUser));\nlet riskySignins=AADSignInEventsBeta\n| where hasRegisteringUser\n| where AccountObjectId in (registeringUser) \n| where RiskLevelDuringSignIn in (\"50\",\"100\") //Medium and High sign-in risk level. \n| where Application in (\"Office 365 Exchange Online\", \"OfficeHome\") \n| where isnotempty(SessionId) \n| project SignInTimestamp=Timestamp, Application, SessionId, AccountObjectId, IPAddress,RiskLevelDuringSignIn \n| summarize SignInTimestamp=argmin(SignInTimestamp,*) by Application,SessionId, AccountObjectId, IPAddress,RiskLevelDuringSignIn; \nregisteredDevices \n| join riskySignins on AccountObjectId \n| where  DeviceRegistrationTimestamp - SignInTimestamp < 6h //Time delta between risky sign-in and device registration less than 6h \n| project-away AccountObjectId1", "attributes": {"description": "Looks for a new device registration in AAD preceded by medium or high-risk sign-in session for the same user within maximum 6h timeframe. \n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/riskySignInToNewMFAMethod.yaml", "query_name": "Risky Sign-in with new MFA method", "query": "let mfaMethodAdded=CloudAppEvents\n| where ActionType =~ \"Update user.\" \n| where RawEventData has \"StrongAuthenticationPhoneAppDetail\"\n| where isnotempty(RawEventData.ObjectId) and isnotempty(RawEventData.Target[1].ID)\n| extend AccountUpn = tostring(RawEventData.ObjectId)\n| extend AccountObjectId = tostring(RawEventData.Target[1].ID)\n| project MfaAddedTimestamp=Timestamp,AccountUpn,AccountObjectId;\nlet usersWithNewMFAMethod=mfaMethodAdded\n| distinct AccountObjectId;\nlet hasusersWithNewMFAMethod = isnotempty(toscalar(usersWithNewMFAMethod));\nlet riskySignins=AADSignInEventsBeta\n| where hasusersWithNewMFAMethod\n| where AccountObjectId in (usersWithNewMFAMethod)\n| where RiskLevelDuringSignIn in (\"50\",\"100\") //Medium and High sign-in risk level.\n| where Application in (\"Office 365 Exchange Online\", \"OfficeHome\")\n| where isnotempty(SessionId)\n| project SignInTimestamp=Timestamp, Application, SessionId, AccountObjectId, IPAddress,RiskLevelDuringSignIn\n| summarize SignInTimestamp=argmin(SignInTimestamp,*) by Application,SessionId, AccountObjectId, IPAddress,RiskLevelDuringSignIn;\nmfaMethodAdded\n| join riskySignins on AccountObjectId\n| where MfaAddedTimestamp - SignInTimestamp < 6h //Time delta between risky sign-in and device registration less than 6h\n| project-away AccountObjectId1", "attributes": {"description": "Looks for a new MFA method added to an account that was preceded by medium or high risk sign-in session for the same user within maximum 6h timeframe \n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/scheduled%20task%20creation.yaml", "query_name": "scheduled task creation", "query": "DeviceEvents \n| where ActionType == \"ScheduledTaskCreated\"\n  and InitiatingProcessAccountSid != \"S-1-5-18\"\n", "attributes": {"description": "Original Sigma Rule: https://github.com/Neo23x0/sigma/blob/master/rules/windows/process_creation/win_susp_schtask_creation.yml.\nQuestions via Twitter: @janvonkirchheim.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Persistence/wadhrama-ransomware.yaml", "query_name": "wadhrama-ransomware", "query": "// Find attempts to establish RDP persistence via the registry\nlet Allow = DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName == \"reg.exe\"\n| where ProcessCommandLine has \"AllowTSConnections\"\n| extend AllowReport = Timestamp ;\n//\nlet Deny = DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName == \"reg.exe\"\n| where ProcessCommandLine has \"fDenyTSConnections\"\n| extend DenyReport = Timestamp;\n//\nlet Special = DeviceProcessEvents\n| where Timestamp > ago(7d)\n| where FileName == \"reg.exe\"\n| where ProcessCommandLine has \"SpecialAccounts\"\n| extend SpecialReport = Timestamp;\n//\nSpecial | join kind=inner (Deny | join kind=inner Allow on DeviceId) on DeviceId\n| where AllowReport < Timestamp +10s and AllowReport > Timestamp -10s\n| where DenyReport < Timestamp +10s and DenyReport > Timestamp -10s\n| where SpecialReport < Timestamp +10s and SpecialReport > Timestamp -10s\n", "attributes": {"description": "This query was originally published in the threat analytics report, RDP ransomware persists as Wadhrama.\nThe ransomware known as Wadhrama has been used in human-operated attacks that follow a particular pattern. The attackers often use Remote Desktop Protocol (RDP) to gain initial access to a device or network, exfiltrate credentials, and maintain persistance.\nThe following query checks for possible Wadhrama-related activity, by searching for attempts to establish RDP persistance via the registry.\nOther techniques used by the group associated with Wadhrama are listed under See also.\nReference - https://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Ransom:Win32/Wadhrama\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/Add%20uncommon%20credential%20type%20to%20application%20%5BNobelium%5D.yaml", "query_name": "Add uncommon credential type to application [Nobelium]", "query": "CloudAppEvents\n| where Application == \"Office 365\"\n| where ActionType in (\"Add service principal credentials.\", \"Update application - Certificates and secrets management \")\n| project Timestamp, RawEventData, AccountDisplayName, ActionType, AccountObjectId\n| extend ModifiedProperties = RawEventData.ModifiedProperties[0]\n| extend NewValue = ModifiedProperties.NewValue, OldValue = ModifiedProperties.OldValue, Name = ModifiedProperties.Name\n| project Timestamp, AccountDisplayName, ActionType, NewValue, OldValue, RawEventData, AccountObjectId\n| where (NewValue has \"KeyType=Password\" and OldValue !has \"KeyType=Password\" and OldValue has \"AsymmetricX509Cert\") or (NewValue has \"AsymmetricX509Cert\" and OldValue !has \"AsymmetricX509Cert\" and OldValue has \"KeyType=Password\")\n| extend NewSecret = set_difference(todynamic(parse_json(tostring(NewValue))), todynamic(parse_json(tostring(OldValue))))\n| project Timestamp,ActionType,ActorType = RawEventData.Actor[-1].ID, ObjectId = RawEventData.Actor[-2].ID, AccountDisplayName, AccountObjectId, AppnName = RawEventData.Target[3].ID, AppObjectId = RawEventData.Target[1].ID, NewSecret = NewSecret[0], RawEventData\n", "attributes": {"description": "The query looks for users or service principals that attached an uncommon credential type to application.\nAs part of the Nobelium campaign, the attacker added credentials to already existing applications and used the application permissions to extract users' mails.\nSee How to: Use the portal to create an Azure AD application and service principal that can access resources.\nReference - https://docs.microsoft.com/azure/active-directory/develop/howto-create-service-principal-portal\n", "techniques": NaN, "tactics": ["Privilege escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/cve-2019-0808-c2.yaml", "query_name": "cve-2019-0808-c2", "query": "//Network Communication to C&C \nDeviceNetworkEvents \n| where Timestamp > ago(14d) \n| where RemoteUrl  in(\"luckluck.blog\", \"fffun-video.biz\") //Dest Address DNS \nor RemoteIP  == \"63.141.233.82\" //Destination Address \n", "attributes": {"description": "This query was originally published in the threat analytics report, Windows 7 zero-day for CVE-2019-0808\nCVE-2019-0808 is a vulnerability that allows an attacker to escape the Windows security sandbox and run arbitrary code with admin privileges. This vulnerability affects Windows 7, Windows Server 2008, and Windows Server 2008 R2.\nExploits for CVE-2019-0808 were first observed as part of highly selective attacks using the Nufsys backdoor. Although the Nufsys-associated exploit was first described as a zero-day, the issue has since been patched.\nThe following query detects possible CVE-2019-0808 exploitation by reporting network communication associated with the Nufsys attacks.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2019-0808\nhttps://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2019-0808\n", "techniques": NaN, "tactics": ["Privilege escalation", "Command and control", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/cve-2019-0808-nufsys-file%20creation.yaml", "query_name": "cve-2019-0808-nufsys-file creation", "query": "//File creation \nDeviceFileEvents \n| where Timestamp > ago(14d) \n| where FolderPath  contains \"temp\" and  FileName in~(\"updata.exe\", \n\"recovery_db.exe\", \"spsextserver.exe\", \"recoverydb.exe\") \nor SHA1 in(\"987cf95281a3f6449681148ea05e44115f74ccbc\", \n\"6f465b791ab8ef289f20c412808af7ae331c87ab\", \n\"d5c6c037735c4518fffcdac1026770d8d251c7c8\") //File SHAs of above processes\n", "attributes": {"description": "This query was originally published in the threat analytics report, Windows 7 zero-day for CVE-2019-0808\nCVE-2019-0808 is a vulnerability that allows an attacker to escape the Windows security sandbox and run arbitrary code with admin privileges. This vulnerability affects Windows 7, Windows Server 2008, and Windows Server 2008 R2.\nExploits for CVE-2019-0808 were first observed as part of highly selective attacks using the Nufsys backdoor. Although the Nufsys-associated exploit was first described as a zero-day, the issue has since been patched.\nThe following query detects possible CVE-2019-0808 exploitation by finding suspicious file creation events associated with Nufsys.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2019-0808\nhttps://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2019-0808\n", "techniques": NaN, "tactics": ["Persistence", "Privilege escalation", "Vulnerability", "Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/cve-2019-0808-set-scheduled-task.yaml", "query_name": "cve-2019-0808-set-scheduled-task", "query": "//Scheduled task creation \nDeviceProcessEvents \n| where Timestamp  > ago(14d) \n| where FileName =~ \"schtasks.exe\"  \n| where ProcessCommandLine  contains \"highest\" and \n(ProcessCommandLine contains \"ecosetup\" or \nProcessCommandLine contains \"spsextserv.exe\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, Windows 7 zero-day for CVE-2019-0808\nCVE-2019-0808 is a vulnerability that allows an attacker to escape the Windows security sandbox and run arbitrary code with admin privileges. This vulnerability affects Windows 7, Windows Server 2008, and Windows Server 2008 R2.\nExploits for CVE-2019-0808 were first observed as part of highly selective attacks using the Nufsys backdoor. Although the Nufsys-associated exploit was first described as a zero-day, the issue has since been patched.\nThe following query detects possible CVE-2019-0808 exploitation by reporting scheduled task creation events associated with the Nufsys attacks.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2019-0808\nhttps://portal.msrc.microsoft.com/security-guidance/advisory/CVE-2019-0808\n", "techniques": NaN, "tactics": ["Persistence", "Privilege escalation", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/dell-driver-vulnerability-2021.yaml", "query_name": "dell-driver-vulnerability-2021", "query": "DeviceFileEvents \n| where SHA256 in (\"0296e2ce999e67c76352613a718e11516fe1b0efc3ffdb8918fc999dd76a73a5\",\"ddbf5ecca5c8086afde1fb4f551e9e6400e94f4428fe7fb5559da5cffa654cc1\",\"552c297d6d7992f8b95287ac6e16f2169b6e629cb6ae0ee42036f093c36142d4\",\"4c727e430fb72f6942768cd1662b4aefda32f10bde43c7232da6713bb5c98bc0\",\"87e38e7aeaaaa96efe1a74f59fca8371de93544b7af22862eb0e574cec49c7c3\")\n| where FolderPath has_any (@\"C:\\Windows\\Temp\\\",@\"C:\\Temp\\\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, Multiple EOP flaws in Dell driver (CVE-2021-21551).\nCVE-2021-21551 is a vulnerability found in dbutil_2_3.sys, a driver distributed with Dell firmware updates and tools. Attackers can exploit this vulnerability to escalate privileges on a compromised device. The following query can detect if the affected driver has been added to a device's \\temp folders.\nReference - https://nvd.nist.gov/vuln/detail/CVE-2021-21551\n", "techniques": NaN, "tactics": ["Privilege escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/detect-cve-2019-0863-AngryPolarBearBug2-exploit.yaml", "query_name": "detect-cve-2019-0863-AngryPolarBearBug2-exploit", "query": "//Find possible CVE-2019-0863 exploitation\nDeviceProcessEvents \n| where FileName =~ \"schtasks.exe\"\n| where ProcessCommandLine contains \"Windows Error Reporting\"\nand ProcessCommandLine contains \"/run\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, May 2019 0-day disclosures.\nIn May and June of 2019, a security researcher with the online alias, SandboxEscaper, discovered and published several elevation-of-privilege vulnerabilities on Github. The researcher included proofs-of-concept demonstrating how to exploit these vulnerabilities.\nPatches and more information about each vulnerability are available below:\n1. CVE-2019-0863 | Windows Error Reporting Elevation of Privilege Vulnerability\n2. CVE-2019-1069 | Task Scheduler Elevation of Privilege Vulnerability\n3. CVE-2019-1053 | Windows Shell Elevation of Privilege Vulnerability\n4. CVE-2019-1064 | Windows Elevation of Privilege Vulnerability\n5. CVE-2019-0973 | Windows Installer Elevation of Privilege Vulnerability\n6. CVE-2019-1129 | Windows Elevation of Privilege Vulnerability\nThis query locates possible activity that exploits CVE-2019-0863 (also known as AngryPolarBearBug2), the first vulnerability listed above.\nReference - https://threatpost.com/sandboxescaper-more-exploits-ie-zero-day/145010/\n", "techniques": NaN, "tactics": ["Privilege escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/detect-cve-2019-0973-installerbypass-exploit.yaml", "query_name": "detect-cve-2019-0973-installerbypass-exploit", "query": "//Find possible use of InstallerBypass (Windows Installer Service exploit)\nDeviceProcessEvents \n| where FileName =~ \"msiexec.exe\"\n| where ProcessCommandLine contains \"/fa\" \nand ProcessCommandLine contains \":\\\\windows\\\\installer\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, May 2019 0-day disclosures.\nIn May and June of 2019, a security researcher with the online alias, SandboxEscaper, discovered and published several elevation-of-privilege vulnerabilities on Github. The researcher included proofs-of-concept demonstrating how to exploit these vulnerabilities.\nPatches and more information about each vulnerability are available below:\n1. CVE-2019-0863 | Windows Error Reporting Elevation of Privilege Vulnerability\n2. CVE-2019-1069 | Task Scheduler Elevation of Privilege Vulnerability\n3. CVE-2019-1053 | Windows Shell Elevation of Privilege Vulnerability\n4. CVE-2019-1064 | Windows Elevation of Privilege Vulnerability\n5. CVE-2019-0973 | Windows Installer Elevation of Privilege Vulnerability\n6. CVE-2019-1129 | Windows Elevation of Privilege Vulnerability\nThis query locates possible activity that exploits CVE-2019-0973 (also known as InstallerBypass), the fifth vulnerability listed above.\nReference - https://threatpost.com/sandboxescaper-more-exploits-ie-zero-day/145010/\n", "techniques": NaN, "tactics": ["Privilege escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/detect-cve-2019-1053-sandboxescape-exploit.yaml", "query_name": "detect-cve-2019-1053-sandboxescape-exploit", "query": "//Find possible use of SandboxEscape (Internet Explorer 11 exploit)\nDeviceFileEvents \n| where FolderPath contains @\".{0afaced1-e828-11d1-9187-b532f1e9575d}\\\"\nand FileName endswith \".lnk\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, May 2019 0-day disclosures.\nIn May and June of 2019, a security researcher with the online alias, SandboxEscaper, discovered and published several elevation-of-privilege vulnerabilities on Github. The researcher included proofs-of-concept demonstrating how to exploit these vulnerabilities.\nPatches and more information about each vulnerability are available below:\n1. CVE-2019-0863 | Windows Error Reporting Elevation of Privilege Vulnerability\n2. CVE-2019-1069 | Task Scheduler Elevation of Privilege Vulnerability\n3. CVE-2019-1053 | Windows Shell Elevation of Privilege Vulnerability\n4. CVE-2019-1064 | Windows Elevation of Privilege Vulnerability\n5. CVE-2019-0973 | Windows Installer Elevation of Privilege Vulnerability\n6. CVE-2019-1129 | Windows Elevation of Privilege Vulnerability\nThis query locates possible activity that exploits CVE-2019-1053 (also known as SandboxEscape), the third vulnerability listed above.\nReference - https://threatpost.com/sandboxescaper-more-exploits-ie-zero-day/145010/\n", "techniques": NaN, "tactics": ["Privilege escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/detect-cve-2019-1069-bearlpe-exploit.yaml", "query_name": "detect-cve-2019-1069-bearlpe-exploit", "query": "//Find possible use of BearLPE (Task Scheduler exploit)\nDeviceFileEvents\n| where FileName =~ \"schtasks.exe\"\n| where InitiatingProcessCommandLine contains \"/change\"\nand InitiatingProcessCommandLine contains \" /TN \"\nand InitiatingProcessCommandLine contains \" /RU \"\nand InitiatingProcessCommandLine contains \" /RP \"\nand InitiatingProcessCommandLine !contains \" /S \"\nand InitiatingProcessCommandLine !contains \" /ST \"\nand InitiatingProcessCommandLine !contains \" /SD \"\nand InitiatingProcessIntegrityLevel !in (\"\", \"High\", \"System\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, May 2019 0-day disclosures.\nIn May and June of 2019, a security researcher with the online alias, SandboxEscaper, discovered and published several elevation-of-privilege vulnerabilities on Github. The researcher included proofs-of-concept demonstrating how to exploit these vulnerabilities.\nPatches and more information about each vulnerability are available below:\n1. CVE-2019-0863 | Windows Error Reporting Elevation of Privilege Vulnerability\n2. CVE-2019-1069 | Task Scheduler Elevation of Privilege Vulnerability\n3. CVE-2019-1053 | Windows Shell Elevation of Privilege Vulnerability\n4. CVE-2019-1064 | Windows Elevation of Privilege Vulnerability\n5. CVE-2019-0973 | Windows Installer Elevation of Privilege Vulnerability\n6. CVE-2019-1129 | Windows Elevation of Privilege Vulnerability\nThis query locates possible activity that exploits CVE-2019-1069 (also known as BearLPE), the second vulnerability listed above.\nReference - https://threatpost.com/sandboxescaper-more-exploits-ie-zero-day/145010/\n", "techniques": NaN, "tactics": ["Privilege escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/detect-cve-2019-1129-byebear-exploit.yaml", "query_name": "detect-cve-2019-1129-byebear-exploit", "query": "//Find possible use of ByeBear (CVE-2019-1129)\nDeviceProcessEvents \n| where ProcessCommandLine contains\n@\"packages\\Microsoft.MicrosoftEdge_8wekyb3d8bbwe\"\nand ProcessCommandLine contains\"/S /Q\"\nand (ProcessCommandLine contains \"rmdir\" or ProcessCommandLine contains \"del\")\n", "attributes": {"description": "This query was originally published in the threat analytics report, May 2019 0-day disclosures.\nIn May and June of 2019, a security researcher with the online alias, SandboxEscaper, discovered and published several elevation-of-privilege vulnerabilities on Github. The researcher included proofs-of-concept demonstrating how to exploit these vulnerabilities.\nPatches and more information about each vulnerability are available below:\n1. CVE-2019-0863 | Windows Error Reporting Elevation of Privilege Vulnerability\n2. CVE-2019-1069 | Task Scheduler Elevation of Privilege Vulnerability\n3. CVE-2019-1053 | Windows Shell Elevation of Privilege Vulnerability\n4. CVE-2019-1064 | Windows Elevation of Privilege Vulnerability\n5. CVE-2019-0973 | Windows Installer Elevation of Privilege Vulnerability\n6. CVE-2019-1129 | Windows Elevation of Privilege Vulnerability\nThis query locates possible activity that exploits CVE-2019-1129 (also known as ByeBear or CVE-2019-0841-Bypass 2), the sixth vulnerability listed above.\nReference - https://threatpost.com/sandboxescaper-more-exploits-ie-zero-day/145010/\n", "techniques": NaN, "tactics": ["Privilege escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/locate-ALPC-local-privilege-elevation-exploit.yaml", "query_name": "locate-ALPC-local-privilege-elevation-exploit", "query": "DeviceFileEvents \n| where Timestamp > ago(7d)\nand FileName =~ \"printconfig.dll\"\nand InitiatingProcessIntegrityLevel != \"System\"\nand InitiatingProcessIntegrityLevel != \"High\"\nand FolderPath contains @\":\\Windows\"\n", "attributes": {"description": "This query was originally published in the threat analytics report, ALPC local privilege elevation.\nWindows ALPC Elevation of Privilege Vulnerability, CVE-2018-8440, could be exploited to run arbitrary code or to gain access to protected directories and areas of the operating system.\nThis vulnerability was patched in the September 2018 Security Update.\nThe following query checks for potential activity related to this vulnerability over the past 7 days. If you wish to check another time period, update the EventTime value.\nReferences:\nhttps://nvd.nist.gov/vuln/detail/CVE-2018-8440\nhttps://support.microsoft.com/help/4457143/windows-81-update-kb4457143\n", "techniques": NaN, "tactics": ["Privilege escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/riskySignInToElevateAccess.yaml", "query_name": "Risky Sign-in with ElevateAccess", "query": "let riskySignInLookback = 3d;\nlet elevatedUsers =\n( CloudAppEvents\n| where Timestamp > ago(1d)\n| where ApplicationId == 12260 // filter Azure Resource Manager events \n| where ActionType has \"elevateAccess\"\n| project  elevatedOperationTimestamp = Timestamp, AccountObjectId);\nlet hasElevatedUsers = isnotempty(toscalar(elevatedUsers));\nAADSignInEventsBeta\n| where hasElevatedUsers\n| where Timestamp > ago(riskySignInLookback)\n| where ErrorCode == 0\n| where RiskLevelDuringSignIn in (50, 100) //10 - low, 50 - medium, 100 - high)\n| join elevatedUsers on AccountObjectId\n| where elevatedOperationTimestamp > Timestamp\n| project LoginTime = Timestamp, elevatedOperationTimestamp, AccountObjectId, AccountDisplayName, riskScore = RiskLevelDuringSignIn", "attributes": {"description": "Looks for users who had a risky sign in (based on AAD Identity Protection risk score) and then performed and ElevateAccess action. ElevateAccess operations can be used by Global Admins to obtain permissions over Azure resources. \n", "techniques": NaN, "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/SAM-Name-Changes-CVE-2021-42278.yaml", "query_name": "SAM-Name-Changes-CVE-2021-42278", "query": "IdentityDirectoryEvents\n| where Timestamp > ago(1d)\n| where ActionType == \"SAM Account Name changed\"\n| extend FROMSAM = parse_json(AdditionalFields)['FROM SAM Account Name']\n| extend TOSAM = parse_json(AdditionalFields)['TO SAM Account Name']\n| where (FROMSAM has \"$\" and TOSAM !has \"$\") \n        or TOSAM in (\"DC1\", \"DC2\", \"DC3\", \"DC4\") // DC Names in the org\n| project Timestamp, Application, ActionType, TargetDeviceName, FROMSAM, TOSAM, ReportId, AdditionalFields\n", "attributes": {"description": "The following query detects possible CVE-2021-42278 exploitation by finding changes of device names in the network using Microsoft Defender for Identity\n", "techniques": NaN, "tactics": ["Privilege escalation", "Vulnerability"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Privilege%20escalation/ServicePrincipalAddedToRole%20%5BNobelium%5D.yaml", "query_name": "ServicePrincipalAddedToRole [Nobelium]", "query": "let queryTime = 1d;\nCloudAppEvents\n| where Timestamp > ago(queryTime)\n| where Application == \"Office 365\"\n| where ActionType == \"Add member to role.\"\n| extend EntityType = RawEventData.Target[2].ID, RoleName = RawEventData.ModifiedProperties[1].NewValue, RoleId = RawEventData.ModifiedProperties[2].NewValue\n| where EntityType == \"ServicePrincipal\"\n| project Timestamp , ActionType, ServicePrincipalName = RawEventData.Target[3].ID, ServicePrincipalId = RawEventData.Target[1].ID, RoleName, RoleId, ActorId = AccountObjectId , ActorDisplayName = AccountDisplayName \n", "attributes": {"description": "One of the indicators of compromise for the Nobelium (formerly Solorigate) campaign was that unexpected service principals have been added to privileged roles. This query looks for service principals that have been added to any role.\nSee Understanding \"Solorigate\"'s Identity IOCs - for Identity Vendors and their customers..\nReference - https://techcommunity.microsoft.com/t5/azure-active-directory-identity/understanding-quot-solorigate-quot-s-identity-iocs-for-identity/ba-p/2007610\n", "techniques": NaN, "tactics": ["Privilege escalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/Antivirus%20detections%20%281%29.yaml", "query_name": "Antivirus detections (1)", "query": "// Query #2:\n//    This query select only machines where more than 1 malware family was detected.\n//    Such behavior is usually indicative that some malware was active on the machine\n// Implementation details:\n//    This query looks for alerts on Windows Defender Antivirus detections.\n//    For most purposes it is probably better to query on the events themselves (see query #1).\n//    However, this query might still be useful sometimes (e.g. to quickly parse the family name).\nAlertInfo | join AlertEvidence on AlertId\n| where Title contains \"Defender AV detected\"\n| parse Title with *\"'\"FamilyName\"'\"*\n| summarize FamilyCount=dcount(FamilyName), Families=makeset(FamilyName), Titles=makeset(Title) by DeviceName, DeviceId, bin(Timestamp, 1d)\n| where FamilyCount > 1\n| limit 100 \n", "attributes": {"description": "Query for Microsoft Defender Antivirus detections.\nQuery #1: Query for Antivirus detection events.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/Antivirus%20detections.yaml", "query_name": "Antivirus detections", "query": "DeviceEvents\n| where ActionType == \"AntivirusDetection\"\n| extend ParsedFields=parse_json(AdditionalFields)\n| project ThreatName=tostring(ParsedFields.ThreatName),\n          WasRemediated=tobool(ParsedFields.WasRemediated),\n          WasExecutingWhileDetected=tobool(ParsedFields.WasExecutingWhileDetected),\n          FileName, SHA1, InitiatingProcessFileName, InitiatingProcessCommandLine,\n          DeviceName, Timestamp\n| limit 100\n", "attributes": {"description": "Query for Microsoft Defender Antivirus detections.\nQuery #1: Query for Antivirus detection events.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/AV%20Detections%20with%20Source.yaml", "query_name": "AV Detections with Source", "query": "let avDetections =\nDeviceEvents\n| where ActionType == \"AntivirusDetection\" and isnotempty(MD5)\n| extend ParsedFields=parse_json(AdditionalFields)\n| project Timestamp, DeviceName, ThreatName=tostring(ParsedFields.ThreatName), FileName, FolderPath, MD5;\n//Get a list of file creations\nlet fileCreations =\nDeviceFileEvents \n| where (isnotempty(FileOriginReferrerUrl) or isnotempty(FileOriginUrl)) and isnotempty(MD5)\n| project MD5, FileOriginUrl, FileOriginReferrerUrl, InitiatingProcessFileName, InitiatingProcessParentFileName;\n//Join the file creations and AV detections on the MD5 of the file\navDetections | join kind=inner (fileCreations) on MD5\n| project-away MD51 //Remove the duplicated MD5 field\n| sort by Timestamp desc \n", "attributes": {"description": "This query shows the source of the AV detections (e.g., the website the file was downloaded from etc.).\nGet the list of AV detections.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/AV%20Detections%20with%20USB%20Disk%20Drive.yaml", "query_name": "AV Detections with USB Disk Drive", "query": "let usbDetections =\n    DeviceEvents\n    | where ActionType == \"AntivirusDetection\" and FolderPath !startswith \"c\" and FolderPath matches regex \"^[A-Za-z]{1}\"\n    | extend ParsedFields=parse_json(AdditionalFields)\n    | project DetectionTime=Timestamp, DeviceName, ThreatName=tostring(ParsedFields.ThreatName), FileName, FolderPath;\n//Get a list of USB disk drive connections, grouped by computer name and DeviceID\nlet usbConnections = \n    DeviceEvents\n    | where ActionType == \"PnpDeviceConnected\"\n    | extend parsed=parse_json(AdditionalFields)\n    | project Timestamp, DeviceName, DeviceId=tostring(parsed.DeviceId), ClassName=tostring(parsed.ClassName)\n    | where ClassName == \"DiskDrive\"\n    | summarize UsbFirstSeen=min(Timestamp), UsbLastSeen=max(Timestamp) by DeviceId, DeviceName;\n//Join USB AV detections and connections, where the detection occurs after the USB has been plugged in\nusbDetections | join kind=inner (usbConnections) on DeviceName | where DetectionTime > UsbFirstSeen and DetectionTime < UsbLastSeen\n| project DetectionTime, DeviceName, ThreatName, FileName, FolderPath, DeviceId, UsbFirstSeen, UsbLastSeen\n| sort by DetectionTime desc\n", "attributes": {"description": "This query make a best-guess detection regarding which removable media device caused an AV detection.\nThe query is best run over 30 days to get the full USB history.\nGet a list of USB AV detections. This assumes any path not beginning with C is a removable/USB device.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardAsrDescriptions.yaml", "query_name": "ExploitGuardAsrDescriptions", "query": "let AsrDescriptionTable = datatable(RuleDescription:string, RuleGuid:string)\n[\n\"Block executable content from email client and webmail\",\"be9ba2d9-53ea-4cdc-84e5-9b1eeee46550\",\n\"Block Office applications from creating child processes\",\"d4f940ab-401b-4efc-aadc-ad5f3c50688a\",\n\"Block Office applications from creating executable content\",\"3b576869-a4ec-4529-8536-b80a7769e899\",\n\"Block Office applications from injecting code into other processes\",\"75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84\",\n\"Block JavaScript or VBScript from launching downloaded executable content\",\"d3e037e1-3eb8-44c8-a917-57927947596d\",\n\"Block execution of potentially obfuscated scripts\",\"5beb7efe-fd9a-4556-801d-275e5ffc04cc\",\n\"Block Win32 API calls from Office macro\",\"92e97fa1-2edf-4476-bdd6-9dd0b4dddc7b\",\n\"Block executable files from running unless they meet a prevalence, age, or trusted list criteria\",\"01443614-cd74-433a-b99e-2ecdc07bfc25\",\n\"Use advanced protection against ransomware\",\"c1db55ab-c21a-4637-bb3f-a12568109d35\",\n\"Block credential stealing from the Windows local security authority subsystem (lsass.exe)\",\"9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2\",\n\"Block process creations originating from PSExec and WMI commands\",\"d1e49aac-8f56-4280-b9ba-993a6d77406c\",\n\"Block untrusted and unsigned processes that run from USB\",\"b2b3f03d-6a65-4f7b-a9c7-1c7ef74a9ba4\",\n\"Block Office communication applications from creating child processes (available for beta testing)\",\"26190899-1602-49e8-8b27-eb1d0a1ce869\",\n\"Block Adobe Reader from creating child processes\",\"7674ba52-37eb-4a4f-a9a1-f0f9a1619a2c\",\n\"Block persistence through WMI event subscription\",\"e6db77e5-3df2-4cf1-b95a-636979351e5b\",\n];\n// Now we query the DeviceEvents table for events where the ActionType field starts with \"Asr\" - which should cover values such as AsrExecutableEmailContentAudited, AsrExecutableEmailContentBlocked, AsrOfficeChildProcessAudited, ....\nDeviceEvents\n| where ActionType startswith \"Asr\"\n// since the RuleGuid is stored inside the additionlfields column, we need to extract it for the join\n// we extend the results to include a new \"RuleGuid\" column that is populated by the extracted RuleId from the json data in AdditionalFields.  \n// we execute a tolower() on the data to make sure it's consistent as we're going to be matching string values. If we have entries thata are uppercase tolower() makes them all lowercase.  We'll do the same with our AsrDescriptionTable data later in the join statement\n// and finally we also extend the results with the extracted \"IsAudit\" column populated from AdditionalFields.  This allow us to determine if the event was blocked or merely audited\n| extend RuleGuid = tolower(tostring(parsejson(AdditionalFields).RuleId))\n| extend IsAudit = parse_json(AdditionalFields).IsAudit\n| project DeviceName, RuleGuid, DeviceId, IsAudit\n// Now we're making our join back to the earlier defined table of rule descriptions and guids (applying that tolower() statement for consistency) and  finally outputting our summary counts\n// We're projecting both the RuleDescription and the RuleGuid.  If there is a new rule that is *NOT* in our table above, we'll get a row with no description, but including the Guid so we can find it and update the table\n| join kind = leftouter (AsrDescriptionTable | project RuleGuid = tolower(RuleGuid), RuleDescription) on RuleGuid\n| summarize MachinesWithAuditEvents = dcountif(DeviceId,IsAudit==1), MachinesWithBlockEvents = dcountif(DeviceId, IsAudit==0), AllEvents=count() by RuleDescription, RuleGuid\n", "attributes": {"description": "Expanding on DeviceEvents output with Attack Surface Reduction (ASR) rule descriptions.\nThe ActionType values of the ASR events already explain what rule was matched and if it was audited or blocked.\nHowever, it could still be useful to have a more human-friendly description in the results.\nAlso, this query is a good example for how you could define your own lookup tables and join with them.\nThe events in the DeviceEvents table contain a GUID for the various ASR rules rather than a full description of the rule.\nThis query will create a table which has the description for each ASR rule as per https://docs.microsoft.com/windows/security/threat-protection/windows-defender-exploit-guard/enable-attack-surface-reduction.\nThis table is then joined to the output of a query against the DeviceEvents table and shows a summary count of the events by the newly defined description.\nThis query shows the ability to use joins and custom dimension tables.\nSee https://docs.loganalytics.io/docs/Language-Reference/Tabular-operators/join-operator for more information on the join syntax.\nFor more questions on this query, feel free to ping @FlyingBlueMonki on twitter or mattegen@microsoft.com via email.\nFirst lets start by creating a table of the rule descriptions to rule guids.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardASRStats%20%281%29.yaml", "query_name": "ExploitGuardASRStats (1)", "query": "// Get stats on ASR blocks - count events and machines per rule\nDeviceEvents\n| where ActionType startswith \"Asr\" and ActionType endswith \"Blocked\"\n// Count total stats - count events and machines per rule\n| summarize EventCount=count(), MachinesCount=dcount(DeviceId) by ActionType\n", "attributes": {"description": "Get stats on ASR audit events - count events and machines per rule.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardASRStats%20%282%29.yaml", "query_name": "ExploitGuardASRStats (2)", "query": "// View ASR audit events - but remove repeating events (e.g. multiple events with same machine, rule, file and process)\nDeviceEvents\n| where ActionType startswith \"ASR\" and ActionType endswith \"Audited\"\n| summarize Timestamp =max(Timestamp) by DeviceName, ActionType,FileName, FolderPath, InitiatingProcessCommandLine, InitiatingProcessFileName, InitiatingProcessFolderPath, InitiatingProcessId, SHA1 \n", "attributes": {"description": "Get stats on ASR audit events - count events and machines per rule.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardASRStats.yaml", "query_name": "ExploitGuardASRStats", "query": "DeviceEvents\n| where ActionType startswith \"Asr\" and ActionType endswith \"Audited\"\n// Count total stats - count events and machines per rule\n| summarize EventCount=count(), MachinesCount=dcount(DeviceId) by ActionType\n", "attributes": {"description": "Get stats on ASR audit events - count events and machines per rule.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardBlockOfficeChildProcess%20%281%29.yaml", "query_name": "ExploitGuardBlockOfficeChildProcess (1)", "query": "// These queries check telemetry from the Exploit Guard rule: Rule: Block Office applications from creating child processes\n// (Rule ID d4f940ab-401b-4efc-aadc-ad5f3c50688a)\n// Read more about it here: https://docs.microsoft.com/windows/security/threat-protection/windows-defender-exploit-guard/attack-surface-reduction-exploit-guard\n// Oftentimes organizations enable this rule in audit mode and check the results before setting block mode.\n// You can use query #2 to measure the rule impact on your network in audit mode before turning it to block mode.\n// Query #1 is used after setting it to block mode - to analyze the block stats.\n// Tags: #ASR\n// Query #2: investigate audit events - before turning the rule on in block mode\nlet minTime = ago(7d);\n// Enrich the ExploitGuard events with column saying if there was a nearby Microsoft Defender for Endpoint alert or not.\n// If there was an alert, so this is probably malware, and it's good that it will be blocked.\n// If there was no alert, so it requires further analysis to determine if this is a clean file or some malware that was missed.\nlet alerts =\n    AlertInfo \n    | where Timestamp > minTime\n    | join AlertEvidence on AlertId\n    | project DeviceName, DetectedTimestamp=Timestamp\n;\nDeviceEvents\n| where ActionType == \"AsrOfficeChildProcessAudited\" and Timestamp > minTime\n| project BlockedProcess=FileName, ParentProcess=InitiatingProcessFileName, DeviceName, Timestamp\n| join kind=leftouter (alerts) on DeviceName\n| extend HasNearbyAlert = abs(Timestamp - DetectedTimestamp) between (0min .. 5min)\n| summarize MachineCount=dcount(DeviceName),\n            RuleHits=count(),\n            NearbyAlertPercent=countif(HasNearbyAlert)*100.0 / count() \n            by BlockedProcess, ParentProcess\n| sort by MachineCount desc\n", "attributes": {"description": "These queries check telemetry from the Exploit Guard rule: Rule: Block Office applications from creating child processes.\n(Rule ID d4f940ab-401b-4efc-aadc-ad5f3c50688a).\nRead more about it here: https://docs.microsoft.com/windows/security/threat-protection/windows-defender-exploit-guard/attack-surface-reduction-exploit-guard.\nOftentimes organizations enable this rule in audit mode and check the results before setting block mode.\nYou can use query #2 to measure the rule impact on your network in audit mode before turning it to block mode.\nQuery #1 is used after setting it to block mode - to analyze the block stats.\nTags: #ASR.\nQuery #1: block stats.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardBlockOfficeChildProcess%20%282%29.yaml", "query_name": "ExploitGuardBlockOfficeChildProcess (2)", "query": "\n// These queries check telemetry from the Exploit Guard rule: Rule: Block Office applications from creating child processes - MTP Schema\n// (Rule ID d4f940ab-401b-4efc-aadc-ad5f3c50688a)\n// Read more about it here: https://docs.microsoft.com/windows/security/threat-protection/windows-defender-exploit-guard/attack-surface-reduction-exploit-guard\n// Oftentimes organizations enable this rule in audit mode and check the results before setting block mode.\n// You can use query #2 to measure the rule impact on your network in audit mode before turning it to block mode.\n// Query #1 is used after setting it to block mode - to analyze the block stats.\n// Tags: #ASR\n//Query #1: block stats\nDeviceEvents\n| where ActionType == \"AsrOfficeChildProcessBlocked\" and Timestamp > ago(7d)\n| project BlockedProcess=FileName, ParentProcess=InitiatingProcessFileName, DeviceName\n| summarize MachineCount=dcount(DeviceName), RuleHits=count() by BlockedProcess, ParentProcess\n| sort by MachineCount desc", "attributes": {"description": "These queries check telemetry from the Exploit Guard rule: Rule: Block Office applications from creating child processes.\n(Rule ID d4f940ab-401b-4efc-aadc-ad5f3c50688a).\nRead more about it here: https://docs.microsoft.com/windows/security/threat-protection/windows-defender-exploit-guard/attack-surface-reduction-exploit-guard.\nOftentimes organizations enable this rule in audit mode and check the results before setting block mode.\nYou can use query #2 to measure the rule impact on your network in audit mode before turning it to block mode.\nQuery #1 is used after setting it to block mode - to analyze the block stats.\nTags: #ASR.\nQuery #1: block stats.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardBlockOfficeChildProcess%20%283%29.yaml", "query_name": "ExploitGuardBlockOfficeChildProcess (3)", "query": "// These queries check telemetry from the Exploit Guard rule: Rule: Block Office applications from creating child processes - MTP Schema\n// (Rule ID d4f940ab-401b-4efc-aadc-ad5f3c50688a)\n// Read more about it here: https://docs.microsoft.com/windows/security/threat-protection/windows-defender-exploit-guard/attack-surface-reduction-exploit-guard\n// Oftentimes organizations enable this rule in audit mode and check the results before setting block mode.\n// You can use query #2 to measure the rule impact on your network in audit mode before turning it to block mode.\n// Query #1 is used after setting it to block mode - to analyze the block stats.\n// Tags: #ASR\n// Query #2: investigate audit events - before turning the rule on in block mode\nlet minTime = ago(7d);\n// Enrich the ExploitGuard events with column saying if there was a nearby Windows Defender ATP alert or not.\n// If there was an alert, so this is probably malware, and it's good that it will be blocked.\n// If there was no alert, so it requires further analysis to determine if this is a clean file or some malware that was missed.\nlet alerts =\n    AlertInfo | join AlertEvidence on AlertId\n    | where Timestamp > minTime\n    | project DeviceName, DetectedTimestamp=Timestamp;\nDeviceEvents\n| where ActionType == \"AsrOfficeChildProcessAudited\" and Timestamp > minTime\n| project BlockedProcess=FileName, ParentProcess=InitiatingProcessFileName, DeviceName, Timestamp\n| join kind=leftouter (alerts) on DeviceName\n| extend HasNearbyAlert = abs(Timestamp - DetectedTimestamp) between (0min .. 5min)\n| summarize MachineCount=dcount(DeviceName),\n            RuleHits=count(),\n            NearbyAlertPercent=countif(HasNearbyAlert)*100.0 / count() \n            by BlockedProcess, ParentProcess\n| sort by MachineCount desc\n", "attributes": {"description": "These queries check telemetry from the Exploit Guard rule: Rule: Block Office applications from creating child processes.\n(Rule ID d4f940ab-401b-4efc-aadc-ad5f3c50688a).\nRead more about it here: https://docs.microsoft.com/windows/security/threat-protection/windows-defender-exploit-guard/attack-surface-reduction-exploit-guard.\nOftentimes organizations enable this rule in audit mode and check the results before setting block mode.\nYou can use query #2 to measure the rule impact on your network in audit mode before turning it to block mode.\nQuery #1 is used after setting it to block mode - to analyze the block stats.\nTags: #ASR.\nQuery #1: block stats.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardBlockOfficeChildProcess.yaml", "query_name": "ExploitGuardBlockOfficeChildProcess", "query": "DeviceEvents\n| where ActionType == \"AsrOfficeChildProcessBlocked\" and Timestamp > ago(7d)\n| project BlockedProcess=FileName, ParentProcess=InitiatingProcessFileName, DeviceName\n| summarize MachineCount=dcount(DeviceName), RuleHits=count() by BlockedProcess, ParentProcess\n| sort by MachineCount desc\n", "attributes": {"description": "These queries check telemetry from the Exploit Guard rule: Rule: Block Office applications from creating child processes.\n(Rule ID d4f940ab-401b-4efc-aadc-ad5f3c50688a).\nRead more about it here: https://docs.microsoft.com/windows/security/threat-protection/windows-defender-exploit-guard/attack-surface-reduction-exploit-guard.\nOftentimes organizations enable this rule in audit mode and check the results before setting block mode.\nYou can use query #2 to measure the rule impact on your network in audit mode before turning it to block mode.\nQuery #1 is used after setting it to block mode - to analyze the block stats.\nTags: #ASR.\nQuery #1: block stats.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardControlledFolderAccess%20%281%29.yaml", "query_name": "ExploitGuardControlledFolderAccess (1)", "query": " // Controlled Folder Access events across devices\nDeviceEvents\n | where ActionType startswith \"ControlledFolderAccess\" \n | summarize AsrDetections=count() by DeviceName\n | order by AsrDetections desc", "attributes": {"description": "Total Controlled Folder Access events.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardControlledFolderAccess%20%282%29.yaml", "query_name": "ExploitGuardControlledFolderAccess (2)", "query": "// Exploit Guard Controlled Folder Access details\nDeviceEvents \n| where ActionType contains \"ControlledFolderAccess\"\n| extend JsonOut = parse_json(AdditionalFields)\n| sort by Timestamp desc \n| project Timestamp, DeviceName, InitiatingProcessAccountName, ActionType,  \n         FileName, FolderPath, RemoteUrl, ProcessCommandLine, InitiatingProcessCommandLine,\n         JsonOut.IsAudit,JsonOut.Uri,JsonOut.RuleId,JsonOut.ActivityId\n", "attributes": {"description": "Total Controlled Folder Access events.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardControlledFolderAccess.yaml", "query_name": "ExploitGuardControlledFolderAccess", "query": "DeviceEvents\n | where ActionType  startswith \"ControlledFolderAccess\" \n | summarize NumberOfEvents=count() by ActionType\n | sort by NumberOfEvents desc\n", "attributes": {"description": "Total Controlled Folder Access events.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardNetworkProtectionEvents.yaml", "query_name": "ExploitGuardNetworkProtectionEvents", "query": "DeviceEvents\n| where Timestamp > ago(7d)\n| where  ActionType  =~ \"ExploitGuardNetworkProtectionBlocked\"\n| summarize count(RemoteUrl) by InitiatingProcessFileName, RemoteUrl, Audit_Only=tostring(parse_json(AdditionalFields).IsAudit)\n| sort by count_RemoteUrl desc\n", "attributes": {"description": "Simple query to show the unique network connections that were audited or blocked by ExploitGuard.\nFor more questions on this query, feel free to ping @FlyingBlueMonki on twitter or mattegen@microsoft.com via email.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardStats%20%281%29.yaml", "query_name": "ExploitGuardStats (1)", "query": "// View ExploitGuard audit events - but remove repeating events (e.g. multiple events with same machine, rule, file and process)\nDeviceEvents\n| where ActionType startswith \"ExploitGuard\" and ActionType endswith \"Audited\"\n| summarize Timestamp =max(Timestamp) by DeviceName, ActionType,FileName, FolderPath, InitiatingProcessCommandLine, InitiatingProcessFileName, InitiatingProcessFolderPath, InitiatingProcessId, SHA1 \n", "attributes": {"description": "Get stats on ExploitGuard blocks - count events and machines per rule.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/ExploitGuardStats.yaml", "query_name": "ExploitGuardStats", "query": "DeviceEvents\n| where ActionType startswith \"ExploitGuard\" and ActionType endswith \"Blocked\"\n// Count total stats - count events and machines per rule\n| summarize EventCount=count(), MachinesCount=dcount(DeviceName) by ActionType\n", "attributes": {"description": "Get stats on ExploitGuard blocks - count events and machines per rule.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/PUA%20ThreatName%20per%20Computer.yaml", "query_name": "PUA ThreatName per Computer", "query": "DeviceEvents\n| where ActionType == \"AntivirusDetection\"\n| extend ParsedFields=parse_json(AdditionalFields)\n| where ParsedFields.ThreatName contains \"PUA\"\n| project DeviceName, FileName, SHA1 , ThreatName=tostring(ParsedFields.ThreatName),\n          WasRemediated=tobool(ParsedFields.WasRemediated),\n          WasExecutingWhileDetected=tobool(ParsedFields.WasExecutingWhileDetected), Timestamp \n", "attributes": {"description": "Today MDE Alerts do not show PUA/WDAV ThreatName. This is a demonstration of how to get, for example, PUA Threat Names.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/SmartScreen%20app%20block%20ignored%20by%20user.yaml", "query_name": "SmartScreen app block ignored by user", "query": "let minTimeRange = ago(7d);\nlet smartscreenAppBlocks = \n    DeviceEvents\n    | where ActionType == \"SmartScreenAppWarning\" and Timestamp > minTimeRange\n            // Filter out SmartScreen test files downloaded from https://demo.smartscreen.msft.net/\n            and not (FileName startswith \"knownmalicious\" and FileName endswith \".exe\")\n    | extend ParsedFields=parse_json(AdditionalFields)\n    | project Timestamp, DeviceName, BlockedFileName=FileName, SHA1, Experience=tostring(ParsedFields.Experience), ActivityId=tostring(ParsedFields.ActivityId), InitiatingProcessFileName;\n// Query for UserDecision events - each one means the user has decided to ignore the warning and run the app.\nlet userIgnoredWarning=\n    DeviceEvents\n    | where ActionType == \"SmartScreenUserOverride\" and Timestamp > minTimeRange\n    | project DeviceName, ActivityId=extractjson(\"$.ActivityId\", AdditionalFields, typeof(string));\n// Join the block and user decision event using an ActivityId\nlet ignoredBlocks = \n\tsmartscreenAppBlocks\n\t| join kind=leftsemi (userIgnoredWarning) on DeviceName, ActivityId\n\t| project-away ActivityId;\nignoredBlocks\n// Select only blocks on \"Malicious\" files.\n// To hunt over Unknown/Untrusted files, remove the following where clause, but then you might want to join with additional signals.\n| where Experience == \"Malicious\"\n", "attributes": {"description": "Query for SmartScreen application blocks on files with \"Malicious\" reputation, where the user has decided to run the malware nontheless.\nRead more about SmartScreen here: https://docs.microsoft.com/windows/security/threat-protection/windows-defender-smartscreen/windows-defender-smartscreen-overview.\nData availability: These events are available only on Windows 10 version 1703 and onwards.\nTags: #SmartScreen.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/SmartScreen%20URL%20block%20ignored%20by%20user.yaml", "query_name": "SmartScreen URL block ignored by user", "query": "let minTimeRange = ago(7d);\nlet smartscreenUrlBlocks = \n    DeviceEvents\n    | where ActionType == \"SmartScreenUrlWarning\" and Timestamp > minTimeRange\n            // Filter out SmartScreen test URLs under https://demo.smartscreen.msft.net/\n            and RemoteUrl !startswith \"https://demo.smartscreen.msft.net/\" \n    | extend ParsedFields=parse_json(AdditionalFields)\n    | project Timestamp, DeviceName, BlockedUrl=RemoteUrl, Recommendation=tostring(ParsedFields.Recommendation), Experience=tostring(ParsedFields.Experience), ActivityId=tostring(ParsedFields.ActivityId);\n// Query for UserDecision events - each one means the user has decided to ignore the warning and run the app.\nlet userIgnoredWarning=\n    DeviceEvents\n    | where ActionType == \"SmartScreenUserOverride\" and Timestamp > minTimeRange\n    | project DeviceName, ActivityId=extractjson(\"$.ActivityId\", AdditionalFields, typeof(string));\n// Join the block and user decision event using an ActivityId\nlet ignoredBlocks = smartscreenUrlBlocks | join kind=leftsemi (userIgnoredWarning) on DeviceName, ActivityId | project-away ActivityId;\n// Optional additional filter - look only for cases where a file was downloaded from Microsoft Edge following the URL block being ignored \nlet edgeDownloads = \n    DeviceFileEvents\n    | where Timestamp > minTimeRange and InitiatingProcessFileName =~ \"browser_broker.exe\"\n    | summarize (DownloadTime, SHA1) = argmax(Timestamp, SHA1) by FileName, DeviceName, FileOriginUrl, FileOriginReferrerUrl;\nignoredBlocks\n| join kind=inner (edgeDownloads) on DeviceName\n| where DownloadTime - Timestamp between (0min .. 2min)\n| project-away DeviceName1\n", "attributes": {"description": "Query for SmartScreen URL blocks, where the user has decided to run the malware nontheless.\nAn additional optional filter is applied to query only for cases where Microsoft Edge has downloaded a file shortly after the ignored block.\nRead more about SmartScreen here: https://docs.microsoft.com/windows/security/threat-protection/windows-defender-smartscreen/windows-defender-smartscreen-overview.\nData availability: These events are available only on Windows 10 version 1703 and onwards.\nTags: #SmartScreen.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Protection%20events/Windows%20filtering%20events%20%28Firewall%29.yaml", "query_name": "Windows filtering events (Firewall)", "query": "DeviceEvents\n| where ActionType in (\"FirewallOutboundConnectionBlocked\", \"FirewallInboundConnectionBlocked\", \"FirewallInboundConnectionToAppBlocked\")\n| project DeviceId , Timestamp , InitiatingProcessFileName , InitiatingProcessParentFileName, RemoteIP, RemotePort, LocalIP, LocalPort\n| summarize MachineCount=dcount(DeviceId) by RemoteIP\n| top 100 by MachineCount desc\n", "attributes": {"description": "Get all filtering events done by the Windows filtering platform.\nThis includes any blocks done by Windows Firewall rules, but also blocks triggered by some 3rd party firewalls.\nWhen no Firewall rules are configured, the default behavior is to block all incoming network connections.\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/ASR--Rule-Ransomware-triggered.yaml", "query_name": "ARS Ransomware Event triggered", "query": "DeviceEvents\n| where Timestamp > ago(30d)\n| where ActionType has_any ('AsrRansomwareBlocked', 'AsrRansomwareAudited')\n| summarize arg_max(Timestamp, *), TotalEvents = count(), TriggeredFiles = make_set(FileName),FileHashes = make_set(SHA1),\nIntiatingProcesses = make_set(InitiatingProcessCommandLine) by DeviceName, AccountName\n| project Timestamp, DeviceName, AccountDomain, AccountName, TotalEvents, TriggeredFiles, FileHashes, IntiatingProcesses\n", "attributes": {"description": "This rule detects when the ASR rule AsrRansomwareBlocked or AsrRansomwareAudited is triggered.\nNo alert is generated by default. This could be the start of a ransomware attack. \nAdditional information available by Microsoft: \nhttps://docs.microsoft.com/microsoft-365/security/defender-endpoint/attack-surface-reduction-rules-reference?view=o365-worldwide#use-advanced-protection-against-ransomware\n", "techniques": ["T1486"], "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Backup%20deletion.yaml", "query_name": "Backup deletion", "query": "DeviceProcessEvents\n| where FileName =~ \"wmic.exe\"\n| where ProcessCommandLine has \"shadowcopy\" and ProcessCommandLine has \"delete\"\n| project DeviceId, Timestamp, InitiatingProcessFileName, FileName,\nProcessCommandLine, InitiatingProcessIntegrityLevel, InitiatingProcessParentFileName\n", "attributes": {"description": "This query identifies use of wmic.exe to delete shadow copy snapshots prior to encryption.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Check%20for%20multiple%20signs%20of%20ransomware%20activity.yaml", "query_name": "Check for multiple signs of ransomware activity", "query": "// Find attempts to stop processes using taskkill.exe\nlet taskKill = DeviceProcessEvents\n| where Timestamp > ago(1d)\n| where FileName =~ \"taskkill.exe\" \n| summarize taskKillCount = dcount(ProcessCommandLine), TaskKillList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 2m)\n| where taskKillCount > 10;\n// Find attempts to stop processes using net stop\nlet netStop = DeviceProcessEvents\n| where Timestamp > ago(1d)\n| where FileName =~ \"net.exe\" and ProcessCommandLine has \"stop\"\n| summarize netStopCount = dcount(ProcessCommandLine), NetStopList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 2m)\n| where netStopCount > 10;\n// Look for cipher.exe deleting data from multiple drives\nlet cipher = DeviceProcessEvents\n| where Timestamp > ago(1d)\n| where FileName =~ \"cipher.exe\" \n// cipher.exe /w flag used for deleting data \n| where ProcessCommandLine has \"/w\" \n| summarize CipherCount = dcount(ProcessCommandLine), \nCipherList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 1m) \n// cipher.exe accessing multiple drives in a short timeframe \n| where CipherCount > 1;\n// Look for use of wevtutil to clear multiple logs\nlet wevtutilClear = DeviceProcessEvents\n| where Timestamp > ago(1d)\n| where ProcessCommandLine has \"WEVTUTIL\" and ProcessCommandLine has \"CL\"\n| summarize LogClearCount = dcount(ProcessCommandLine), ClearedLogList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 5m)\n| where LogClearCount > 10;\n// Look for sc.exe disabling services\nlet scDisable = DeviceProcessEvents\n| where Timestamp > ago(1d)\n| where ProcessCommandLine has \"sc\" and ProcessCommandLine has \"config\" and ProcessCommandLine has \"disabled\"\n| summarize ScDisableCount = dcount(ProcessCommandLine), ScDisableList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 5m)\n| where ScDisableCount > 10;\n// Main query for counting and aggregating evidence\nDeviceProcessEvents\n| where Timestamp > ago(1d)\n| where FileName =~ \"vssadmin.exe\" and ProcessCommandLine has_any(\"list shadows\", \"delete shadows\")\nor FileName =~ \"fsutil.exe\" and ProcessCommandLine has \"usn\" and ProcessCommandLine has \"deletejournal\"\nor ProcessCommandLine has(\"bcdedit\") and ProcessCommandLine has_any(\"recoveryenabled no\", \"bootstatuspolicy ignoreallfailures\")\nor ProcessCommandLine has \"wbadmin\" and ProcessCommandLine has \"delete\" and ProcessCommandLine has_any(\"backup\", \"catalog\", \"systemstatebackup\")\nor (ProcessCommandLine has \"wevtutil\" and ProcessCommandLine has \"cl\") \nor (ProcessCommandLine has \"wmic\" and ProcessCommandLine has \"shadowcopy delete\")\nor (ProcessCommandLine has \"sc\" and ProcessCommandLine has \"config\" and ProcessCommandLine has \"disabled\")\n| extend Bcdedit = iff(ProcessCommandLine has \"bcdedit\" and ProcessCommandLine has_any(\"recoveryenabled no\", \"bootstatuspolicy ignoreallfailures\"), 1, 0)\n| extend ShadowCopyDelete = iff (ProcessCommandLine has \"shadowcopy delete\", 1, 0)\n| extend VssAdminShadows = iff(ProcessCommandLine has \"vssadmin\" and ProcessCommandLine has_any(\"list shadows\", \"delete shadows\"), 1, 0)\n| extend Wbadmin = iff(ProcessCommandLine has \"wbadmin\" and ProcessCommandLine has \"delete\" and ProcessCommandLine has_any(\"backup\", \"catalog\", \"systemstatebackup\"), 1,0)\n| extend Fsutil = iff(ProcessCommandLine has \"fsutil\" and ProcessCommandLine has \"usn\" and ProcessCommandLine has \"deletejournal\", 1, 0)\n| summarize FirstActivity = min(Timestamp), ReportId = any(ReportId), Commands = make_set(ProcessCommandLine) by DeviceId, Fsutil, Wbadmin, ShadowCopyDelete, Bcdedit, VssAdminShadows, bin(Timestamp, 6h)\n// Joining extra evidence\n| join kind=leftouter (wevtutilClear) on $left.DeviceId == $right.DeviceId\n| join kind=leftouter (cipher) on $left.DeviceId == $right.DeviceId\n| join kind=leftouter (netStop) on $left.DeviceId == $right.DeviceId\n| join kind=leftouter (taskKill) on $left.DeviceId == $right.DeviceId\n| join kind=leftouter (scDisable) on $left.DeviceId == $right.DeviceId\n| extend WevtutilUse = iff(LogClearCount > 10, 1, 0)\n| extend CipherUse = iff(CipherCount > 1, 1, 0)\n| extend NetStopUse = iff(netStopCount > 10, 1, 0)\n| extend TaskkillUse = iff(taskKillCount > 10, 1, 0)\n| extend ScDisableUse = iff(ScDisableCount > 10, 1, 0)\n// Adding up all evidence\n| mv-expand CommandList = NetStopList, TaskKillList, ClearedLogList, CipherList, Commands, ScDisableList\n// Format results\n| summarize BcdEdit = iff(make_set(Bcdedit) contains \"1\" , 1, 0), NetStop10PlusCommands = iff(make_set(NetStopUse) contains \"1\", 1, 0), Wevtutil10PlusLogsCleared = iff(make_set(WevtutilUse) contains \"1\", 1, 0),\nCipherMultipleDrives = iff(make_set(CipherUse) contains \"1\", 1, 0), Fsutil = iff(make_set(Fsutil) contains \"1\", 1, 0), ShadowCopyDelete = iff(make_set(ShadowCopyDelete) contains \"1\", 1, 0),\nWbadmin = iff(make_set(Wbadmin) contains \"1\", 1, 0), TaskKill10PlusCommand = iff(make_set(TaskkillUse) contains \"1\", 1, 0), VssAdminShadow = iff(make_set(VssAdminShadows) contains \"1\", 1, 0), \nScDisable = iff(make_set(ScDisableUse) contains \"1\", 1, 0), TotalEvidenceCount = count(CommandList), EvidenceList = make_set(Commands), StartofBehavior = min(FirstActivity) by DeviceId, bin(Timestamp, 1d)\n| extend UniqueEvidenceCount = BcdEdit + NetStop10PlusCommands + Wevtutil10PlusLogsCleared + CipherMultipleDrives + Wbadmin + Fsutil + TaskKill10PlusCommand + VssAdminShadow + ScDisable + ShadowCopyDelete\n| where UniqueEvidenceCount > 2\n", "attributes": {"description": "Instead of running several queries separately, you can also use a comprehensive query that checks for multiple signs of ransomware activity to identify affected devices. The following consolidated query:\nLooks for both relatively concrete and subtle signs of ransomware activity\nWeighs the presence of these signs\nIdentifies devices with a higher chance of being targets of ransomware\nWhen run, this consolidated query returns a list of devices that have exhibited multiple signs of attack. The count of each type of ransomware activity is also shown.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Clearing%20of%20forensic%20evidence%20from%20event%20logs%20using%20wevtutil.yaml", "query_name": "Clearing of forensic evidence from event logs using wevtutil", "query": "// Look for use of wevtutil to clear multiple logs\nDeviceProcessEvents\n| where Timestamp > ago(1d)\n| where ProcessCommandLine has \"WEVTUTIL\" and ProcessCommandLine has \"CL\"\n| summarize LogClearCount = dcount(ProcessCommandLine), ClearedLogList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 5m)\n| where LogClearCount > 10\n", "attributes": {"description": "This query checks for attempts to clear at least 10 log entries from event logs using wevtutil.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/DarkSide.yaml", "query_name": "DarkSide", "query": "DeviceProcessEvents \n| where FileName =~ \"rundll32.exe\" | where ProcessCommandLine matches regex @\".dll,#(?:1|3) worker[0-9]\\sjob[0-9]-[0-9]{4,}\"\n", "attributes": {"description": "Use this query to look for running DarkSide ransomware behavior in the environment\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Deletion%20of%20data%20on%20multiple%20drives%20using%20cipher%20exe.yaml", "query_name": "Deletion of data on multiple drives using cipher exe", "query": "// Look for cipher.exe deleting data from multiple drives\nDeviceProcessEvents\n| where Timestamp > ago(1d)\n| where FileName =~ \"cipher.exe\" \n// cipher.exe /w flag used for deleting data \n| where ProcessCommandLine has \"/w\" \n| summarize CipherCount = dcount(ProcessCommandLine),\nCipherList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 1m) \n// cipher.exe accessing multiple drives in a short timeframe \n| where CipherCount > 1\n", "attributes": {"description": "This query checks for attempts to delete data on multiple drives using cipher.exe. This activity is typically done by ransomware to prevent recovery of data after encryption.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Discovery%20for%20highly-privileged%20accounts.yaml", "query_name": "Discovery for highly-privileged accounts", "query": "DeviceProcessEvents\n| where FileName == \"net.exe\"\n// Create a set for the command lines\n| summarize makeset(ProcessCommandLine) by InitiatingProcessFileName, AccountName, DeviceId, bin(Timestamp, 5m)\n// Other process launches by Net in that same timeframe\n| where (set_ProcessCommandLine has \"admin\" \nand set_ProcessCommandLine has_any(\"domain\", \"enterprise\", \"backup operators\"))\nand set_ProcessCommandLine has \"group\" and set_ProcessCommandLine contains \"/do\"\n", "attributes": {"description": "Use this query to locate commands related to discovering highly privileged users in an environment, sometimes a precursor to ransomware\n", "techniques": NaN, "tactics": ["Discovery", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Distribution%20from%20remote%20location.yaml", "query_name": "Distribution from remote location", "query": "AlertInfo\n| where Title == \"File dropped and launched from remote location\"\n| join AlertEvidence on $left.AlertId == $right.AlertId\n// Looking for tools involved in potential distribution of ransomware\n| where FileName hasprefix \"psexe\" or (FileName matches regex @\"^([a-z0-9]){7}\\.exe$\" and FileName matches regex \"[0-9]{1,5}\")\nor ProcessCommandLine has \"accepteula\"\n", "attributes": {"description": "This query checks for alerts related to file drop and remote execution where the file name matches PsExec and similar tools used for distribution\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Fake%20Replies.yaml", "query_name": "Fake Replies", "query": "let SubjectTerms = pack_array('onus','equired','all','urvey','eb', 'eport','you','nation','me','itting','book','ocument','ill'); \nEmailEvents \n| where EmailDirection == \"Inbound\" \n| where Subject startswith \"RE:\" \n| where Subject has_any(SubjectTerms) \n| join EmailUrlInfo on $left.NetworkMessageId == $right.NetworkMessageId \n| where Url startswith \"https://docs.google.com/document/\" \n", "attributes": {"description": "Use this query to find spoofed reply emails that contain certain keywords in the subject. The emails are also checked for a link to a document in Google Docs.\nThese attacks have been observed leading to ransomware\n", "techniques": NaN, "tactics": ["Initial access", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/File%20Backup%20Deletion%20Alerts.yaml", "query_name": "File Backup Deletion Alerts", "query": "AlertInfo\n| where Title == \"File backups were deleted\"\n| join AlertEvidence on $left.AlertId == $right.AlertId\n", "attributes": {"description": "This query checks alerts related to file backup deletion and enriches with additional alert evidence information\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Gootkit%20File%20Delivery.yaml", "query_name": "Gootkit File Delivery", "query": "AlertInfo | where Title =~ \"Suspected delivery of Gootkit malware\" \n// Below section is to surface active follow-on Command and Control as a result of the above behavior. Comment out the below joins to see \n// only file create events where the malware may be present but has not yet been executed. \n//// \n// Get alert evidence \n| join AlertEvidence on $left.AlertId == $right.AlertId \n// Look for C2 \n| join DeviceNetworkEvents on $left.DeviceId == $right.DeviceId \n| where InitiatingProcessFileName =~ \"wscript.exe\" and InitiatingProcessCommandLine has \".zip\" and InitiatingProcessCommandLine has \".js\" \n| summarize by RemoteUrl, RemoteIP , DeviceId, InitiatingProcessCommandLine, Timestamp, InitiatingProcessFileName, AlertId, Title, AccountName\n", "attributes": {"description": "This query surfaces alerts related to Gootkit and enriches with command and control information, which has been observed delivering ransomware.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/HTA%20Startup%20Persistence.yaml", "query_name": "HTA Startup Persistence", "query": "DeviceFileEvents\n| where FolderPath contains @\"\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\\"\n| where FileName endswith \".hta\"\n", "attributes": {"description": "Use this query to locate persistence in Startup with HTA files.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/IcedId%20attachments.yaml", "query_name": "IcedId attachments", "query": "// Identify a reply or forward via subject line \nlet SubjectTerms = pack_array(\"RE:\",\"FW:\",\"FWD:\",\"AW:\",\"WG:\"); \nEmailEvents \n| where Subject has_any(SubjectTerms) \n| where EmailDirection == \"Inbound\" // Join on those emails by file type (doc or zip>doc) \n| join EmailAttachmentInfo on $left.NetworkMessageId == $right.NetworkMessageId \n| where AttachmentCount == 1 \n| where FileType has 'WordStorage' or FileType has 'WordStorage;Zip'\n", "attributes": {"description": "Use this query to locate emails with subject indicators of a reply or forward, and the attachment is a .doc, or a .zip containing a .doc. Review results for suspicious emails.\nIcedId can lead to ransomware\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/IcedId%20Delivery.yaml", "query_name": "IcedId Delivery", "query": "DeviceFileEvents \n| where InitiatingProcessFileName in~(\"msedge.exe\", \"chrome.exe\", \"explorer.exe\", \"7zFM.exe\", \"firefox.exe\", \"browser_broker.exe\") \n| where FileOriginReferrerUrl has \".php\" and FileOriginReferrerUrl has \".top\" and FileOriginUrl  has_any(\"googleusercontent\", \"google\", \"docs\")\n", "attributes": {"description": "Use this query to locate successful delivery of associated malicious downloads that can lead to ransomware\n", "techniques": NaN, "tactics": ["Initial access", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/IcedId%20email%20delivery.yaml", "query_name": "IcedId email delivery", "query": "EmailUrlInfo \n| where Url matches regex @\"\\bsites\\.google\\.com\\/view\\/(?:id)?\\d{9,}\\b\" \n| join EmailEvents on NetworkMessageId // Note: Replace the following subject lines with the one generated by your website's Contact submission form if no results return initially \n| where Subject has_any('Contact Us', 'New Submission', 'Contact Form', 'Form submission')\n", "attributes": {"description": "Use this query to locate emails and malicious downloads related to the IcedId activity that can lead to ransomware\n", "techniques": NaN, "tactics": ["Initial access", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/LaZagne%20Credential%20Theft.yaml", "query_name": "LaZagne Credential Theft", "query": "DeviceProcessEvents \n| where FileName =~ 'reg.exe'\n| where ProcessCommandLine has_all('save','hklm','sam')\n| project DeviceId, Timestamp, InitiatingProcessId, InitiatingProcessFileName, ProcessId, FileName, ProcessCommandLine\n", "attributes": {"description": "Use this query to locate processes executing credential theft activity, often LaZagne in ransomware compromises.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Potential%20ransomware%20activity%20related%20to%20Cobalt%20Strike.yaml", "query_name": "Potential ransomware activity related to Cobalt Strike", "query": "// Look for sc.exe disabling services\nAlertInfo \n// Attempts to clear security event logs. \n| where Title in(\"Event log was cleared\", \n// List alerts flagging attempts to delete backup files. \n\"File backups were deleted\", \n// Potential Cobalt Strike activity - Note that other threat activity can also \n// trigger alerts for suspicious decoded content \n\"Suspicious decoded content\", \n// Cobalt Strike activity \n\"\\'Atosev\\' malware was detected\", \n\"\\'Ploty\\' malware was detected\", \n\"\\'Bynoco\\' malware was detected\",\n\"\\'Cobaltstrike\\' malware was detected\",\n\"Echo command over pipe on localhost\",\n\"Known attack framework activity was observed\",\n\"An active \\'Cobaltstrike\\' malware was detected\",\n\"Suspicious \\'CobaltStrike\\' behavior was prevented\",\n\"Suspicious process launch by Rundll32.exe\") \n| extend AlertTime = Timestamp | distinct AlertTime, AlertId, Title \n| join AlertEvidence on $left.AlertId == $right.AlertId\n| summarize by DeviceId, AlertTime, Title, AlertId\n// Get device IDs\n| join DeviceLogonEvents on $left.DeviceId == $right.DeviceId \n// Creating 10 day Window surrounding alert activity \n| where Timestamp < AlertTime +5d and Timestamp > AlertTime - 5d // Projecting specific columns \n| project Title, DeviceName, DeviceId, Timestamp, LogonType, AccountDomain, AccountName, AccountSid, AlertTime, AlertId, RemoteIP, RemoteDeviceName\n", "attributes": {"description": "Use this query to look for alerts related to suspected ransomware and Cobalt Strike activity, a tool used in numerous ransomware campaigns\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Qakbot%20discovery%20activies.yaml", "query_name": "Qakbot discovery activies", "query": "DeviceProcessEvents \n| where InitiatingProcessFileName in~('mobsync.exe','explorer.exe')\n| where (FileName =~ 'net.exe' and InitiatingProcessCommandLine has_all('view','/all'))\n     or (FileName =~ 'whoami.exe' and InitiatingProcessCommandLine has '/all')\n     or (FileName =~ 'nslookup.exe' and InitiatingProcessCommandLine has_all('querytype=ALL','timeout=10'))\n     or (FileName =~ 'netstat.exe' and InitiatingProcessCommandLine has '-nao')\n     or (FileName =~ 'arp.exe' and InitiatingProcessCommandLine has '-a')\n     or (FileName =~ 'ping.exe' and InitiatingProcessCommandLine has '-t' and InitiatingProcessCommandLine endswith '127.0.0.1')\n| summarize DiscoveryCommands = dcount(InitiatingProcessCommandLine), make_set(InitiatingProcessFileName), make_set(FileName), make_set(InitiatingProcessCommandLine) by DeviceId, bin(Timestamp, 5m)   \n| where DiscoveryCommands >= 3\n", "attributes": {"description": "Use this query to locate injected processes launching discovery activity. Qakbot has been observed leading to ransomware in numerous instances.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Sticky%20Keys.yaml", "query_name": "Sticky Keys", "query": "// Checks for possible hijacking of Sticky Keys feature \nAlertInfo | where Title == \"Sticky Keys binary hijack detected\"\n", "attributes": {"description": "A technique used in numerous ransomware attacks is a Sticky Keys hijack for privilege escalation/persistence. Surface realted alerts with this query.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Stopping%20multiple%20processes%20using%20taskkill.yaml", "query_name": "Stopping multiple processes using taskkill", "query": "// Find attempts to stop processes using taskkill.exe\nDeviceProcessEvents\n| where Timestamp > ago(1d)\n| where FileName =~ \"taskkill.exe\" \n| summarize taskKillCount = dcount(ProcessCommandLine), TaskKillList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 2m)\n| where taskKillCount > 10\n", "attributes": {"description": "This query checks for attempts to stop at least 10 separate processes using the taskkill.exe utility. Run query\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Stopping%20processes%20using%20net%20stop.yaml", "query_name": "Stopping processes using net stop", "query": "// Find attempts to stop processes using net stop\nDeviceProcessEvents\n| where Timestamp > ago(1d)\n| where FileName =~ \"net.exe\" and ProcessCommandLine has \"stop\"\n| summarize netStopCount = dcount(ProcessCommandLine), NetStopList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 2m)\n| where netStopCount > 10\n", "attributes": {"description": "This query checks for attempts to stop at least 10 separate processes using the net stop command. Run query\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Suspicious%20Bitlocker%20Encryption.yaml", "query_name": "Suspicious Bitlocker Encryption", "query": "DeviceProcessEvents\n| where FileName =~ \"reg.exe\" \n// Search for BitLocker encryption being enabled without the chip\n    and ProcessCommandLine has \"EnableBDEWithNoTPM\"\n    // Using contains due to variant forms of capturing 1: 1, 0x1\n    and (ProcessCommandLine has \"true\" or ProcessCommandLine contains \"1\")\n// Search for this activity being launched by batch scripts, typically as: C:\\Windows\\[name].bat\n| where InitiatingProcessCommandLine has_all (@\"C:\\Windows\\\", \".bat\")\n", "attributes": {"description": "Looks for potential instances of bitlocker modifying registry settings to allow encryption, where it's executed via a .bat file.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Suspicious%20Google%20Doc%20Links.yaml", "query_name": "Suspicious Google Doc Links", "query": "EmailUrlInfo \n| where Url startswith \"https://docs.google.com/document/\" \n| join (EmailEvents \n| where EmailDirection == \"Inbound\" \n| where InternetMessageId matches regex \"\\\\<\\\\w{ 38,42} \\\\@\") on NetworkMessageId \n", "attributes": {"description": "Use this query to find emails with message IDs that resemble IDs used in known attack emails and contain a link a document in Google Docs. These behaviors have\nbeen observed leading to ransomware attacks.\n", "techniques": NaN, "tactics": ["Initial access", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Suspicious%20Image%20Load%20related%20to%20IcedId.yaml", "query_name": "Suspicious Image Load related to IcedId", "query": "DeviceImageLoadEvents \n| where InitiatingProcessFileName in~ ('rundll32.exe','regsvr32.exe') \n| where FileName endswith '.txt' or FileName endswith '.pdf'\n", "attributes": {"description": "Use this query to locate suspicious load image events by rundll32.exe or regsvr32.exe, a behavior associated with IcedId, which can lead to ransomware.\n", "techniques": NaN, "tactics": ["Execution", "Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Turning%20off%20services%20using%20sc%20exe.yaml", "query_name": "Turning off services using sc exe", "query": "// Look for sc.exe disabling services\nDeviceProcessEvents\n| where Timestamp > ago(1d)\n| where ProcessCommandLine has \"sc\" and ProcessCommandLine has \"config\" and ProcessCommandLine has \"disabled\"\n| summarize ScDisableCount = dcount(ProcessCommandLine), ScDisableList = make_set(ProcessCommandLine) by DeviceId, bin(Timestamp, 5m)\n| where ScDisableCount > 10\n", "attributes": {"description": "This query checks for attempts to turn off at least 10 existing services using sc.exe.\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/Turning%20off%20System%20Restore.yaml", "query_name": "Turning off System Restore", "query": "DeviceProcessEvents\n//Pivoting for rundll32  \n| where InitiatingProcessFileName =~ 'rundll32.exe'   \n//Looking for empty command line   \nand InitiatingProcessCommandLine !contains \" \" and InitiatingProcessCommandLine != \"\"  \n//Looking for schtasks.exe as the created process  \nand FileName in~ ('schtasks.exe')  \n//Disabling system restore   \nand ProcessCommandLine has 'Change' and ProcessCommandLine has 'SystemRestore' \nand ProcessCommandLine has 'disable'\n", "attributes": {"description": "This query identifies attempts to stop System Restore and prevent the system from creating restore points, which can be used to recover data encrypted by ransomware\n", "techniques": NaN, "tactics": ["Ransomware"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/DEV-0270/Add%20malicious%20user%20to%20Admins%20and%20RDP%20users%20group%20via%20PowerShell.yaml", "query_name": "Add malicious user to Admins and RDP users group via PowerShell", "query": "DeviceProcessEvents \n| where InitiatingProcessFileName =~ 'powershell.exe' \n| where InitiatingProcessCommandLine has_all('$admins=', 'System.Security.Principal.SecurityIdentifier', 'Translate', '-split', 'localgroup', '/add', '$rdp=')\n", "attributes": {"description": "Look for adding a user to Administrators in remote desktop users via PowerShell.\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/DEV-0270/Create%20new%20user%20with%20known%20DEV-0270%20username%20and%20password.yaml", "query_name": "Create new user with known DEV-0270 username and password", "query": "DeviceProcessEvents \n| where InitiatingProcessCommandLine has_all('net user', '/add') \n| parse InitiatingProcessCommandLine with * \"user \" username \" \"* \n| extend password = extract(@\"\\buser\\s+[^\\s]+\\s+([^\\s]+)\", 1, InitiatingProcessCommandLine) \n| where username in('DefaultAccount') or password in('P@ssw0rd1234', '_AS_@1394')\n", "attributes": {"description": "Search for the creation of a new user using a known DEV-0270 username/password schema.\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/DEV-0270/Disabling%20Services%20via%20Registry.yaml", "query_name": "Disabling Services via Registry", "query": "DeviceProcessEvents\n| where InitiatingProcessCommandLine has_all(@'\"reg\"', 'add', @'\"HKLM\\SOFTWARE\\Policies\\', '/v','/t', 'REG_DWORD', '/d', '/f')\n  and InitiatingProcessCommandLine has_any('DisableRealtimeMonitoring', 'UseTPMKey', 'UseTPMKeyPIN', 'UseAdvancedStartup', \n  'EnableBDEWithNoTPM', 'RecoveryKeyMessageSource')\n", "attributes": {"description": "Search for processes modifying the registry to disable security features.\n", "techniques": NaN, "tactics": ["Defense Evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/DEV-0270/DLLHost.exe%20file%20creation%20via%20PowerShell.yaml", "query_name": "DLLHost.exe file creation via PowerShell", "query": "DeviceProcessEvents \n| where InitiatingProcessFileName =~ 'powershell.exe' \n| where InitiatingProcessCommandLine has_all('$file=', 'dllhost.exe', 'Invoke-WebRequest', '-OutFile')\n", "attributes": {"description": "Identify masqueraded DLLHost.exe file created by PowerShell.\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/DEV-0270/DLLHost.exe%20WMIC%20domain%20discovery.yaml", "query_name": "DLLHost.exe WMIC domain discovery", "query": "DeviceProcessEvents \n| where InitiatingProcessFileName =~ \"dllhost.exe\" and InitiatingProcessCommandLine == \"dllhost.exe\" \n| where ProcessCommandLine has \"wmic computersystem get domain\"\n", "attributes": {"description": "Identify dllhost.exe using WMIC to discover additional hosts and associated domain.\n", "techniques": NaN, "tactics": ["Reconnaissance"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/DEV-0270/Email%20data%20exfiltration%20via%20PowerShell.yaml", "query_name": "Email data exfiltration via PowerShell", "query": "DeviceProcessEvents \n| where FileName =~ 'powershell.exe' \n| where ProcessCommandLine has_all('Add-PSSnapin', 'Get-Recipient', '-ExpandProperty', 'EmailAddresses', 'SmtpAddress', '-hidetableheaders')\n", "attributes": {"description": "Identify email exfiltration conducted by PowerShell.\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/DEV-0270/Modifying%20the%20registry%20to%20add%20a%20ransom%20message%20notification.yaml", "query_name": "Modifying the registry to add a ransom message notification", "query": "DeviceProcessEvents \n| where InitiatingProcessCommandLine has_all('\"reg\"', 'add', @'\"HKLM\\SOFTWARE\\Policies\\', '/v','/t', 'REG_DWORD', '/d', '/f', 'RecoveryKeyMessage', 'Your drives are Encrypted!', '@') \n", "attributes": {"description": "Identify registry modifications that is indicative of a ransom note tied to DEV-0270.\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Ransomware/DEV-0270/PowerShell%20adding%20exclusion%20path%20for%20Microsoft%20Defender%20of%20ProgramData.yaml", "query_name": "PowerShell adding exclusion path for Microsoft Defender of ProgramData", "query": "DeviceProcessEvents \n| where FileName =~ \"powershell.exe\" and ProcessCommandLine has_all(\"try\", \"Add-MpPreference\", \"-ExclusionPath\", \"ProgramData\", \"catch\")\n", "attributes": {"description": "Identify PowerShell creating an exclusion path of ProgramData directory for Microsoft Defender to not monitor.\n", "techniques": NaN, "tactics": ["Defense Evasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Troubleshooting/Connectivity%20Failures%20by%20Device.yaml", "query_name": "Connectivity Failures by Device", "query": "let TargetURLs = dynamic(['crl.microsoft.com',\n'ctldl.windowsupdate.com',\n'www.microsoft.com',\n'events.data.microsoft.com',\n'login.microsoftonline.com',\n'login.live.com',\n'settings-win.data.microsoft.com',\n'x.cp.wd.microsoft.com',\n'cdn.x.cp.wd.microsoft.com',\n'eu-cdn.x.cp.wd.microsoft.com',\n'wu-cdn.x.cp.wd.microsoft.com',\n'officecdn-microsoft-com.akamaized.net',\n'packages.microsoft.com',\n'login.windows.net  ',\n'unitedstates.x.cp.wd.microsoft.com',\n'us.vortex-win.data.microsoft.com',\n'us-v20.events.data.microsoft.com',\n'winatp-gw-cus.microsoft.com',\n'winatp-gw-eus.microsoft.com',\n'winatp-gw-cus3.microsoft.com',\n'winatp-gw-eus3.microsoft.com',\n'automatedirstrprdcus.blob.core.windows.net',\n'automatedirstrprdeus.blob.core.windows.net',\n'automatedirstrprdcus3.blob.core.windows.net',\n'automatedirstrprdeus3.blob.core.windows.net',\n'ussus1eastprod.blob.core.windows.net',\n'ussus2eastprod.blob.core.windows.net',\n'ussus3eastprod.blob.core.windows.net',\n'ussus4eastprod.blob.core.windows.net',\n'wsus1eastprod.blob.core.windows.net',\n'wsus2eastprod.blob.core.windows.net',\n'ussus1westprod.blob.core.windows.net',\n'ussus2westprod.blob.core.windows.net',\n'ussus3westprod.blob.core.windows.net',\n'ussus4westprod.blob.core.windows.net',\n'wsus1westprod.blob.core.windows.net',\n'wsus2westprod.blob.core.windows.net',\n'europe.x.cp.wd.microsoft.com',\n'eu.vortex-win.data.microsoft.com',\n'eu-v20.events.data.microsoft.com',\n'winatp-gw-neu.microsoft.com',\n'winatp-gw-weu.microsoft.com',\n'automatedirstrprdneu.blob.core.windows.net',\n'automatedirstrprdweu.blob.core.windows.net',\n'usseu1northprod.blob.core.windows.net',\n'wseu1northprod.blob.core.windows.net',\n'usseu1westprod.blob.core.windows.net',\n'wseu1westprod.blob.core.windows.net',\n'unitedkingdom.x.cp.wd.microsoft.com',\n'uk.vortex-win.data.microsoft.com',\n'uk-v20.events.data.microsoft.com',\n'winatp-gw-uks.microsoft.com',\n'winatp-gw-ukw.microsoft.com',\n'automatedirstrprduks.blob.core.windows.net',\n'automatedirstrprdukw.blob.core.windows.net',\n'ussuk1southprod.blob.core.windows.net',\n'wsuk1southprod.blob.core.windows.net',\n'ussuk1westprod.blob.core.windows.net',\n'wsuk1westprod.blob.core.windows.net',\n'go.microsoft.com ',\n'definitionupdates.microsoft.com ',\n'fe3cr.delivery.mp.microsoft.com/ClientWebService/client.asmx',\n'msdl.microsoft.com',\n'vortex-win.data.microsoft.com']);\nDeviceNetworkEvents\n| where isnotempty(RemoteUrl) and ActionType == 'ConnectionFailed'\n| extend Domain = case(RemoteUrl contains \"//\", parse_url(RemoteUrl).Host, RemoteUrl)\n| where Domain in(TargetURLs)\n| summarize arg_max(Timestamp, DeviceName), ConnectionFailures = count() by DeviceId, Domain\n| extend DomainDetails = pack(Domain, ConnectionFailures)\n| summarize DomainDetails = make_list(DomainDetails), LastConnectionFailure = any(Timestamp), DeviceName = any(DeviceName), TotalConnectionFailures = sum(ConnectionFailures) by DeviceId\n| order by TotalConnectionFailures desc\n", "attributes": {"description": "This query checks for network connection failures to Microsoft Defender for Endpoint URLs.\nThe output includes any device with 1+ connectivity failures, a list of the domains they\nfailed to connect to (including the number of failures), as well as the overall number of\nfailures in the time period. Results are sorted by the total number of connection failures\nby the device.\n", "techniques": NaN, "tactics": ["Misconfiguration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/Troubleshooting/Connectivity%20Failures%20by%20Domain.yaml", "query_name": "Connectivity Failures by Domain", "query": "let TargetURLs = dynamic(['winatp-gw-cus.microsoft.com', 'winatp-gw-eus.microsoft.com', 'winatp-gw-weu.microsoft.com',\n    'winatp-gw-neu.microsoft.com', 'winatp-gw-uks.microsoft.com', 'winatp-gw-ukw.microsoft.com', 'winatp-gw-usgv.microsoft.com',\n    'winatp-gw-usgt.microsoft.com', 'eu.vortex-win.data.microsoft.com', 'us.vortex-win.data.microsoft.com',\n    'uk.vortex-win.data.microsoft.com', 'events.data.microsoft.com', 'settings-win.data.microsoft.com', 'eu-v20.events.data.microsoft.com',\n    'uk-v20.events.data.microsoft.com', 'us-v20.events.data.microsoft.com', 'us4-v20.events.data.microsoft.com',\n    'us5-v20.events.data.microsoft.com', 'ctldl.windowsupdate.com']);\nDeviceNetworkEvents\n| where isnotempty(RemoteUrl) and ActionType == 'ConnectionFailed'\n| extend Domain = case(RemoteUrl contains \"//\", parse_url(RemoteUrl).Host, RemoteUrl)\n| where Domain in(TargetURLs)\n| summarize (LastConnectionFailure, DeviceName) = arg_max(Timestamp, DeviceName), ConnectionFailures = count(), DistinctMachines = dcount(DeviceId) by Domain\n| order by DistinctMachines desc\n", "attributes": {"description": "This query is designed to help troubleshoot connectivity issues to Microsoft Defender for Endpoint URLs.\nIt provides a summary of the number of failures which occurred, the number of distinct machines that failed\nto connect to the URL, and sorts them by the sum of the overall number of failures recorded.\n", "techniques": NaN, "tactics": ["Malware, component"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/TVM/Detect_CISA_Alert_AA22-117A2021_Top_Routinely_Exploited_Vulnerabilities.yaml", "query_name": "Detect CISA Alert (AA22-117A) 2021 Top Routinely Exploited Vulnerabilities", "query": "// CISA Alert (AA22-117A) 2021 Top Routinely Exploited Vulnerabilities https://www.cisa.gov/uscert/ncas/alerts/aa22-117a\nlet CISAAlertAA22117A= dynamic(\n[\n\"CVE-2021-44228\", // Log4Shell - Apache Log4j - Remote code execution (RCE)\n\"CVE-2021-40539\", // Zoho ManageEngine AD SelfService Plus - RCE\n\"CVE-2021-34523\", // ProxyShell - Microsoft Exchange Server - Elevation of privilege\n\"CVE-2021-34473\", // ProxyShell - Microsoft Exchange Server - RCE\n\"CVE-2021-31207\", // ProxyShell - Microsoft Exchange Server - Security feature bypass\n\"CVE-2021-27065\", // ProxyLogon - Microsoft Exchange Server - RCE\n\"CVE-2021-26858\", // ProxyLogon - Microsoft Exchange Server - RCE\n\"CVE-2021-26857\", // ProxyLogon - Microsoft Exchange Server - RCE\n\"CVE-2021-26855\", // ProxyLogon - Microsoft Exchange Server - RCE\n\"CVE-2021-26084\", // Atlassian Confluence Server and Data Center - Arbitrary code execution\n\"CVE-2021-21972\", // VMware vSphere Client - RCE \n\"CVE-2020-1472\", // ZeroLogon - Microsoft Netlogon Remote Protocol (MS-NRPC) - Elevation of privilege\n\"CVE-2020-0688\", // Microsoft Exchange Server - RCE\n\"CVE-2019-11510\", // Pulse Secure Pulse Connect Secure - Arbitrary file reading\n\"CVE-2018-13379\", // Fortinet FortiOS and FortiProxy - Path traversal\n\"CVE-2021-42237\", // Sitecore XP - RCE\n\"CVE-2021-35464\", // ForgeRock OpenAM server - RCE\n\"CVE-2021-27104\", // Accellion FTA - OS command execution\n\"CVE-2021-27103\", // Accellion FTA - Server-side request forgery\n\"CVE-2021-27102\", // Accellion FTA - OS command execution\n\"CVE-2021-27101\", // Accellion FTA - SQL injection\n\"CVE-2021-21985\", // SQL injection - RCE\n\"CVE-2021-20038\", // SonicWall Secure Mobile Access (SMA) - RCE\n\"CVE-2021-40444\", // Microsoft MSHTML - RCE\n\"CVE-2021-34527\", // Microsoft Windows Print Spooler - RCE\n\"CVE-2021-3156\", // Suco - Microsoft Windows Print Spooler\n\"CVE-2021-27852\", // Checkbox Survey - Remote arbitrary code execution\n\"CVE-2021-22893\", // Pulse Secure Pulse Connect Secure - Remote arbitrary code execution\n\"CVE-2021-20016\", // SonicWall SSLVPN SMA100 - Improper SQL command neutralization, allowing for credential access\n\"CVE-2021-1675\", // Windows Print Spooler - RCE\n\"CVE-2020-2509\", // QNAP QTS and QuTS hero - Remote arbitrary code execution\n\"CVE-2019-19781\", // Citrix Application Delivery Controller (ADC) and Gateway - Arbitrary code execution\n\"CVE-2019-18935\", // Progress Telerik UI for ASP.NET AJAX - Code execution\n\"CVE-2018-0171\", // Cisco IOS Software and IOS XE Software - Remote arbitrary code execution\n\"CVE-2017-11882\", // Microsoft Office - RCE\n\"CVE-2017-0199\" // Microsoft Office - RCE\n ]\n);\nDeviceTvmSoftwareVulnerabilitiesKB\n| where CveId in(CISAAlertAA22117A)\n| join DeviceTvmSoftwareVulnerabilities on CveId\n| project-away CveId1, VulnerabilitySeverityLevel1, AffectedSoftware\n", "attributes": {"description": "This advanced hunting query detects CISA Alert (AA22-117A) 2021 Top Routinely Exploited Vulnerabilities https://www.cisa.gov/uscert/ncas/alerts/aa22-117a\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/TVM/devices_with_vuln_and_users_received_payload%20%281%29.yaml", "query_name": "devices_with_vuln_and_users_received_payload (1)", "query": "// 1.\tA list of all devices that have this vulnerability\n// 2.\tA list of all users that uses those devices\n// If these users opened those .mkv files\nlet all_computers_with_vlcvln=\nDeviceTvmSoftwareVulnerabilities \n| where SoftwareName contains \"vlc\" \n| summarize makelist(DeviceName);\nDeviceFileEvents \n| where DeviceName  in (all_computers_with_vlcvln)\n| where FileName contains \"mkv\" \n", "attributes": {"description": "// Author: jan geisbauer\n// @janvonkirchheim\n// ------------------------\n// 1.\tA list of all devices that have this vulnerability\n// 2.\tA list of all users that uses those devices\n// 3.\tIf these users received .mkv files recently\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/TVM/devices_with_vuln_and_users_received_payload.yaml", "query_name": "devices_with_vuln_and_users_received_payload", "query": "let all_computers_with_vlcvln=\nDeviceTvmSoftwareVulnerabilities \n| where SoftwareName contains \"vlc\" \n| summarize makelist(DeviceName);\nlet all_affected_users=\nDeviceInfo\n| where DeviceName in (all_computers_with_vlcvln)\n| mvexpand todynamic(LoggedOnUsers)\n| extend ParsedFields = parsejson(LoggedOnUsers)\n| project UserName = ParsedFields.UserName\n| summarize makelist(tolower(UserName));\nlet all_email_addresses_aff_users=\nIdentityInfo\n| where tolower(AccountName) in (all_affected_users)\n| summarize makelist(tolower(EmailAddress));\nEmailAttachmentInfo\n| where FileName contains \".mkv\"\n| where tolower(RecipientEmailAddress) in (all_email_addresses_aff_users)\n", "attributes": {"description": "// Author: jan geisbauer\n// @janvonkirchheim\n// ------------------------\n// 1.\tA list of all devices that have this vulnerability\n// 2.\tA list of all users that uses those devices\n// 3.\tIf these users received .mkv files recently\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/TVM/Microsoft%20Defender%20Anti%20virus%20Engine%20details.yaml", "query_name": "Microsoft Defender AV Engine up to date info", "query": "let expiringPublishdate = ago(8d);\nDeviceTvmInfoGathering\n| extend DataRefreshTimestamp = Timestamp,    \nAvIsEngineUpToDateTemp = tostring(AdditionalFields.AvIsEngineUptodate),   \nAvSignatureDataRefreshTime = todatetime(AdditionalFields.AvSignatureDataRefreshTime), \nAvSignaturePublishTime = todatetime(AdditionalFields.AvSignaturePublishTime),    \nAvEngineVersion =  tostring(AdditionalFields.AvEngineVersion)\n| extend AvIsEngineUpToDate = iif(((((isempty(AvIsEngineUpToDateTemp)\nor (isnull(AvSignatureDataRefreshTime)))\nor (isnull(AvSignaturePublishTime)))\nor (AvSignatureDataRefreshTime < expiringPublishdate))\nor (AvSignaturePublishTime < expiringPublishdate)), \"Unknown\", tostring(AvIsEngineUpToDateTemp))  \n| extend AvEngineVersion = iif(AvEngineVersion == \"\", \"Unknown\", AvEngineVersion)\n| project DeviceId, DeviceName,  OSPlatform, AvEngineVersion, DataRefreshTimestamp, AvIsEngineUpToDate, AvSignaturePublishTime, AvSignatureDataRefreshTime\n| summarize DeviceCount = count(), DataRefreshTimestamp = max(DataRefreshTimestamp), EngineUpToDateDeviceCount = countif(AvIsEngineUpToDate == \"true\"), EngineNotUpToDateDeviceCount = countif(AvIsEngineUpToDate == \"false\"), EngineNotAvailableDeviceCount = countif(AvIsEngineUpToDate == \"Unknown\") by OSPlatform,AvEngineVersion\n", "attributes": {"description": "'Provides the Engine version and total count of up to date devices, not up to date devices and count of devices whose status is not available relevant to the Engine version.'\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/TVM/Microsoft%20Defender%20Anti%20virus%20Platform%20details.yaml", "query_name": "Microsoft Defender AV Platform up to date information", "query": "let expiringPublishdate = ago(8d);\nDeviceTvmInfoGathering\n| extend DataRefreshTimestamp = Timestamp,    \nAvIsPlatformUpToDateTemp=tostring(AdditionalFields.AvIsPlatformUptodate),\nAvSignatureDataRefreshTime = todatetime(AdditionalFields.AvSignatureDataRefreshTime), \nAvSignaturePublishTime = todatetime(AdditionalFields.AvSignaturePublishTime),\nAvPlatformVersion =  tostring(AdditionalFields.AvPlatformVersion) \n| extend AvIsPlatformUpToDate = iif(((((isempty(AvIsPlatformUpToDateTemp)\nor (isnull(AvSignatureDataRefreshTime)))\nor (isnull(AvSignaturePublishTime)))\nor (AvSignatureDataRefreshTime < expiringPublishdate))\nor (AvSignaturePublishTime < expiringPublishdate)), \"Unknown\", tostring(AvIsPlatformUpToDateTemp)) \n| extend AvPlatformVersion = iif(AvPlatformVersion == \"\", \"Unknown\", AvPlatformVersion)\n| project DeviceId, DeviceName,  OSPlatform, AvPlatformVersion, DataRefreshTimestamp, AvIsPlatformUpToDate, AvSignaturePublishTime, AvSignatureDataRefreshTime\n| summarize DeviceCount = count(), DataRefreshTimestamp = max(DataRefreshTimestamp), PlatformUpToDateDeviceCount = countif(AvIsPlatformUpToDate == \"true\"),  PlatformNotUpToDateDeviceCount = countif(AvIsPlatformUpToDate == \"false\"),  PlatformNotAvailableDeviceCount = countif(AvIsPlatformUpToDate == \"Unknown\") by OSPlatform,AvPlatformVersion\n", "attributes": {"description": "'Provides the Platform version and total count of up to date devices, not up to date devices and count of devices whose status is not available relevant to the Platform version.'\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/TVM/Microsoft%20Defender%20Anti%20virus%20Security%20Intelligence%20details.yaml", "query_name": "Microsoft Defender AV Security Intelligence up to date information", "query": "let expiringPublishdate = ago(8d);\nDeviceTvmInfoGathering\n| extend DataRefreshTimestamp = Timestamp, \nAvIsSignatureUpToDateTemp = tostring(AdditionalFields.AvIsSignatureUptoDate),\nAvSignatureDataRefreshTime = todatetime(AdditionalFields.AvSignatureDataRefreshTime), \nAvSignaturePublishTime = todatetime(AdditionalFields.AvSignaturePublishTime),\nAvSignatureVersion =  tostring(AdditionalFields.AvSignatureVersion)  \n| extend AvIsSignatureUpToDate = iif(((((isempty(AvIsSignatureUpToDateTemp)\nor (isnull(AvSignatureDataRefreshTime)))\nor (isnull(AvSignaturePublishTime)))\nor (AvSignaturePublishTime < expiringPublishdate))\nor (AvIsSignatureUpToDateTemp == True\nand AvSignaturePublishTime < expiringPublishdate)), \"Unknown\", tostring(AvIsSignatureUpToDateTemp))\n| extend AvSecurityIntelVersion = iif(AvSignatureVersion == \"\", \"Unknown\", AvSignatureVersion)\n| project DeviceId, DeviceName, OSPlatform, AvSecurityIntelVersion,  DataRefreshTimestamp, AvIsSignatureUpToDate, AvSignaturePublishTime, AvSignatureDataRefreshTime\n| summarize DeviceCount = count(), DataRefreshTimestamp = max(DataRefreshTimestamp), SecurityIntelUpToDateDeviceCount = countif(AvIsSignatureUpToDate == \"true\"), SecurityIntelNotUpToDateDeviceCount = countif(AvIsSignatureUpToDate == \"false\"), SecurityIntelNotAvailableDeviceCount = countif(AvIsSignatureUpToDate == \"Unknown\") by OSPlatform,AvSecurityIntelVersion\n", "attributes": {"description": "'Provides the Security Intelligence version and total count of up to date devices, not up to date devices and count of devices whose status is not available relevant to the security intelligence version.'\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/TVM/Microsoft%20Defender%20AV%20details.yaml", "query_name": "Microsoft Defender AV details", "query": "let expiringPublishdate = ago(8d);\nDeviceTvmInfoGathering\n| extend AvMode = iif(tostring(AdditionalFields.AvMode) == '0', 'Active', iif(tostring(AdditionalFields.AvMode) == '1', 'Passive',iif(tostring(AdditionalFields.AvMode) == '2', 'Disabled', iif(tostring(AdditionalFields.AvMode) == '5', 'PassiveAudit',iif(tostring(AdditionalFields.AvMode) == '4', 'EDR Blocked' ,'Unknown')))))  \n| extend AvIsSignatureUpToDateTemp = tostring(AdditionalFields.AvIsSignatureUptoDate), DataRefreshTimestamp= Timestamp,\nAvIsPlatformUptodateTemp=tostring(AdditionalFields.AvIsPlatformUptodate),\nAvIsEngineUptodateTemp = tostring(AdditionalFields.AvIsEngineUptodate), \nAvSignatureDataRefreshTime = todatetime(AdditionalFields.AvSignatureDataRefreshTime), \nAvSignaturePublishTime = todatetime(AdditionalFields.AvSignaturePublishTime),\nAvSignatureVersion =  tostring(AdditionalFields.AvSignatureVersion),\nAvEngineVersion =  tostring(AdditionalFields.AvEngineVersion),\nAvPlatformVersion =  tostring(AdditionalFields.AvPlatformVersion)\n| extend AvIsSignatureUpToDate = iif(((((isnull(AvIsSignatureUpToDateTemp)\nor (isnull(AvSignatureDataRefreshTime)))\nor (isnull(AvSignaturePublishTime))))\nor (AvIsSignatureUpToDateTemp == \"true\"\nand AvSignaturePublishTime < expiringPublishdate)), \"Unknown\", tostring(AvIsSignatureUpToDateTemp))\n| extend AvIsEngineUpToDate = iif(((((isnull(AvIsEngineUptodateTemp)\nor (isnull(AvSignatureDataRefreshTime)))\nor (isnull(AvSignaturePublishTime)))\nor (AvSignatureDataRefreshTime < expiringPublishdate))\nor (AvSignaturePublishTime < expiringPublishdate)), \"Unknown\", tostring(AvIsEngineUptodateTemp))\n| extend AvIsPlatformUpToDate = iif(((((isnull(AvIsPlatformUptodateTemp)\nor (isnull(AvSignatureDataRefreshTime)))\nor (isnull(AvSignaturePublishTime)))\nor (AvSignatureDataRefreshTime < expiringPublishdate))\nor (AvSignaturePublishTime < expiringPublishdate)), \"Unknown\", tostring(AvIsPlatformUptodateTemp))\n| project DeviceId, DeviceName, DataRefreshTimestamp, OSPlatform, AvMode, AvSignatureVersion, AvIsSignatureUpToDate, AvEngineVersion, AvIsEngineUpToDate, AvPlatformVersion , AvIsPlatformUpToDate, AvSignaturePublishTime, AvSignatureDataRefreshTime\n//| where DataRefreshTimestamp between (datetime(\"2022-07-19 00:00:00\") .. datetime(\"2022-07-19 18:01:00\"))\n| where DataRefreshTimestamp > ago(6h)\n| order by DeviceName asc\n| limit 10000\n", "attributes": {"description": "'This query will identify the Microsoft Defender Antivirus Security Intelligence version, Security Intelligence up to date value, Engine version, Engine up to date value,  Product version (aka Platform version),Product (aka Platform) up to date value, Security Intelligence publish/build timestamp, Security intel refresh timestamp and provide a list of devices with these details.'\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Microsoft%20365%20Defender/TVM/Microsoft%20Defender%20AV%20mode%20device%20count.yaml", "query_name": "Microsoft Defender AV mode device count", "query": "DeviceTvmInfoGathering\n| extend AvMode = iif(tostring(AdditionalFields.AvMode) == '0', 'Active', iif(tostring(AdditionalFields.AvMode) == '1', 'Passive',iif(tostring(AdditionalFields.AvMode) == '2', 'Disabled', iif(tostring(AdditionalFields.AvMode) == '5', 'PassiveAudit',iif(tostring(AdditionalFields.AvMode) == '4', 'EDR Blocked' ,'Unknown')))))  \n| summarize DeviceCount = count() by AvMode\n", "attributes": {"description": "'Provides the Anti virus mode and device count falling under that AV mode.'\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/AADPrivilegedAccountsFailedMFA.yaml", "query_name": "Privileged Accounts - Failed MFA", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet aadFunc = (tableName:string){\nIdentityInfo\n| where AssignedRoles contains \"Admin\"\n| mv-expand AssignedRoles\n| extend Roles = tostring(AssignedRoles), AccountUPN = tolower(AccountUPN)\n| where Roles contains \"Admin\"\n| distinct Roles, AccountUPN\n| join kind=inner (\n  // Failed Signins attempts with reasoning related to MFA.\n  table(tableName)\n  | where TimeGenerated between(starttime..endtime)\n  | where ResultDescription has_any (\"MFA\", \"second factor\", \"multi-factor\", \"second factor\") or ResultType in (50074, 50076, 50079, 50072, 53004, 500121)\n) on $left.AccountUPN == $right.UserPrincipalName\n| extend timestamp = TimeGenerated, IPCustomEntity = IPAddress, AccountCustomEntity = UserPrincipalName\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "' Identifies failed MFA attempts from Privileged accounts. Privileged accounts list can be based on IdentityInfo UEBA table or built-in watchlist.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/AnomolousSignInsBasedonTime.yaml", "query_name": "Anomolous Sign Ins Based on Time", "query": "let admins = (IdentityInfo\n| where AssignedRoles contains \"Admin\"\n| summarize by tolower(AccountUPN));\nlet ts_data = (SigninLogs\n| where TimeGenerated > ago(14d)\n| extend AccountUPN = tolower(UserPrincipalName)\n| where AccountUPN in (admins)\n| make-series count() on TimeGenerated step 1h by UserPrincipalName\n| extend series_decompose(count_)\n| extend NoLogons = count_);\nlet TimeSeriesAlerts=ts_data\n| extend (anomalies, score, baseline) = series_decompose_anomalies(count_, 2.5, -1, 'linefit',0, 'ctukey', 3)\n| mv-expand NoLogons to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)\n| where anomalies > 0\n| where NoLogons > 15\n| project UserPrincipalName, TimeGenerated, NoLogons, baseline, anomalies, score;\nTimeSeriesAlerts\n| join kind=inner (\nSigninLogs\n| summarize ResultTypeCount=count(),ResultTypes=make_set(ResultType), Locations=make_set(Location), Apps=make_set(AppDisplayName), Ips=make_set( IPAddress) by UserPrincipalName, bin(TimeGenerated, 1h)\n) on UserPrincipalName, TimeGenerated\n| summarize AnomolyTimes = make_set(TimeGenerated), Ips = make_set(Ips), Apps = make_set(Apps), sum(anomalies), Locations=make_set(Locations) by UserPrincipalName\n| sort by sum_anomalies desc\n", "attributes": {"description": "'Identifies anomolies in signin events based on the volume of signin events over time. Use this to identify suspicious authentication patterns such as spikes in activity or out of hours events.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/ApplicationGrantedEWSPermissions.yaml", "query_name": "Application Granted EWS Permissions", "query": "AuditLogs\n| where Category == \"ApplicationManagement\"\n| where OperationName has \"Add app role assignment to service principal\"\n| extend UA = tostring(AdditionalDetails[0].value)\n| mv-expand TargetResources\n| extend ModifiedProps = TargetResources.modifiedProperties\n| mv-expand ModifiedProps\n| where ModifiedProps.newValue has \"Use Exchange Web Services with full access to all mailboxes\"\n| extend Action = ModifiedProps.newValue\n| extend User = tolower(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n| join kind=inner AuditLogs on CorrelationId\n| mv-expand TargetResources1\n| mv-expand TargetResources1.modifiedProperties\n| project-reorder TargetResources1_modifiedProperties\n| extend displayName_ = tostring(TargetResources1_modifiedProperties.displayName)\n| extend AppId = iff(tostring(TargetResources1_modifiedProperties.displayName) == \"ServicePrincipal.AppId\", tostring(TargetResources1_modifiedProperties.newValue), \"\")\n| extend AppName = iff(tostring(TargetResources1_modifiedProperties.displayName) == \"ServicePrincipal.DisplayName\", tostring(TargetResources1_modifiedProperties.newValue), \"\")\n| summarize make_set(AppName), make_set(AppId) by TimeGenerated, ActivityDisplayName, UA, User, Result, OperationName, tostring(InitiatedBy), bin(TimeGenerated, 1d), tostring(Action)\n| where tostring(set_AppId) != '[\"\"]'\n| project-reorder TimeGenerated, User, set_AppName\n| join kind=leftouter (SecurityAlert\n| where ProviderName == \"IPC\"\n| extend User = tolower(tostring(parse_json(ExtendedProperties).[\"User Account\"]))\n| summarize count_AlertName = count() by bin(TimeGenerated, 1d), User) on TimeGenerated, User\n| extend NumberofAADAlerts = iif(isnotempty(count_AlertName), count_AlertName, 0)\n| sort by NumberofAADAlerts desc\n| extend AppName = tostring(set_AppName[1])\n| extend AppID = tostring(set_AppId[1])\n| project-away set_AppName, set_AppId\n| project-reorder TimeGenerated, ActivityDisplayName, Action, User, NumberofAADAlerts, AppName, AppID\n| extend timestamp = TimeGenerated, AccountCustomEntity = User\n", "attributes": {"description": "'Finds AD applications granted permissions to read users mailboxes via Exchange Web Services (EWS). A threat actor could add these permissions to an application they control in order to gain persistent access to user's mail.\nReview the applications granted these permissions to ensure they are required and were granted legitimately.'\n", "techniques": ["T1078.004", "T1114.002"], "tactics": ["Collection", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/AzureResourceAssignedPublicIP.yaml", "query_name": "Azure Resources assigned Public IP Addresses", "query": "let OperationNames = dynamic([\"microsoft.compute/virtualMachines/write\", \"microsoft.resources/deployments/write\"]);\nAzureActivity\n// We look for any Operation that modified and then was accepted or succeeded where a publicipaddress component is referenced\n| where OperationNameValue in~ (OperationNames)\n| where ActivityStatusValue has_any (\"Succeeded\", \"Accepted\")\n| where Properties contains \"publicipaddress\"\n//| extend frontendIPConfigurations = Properties.responseBody.properties.frontendIPConfigurations\n// parsing the publicIPAddress from Properties. It is only available if the allocation method is Static.\n| parse Properties with * \"publicIPAddress\\\\\" PublicIPAddressParse\n| extend publicIPAddress_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).ipAddress) \n| extend publicIPAddressVersion_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAddressVersion) \n| extend publicIPAllocationMethod_ = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).responseBody)).properties)).publicIPAllocationMethod) \n| extend scope_ = tostring(parse_json(Authorization).scope) \n| project TimeGenerated, OperationNameValue, publicIPAllocationMethod_ , publicIPAddressVersion_, scope_ , Caller, CallerIpAddress, ActivityStatusValue, Resource \n// Join in the AzureNetworkAnalytics so that we can determine if any connections were made via the public ip address and get the currently assigned ip address when allocation method is Dynamic\n| join kind= inner (\nunion isfuzzy=true\n(AzureNetworkAnalytics_CL\n// Controlling for Schema Version and later parsing - This is Version 2 and Public IPs only\n| where isnotempty(FASchemaVersion_s) and isnotempty(DestPublicIPs_s)\n| extend SchemaVersion = FASchemaVersion_s\n| extend PublicIPs = tostring(split(DestPublicIPs_s,\"|\")[0])\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(FlowStartTime_t), LastProcessedTimeUtc = max(FlowEndTime_t), \nRegions = makeset(Region_s), AzureRegions = makeset(AzureRegion_s), VMs = makeset(VM_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), DestPort = makeset(DestPort_d), SrcIP = makeset(SrcIP_s), \nActivityCount = count() by NSGRule_s, NSGList_s, SubNet = Subnet1_s, FlowDirection_s, Subscription = Subscription1_g, Tags_s, SchemaVersion\n//NSGList_s contains the subscription ID, remove that as we already have a field for this and now it will match what we get for SchemaVersion 1\n| extend NSG = case(isnotempty(NSGList_s), strcat(split(NSGList_s, \"/\")[-2],\"/\",split(NSGList_s, \"/\")[-1]), \"NotAvailable\")\n// Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity\n| extend NSG_Name = tostring(split(NSG, \"/\")[-1])\n),\n(\nAzureNetworkAnalytics_CL \n// Controlling for Schema Version and later parsing - This is Version 1\n| where isempty(FASchemaVersion_s)\n// Controlling for public IPs only\n| where isnotempty(PublicFrontendIPs_s) or isnotempty(PublicIPAddresses_s)\n| where PublicFrontendIPs_s != \"null\" or PublicIPAddresses_s != \"null\"\n| extend SchemaVersion = SchemaVersion_s\n// The Public IP can be indicated in one of 2 locations, assigning here for easy union results\n| extend PublicIPs = case(isnotempty(PublicFrontendIPs_s), PublicFrontendIPs_s,\nPublicIPAddresses_s) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(TimeProcessed_t), LastProcessedTimeUtc = max(TimeProcessed_t), \nRegions = makeset(Region_s), AzureRegions = makeset(DiscoveryRegion_s), VMs = makeset(VirtualMachine_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), \nSrcIP = makeset(PrivateIPAddresses_s), Name = makeset(Name_s), DestPort = makeset(DestinationPortRange_s),\nActivityCount = count() by NSG = NSG_s, SubNet = Subnetwork_s, Subscription = Subscription_g, Tags_s, SchemaVersion\n// Some events don't have an NSG listed, populating so it is clear it is not available in the datatype\n| extend NSG = case(isnotempty(NSG), NSG, \"NotAvailable\")\n// Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity\n| extend NSG_Name = tostring(split(NSG, \"/\")[-1])\n)\n| project StartTimeUtc, EndTimeUtc, FirstProcessedTimeUTC, LastProcessedTimeUtc, PublicIPs, NSG, NSG_Name, SrcIP, DestPort, SubNet, Name, VMs, MACAddresses, ActivityCount, Regions, AzureRegions, Subscription, Tags_s, SchemaVersion\n) on $left.Resource == $right.NSG_Name\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Identifies when public IP addresses are assigned to Azure Resources.  Additionally, shows connections to those resources.\nResources: \nhttps://docs.microsoft.com/azure/azure-monitor/insights/azure-networking-analytics\nhttps://docs.microsoft.com/azure/network-watcher/traffic-analytics-schema'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/AzureResourceCreationWithNetworkActivity.yaml", "query_name": "Anomalous Resource Creation and related Network Activity", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nlet activity = AzureActivity\n| where TimeGenerated >= startofday(ago(lookback))\n// We look for any Operation that created and then succeeded where ActivitySubstatusValue has a value so that we can provide context\n| where OperationNameValue endswith \"write\"\n| where ActivityStatusValue has \"Succeeded\"\n| make-series dResourceCount=dcount(ResourceId) default=0 on EventSubmissionTimestamp in range(startofday(ago(7d)), now(), 1d) by Caller, Resource, OperationNameValue\n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)\n// Comment slope reference below to see all returns\n| where Slope > 0.2\n| join kind=leftsemi (\n// Last day's activity is anomalous\nAzureActivity\n| where TimeGenerated between(starttime..endtime)\n// We look for any Operation that created and then succeeded where ActivitySubstatusValue has a value so that we can provide context\n| where OperationNameValue endswith \"write\"\n| where ActivityStatusValue has \"Succeeded\"\n| make-series dResourceCount=dcount(ResourceId) default=0 on EventSubmissionTimestamp in range(startofday(ago(1d)), now(), 1d) by Caller, Resource, OperationNameValue\n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dResourceCount)\n// Comment slope reference below to see all returns\n| where Slope > 0.2\n) on Caller, Resource, OperationNameValue\n// Expanding the fields that were grouped so we can match on a time window when we join the details later\n| mvexpand EventSubmissionTimestamp, dResourceCount\n// Making sure the fields are the right type or the join fails\n| extend todatetime(EventSubmissionTimestamp), tostring(dResourceCount)\n| join kind= inner (\n  AzureActivity\n  | where TimeGenerated between(starttime..endtime)\n  // We look for any Operation that created and then succeeded where ActivitySubstatusValue has a value so that we can provide context\n  | where OperationNameValue endswith \"write\"\n  | where ActivityStatusValue has \"Succeeded\" and isnotempty(ActivitySubstatusValue)\n  | summarize by EventSubmissionTimestamp = bin(EventSubmissionTimestamp, 1d), Caller, CallerIpAddress, OperationNameValue, ActivityStatusValue, Resource, ResourceGroup, ResourceId, SubscriptionId\n) on EventSubmissionTimestamp, Caller, Resource, OperationNameValue;\nlet NetworkAnalytics =\n  union isfuzzy=true\n  (AzureNetworkAnalytics_CL\n  | where TimeGenerated between(starttime..endtime)\n  // Controlling for Schema Version and later parsing - This is Version 2 and Public IPs only\n  | where (isnotempty(FASchemaVersion_s) and isnotempty(DestPublicIPs_s))\n  | extend SchemaVersion = FASchemaVersion_s\n  | extend PublicIPs = tostring(split(DestPublicIPs_s,\"|\")[0])\n  | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(FlowStartTime_t), LastProcessedTimeUtc = max(FlowEndTime_t),\n  Regions = makeset(Region_s), AzureRegions = makeset(AzureRegion_s), VMs = makeset(VM_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs), DestPort = makeset(DestPort_d), SrcIP = makeset(SrcIP_s),\n  ActivityCount = count() by NSGRule_s, NSGList_s, SubNet = Subnet1_s, FlowDirection_s, Subscription = Subscription1_g, Tags_s, SchemaVersion\n  //NSGList_s contains the subscription ID, remove that as we already have a field for this and now it will match what we get for SchemaVersion 1\n  | extend NSG = case(isnotempty(NSGList_s), strcat(split(NSGList_s, \"/\")[-2],\"/\",split(NSGList_s, \"/\")[-1]), \"NotAvailable\")\n  // Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity\n  | extend NSG_Name = tostring(split(NSG, \"/\")[-1])\n  ),\n  (\n  AzureNetworkAnalytics_CL\n  | where TimeGenerated between(starttime..endtime)\n  // Controlling for Schema Version and later parsing - This is Version 1\n  | where isempty(FASchemaVersion_s)\n  // Controlling for public IPs only\n  | where isnotempty(PublicFrontendIPs_s) or isnotempty(PublicIPAddresses_s)\n  | where PublicFrontendIPs_s != \"null\" or PublicIPAddresses_s != \"null\"\n  | extend SchemaVersion = SchemaVersion_s\n  // The Public IP can be indicated in one of 2 locations, assigning here for easy union results\n  | extend PublicIPs = case(isnotempty(PublicFrontendIPs_s), PublicFrontendIPs_s,\n  PublicIPAddresses_s)\n  | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FirstProcessedTimeUTC = min(TimeProcessed_t), LastProcessedTimeUtc = max(TimeProcessed_t),\n  Regions = makeset(Region_s), AzureRegions = makeset(DiscoveryRegion_s), VMs = makeset(VirtualMachine_s), MACAddresses = makeset(MACAddress_s), PublicIPs = makeset(PublicIPs),\n  SrcIP = makeset(PrivateIPAddresses_s), Name = makeset(Name_s), DestPort = makeset(DestinationPortRange_s),\n  ActivityCount = count() by NSG = NSG_s, SubNet = Subnetwork_s, Subscription = Subscription_g, Tags_s, SchemaVersion\n  // Some events don't have an NSG listed, populating so it is clear it is not available in th datatype\n  | extend NSG = case(isnotempty(NSG), NSG, \"NotAvailable\")\n  // Depending on the SchemaVersion, we will need to provide the NSG_Name for matching against the resource identified in AzureActivity\n  | extend NSG_Name = tostring(split(NSG, \"/\")[-1])\n  )\n  | project StartTimeUtc, EndTimeUtc, FirstProcessedTimeUTC, LastProcessedTimeUtc, PublicIPs, NSG, NSG_Name, SrcIP, DestPort, SubNet, Name, VMs, MACAddresses, ActivityCount, Regions, AzureRegions, Subscription, Tags_s, SchemaVersion\n  ;\n  activity | join kind= leftouter (NetworkAnalytics\n  ) on $left.Resource == $right.NSG_Name\n  | extend timestamp = StartTimeUtc, AccountCustomEntity = Caller, IPCustomEntity = CallerIpAddress\n", "attributes": {"description": "'Indicates when an anomalous number of resources are created successfully in Azure via the AzureActivity log.\nThis is then joined with the AzureNetworkAnalytics_CL data to identify any network related activity for the created resource.\nThe anomaly detection identifies activities that have occured both since the start of the day 1 day ago and the start of the day 7 days ago.\nThe start of the day is considered 12am UTC time.\nResource creation could indicated malicious or spurious use of your Azure Resource allocation.  Resources can be abused in relation to digital\ncurrency mining, command and control, exfiltration, distributed attacks and propagation of malware, among others. Verify that this resource creation\nis expected.\nResources:\nhttps://docs.microsoft.com/azure/azure-monitor/insights/azure-networking-analytics\nhttps://docs.microsoft.com/azure/network-watcher/traffic-analytics-schema'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/AzureRunCommandMDELinked.yaml", "query_name": "Azure VM Run Command linked with MDE", "query": "AzureActivity\n// Isolate run command actions\n| where OperationNameValue == \"Microsoft.Compute/virtualMachines/runCommand/action\"\n// Confirm that the operation impacted a virtual machine\n| where Authorization has \"virtualMachines\"\n// Each runcommand operation consists of three events when successful, Started, Accepted (or Rejected), Successful (or Failed).\n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), max(CallerIpAddress), make_list(ActivityStatusValue) by CorrelationId, Authorization, Caller\n// Limit to Run Command executions that Succeeded\n| where list_ActivityStatusValue has \"Succeeded\"\n// Extract data from the Authorization field, allowing us to later extract the Caller (UPN) and CallerIpAddress\n| extend Authorization_d = parse_json(Authorization)\n| extend Scope = Authorization_d.scope\n| extend Scope_s = split(Scope, \"/\")\n| extend Subscription = tostring(Scope_s[2])\n| extend VirtualMachineName = tostring(Scope_s[-1])\n| project StartTime, EndTime, Subscription, VirtualMachineName, CorrelationId, Caller, CallerIpAddress=max_CallerIpAddress\n| join kind=leftouter (\n    DeviceFileEvents\n    | where InitiatingProcessFileName == \"RunCommandExtension.exe\"\n    | extend VirtualMachineName = tostring(split(DeviceName, \".\")[0])\n    | project VirtualMachineName, PowershellFileCreatedTimestamp=TimeGenerated, FileName, FileSize, InitiatingProcessAccountName, InitiatingProcessAccountDomain, InitiatingProcessFolderPath, InitiatingProcessId\n) on VirtualMachineName\n// We need to filter by time sadly, this is the only way to link events\n| where PowershellFileCreatedTimestamp between (StartTime .. EndTime)\n| project StartTime, EndTime, PowershellFileCreatedTimestamp, VirtualMachineName, Caller, CallerIpAddress, FileName, FileSize, InitiatingProcessId, InitiatingProcessAccountDomain, InitiatingProcessFolderPath\n| join kind=inner(\n    DeviceEvents\n    | extend VirtualMachineName = tostring(split(DeviceName, \".\")[0])\n    | where InitiatingProcessCommandLine has \"-File\"\n    | extend PowershellFileName = extract(@\"\\-File\\s(script[0-9]{1,9}\\.ps1)\", 1, InitiatingProcessCommandLine)\n    | extend PSCommand = tostring(parse_json(AdditionalFields).Command)\n    | order by TimeGenerated asc \n    | where PSCommand != PowershellFileName \n    | summarize PowershellExecStart=min(TimeGenerated), PowershellExecEnd=max(TimeGenerated), make_list(PSCommand) by PowershellFileName, InitiatingProcessCommandLine\n) on $left.FileName == $right.PowershellFileName\n| project StartTime, EndTime, PowershellFileCreatedTimestamp, PowershellExecStart, PowershellExecEnd, PowershellFileName, PowershellScriptCommands=list_PSCommand, Caller, CallerIpAddress, InitiatingProcessCommandLine, PowershellFileSize=FileSize, VirtualMachineName\n| order by StartTime asc \n| extend ScriptFingerprintHash = hash_sha256(tostring(PowershellScriptCommands))\n", "attributes": {"description": "'Identifies any Azure VM Run Command operations and links these operations with\nMDE host logging. Linking these two data sources provides hunting opportunities.\nLogging from AzureActivity provides the IP address and UPN of the account that\ninvoked the command. Joining this with logging from MDE provides insights into\nwhat cmdlets were loaded by the command.'\n", "techniques": ["T1570", "T1078.004"], "tactics": ["LateralMovement", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/BackupDeletion.yaml", "query_name": "Backup Deletion", "query": "( union isfuzzy=true\n(SecurityEvent\n| where EventID==4688\n| extend FileName = Process, ProcessCommandLine = CommandLine\n| where FileName =~ \"vssadmin.exe\" and ProcessCommandLine has \"delete shadows\"\n or ProcessCommandLine has(\"bcdedit\") and ProcessCommandLine has_any(\"recoveryenabled no\", \"bootstatuspolicy ignoreallfailures\")\n or (ProcessCommandLine has \"wmic\" and ProcessCommandLine has \"shadowcopy delete\")\n or ProcessCommandLine has \"wbadmin\" and ProcessCommandLine has \"delete\" and ProcessCommandLine has_any(\"backup\", \"catalog\", \"systemstatebackup\")\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, ProcessCustomEntity = NewProcessName\n),\n(WindowsEvent\n| where EventID == 4688 \n| extend ProcessCommandLine = tostring(EventData.CommandLine)\n| where  EventData has \"vssadmin.exe\" and ProcessCommandLine has \"delete shadows\"\n or ProcessCommandLine has(\"bcdedit\") and ProcessCommandLine has_any(\"recoveryenabled no\", \"bootstatuspolicy ignoreallfailures\")\n or (ProcessCommandLine has \"wmic\" and ProcessCommandLine has \"shadowcopy delete\")\n or ProcessCommandLine has \"wbadmin\" and ProcessCommandLine has \"delete\" and ProcessCommandLine has_any(\"backup\", \"catalog\", \"systemstatebackup\") \n| extend Account = strcat(EventData.TargetDomainName,\"\\\\\", EventData.TargetUserName)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n),\n(DeviceProcessEvents\n| where FileName =~ \"vssadmin.exe\" and ProcessCommandLine has \"delete shadows\"\n or ProcessCommandLine has(\"bcdedit\") and ProcessCommandLine has_any(\"recoveryenabled no\", \"bootstatuspolicy ignoreallfailures\")\n or (ProcessCommandLine has \"wmic\" and ProcessCommandLine has \"shadowcopy delete\")\n or ProcessCommandLine has \"wbadmin\" and ProcessCommandLine has \"delete\" and ProcessCommandLine has_any(\"backup\", \"catalog\", \"systemstatebackup\") \n| extend timestamp = TimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = DeviceName, ProcessCustomEntity = InitiatingProcessFileName\n),\n(imProcessCreate\n| extend FileName = Process, ProcessCommandLine = CommandLine\n| where FileName =~ \"vssadmin.exe\" and ProcessCommandLine has \"delete shadows\"\n or ProcessCommandLine has(\"bcdedit\") and ProcessCommandLine has_any(\"recoveryenabled no\", \"bootstatuspolicy ignoreallfailures\")\n or (ProcessCommandLine has \"wmic\" and ProcessCommandLine has \"shadowcopy delete\")\n or ProcessCommandLine has \"wbadmin\" and ProcessCommandLine has \"delete\" and ProcessCommandLine has_any(\"backup\", \"catalog\", \"systemstatebackup\")\n| extend timestamp = TimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = Dvc, ProcessCustomEntity = Process\n)\n)\n", "attributes": {"description": "'This hunting query will help detect attempts to delete backup. Though such an activity could be legitimate as part of regular business operations, often ransomwares also perform such actions so that once the files are encrypted by them, backups cannot be used to restore encrypted files and thus cause interruption to regular business services.'\n", "techniques": ["T1490"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/CobaltDNSBeacon.yaml", "query_name": "Cobalt Strike DNS Beaconing", "query": "\nlet badNames = dynamic([\"aaa.stage.\", \"post.1\"]);\n(union isfuzzy=true\n(DnsEvents \n| where Name has_any (badNames)\n| extend Domain = Name, SourceIp = ClientIP, RemoteIP = todynamic(IPAddresses)\n| mvexpand RemoteIP\n| extend RemoteIP = tostring(RemoteIP)),\n(VMConnection\n| where isnotempty(RemoteDnsCanonicalNames) \n| parse RemoteDnsCanonicalNames with * '[\"' DNSName '\"]' *\n| where DNSName has_any (badNames)\n| extend Domain = DNSName, RemoteIP = RemoteIp\n))\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by Domain, SourceIp, RemoteIP, Computer\n| extend timestamp = StartTimeUtc, HostCustomEntity = Computer, IPCustomEntity = RemoteIP\n", "attributes": {"description": "'Cobalt Strike is a famous Pen Test tool that is used by pen testers as well as attackers alike To compromise an environment. \nThe query tries to detect suspicious DNS queries known from Cobalt Strike beacons.\nThis is based out of sigma rules described here: https://github.com/Neo23x0/sigma/blob/master/rules/network/net_mal_dns_cobaltstrike.yml'\n", "techniques": ["T1568", "T1008"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/CriticalOperationsWithSystemrestore.yaml", "query_name": "Critical user management operations followed by disabling of System Restore from admin account", "query": "let security_info_actions = dynamic([\"User registered security info\", \"User changed default security info\", \"User deleted security info\", \"Admin updated security info\", \"User reviewed security info\", \"Admin deleted security info\", \"Admin registered security info\"]);\nlet AdminUsers =\n(IdentityInfo\n| mv-expand AssignedRoles\n| where AssignedRoles matches regex 'Admin'\n| summarize by tolower(AccountUPN));\n(union isfuzzy=true\n(\nSecurityEvent\n| where EventID == '4688'\n| where ParentProcessName has 'rundll32.exe'\nand NewProcessName has 'schtasks.exe'\nand CommandLine has 'Change' and CommandLine has 'SystemRestore'\nand CommandLine has 'disable'\n| extend MachineName = Computer , Process = NewProcessName\n| project AccountDomain,Account = AccountName, _ResourceId, _SubscriptionId, CategoryId, ClientIPAddress, CommandLine, Process\n),\n(\nWindowsEvent\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend CommandLine = tostring(EventData.CommandLine)\n| where isnotempty(CommandLine)\n| where ParentProcessName has 'rundll32.exe'\nand NewProcessName has 'schtasks.exe'\nand CommandLine has 'Change' and CommandLine has 'SystemRestore' and CommandLine has 'disable'\n| extend MachineName = Computer , Process = NewProcessName\n| extend MachineName = Computer , Process = NewProcessName\n| extend Account = strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| project _ResourceId, _SubscriptionId, CommandLine, Account, Computer, IpAddress, Process\n),\n(\nDeviceProcessEvents\n| where InitiatingProcessFileName =~ 'rundll32.exe'\nand InitiatingProcessCommandLine !contains \" \" and InitiatingProcessCommandLine != \"\"\nand FileName in~ ('schtasks.exe')\nand ProcessCommandLine has 'Change' and ProcessCommandLine has 'SystemRestore' and ProcessCommandLine has 'disable'\n| extend MachineName = DeviceName , Process = InitiatingProcessFolderPath, Account = AccountName\n| project AccountDomain,Account = AccountName, AccountObjectId, TenantId, ReportId, Computer=MachineName, Process\n))\n| join kind=inner\n(\nAuditLogs\n| where Category =~ \"UserManagement\"\n| where ActivityDisplayName in (security_info_actions)\n| extend Initiator = tostring(InitiatedBy.user.userPrincipalName)\n| extend IP = tostring(InitiatedBy.user.ipAddress)\n| extend Target = tolower(tostring(TargetResources[0].userPrincipalName))\n| where Target in (AdminUsers)\n| project ActivityDateTime, Target, IP, Account=Initiator, ResourceId, ResultType, AADTenantId, CorrelationId, OperationName\n) on Account\n| project AccountCustomEntity=Account, CategoryId, HostCustomEntity=Computer, IPCustomEntity=IpAddress, CorrelationId, ReportId, ResourceId, TenantId, ProcessCustomEntity=Process, CommandLineCustomEntity=CommandLine, _ResourceId, _SubscriptionId\n", "attributes": {"description": "'This query could identify critical user management operations like user registration(Azure AD Multi-Factor Authentication & self-service password reset (SSPR)) authentication by admin account followed by attempts to stop System Restore activity. Stopping system restore prevents from recovering data by going back to a restore point. The operations could be an indication of attackers trying to maintain persistence, move laterally with attempts to stop system restore point that could point to a potential ransomware attack.'\n", "techniques": ["T1078", "T1490"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/Dev-0056CommandLineActivityNovember2021.yaml", "query_name": "Dev-0056 Command Line Activity November 2021", "query": "(union isfuzzy=true\n(DeviceProcessEvents  \n| where ProcessCommandLine has_any(\"/q /c color f7&\", \"Net.We$()bClient\", \"$b,15,$b.Length-15\") or (ProcessCommandLine has \"FromBase64String\" and ProcessCommandLine has_all(\"-nop\", \"iex\", \"(iex\")) \n| join kind=leftouter (SecurityAlert\n| where ProviderName =~ \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| mv-expand todynamic(Entities)\n| extend DeviceId = tostring(parse_json(Entities).MdatpDeviceId)\n| where isnotempty(DeviceId)\n// Increase risk score further if alerts relate to malware assocaited with threat actor\n| extend AlertRiskScore =iif(ThreatName has_any (\"Backdoor:MSIL/ShellClient.A\", \"Backdoor:MSIL/ShellClient.A!dll\", \"Trojan:MSIL/Mimikatz.BA!MTB\"), 1.0, 0.5)) on DeviceId\n| extend AlertRiskScore = iif(isempty(AlertRiskScore), 0.0 , AlertRiskScore)\n| project-reorder  TimeGenerated, DeviceName, DeviceId, ProcessCommandLine, AccountName\n| extend timestamp = TimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = DeviceName,  ProcessCustomEntity = InitiatingProcessFileName\n),\n(SecurityEvent\n| where EventID == '4688'\n| where ( CommandLine has_any(\"/q /c color f7&\", \"Net.We$()bClient\", \"$b,15,$b.Length-15\")) or (CommandLine has \"FromBase64String\" and CommandLine has_all(\"-nop\", \"iex\", \"(iex\"))\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, CommandLine\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n),\n(WindowsEvent\n| where EventID == '4688' and (EventData has_any(\"/q /c color f7&\", \"Net.We$()bClient\", \"$b,15,$b.Length-15\") or (EventData has \"FromBase64String\" and EventData has_all(\"-nop\", \"iex\", \"(iex\")) )\n| extend CommandLine = tostring(EventData.CommandLine) \n| where ( CommandLine has_any(\"/q /c color f7&\", \"Net.We$()bClient\", \"$b,15,$b.Length-15\")) or (CommandLine has \"FromBase64String\" and CommandLine has_all(\"-nop\", \"iex\", \"(iex\"))\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| extend Account = iff((isempty(EventData.SubjectDomainName) or EventData.SubjectDomainName == \"-\"),\"\", strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName)))\n| extend NewProcessId = tostring(EventData.NewProcessId)\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, CommandLine\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n)\n)\n", "attributes": {"description": "'This hunting query looks for process command line activity related to activity observed by Dev-0056.The command lines this query hunts for are used as part of the threat actor's post exploitation activity.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/Dev-0322CommandLineActivityNovember2021%28ASIMVersion%29.yaml", "query_name": "Dev-0322 Command Line Activity November 2021 (ASIM Version)", "query": "// Look for command lines observed used by the threat actor\nlet cmd_lines = dynamic(['cmd.exe /c \"wmic /node:redacted process call create \"ntdsutil snapshot \\\\\"activate instance ntds\\\\\" create quit quit > c:\\\\windows\\\\temp\\\\nt.dat\";', 'regsvr32 /s c:\\\\windows\\\\temp\\\\user64.dll', 'process call  create \"cmd /c c:\\\\windows\\\\temp\\\\gac.exe -i c:\\\\windows\\temp\\\\ScriptModule.dll >c:\\\\windows\\\\temp\\\\tmp.dat\"']);\nimProcess\n// Look for static cmd lines and dynamic one using regex\n| where CommandLine  has_any (cmd_lines) or CommandLine matches regex \"save HKLM\\\\SYSTEM [^ ]*_System.HIV\" or CommandLine matches regex 'cmd.exe /c \"wmic /node:[^ ]* process call create \"ntdsutil snapshot \\\\\"activate instance ntds\\\\\" create quit quit > c:\\\\windows\\\\temp\\\\nt.dat\";'\n| summarize count(), FirstSeen=min(TimeGenerated), LastSeen = max(TimeGenerated) by DvcId, Dvc, CommandLine, AccountName, FilePath\n// Base risk score on number of command lines seen for each host\n| extend RiskScore = count_\n// Increase risk score if host has recent security alerts\n| join kind=leftouter (SecurityAlert\n| where ProviderName =~ \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| mv-expand todynamic(Entities)\n| extend DvcId = tostring(parse_json(Entities).MdatpDeviceId)\n| where isnotempty(DvcId)\n// Increase risk score further if alerts relate to malware assocaited with threat actor\n| extend AlertRiskScore = iif(ThreatName has_any (\"Zebracon\", \"Trojan:MSIL/Gacker.A!dha\", \"Backdoor:MSIL/Kokishell.A!dha\"), 1.0, 0.5)) on DvcId\n// Create aggregate risk score\n| extend AlertRiskScore = iif(isempty(AlertRiskScore), 0.0 , AlertRiskScore)\n| extend RiskScore = RiskScore + AlertRiskScore\n| project-reorder  FirstSeen, LastSeen, RiskScore, Dvc, DvcId, CommandLine, AccountName\n| extend File = split(Process, \"\\\\\")[-1]\n| extend timestamp = FirstSeen, AccountCustomEntity = AccountName, HostCustomEntity = Dvc\n", "attributes": {"description": "'This hunting query looks for process command line activity related to activity observed by Dev-0322 relating to compromise of systems running the ZOHO ManageEngine ADSelfService Plus software.\n  The command lines this query hunts for are used as part of the threat actor's post exploitation activity. Some or all of the commands may be run by the threat actor.\n  The risk score associated with each result is based on a number of factors, hosts with higher risk events should be investigated first.\n  This query uses the Microsoft Sentinel Information Model - https://docs.microsoft.com/azure/sentinel/normalization'\n", "techniques": ["T1078", "T1219", "T1021"], "tactics": ["Persistence", "LateralMovement", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/Dev-0322CommandLineActivityNovember2021.yaml", "query_name": "Dev-0322 Command Line Activity November 2021", "query": "// Look for command lines observed used by the threat actor\nlet cmd_lines = dynamic(['regsvr32 /s c:\\\\windows\\\\temp\\\\user64.dll', 'process call  create \"cmd /c c:\\\\windows\\\\temp\\\\gac.exe -i c:\\\\windows\\temp\\\\ScriptModule.dll >c:\\\\windows\\\\temp\\\\tmp.dat\"']);\nDeviceProcessEvents\n// Look for static cmd lines and dynamic one using regex\n| where ProcessCommandLine has_any (cmd_lines) or ProcessCommandLine matches regex \"save HKLM\\\\SYSTEM [^ ]*_System.HIV\" or ProcessCommandLine matches regex 'cmd.exe /c \"wmic /node:[^ ]* process call create \"ntdsutil snapshot \\\\\"activate instance ntds\\\\\" create quit quit > c:\\\\windows\\\\temp\\\\nt.dat\";'  or InitiatingProcessCommandLine has_any (cmd_lines) or InitiatingProcessCommandLine  matches regex \"save HKLM\\\\SYSTEM [^ ]*_System.HIV\" or InitiatingProcessCommandLine  matches regex \"save HKLM\\\\SYSTEM [^ ]*_System.HIV\" or ProcessCommandLine matches regex 'cmd.exe /c \"wmic /node:[^ ]* process call create \"ntdsutil snapshot \\\\\"activate instance ntds\\\\\" create quit quit > c:\\\\windows\\\\temp\\\\nt.dat\";'\n| summarize count(), FirstSeen=min(TimeGenerated), LastSeen = max(TimeGenerated) by DeviceId, DeviceName, ProcessCommandLine, AccountName, FileName, InitiatingProcessCommandLine, InitiatingProcessFileName, InitiatingProcessAccountName, InitiatingProcessAccountSid, SHA256\n// Base risk score on number of command lines seen for each host\n| extend RiskScore = count_\n// Increase risk score if host has recent security alerts\n| join kind=leftouter (SecurityAlert\n| where ProviderName =~ \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| mv-expand todynamic(Entities)\n| extend DeviceId = tostring(parse_json(Entities).MdatpDeviceId)\n| where isnotempty(DeviceId)\n// Increase risk score further if alerts relate to malware assocaited with threat actor\n| extend AlertRiskScore = iif(ThreatName has_any (\"Zebracon\", \"Trojan:MSIL/Gacker.A!dha\", \"Backdoor:MSIL/Kokishell.A!dha\"), 1.0, 0.5)) on DeviceId\n| extend AlertRiskScore = iif(isempty(AlertRiskScore), 0.0 , AlertRiskScore)\n// Create aggregate risk score\n| extend RiskScore = RiskScore + AlertRiskScore\n| project-reorder  FirstSeen, LastSeen, RiskScore, DeviceName, DeviceId, ProcessCommandLine, AccountName\n| extend timestamp = FirstSeen, AccountCustomEntity = AccountName, HostCustomEntity = DeviceName,\n", "attributes": {"description": "'This hunting query looks for process command line activity related to activity observed by Dev-0322 relating to compromise of systems running the ZOHO ManageEngine ADSelfService Plus software.\n  The command lines this query hunts for are used as part of the threat actor's post exploitation activity. Some or all of the commands may be run by the threat actor.\n  The risk score associated with each result is based on a number of factors, hosts with higher risk events should be investigated first.'\n", "techniques": ["T1078", "T1219", "T1021"], "tactics": ["Persistence", "LateralMovement", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/Dev-0322FileDropActivityNovember2021%28ASIMVersion%29.yaml", "query_name": "Dev-0322 File Drop Activity November 2021 (ASIM Version)", "query": "// Look for the specific files dropped by threat actor\nlet files = dynamic([\"C:\\\\ProgramData\\\\Microsoft\\\\Crypto\\\\RSA\\\\key.dat \", \"c:\\\\windows\\\\temp\\\\ccc.exe\"]);\nimFileEvent\n| where EventType =~ \"FileCreated\"\n| where FileName endswith \"elrs.exe\" or FilePath has_any (files)\n// Increase the risk score of command accessing file also seen\n| join kind=leftouter (imProcess\n| where CommandLine contains \"cmd /c elrs.exe\") on DvcId\n| extend RiskScore = iif(isnotempty(DvcId1), 1.0, 0.5)\n| project-reorder TimeGenerated, DvcId, FileName, FilePath, CommandLine, RiskScore\n// Increase risk score if recent alerts for the host\n| join kind=leftouter (SecurityAlert\n| where ProviderName =~ \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| mv-expand todynamic(Entities)\n| extend DvcId = tostring(parse_json(Entities).MdatpDeviceId)\n| where isnotempty(DvcId)\n// Higher risk score are for Defender alerts related to threat actor\n| extend AlertRiskScore = iif(ThreatName has_any (\"Zebracon\", \"Trojan:MSIL/Gacker.A!dha\", \"Backdoor:MSIL/Kokishell.A!dha\"), 1.0, 0.5)\n| project DvcId, AlertRiskScore) on DvcId\n| extend AlertRiskScore = iif(isempty(AlertRiskScore), 0.0, AlertRiskScore)\n// Create agregate risk score\n| extend RiskScore = RiskScore + AlertRiskScore\n| extend timestamp = TimeGenerated, HostCustomEntity = Dvc, AccountCustomEntity = AccountName\n", "attributes": {"description": "'This hunting query looks for file creation events related to activity observed by Dev-0322 relating to compromise of systems running the ZOHO ManageEngine ADSelfService Plus software.\n  The files this query hunts for are dropped as part of the threat actors post exploitation activity. Some or all of the files may be dropped by the threat actor.\n  The risk score associated with each result is based on a number of factors, hosts with higher risk events should be investigated first.\n  This query uses the Microsoft Sentinel Information Model - https://docs.microsoft.com/azure/sentinel/normalization'\n", "techniques": ["T1078", "T1219"], "tactics": ["Persistence", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/Dev-0322FileDropActivityNovember2021.yaml", "query_name": "Dev-0322 File Drop Activity November 2021", "query": "// Look for the specific files dropped by threat actor\nlet files = dynamic([\"C:\\\\ProgramData\\\\Microsoft\\\\Crypto\\\\RSA\\\\key.dat \", \"c:\\\\windows\\\\temp\\\\ccc.exe\"]);\nDeviceFileEvents\n| where FileName endswith \"elrs.exe\" or FolderPath has_any (files)\n// Increase the risk score of command accessing file also seen\n| join kind=leftouter (DeviceProcessEvents\n| where ProcessCommandLine contains \"cmd /c elrs.exe\") on DeviceId\n| extend RiskScore = iif(isnotempty(DeviceId1), 1.0, 0.5)\n| project-reorder TimeGenerated, DeviceName, FileName, FolderPath, ProcessCommandLine, RiskScore, InitiatingProcessAccountName\n// Increase risk score if recent alerts for the host\n| join kind=leftouter (SecurityAlert\n| where ProviderName =~ \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| mv-expand todynamic(Entities)\n| extend DeviceId = tostring(parse_json(Entities).MdatpDeviceId)\n| where isnotempty(DeviceId)\n// Higher risk score are for Defender alerts related to threat actor\n| extend AlertRiskScore = iif(ThreatName has_any (\"Zebracon\", \"Trojan:MSIL/Gacker.A!dha\", \"Backdoor:MSIL/Kokishell.A!dha\"), 1.0, 0.5)\n| project DeviceId, AlertRiskScore) on DeviceId\n// Create agregate risk score\n| extend RiskScore = RiskScore + AlertRiskScore\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName, AccountCustomEntity = AccountName\n", "attributes": {"description": "'This hunting query looks for file creation events related to activity observed by Dev-0322 relating to compromise of systems running the ZOHO ManageEngine ADSelfService Plus software.\n  The files this query hunts for are dropped as part of the threat actors post exploitation activity. Some or all of the files may be dropped by the threat actor.\n  The risk score associated with each result is based on a number of factors, hosts with higher risk events should be investigated first.'\n", "techniques": ["T1078", "T1219"], "tactics": ["Persistence", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/DormantServicePrincipalUpdateCredsandLogsIn.yaml", "query_name": "Dormant Service Principal Update Creds and Logs In", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = endtime - 14d;\nlet sp_active_users = AADServicePrincipalSignInLogs\n| where TimeGenerated between(lookback..starttime)\n| where ResultType  == 0\n| summarize by ServicePrincipalId;\nAuditLogs\n| where TimeGenerated between(starttime..endtime)\n// Looking for new creds added to an SP rather than MFA\n| where OperationName in (\"Add service principal credentials\", \"Update application - Certificates and secrets management\")\n| extend ServicePrincipalId = tostring(TargetResources[0].id)\n| where ServicePrincipalId !in (sp_active_users)\n| join kind=inner (SigninLogs | where TimeGenerated between(starttime..endtime) | where ResultType == 0) on ServicePrincipalId\n| extend AccountCustomEntity = ServicePrincipalId, IPCustomEntity = IPAddress\n", "attributes": {"description": "'This query look for Service Principal accounts that are no longer used where a user has added or updated credentials for them before logging in with the Service Principal.\n Threat actors may look to re-activate dormant accounts and use them for access in the hope that changes to such dormant accounts may go un-noticed.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/DormantUserUpdateMFAandLogsIn-UEBA.yaml", "query_name": "Dormant User Update MFA and Logs In - UEBA", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = endtime - 14d;\nlet active_users = (\n  BehaviorAnalytics\n  | extend dormant = tostring(UsersInsights.IsDormantAccount)\n  | where isempty(dormant)\n  | summarize by UserPrincipalName);\nAuditLogs\n| where TimeGenerated between(starttime..endtime)\n// Get users where they added MFA\n| where OperationName =~ \"User registered security info\"\n| extend TargetUser = tolower(tostring(TargetResources[0].userPrincipalName))\n| extend UserId = tostring(TargetResources[0].id)\n// Check and see if this activity was from a user who is considered not active\n| where UserId !in (active_users)\n// Further reduce FP by just looking at users who have successfully logged in recently as well (avoiding hits for users adding MFA but not actually logging in)\n| join kind=inner (SigninLogs | where TimeGenerated > ago(1d) | where ResultType == 0 | summarize max(TimeGenerated), make_set(IPAddress), make_set(UserAgent), make_set(LocationDetails) by UserPrincipalName, UserId\n) on UserId\n| extend LogonLocation = set_LocationDetails[0], LogonUserAgent = set_UserAgent[0], LogonIP = set_IPAddress[0]\n| project-rename MostRecentLogon = max_TimeGenerated\n| project-reorder TimeGenerated, TargetUser, OperationName, ResultDescription, MostRecentLogon, LogonUserAgent, LogonLocation, LogonIP\n| extend AccountCustomEntity = TargetUser, IPCustomEntity = LogonIP\n", "attributes": {"description": "'This query look for accounts that have not been successfully logged into recently who then add or update an MFA method before logging in.\nThreat actors may look to re-activate dormant accounts and use them for access by adding MFA methods in the hope that changes to such dormant accounts may go un-noticed. This query uses the Microsoft Sentinel UEBA features.\nRef: [LINK TO BLOG]'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/DormantUserUpdateMFAandLogsIn.yaml", "query_name": "Dormant User Update MFA and Logs In", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = endtime - 14d;\nlet active_users = (\n    SigninLogs\n    | where TimeGenerated between(lookback..starttime)\n    | where ResultType == 0\n    | extend UserPrincipalName == tolower(UserPrincipalName)\n    | summarize by UserId);\nAuditLogs\n| where TimeGenerated between(starttime..endtime)\n// Get users where they added MFA\n| where OperationName =~ \"User registered security info\"\n| extend TargetUser = tolower(tostring(TargetResources[0].userPrincipalName))\n| extend UserId = tostring(TargetResources[0].id)\n// Check and see if this activity was from a user who is considered not active\n| where UserId !in (active_users)\n// Further reduce FP by just looking at users who have successfully logged in recently as well (avoiding hits for users adding MFA but not actually logging in)\n| join kind=inner (SigninLogs | where TimeGenerated  between(starttime..endtime) | where ResultType == 0 | summarize max(TimeGenerated), make_set(IPAddress), make_set(UserAgent), make_set(LocationDetails) by UserPrincipalName, UserId\n) on UserId\n| extend LogonLocation = set_LocationDetails[0], LogonUserAgent = set_UserAgent[0], LogonIP = set_IPAddress[0]\n| project-rename MostRecentLogon = max_TimeGenerated\n| project-reorder TimeGenerated, TargetUser, OperationName, ResultDescription, MostRecentLogon, LogonUserAgent, LogonLocation, LogonIP\n| extend AccountCustomEntity = TargetUser, IPCustomEntity = LogonIP\n", "attributes": {"description": "'This querys look for users accounts that have not been successfully logged into recently, who then have a MFA method added or updated before logging in.\nThreat actors may look to re-activate dormant accounts and use them for access by adding MFA methods in the hope that changes to such dormant accounts may go un-noticed.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/DownloadofNewFileUsingCurl.yaml", "query_name": "Download of New File Using Curl", "query": "let known_files = DeviceNetworkEvents\n  | where TimeGenerated between (ago(7d)..ago(1d))\n  | where InitiatingProcessFileName has \"curl\"\n  | extend url = extract(\"http[s]?:\\\\/\\\\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\", 0,InitiatingProcessCommandLine)\n  | extend ip = extract(\"(\\\\b25[0-5]|\\\\b2[0-4][0-9]|\\\\b[01]?[0-9][0-9]?)(\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}[^ ]*\", 0, InitiatingProcessCommandLine)\n  | extend remote_file = iif(isnotempty(url), url, ip)\n  | union (SecurityEvent\n  | where TimeGenerated between (ago(7d)..ago(1d))\n  | where EventID == 4688\n  | where CommandLine has \"curl\"\n  | extend url = extract(\"http[s]?:\\\\/\\\\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\", 0,CommandLine)\n  | extend ip = extract(\"(\\\\b25[0-5]|\\\\b2[0-4][0-9]|\\\\b[01]?[0-9][0-9]?)(\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}[^ ]*\", 0, CommandLine)\n  | extend remote_file = iif(isnotempty(url), url, ip))\n  | summarize by remote_file;\n  DeviceNetworkEvents\n  | where TimeGenerated > ago(1d)\n  | where InitiatingProcessFileName has \"curl\"\n  | extend url = extract(\"http[s]?:\\\\/\\\\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\", 0,InitiatingProcessCommandLine)\n  | extend ip = extract(\"(\\\\b25[0-5]|\\\\b2[0-4][0-9]|\\\\b[01]?[0-9][0-9]?)(\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}[^ ]*\", 0, InitiatingProcessCommandLine)\n  | extend remote_file = iif(isnotempty(url), url, ip)\n  | union (SecurityEvent\n  | where EventID == 4688\n  | where CommandLine has \"curl\"\n  | extend url = extract(\"http[s]?:\\\\/\\\\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\", 0,CommandLine)\n  | extend ip = extract(\"(\\\\b25[0-5]|\\\\b2[0-4][0-9]|\\\\b[01]?[0-9][0-9]?)(\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}[^ ]*\", 0, CommandLine)\n  | extend remote_file = iif(isnotempty(url), url, ip))\n  | where remote_file !in (known_files)\n", "attributes": {"description": "'Threat actors may use tools such as Curl to download additional files, communicate with C2 infrastructure, or exfiltrate data. This query looks for new files being downloaded using Curl. Curl also has legitimate uses files and hosts should be reviewed to identify potentially malicious activity.\n  Ref: https://www.microsoft.com/security/blog/2022/07/27/untangling-knotweed-european-private-sector-offensive-actor-using-0-day-exploits/'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/ExchangeServersAssociatedSecurityAlerts.yaml", "query_name": "Exchange Servers and Associated Security Alerts", "query": "\nW3CIISLog\n| where csUriStem has_any(\"/owa/auth/\", \"/ecp/healthcheck.htm\", \"/ews/exchange.asmx\")\n| summarize by computer=tolower(Computer)\n| join kind=leftouter (\n  SecurityAlert\n  | extend alertData = parse_json(Entities)\n  | mvexpand alertData\n  | where alertData.Type == \"host\"\n  | extend computer = iff(isnotempty(alertData.DnsDomain), tolower(strcat(tostring(alertData.HostName), \".\" , tostring(alertData.DnsDomain))),tolower(tostring(alertData.HostName)))\n  | summarize Alerts=dcount(SystemAlertId), AlertTimes=make_list(TimeGenerated), AlertNames=make_list(AlertName) by computer\n) on computer\n| project ExchangeServer=computer, Alerts, AlertTimes, AlertNames\n", "attributes": {"description": "'This query will dynamically identify Exchange servers using common web paths used by the application in the csUriStem. The query\nwill then collect MDE alerts from the SecurityAlert table using the identified Exchange Server hostnames.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/FailedSigninsWithAuditDetails.yaml", "query_name": "Failed service logon attempt by user account with available AuditData", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nlet failLimit = 10;\nlet ipLimit = 3;\nlet failedSignins = SigninLogs\n| where TimeGenerated between(starttime..endtime)\n| where ResultType != \"0\" and AppDisplayName != \"Windows Sign In\"\n| extend UserPrincipalName = tolower(UserPrincipalName)\n| extend CityState = strcat(tostring(LocationDetails.city),\"|\", tostring(LocationDetails.state))\n| extend Result = strcat(ResultType,\"-\",ResultDescription)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), DistinctIPAddressCount = dcount(IPAddress), IPAddresses = makeset(IPAddress),\nCityStates = makeset(CityState), DistinctResultCount = dcount(Result), Results = makeset(Result), AppDisplayNames = makeset(AppDisplayName),\nFailedLogonCount = count() by Type, OperationName, Category, UserPrincipalName = tolower(UserPrincipalName), ClientAppUsed, Location, CorrelationId\n| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, AppDisplayNames, DistinctIPAddressCount, IPAddresses, DistinctResultCount,\nResults, FailedLogonCount, Location, CityStates\n| where FailedLogonCount >= failLimit or DistinctIPAddressCount >= ipLimit\n| extend Activity = pack(\"IPAddresses\", IPAddresses, \"AppDisplayNames\", AppDisplayNames, \"Results\", Results, \"Location\", Location, \"CityStates\", CityStates)\n| project Type, StartTimeUtc, EndTimeUtc, OperationName, Category, UserPrincipalName, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, Activity\n| extend AccountCustomEntity = UserPrincipalName;\nlet accountMods = AuditLogs | where TimeGenerated >= ago(lookback)\n| where Category == \"UserManagement\" or Category == \"GroupManagement\"\n| extend ModProps = TargetResources.[0].modifiedProperties\n| extend InitiatedBy = case(\nisnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName),\nisnotempty(tostring(parse_json(tostring(InitiatedBy.app)).displayName)), tostring(parse_json(tostring(InitiatedBy.app)).displayName),\n\"\")\n| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n| mvexpand ModProps\n| extend PropertyName = tostring(ModProps.displayName), oldValue = tostring(ModProps.oldValue), newValue = tostring(ModProps.newValue)\n| extend ModifiedProps = pack(\"PropertyName\",PropertyName,\"oldValue\",oldValue,\"newValue\",newValue)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Activity = make_bag(ModifiedProps) by Type, InitiatedBy, UserPrincipalName, Category, OperationName, CorrelationId, Id\n| extend AccountCustomEntity = UserPrincipalName;\n// Gather only Audit data for UserPrincipalNames that we have Audit data for\nlet accountNameOnly = failedSignins | project UserPrincipalName;\nlet auditMods = accountNameOnly\n| join kind= innerunique (\naccountMods\n) on UserPrincipalName;\nlet availableAudits = auditMods | project UserPrincipalName;\nlet signinsWithAudit = availableAudits\n| join kind= innerunique (\nfailedSignins\n) on UserPrincipalName;\n// Union the Current Signin failures so we do not lose them with the Auditing data we do have\nlet activity = (union isfuzzy=true\nsigninsWithAudit, auditMods)\n| order by StartTimeUtc, UserPrincipalName;\nactivity\n| project StartTimeUtc, EndTimeUtc, DataType = Type, Category, OperationName, UserPrincipalName, InitiatedBy, Activity, FailedLogonCount, DistinctIPAddressCount, DistinctResultCount, CorrelationId, Id\n| order by UserPrincipalName, StartTimeUtc\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'User account failed to logon in current period (default last 1 day). Excludes Windows Sign in attempts due to noise and limits to only more than 10 failed logons or 3 different IPs used.\nAdditionally, Azure Audit Log data from the last several days(default 7 days) related to the given UserPrincipalName will be joined if available.\nThis can help to understand any events for this same user related to User or Group Management.\nResults may indicate a potential malicious use of an account that is rarely used. It is possible this is an account that is new or newly enabled.\nThe associated Azure Audit data should help determine any recent changes to this account and may help you understand why the logons are failing.\nReceiving no results indicates that there were no less than 10 failed logons or that the Auditlogs related to this UserPrincipalName in the default 7 days.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/FireEyeRedTeamComms.yaml", "query_name": "FireEye stolen red teaming tools communications", "query": "\nlet domainCountThreshold = 100; //Maxiumum number of times a domain ahs been visited\n//Backdoor.HTTP.BEACON.[Yelp GET]\nlet FEQuery1 = CommonSecurityLog\n| where RequestMethod == \"GET\"\n| where RequestURL contains \"&parent_request_id=\"\n| where RequestURL matches regex @\"&parent_request_id=(?:[A-Za-z0-9_\\/\\+\\-\\%]{128,1000})={0,2}[^\\r\\n]{0,256}\"\n| extend Quality = \"high\"\n| extend RuleName = \"Backdoor.HTTP.BEACON.[Yelp GET]\"\n| project TimeGenerated, Quality, RuleName, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL;\n//Backdoor.HTTP.BEACON.[CSBundle CDN GET]\nlet FEQuery2 = CommonSecurityLog\n| where RequestMethod == \"GET\"\n| where FileType =~ \"GZIP\"\n| where RequestURL matches regex @\"(?:\\/v1\\/queue|\\/v1\\/profile|\\/v1\\/docs\\/wsdl|\\/v1\\/pull)\"\n| extend Quality = \"low\"\n| extend RuleName = \"Backdoor.HTTP.BEACON.[CSBundle CDN GET]\"\n| project TimeGenerated, Quality, RuleName, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL;\n//Backdoor.HTTP.BEACON.[CSBundle USAToday GET]\nlet FEQuery3 = CommonSecurityLog\n| where RequestMethod == \"GET\"\n| where isempty(RequestContext)\n| where RequestURL matches regex @\"(?:\\/USAT-GUP\\/user\\/|\\/entertainment\\/|\\/entertainment\\/navdd-q1a2z3Z6TET4gv2PNfXpaJAniOzOajK7M\\.min\\.json|\\/global-q1a2z3C4M2nNlQYzWhCC0oMSEFjQbW1KA\\.min\\.json|\\/life\\/|\\/news\\/weather\\/|\\/opinion\\/|\\/sports\\/|\\/sports\\/navdd-q1a2z3JHa8KzCRLOQAnDoVywVWF7UwxJs\\.min\\.json|\\/tangstatic\\/js\\/main-q1a2z3b37df2b1\\.min\\.js|\\/tangstatic\\/js\\/pbjsandwich-q1a2z300ab4198\\.min\\.js|\\/tangstatic\\/js\\/pg-q1a2z3bbc110a4\\.min\\.js|\\/tangsvc\\/pg\\/3221104001\\/|\\/ta`ngsvc\\/pg\\/5059005002\\/|\\/tangsvc\\/pg\\/5066496002\\/|\\/tech\\/|\\/travel\\/)\"\n| where DestinationHostName !endswith \"usatoday.com\"\n| extend Quality = \"medium\"\n| extend RuleName = \"Backdoor.HTTP.BEACON.[CSBundle USAToday GET]\"\n| project TimeGenerated, Quality, RuleName, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL;\n//Backdoor.HTTP.BEACON.[CSBundle Original POST]\nlet FEQuery4 = CommonSecurityLog\n| where RequestMethod == \"POST\"\n| where isempty(RequestContext)\n| where RequestURL matches regex @\"(?:\\/v4\\/links\\/check-activity\\/check|\\/v1\\/stats|\\/gql|\\/api2\\/json\\/check\\/ticket|\\/1.5\\/95648064\\/storage\\/history|\\/1.5\\/95648064\\/storage\\/tabs|\\/u\\/0\\/_\\/og\\/botguard\\/get|\\/ev\\/prd001001|\\/ev\\/ext001001|\\/gp\\/aw\\/ybh\\/handlers|\\/v3\\/links\\/ping-beat\\/check)\"\n| extend Quality = \"low\"\n| extend RuleName = \"Backdoor.HTTP.BEACON.[CSBundle Original POST]\"\n| project TimeGenerated, Quality, RuleName, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL;\n//Backdoor.HTTP.BEACON.[CSBundle MSOffice POST\nlet FEQuery5 = CommonSecurityLog\n| where RequestMethod == \"POST\"\n| where isempty(RequestContext)\n| where RequestURL contains \"/v1/push\"\n| extend Quality = \"low\"\n| extend RuleName = \"Backdoor.HTTP.BEACON.[CSBundle MSOffice POST]\"\n| project TimeGenerated, Quality, RuleName, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL;\n//Backdoor.HTTP.BEACON.[CSBundle NYTIMES POST]\nlet FEQuery6 = CommonSecurityLog\n| where RequestMethod == \"POST\"\n| where isempty(RequestContext)\n| where RequestURL matches regex @\"(?:\\/track|\\/api\\/v1\\/survey\\/embed|\\/svc\\/weather\\/v2)\"\n| extend Quality = \"low\"\n| extend RuleName = \"Backdoor.HTTP.BEACON.[CSBundle NYTIMES POST]\"\n| project TimeGenerated, Quality, RuleName, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL;\n//Backdoor.HTTP.BEACON.[CSBundle MSOffice GET]\nlet FEQuery7 = CommonSecurityLog\n| where RequestMethod == \"GET\"\n| where isempty(RequestContext)\n| where RequestURL matches regex @\"(?:\\/updates|\\/license\\/eula|\\/docs\\/office|\\/software-activation)\"\n| extend Quality = \"low\"\n| extend RuleName = \"Backdoor.HTTP.BEACON.[CSBundle MSOffice GET]\"\n| project TimeGenerated, Quality, RuleName, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL;\n//Backdoor.HTTP.BEACON.[CSBundle MSOffice POST]\nlet FEQuery8 = CommonSecurityLog\n| where RequestMethod == \"POST\"\n| where isempty(RequestContext)\n| where RequestURL contains \"/notification\"\n| extend Quality = \"low\"\n| extend RuleName = \"Backdoor.HTTP.BEACON.[CSBundle MSOffice POST]\"\n| project TimeGenerated, Quality, RuleName, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL;\n//Backdoor.HTTP.BEACON.[CSBundle Original GET]\nlet FEQuery9 = CommonSecurityLog\n| where RequestMethod == \"GET\"\n| where isempty(RequestContext)\n| where RequestURL matches regex @\"(?:\\/api2\\/json\\/access\\/ticket|\\/api2\\/json\\/cluster\\/resources|\\/api2\\/json\\/cluster\\/tasks|\\/en-us\\/p\\/onerf\\/MeSilentPassport|\\/en-us\\/p\\/book-2\\/8MCPZJJCC98C|\\/en-us\\/store\\/api\\/checkproductinwishlist|\\/gp\\/cerberus\\/gv|\\/gp\\/aj\\/private\\/reviewsGallery\\/get-application-resources|\\/gp\\/aj\\/private\\/reviewsGallery\\/get-image-gallery-assets|\\/v1\\/buckets\\/default\\/ext-5dkJ19tFufpMZjVJbsWCiqDcclDw\\/records|\\/v3\\/links\\/ping-centre|\\/v4\\/links\\/activity-stream|\\/wp-content\\/themes\\/am43-6\\/dist\\/records|\\/wp-content\\/themes\\/am43-6\\/dist\\/records|\\/wp-includes\\/js\\/script\\/indigo-migrate)\"\n| extend Quality = \"medium\"\n| extend RuleName = \"Backdoor.HTTP.BEACON.[CSBundle Original GET]\"\n| project TimeGenerated, Quality, RuleName, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL;\nlet Results = union FEQuery1, FEQuery3, FEQuery4, FEQuery5, FEQuery6, FEQuery7, FEQuery8, FEQuery9;\n//Check to see if the destination host name is low hitting in data, defeats a lot of legit API traffic\nResults\n| join (\n    CommonSecurityLog\n    | where DestinationHostName != \"\"\n  | summarize DomainCount=count() by DestinationHostName)\non $left.DestinationHostName == $right.DestinationHostName\n| project TimeGenerated, Quality, DeviceVendor, DeviceProduct, TenantId, SourceIP, DestinationIP, DestinationHostName, RequestMethod, RequestURL, DomainCount\n| where DomainCount <= domainCountThreshold\n", "attributes": {"description": "'This composite hunting query will highlight any HTTP traffic in CommonSecurityLog web proxies (such as ZScaler) that match known patterns used by red teaming tools potentially stolen from FireEye. Most FireEye red teaming tools are designed to mimic\nlegitimate API activity, false positives are common. This query includes a basic check to determine how common a hostname is in you environment, and allows you to modify this threshold to remove legitimate traffic from the query results.\nThis query contains only a subset of potential FireEye red team tool communications, and therefore should not be relied upon alone :) .'\n", "techniques": ["T1071.001"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/FirewallRuleChanges_using_netsh.yaml", "query_name": "Rare firewall rule changes using netsh", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\n// historical time frame\nlet lookback = totimespan((endtime-starttime)*7);\nlet AccountAllowList = dynamic(['SYSTEM']);\nlet tokens = dynamic([\"add\", \"delete\", \"set\"]);\n(union isfuzzy=true\n(\nSecurityEvent\n| where TimeGenerated >= ago(lookback)\n// remove comment below to adjust for noise\n// | where Process =~ \"netsh.exe\"\n| where CommandLine has_all (\"advfirewall\", \"firewall\") and CommandLine has_any (tokens)\n| where AccountType !~ \"Machine\" and Account !in~ (AccountAllowList)\n| extend KeyValuePairs = extract_all(@'(?P<key>\\w+)=(?P<value>[a-zA-Z0-9-\\\":\\\\\\s$_@().\"]+\\\"|[a-zA-Z0-9-\\\":$_\\\\@().\"]+)', dynamic([\"key\",\"value\"]), CommandLine)\n| mv-apply KeyValuePairs on (\n  summarize CommandLineParsed = make_bag(pack(tostring(KeyValuePairs[0]), KeyValuePairs[1]))\n )\n| extend RuleName = tostring(parse_json(CommandLineParsed).name), Program = tostring(parse_json(CommandLineParsed).program)\n| join kind=leftanti (\nSecurityEvent\n| where TimeGenerated between (starttime..endtime)\n// remove comment below to adjust for noise\n// | where Process =~ \"netsh.exe\"\n| where CommandLine has_all (\"advfirewall\", \"firewall\") and CommandLine has_any (tokens)\n| where AccountType !~ \"Machine\" and Account !in~ (AccountAllowList)\n| extend KeyValuePairs = extract_all(@'(?P<key>\\w+)=(?P<value>[a-zA-Z0-9-\\\":\\\\\\s$_@().\"]+\\\"|[a-zA-Z0-9-\\\":$_\\\\@().\"]+)', dynamic([\"key\",\"value\"]), CommandLine)\n| mv-apply KeyValuePairs on (\n  summarize CommandLineParsed = make_bag(pack(tostring(KeyValuePairs[0]), KeyValuePairs[1]))\n )\n| extend RuleName = tostring(parse_json(CommandLineParsed).name), Program = tostring(parse_json(CommandLineParsed).program)\n) on RuleName, Program\n| summarize count() , StartTime= min(TimeGenerated), EndTime=max(TimeGenerated) by Type, Computer, Account, SubjectDomainName, SubjectUserName, RuleName, Program, CommandLineParsed = tostring(CommandLineParsed), Process, ParentProcessName\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(\nDeviceProcessEvents\n| where TimeGenerated >= ago(lookback)\n// remove comment below to adjust for noise\n// | where InitiatingProcessFileName =~ \"netsh.exe\"\n| where InitiatingProcessCommandLine has_all (\"advfirewall\", \"firewall\") and InitiatingProcessCommandLine has_any (tokens)\n| where AccountName !in~ (AccountAllowList)\n| extend KeyValuePairs = extract_all(@'(?P<key>\\w+)=(?P<value>[a-zA-Z0-9-\\\":\\\\\\s$_@().\"]+\\\"|[a-zA-Z0-9-\\\":$_\\\\@().\"]+)', dynamic([\"key\",\"value\"]), InitiatingProcessCommandLine)\n| mv-apply KeyValuePairs on (\n  summarize CommandLineParsed = make_bag(pack(tostring(KeyValuePairs[0]), KeyValuePairs[1]))\n)\n| extend RuleName = tostring(parse_json(CommandLineParsed).name), Program = tostring(parse_json(CommandLineParsed).program)\n| join kind=leftanti (\nDeviceProcessEvents\n| where TimeGenerated between (starttime..endtime)\n// remove comment below to adjust for noise\n// | where InitiatingProcessFileName =~ \"netsh.exe\"\n| where InitiatingProcessCommandLine has_all (\"advfirewall\", \"firewall\") and InitiatingProcessCommandLine has_any (tokens)\n| where AccountName !in~ (AccountAllowList)\n| extend KeyValuePairs = extract_all(@'(?P<key>\\w+)=(?P<value>[a-zA-Z0-9-\\\":\\\\\\s$_@().\"]+\\\"|[a-zA-Z0-9-\\\":$_\\\\@().\"]+)', dynamic([\"key\",\"value\"]), InitiatingProcessCommandLine)\n| mv-apply KeyValuePairs on (\n  summarize CommandLineParsed = make_bag(pack(tostring(KeyValuePairs[0]), KeyValuePairs[1]))\n)\n| extend RuleName = tostring(parse_json(CommandLineParsed).name), Program = tostring(parse_json(CommandLineParsed).program)\n) on RuleName, Program\n| summarize count() , StartTime= min(TimeGenerated), EndTime=max(TimeGenerated) by Type, DeviceName, AccountName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, RuleName, Program,  CommandLineParsed = tostring(CommandLineParsed), InitiatingProcessFileName, InitiatingProcessParentFileName\n| extend timestamp = StartTime, AccountCustomEntity = InitiatingProcessAccountName, HostCustomEntity = DeviceName\n),\n(\nEvent\n| where TimeGenerated > ago(lookback)\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n// remove comment below to adjust for noise\n// | where OriginalFileName =~ \"netsh.exe\"\n| where CommandLine has_all (\"advfirewall\", \"firewall\") and CommandLine has_any (tokens)\n| where User !in~ (AccountAllowList)\n| extend KeyValuePairs = extract_all(@'(?P<key>\\w+)=(?P<value>[a-zA-Z0-9-\\\":\\\\\\s$_@().\"]+\\\"|[a-zA-Z0-9-\\\":$_\\\\@().\"]+)', dynamic([\"key\",\"value\"]), CommandLine)\n| mv-apply KeyValuePairs on (\n  summarize CommandLineParsed = make_bag(pack(tostring(KeyValuePairs[0]), KeyValuePairs[1]))\n)\n| extend RuleName = tostring(parse_json(CommandLineParsed).name), Program = tostring(parse_json(CommandLineParsed).program)\n| join kind=leftanti (\nEvent\n| where TimeGenerated > ago(lookback)\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n// remove comment below to adjust for noise\n// | where OriginalFileName =~ \"netsh.exe\"\n| where CommandLine has_all (\"advfirewall\", \"firewall\") and CommandLine has_any (tokens)\n| where User !in~ (AccountAllowList)\n| extend KeyValuePairs = extract_all(@'(?P<key>\\w+)=(?P<value>[a-zA-Z0-9-\\\":\\\\\\s$_@().\"]+\\\"|[a-zA-Z0-9-\\\":$_\\\\@().\"]+)', dynamic([\"key\",\"value\"]), CommandLine)\n| mv-apply KeyValuePairs on (\n  summarize CommandLineParsed = make_bag(pack(tostring(KeyValuePairs[0]), KeyValuePairs[1]))\n)\n| extend RuleName = tostring(parse_json(CommandLineParsed).name), Program = tostring(parse_json(CommandLineParsed).program)\n) on RuleName, Program\n| extend Type = strcat(Type, \": \", Source)\n| summarize count() , StartTime= min(TimeGenerated), EndTime=max(TimeGenerated) by Type, Computer, User, Process, RuleName, Program, CommandLineParsed = tostring(CommandLineParsed), ParentImage\n| extend timestamp = StartTime, AccountCustomEntity = User, HostCustomEntity = Computer\n)\n)\n", "attributes": {"description": "This query will show rare firewall rule changes using netsh utility by comparing rule names and program names from the previous day\nwith those from the historical chosen time frame.\n- This technique was seen in relation to Solarigate attack but the results can indicate potential  malicious activity used in different attacks.\n- The process name in each data source is commented out as an adversary could rename it. It is advisable to keep process name commented but\n  if the results show unrelated false positives, users may want to uncomment it.\n- Note also that the queries use the KQL \"has_all\" operator, which hasn't yet been documented officially, but will be soon.\n  In short, \"has_all\" will only match when the referenced field has all strings in the list.\nRefer to netsh syntax: https://docs.microsoft.com/windows-server/administration/windows-commands/netsh\nRefer to our M365 blog for details on use during the Solorigate attack:\nhttps://www.microsoft.com/security/blog/2021/01/20/deep-dive-into-the-solorigate-second-stage-activation-from-sunburst-to-teardrop-and-raindrop/\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/LogonwithExpiredAccount.yaml", "query_name": "Failed Login Attempt by Expired account", "query": "\n(union isfuzzy=true\n(SecurityEvent \n| where EventID == 4625\n//4625: An account failed to log on\n| where AccountType == 'User' \n| where SubStatus == '0xc0000193' \n| extend Reason = \ncase\n( SubStatus == '0xc0000193', 'Windows EventID (4625) - Account has expired', \"Unknown\")\n| project Computer, Account,  Reason , TimeGenerated\n),\n(\nSecurityEvent \n| where EventID == 4769\n//4769: A Kerberos service ticket was requested ( Kerberos Auth)\n| parse EventData with * 'Status\">' Status \"<\" *\n| parse EventData with * 'TargetUserName\">' TargetUserName \"<\" *\n| where Status == '0x12'\n| where TargetUserName !has \"$\" and isnotempty(TargetUserName)\n| extend Reason = \ncase(\nStatus == '0x12', 'Windows EventID (4769) - Account disabled, expired, locked out',\n'Unknown'), Account = TargetUserName \n| project Computer, Account, Reason , TimeGenerated\n),\n(\nSecurityEvent\n| where EventID == 4776 \n// 4776: The domain controller attempted to validate the credentials for an account ( NTLM Auth)\n| where Status == \"0xc0000193\"\n| extend Reason = \ncase(\nErrorCode == '0xc0000193', 'Windows EventID (4776) - Account has expired',\n'Unknown'), Account = TargetAccount \n| parse EventData with * 'Workstation\">' Workstation \"<\" *\n| extend Workstation = trim_start(@\"[\\\\]*\", Workstation)\n| extend Computer = iff(isnotempty(Workstation), Workstation, Computer ) \n| project Computer, Account, Reason , TimeGenerated\n) ,\n(\nSigninLogs \n| where ResultType == \"50057\" \n| extend Reason = \ncase(\nResultType == '50057', 'SigninLogs( Result Code- 50057) - User account is disabled. The account has been disabled by an administrator.',\n'Unknown'), Account = UserPrincipalName \n| project Computer, Account, Reason , TimeGenerated\n) )\n| summarize StartTimeUtc = min(TimeGenerated), EndTImeUtc = max(TimeGenerated), EventCount = count() by Computer, Account, Reason\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer\n| order by EventCount desc \n", "attributes": {"description": "'This query looks at Account Logon events found through Windows Event Id's as well as SigninLogs to discover \nlogin attempts by accounts that have expired.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NetworkConnectiontoOMIPorts.yaml", "query_name": "Connection from external IP to OMI related Ports", "query": "let Port = dynamic([\"5985\",\"5986\",\"1270\"]); \n(union isfuzzy=true\n(imNetworkSession\n| extend result = ipv4_is_private(SrcIpAddr)\n| where result == 0  and SrcIpAddr != \"127.0.0.1\"\n| where DstPortNumber in (Port)\n| where EventResult != 'Failure'\n| project TimeGenerated, EventProduct, EventResourceId, EventResult, SourceIp = SrcIpAddr, DestinationIp = DstIpAddr,Type, Computer, DestinationPort= DstPortNumber, SrcPortNumber, Protocol = NetworkProtocol, RemoteCountry = SrcGeoCountry, SrcGeoCity, RemoteLatitude = SrcGeoLatitude, RemoteLongitude = SrcGeoLongitude\n| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp \n),\n(VMConnection\n| where Direction == \"inbound\"\n| extend result = ipv4_is_private(SourceIp)\n| where result == 0  and SourceIp != \"127.0.0.1\"\n| where ProcessName == 'omiengine'\n| where DestinationPort in (Port)\n| project TimeGenerated, Computer, Direction, ProcessName, SourceIp, DestinationIp, DestinationPort, Protocol, RemoteCountry, RemoteLatitude, RemoteLongitude, Type\n| extend Timestamp = TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = SourceIp\n),\n(AzureNetworkAnalytics_CL\n| extend result = ipv4_is_private(SrcIP_s) \n| where result == 0 and SrcIP_s != \"127.0.0.1\"\n| where L7Protocol_s has 'wsman'\n| where DestPort_d in (Port)\n| parse VM_s with * '/' VM \n| project TimeGenerated, SourceIp = SrcIP_s, DestinationIp = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRule_s, VM, Type\n| extend Timestamp = TimeGenerated, HostCustomEntity = VM, IPCustomEntity = SourceIp\n),\nAzureDiagnostics\n| where Category == \"AzureFirewallNetworkRule\" and OperationName == \"AzureFirewallNatRuleLog\"\n| parse msg_s with Protocol ' request from ' SourceIp ':' SourcePort ' to ' DestinationIp ':' DestinationPort \" was \" Action \" to \" InternalIP ':' InternalPort\n| where DestinationPort in (Port)\n| project TimeGenerated, SourceIp, DestinationIp, DestinationPort, Protocol, Action, Resource\n| extend Timestamp = TimeGenerated, IPCustomEntity = SourceIp\n)\n)\n", "attributes": {"description": "'This query identifies connection attempts from the external IP addresses to the management ports(5985,5986,1270) related to Open Management Infrastructure(OMI). \n OMI is the Linux equivalent of Windows WMI and helps users manage configurations across remote and local environments. \n The query aims to find attacks targeting OMI vulnerability (CVE-2021-38647). The query primarily leverages the Network Session normalization schema(imNetworkSession) \n as well as a few other logs to look for this activity. The Network normalizing parsers can be deployed in a click using an ARM Template shared in the link below:\n Reference: https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-for-omi-vulnerability-exploitation-with-azure-sentinel/ba-p/2764093\n Reference: https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure\n Reference: https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/ASimNetworkSession\n", "techniques": ["T1595", "T1190"], "tactics": ["Reconnaissance", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NICKELCommandLineActivity-Nov2021.yaml", "query_name": "NICKEL Command Line Activity November 2021", "query": "let xcopy_tokens = dynamic([\"xcopy\", \"\\\\windows\\\\temp\\\\wmi\", \"/S/Y/C\"]);\nlet archive_tokens = dynamic([\"\\\\windows\\\\temp\\\\wmi\", \".rar\", \".7zip\"]);\nlet SigNames = dynamic([\"Backdoor:Win32/Leeson\", \"Trojan:Win32/Kechang\", \"Backdoor:Win32/Nightimp!dha\", \"Trojan:Win32/QuarkBandit.A!dha\", \"TrojanSpy:Win32/KeyLogger\"]);\n(union isfuzzy=true\n(DeviceProcessEvents  \n| where ProcessCommandLine has_all(xcopy_tokens) or (ProcessCommandLine has_all (archive_tokens)) \n| join kind=leftouter (\nSecurityAlert\n| where ProductName == \"Microsoft Defender Advanced Threat Protection\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| where isnotempty(ThreatName)\n| extend AlertRiskScore =iif(ThreatName has_any (SigNames), 1.0, 0.5)) on DeviceId\n| extend AlertRiskScore = iif(isempty(AlertRiskScore), 0.0 , AlertRiskScore)\n| project-reorder  TimeGenerated, DeviceName, DeviceId, ProcessCommandLine, AccountName\n| extend timestamp = TimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = DeviceName,  ProcessCustomEntity = InitiatingProcessFileName\n),\n(imProcessCreate\n| where (CommandLine has_all (xcopy_tokens)) or (CommandLine has_all (archive_tokens))\n| extend timestamp = TimeGenerated, HostCustomEntity = DvcHostname , AccountCustomEntity = ActorUsername, ProcessCustomEntity = TargetProcessFilePath\n),\n(SecurityEvent\n| where EventID == '4688'\n| where (CommandLine has_all (xcopy_tokens)) or (CommandLine has_all (archive_tokens))\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, CommandLine\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n),\n(WindowsEvent\n| where EventID == '4688' and (EventData has_all (xcopy_tokens) or EventData has_all (archive_tokens))\n| extend CommandLine = tostring(EventData.CommandLine) \n| where (CommandLine has_all (xcopy_tokens)) or (CommandLine has_all (archive_tokens))\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend NewProcessId = tostring(EventData.NewProcessId)\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, CommandLine\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n)\n)\n", "attributes": {"description": "'This hunting query looks for process command line activity related to data collection and staging observed by NICKEL.\nIt hunts for use of tools such as xcopy and renamed archiving tools for data collection and staging purposes on the hosts with signatures observed related to NICKEL actor.'\n", "techniques": ["T1074.001"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/NickelRegIOCPatterns.yaml", "query_name": "Known NICKEL Registry modifications patterns", "query": "let reg_paths = dynamic([\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Internet Explorer\\\\Main\", \n                        \"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Internet Explorer\\\\Recovery\", \n                        \"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Internet Explorer\\\\Privacy\", \n                        \"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings\\\\ZoneMap\"\n                        ]);\nlet reg_keys = dynamic([\"Start Page\", \"DisableFirstRunCustomize\", \"RunOnceComplete\", \"RunOnceHasShown\", \"Check_Associations\", \"AutoRecover\", \"ClearBrowsingHistoryOnExit\", \"Completed\", \"IEHarden\"]);\n(union isfuzzy=true\n(\nSecurityEvent\n| where EventID == 4657\n| where ObjectName has_any (reg_paths) and ObjectValueName has_any (reg_keys)\n| summarize Count=count() by Computer, Account, ObjectName\n| extend AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(\nWindowsEvent\n| where EventID == 4657 and EventData  has_any (reg_paths) and EventData has_any (reg_keys)\n| extend ObjectName = tostring(EventData.ObjectName)\n| extend ObjectValueName = tostring(EventData.ObjectValueName)\n| where ObjectName has_any (reg_paths) and ObjectValueName has_any (reg_keys)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| summarize Count=count() by Computer, Account, ObjectName\n| extend AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(\nEvent\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID in (12, 13)\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| where TargetObject has_any (reg_paths) and TargetObject has_any (reg_keys)\n| summarize Count=count() by Computer, UserName, tostring(TargetObject)\n| extend AccountCustomEntity = UserName, HostCustomEntity = Computer\n),\n(\nimRegistry\n| where RegistryKey has_any (reg_paths) and RegistryValue has_any (reg_keys)\n| summarize Count=count() by Dvc, Username, RegistryKey\n| extend AccountCustomEntity = Username, HostCustomEntity = Dvc\n)\n)\n", "attributes": {"description": "'This query identifies instances where malware intentionally configures the browser settings for its use by modifying the following registry entries by NICKEL threat actor.'\n", "techniques": ["T1546.012"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/PermutationsOnLogonNames.yaml", "query_name": "Permutations on logon attempts by UserPrincipalNames indicating potential brute force", "query": "\nlet fl_Min = 3;\nlet un_MatchMin = 2;\nlet upnFunc = (tableName:string){\ntable(tableName) \n| extend Operation = columnifexists(\"Operation\", \"Sign-in activity\")\n| where Operation == \"UserLoginFailed\" or Operation == \"Sign-in activity\"\n| extend Result = columnifexists(\"ResultType\", \"tempValue\")\n| extend Result = iff(Result == \"tempValue\", columnifexists(\"ResultStatus\", Result), Result)\n| extend ResultValue = case(Result == \"0\", \"Success\", Result == \"Success\" or Result == \"Succeeded\", \"Success\", Result)\n| where ResultValue != \"Success\"\n| extend UserPrincipalName = columnifexists(\"UserPrincipalName\", \"tempValue\") \n| extend UserPrincipalName = iff(tableName == \"OfficeActivity\", tolower(UserId), tolower(UserPrincipalName))\n| extend UPN = split(UserPrincipalName, \"@\")\n| extend UserNameOnly = tostring(UPN[0]), DomainOnly = tostring(UPN[1])\n| where UserNameOnly contains \".\" or UserPrincipalName contains \"-\" or UserPrincipalName contains \"_\"\n// Verify we only get accounts without other separators, it would be difficult to identify multi-level separators\n// Count of any that are not alphanumeric\n| extend charcount = countof(UserNameOnly, '[^0-9A-Za-z]', \"regex\")\n// Drop any that have non-alphanumeric characters still included\n| where charcount < 2\n// Creating array of name pairs that include the separators we are interested in, this can be added to if needed.\n| extend unoArray = case(\nUserNameOnly contains \".\", split(UserNameOnly, \".\"),\nUserNameOnly contains \"-\", split(UserNameOnly, \"-\"),\nUserNameOnly contains \"_\", split(UserNameOnly, \"_\"),\nUserNameOnly)\n| extend First = iff(isnotempty(tostring(parse_json(unoArray)[0])), tostring(parse_json(unoArray)[0]),tostring(unoArray))\n| extend Last = tostring(parse_json(unoArray)[1])\n| extend First4char = iff(countof(substring(First, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(First, 0,4), \"LessThan4\"),\nFirst6char = iff(countof(substring(First, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(First, 0,6), \"LessThan6\"),\nFirst8char = iff(countof(substring(First, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(First, 0,8), \"LessThan8\"),\nLast4char = iff(countof(substring(Last, 0,4), '[0-9A-Za-z]', \"regex\") >= 4, substring(Last, 0,4), \"LessThan4\"),\nLast6char = iff(countof(substring(Last, 0,6), '[0-9A-Za-z]', \"regex\") >= 6, substring(Last, 0,6), \"LessThan6\"),\nLast8char = iff(countof(substring(Last, 0,8), '[0-9A-Za-z]', \"regex\") >= 8, substring(Last, 0,8), \"LessThan8\")\n| where First != Last\n| summarize UserNames = makeset(UserNameOnly),\nfl_Count = count() by bin(TimeGenerated, 10m), First4char, First6char, First8char, Last4char, Last6char, Last8char, Type\n};\nlet SigninList = upnFunc(\"SigninLogs\");\nlet OffActList = upnFunc(\"OfficeActivity\");\nlet UserNameList = (union isfuzzy=true SigninList, OffActList);\nlet Char4List = UserNameList\n| project TimeGenerated, First4char, Last4char, UserNames, fl_Count, Type\n| where First4char != \"LessThan4\" and Last4char != \"LessThan4\";\n// Break out first and last so we can then join and see where a first and last match.\nlet First4charList = Char4List | where isnotempty(First4char)\n| summarize un_MatchOnFirst = makeset(UserNames),\nfl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First4char, Type\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;\nlet Last4charList = Char4List | where isnotempty(Last4char) \n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last4char, Type\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\nlet char4 = First4charList | join Last4charList on CharSet and TimeGenerated\n| project-away TimeGenerated1, CharSet1\n// Make sure that we get more than a single match for First or Last\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\nlet Char6List = UserNameList\n| project TimeGenerated, First6char, Last6char, UserNames, fl_Count, Type\n| where First6char != \"LessThan6\" and Last6char != \"LessThan6\";\n// Break out first and last so we can then join and see where a first and last match.\nlet First6charList = Char6List | where isnotempty(First6char)\n| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First6char, Type\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type;\nlet Last6charList = Char6List | where isnotempty(Last6char)\n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last6char, Type\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\nlet char6 = First6charList | join Last6charList on CharSet and TimeGenerated\n| project-away TimeGenerated1, CharSet1\n// Make sure that we get more than a single match for First or Last\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\nlet Char8List = UserNameList\n| project TimeGenerated, First8char, Last8char, UserNames, fl_Count, Type\n| where First8char != \"LessThan8\" and Last8char != \"LessThan8\";\n// Break out first and last so we can then join and see where a first and last match.\nlet First8charList = Char8List | where isnotempty(First8char)\n| summarize un_MatchOnFirst = makeset(UserNames), fl_CountForFirst = sum(fl_Count) by TimeGenerated, CharSet = First8char, Type\n| project TimeGenerated, CharSet, un_MatchOnFirst, un_MatchOnFirstCount = array_length(un_MatchOnFirst), fl_CountForFirst, Type; \nlet Last8charList = Char8List | where isnotempty(Last8char)\n| summarize un_MatchOnLast = makeset(UserNames), fl_CountForLast = sum(fl_Count) by TimeGenerated, CharSet = Last8char, Type\n| project TimeGenerated, CharSet, un_MatchOnLast, un_MatchOnLastCount = array_length(un_MatchOnLast), fl_CountForLast, Type;\nlet char8 = First8charList | join Last8charList on CharSet and TimeGenerated\n| project-away TimeGenerated1, CharSet1\n// Make sure that we get more than a single match for First or Last\n| where un_MatchOnFirstCount >= un_MatchMin or un_MatchOnLastCount >= un_MatchMin\n| where fl_CountForFirst >= fl_Min or fl_CountForLast >= fl_Min;\n(union isfuzzy=true char4, char6, char8)\n| project Type, TimeGenerated, CharSet, UserNameMatchOnFirst = un_MatchOnFirst, UserNameMatchOnFirstCount = un_MatchOnFirstCount,\nFailedLogonCountForFirst = fl_CountForFirst, UserNameMatchOnLast = un_MatchOnLast, UserNameMatchOnLastCount = un_MatchOnLastCount,\nFailedLogonCountForLast = fl_CountForLast\n| sort by UserNameMatchOnFirstCount desc, UserNameMatchOnLastCount desc\n| extend timestamp = TimeGenerated\n", "attributes": {"description": "'Attackers sometimes try variations on account logon names, this will identify failed attempts on logging in using permutations \nbased on known first and last name within 10m time windows, for UserPrincipalNames that separated by hyphen(-), underscore(_) and dot(.).\nIf there is iteration through these separators or order changes in the logon name it may indicate potential Brute Force logon attempts.\nFor example, attempts with first.last@example.com, last.first@example.com, first_last@example.com and so on.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/PersistViaIFEORegistryKey.yaml", "query_name": "Persisting Via IFEO Registry Key", "query": "(union isfuzzy=true\n(\nSecurityEvent\n| where EventID == 4657\n| where ObjectName has_all (\"\\\\REGISTRY\\\\MACHINE\", \"Image File Execution Options\")\n| where ObjectName !endswith \"Image File Execution Options\"\n| summarize Count=count() by Computer, Account, ObjectName\n| top 10 by Count desc \n| extend AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(\nWindowsEvent\n| where EventID == 4657 and EventData has_all (\"\\\\REGISTRY\\\\MACHINE\", \"Image File Execution Options\")\n| extend ObjectName = tostring(EventData.ObjectName)\n| where ObjectName has_all (\"\\\\REGISTRY\\\\MACHINE\", \"Image File Execution Options\")\n| where ObjectName !endswith \"Image File Execution Options\"\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| summarize Count=count() by Computer, Account, ObjectName\n| top 10 by Count desc \n| extend AccountCustomEntity = Account, HostCustomEntity = Computer\n),\n(\nEvent\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID in (12, 13)\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| where TargetObject has_all (\"HKLM\", \"Image File Execution Options\")\n| summarize Count=count() by Computer, UserName, tostring(TargetObject)\n| top 10 by Count desc\n| extend AccountCustomEntity = UserName, HostCustomEntity = Computer\n),\n(\nimRegistry\n| where RegistryKey has_all (\"HKEY_LOCAL_MACHINE\", \"Image File Execution Options\")\n| summarize Count=count() by Dvc, Username, RegistryKey\n| top 10 by Count desc\n| extend AccountCustomEntity = Username, HostCustomEntity = Dvc\n)\n", "attributes": {"description": "'This query detects instances where IFEO registry keys were created and deleted frequently within a short period of time.'\n", "techniques": ["T1546.012"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/PossibleCommandInjectionagainstAzureIR.yaml", "query_name": "Possible command injection attempts against Azure Integration Runtimes", "query": "let parent_proc_list = dynamic([\"diawp.exe\", \"ReportingServicesService.exe\", \"RSPortal.exe\", \"RsPowerBI.exe\", \"taskexecutor.exe\"]);\nlet cmdline_tokens = dynamic([\"| curl \", \"/c start \", \" whoami 2>&1\", \"-m 5 \", \"--data-binary\"]);\n(union isfuzzy=true\n( DeviceProcessEvents  \n| where FileName =~ \"cmd.exe\"\n| where InitiatingProcessFileName in~ (parent_proc_list)\n| where ProcessCommandLine has_any (cmdline_tokens)\n| project-reorder  TimeGenerated, DeviceName, DeviceId, FileName, ProcessCommandLine, InitiatingProcessFileName, AccountName\n| extend timestamp = TimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = DeviceName,  ProcessCustomEntity = FileName\n),\n(imProcessCreate\n| where ParentProcessName endswith \"diawp.exe\" or ParentProcessName endswith \"ReportingServicesService.exe\" or ParentProcessName endswith \"RSPortal.exe\" or ParentProcessName endswith \"RsPowerBI.exe\" or ParentProcessName endswith \"taskexecutor.exe\"\n| where ActingProcessName = \"cmd.exe\"\n| where (CommandLine has_any (cmdline_tokens))\n| extend timestamp = TimeGenerated, HostCustomEntity = DvcHostname , AccountCustomEntity = ActorUsername, ProcessCustomEntity = TargetProcessFilePath\n),\n(SecurityEvent\n| where EventID == '4688'\n| where Process == \"cmd.exe\" and isnotempty(ParentProcessName)\n| extend ParentProcess = tostring(parse_json(parse_path(ParentProcessName)).Filename)\n| where ParentProcess in~ (parent_proc_list)  and (CommandLine has_any (cmdline_tokens)) \n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, CommandLine\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n),\n(WindowsEvent\n| where EventID == '4688' and (EventData has_any (cmdline_tokens) or EventData has_all (parent_proc_list))\n| extend CommandLine = tostring(EventData.CommandLine) \n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| where NewProcessName =~ \"cmd.exe\" and ParentProcessName in~ (parent_proc_list)\n| where (CommandLine has_any (cmdline_tokens))\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend NewProcessId = tostring(EventData.NewProcessId)\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, CommandLine\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName\n)\n)\n", "attributes": {"description": "'This hunting query looks for potential command injection attempts via the vulnerable third-party driver against Azure IR with Managed VNet or SHIR processes as well as post-exploitation activity based on process execution and command line activity\nReference: https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-29972 \n https://msrc-blog.microsoft.com/2022/05/09/vulnerability-mitigated-in-the-third-party-data-connector-used-in-azure-synapse-pipelines-and-azure-data-factory-cve-2022-29972'\n", "techniques": ["T1074.001"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/PotentialMicrosoftSecurityServicesTampering.yaml", "query_name": "Potential Microsoft security services tampering", "query": "\nlet includeProc = dynamic([\"sc.exe\",\"net1.exe\",\"net.exe\", \"taskkill.exe\", \"cmd.exe\", \"powershell.exe\"]);\nlet action = dynamic([\"stop\",\"disable\", \"delete\"]);\nlet service1 = dynamic(['sense', 'windefend', 'mssecflt']);\nlet service2 = dynamic(['sense', 'windefend', 'mssecflt', 'healthservice']);\nlet params1 = dynamic([\"-DisableRealtimeMonitoring\", \"-DisableBehaviorMonitoring\" ,\"-DisableIOAVProtection\"]);\nlet params2 = dynamic([\"sgrmbroker.exe\", \"mssense.exe\"]);\nlet regparams1 = dynamic(['reg add \"HKLM\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows Defender\"', 'reg add \"HKLM\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\Windows Advanced Threat Protection\"']);\nlet regparams2 = dynamic(['ForceDefenderPassiveMode', 'DisableAntiSpyware']);\nlet regparams3 = dynamic(['sense', 'windefend']);\nlet regparams4 = dynamic(['demand', 'disabled']);\nlet regparams5 = dynamic(['reg add \"HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\services\\\\HealthService\"', 'reg add \"HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Sense\"', 'reg add \"HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\WinDefend\"', 'reg add \"HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\MsSecFlt\"', 'reg add \"HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\DiagTrack\"', 'reg add \"HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\SgrmBroker\"', 'reg add \"HKLMSYSTEM\\\\CurrentControlSet\\\\Services\\\\SgrmAgent\"', 'reg add \"HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\AATPSensorUpdater\"' , 'reg add \"HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\AATPSensor\"', 'reg add \"HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\mpssvc\"']);\nlet regparams6 = dynamic(['/d 4','/d \"4\"','/d 0x00000004']);\nlet regparams7 = dynamic(['/d 1','/d \"1\"','/d 0x00000001']);\n(union isfuzzy=true\n(\nSecurityEvent\n| where EventID == 4688\n| extend ProcessName = tostring(split(NewProcessName, '\\\\')[-1])\n| where ProcessName in~ (includeProc)\n| where (CommandLine has_any (action) and CommandLine has_any (service1)) \nor (CommandLine has_any (params1) and CommandLine has 'Set-MpPreference' and CommandLine has '$true')\nor (CommandLine has_any (params2) and CommandLine has \"/IM\") \nor (CommandLine has_any (regparams5) and CommandLine has 'Start' and CommandLine has_any (regparams6))\nor (CommandLine has_any (regparams1) and CommandLine has_any (regparams2) and CommandLine has_any (regparams7)) \nor (CommandLine has \"start\" and CommandLine has \"config\" and CommandLine has_any (regparams3) and CommandLine has_any (regparams4))\n| project TimeGenerated, Computer, Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(\nWindowsEvent\n| where EventID == 4688 and EventData has_any(includeProc)\n| where (EventData  has_any (action) and EventData has_any (service1)) \nor (EventData has_any (params1) and EventData has 'Set-MpPreference' and EventData has '$true')\nor (EventData has_any (params2) and EventData has \"/IM\") \nor (EventData has_any (regparams5) and EventData has 'Start' and EventData has_any (regparams6))\nor (EventData has_any (regparams1) and EventData has_any (regparams2) and EventData has_any (regparams7)) \nor (EventData has \"start\" and EventData has \"config\" and EventData has_any (regparams3) and EventData has_any (regparams4))\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend ProcessName = tostring(split(NewProcessName, '\\\\')[-1])\n| where ProcessName in~ (includeProc)\n| extend CommandLine = tostring(EventData.CommandLine) \n| where (CommandLine has_any (action) and CommandLine has_any (service1)) \nor (CommandLine has_any (params1) and CommandLine has 'Set-MpPreference' and CommandLine has '$true')\nor (CommandLine has_any (params2) and CommandLine has \"/IM\") \nor (CommandLine has_any (regparams5) and CommandLine has 'Start' and CommandLine has_any (regparams6))\nor (CommandLine has_any (regparams1) and CommandLine has_any (regparams2) and CommandLine has_any (regparams7)) \nor (CommandLine has \"start\" and CommandLine has \"config\" and CommandLine has_any (regparams3) and CommandLine has_any (regparams4))\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| extend AccountDomain = tostring(EventData.AccountDomain)\n| extend Activity=\"4688 - A new process has been created.\"\n| extend EventSourceName=Provider\n| project TimeGenerated, Computer, Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(\nEvent\n| where Source =~ \"Microsoft-Windows-SENSE\"\n| where EventID == 87 and ParameterXml in (\"<Param>sgrmbroker</Param>\", \"<Param>WinDefend</Param>\")\n| project TimeGenerated, Computer, Account = UserName, EventID, Activity = RenderedDescription, EventSourceName = Source, Type\n),\n(\nDeviceProcessEvents\n| where InitiatingProcessFileName in~ (includeProc)\n| where (InitiatingProcessCommandLine has_any(action) and InitiatingProcessCommandLine has_any (service2) and InitiatingProcessParentFileName != 'cscript.exe')\nor (InitiatingProcessCommandLine has_any (params1) and InitiatingProcessCommandLine has 'Set-MpPreference' and InitiatingProcessCommandLine has '$true') \nor (InitiatingProcessCommandLine has_any (params2) and InitiatingProcessCommandLine has \"/IM\") \nor ( InitiatingProcessCommandLine has_any (regparams5) and  InitiatingProcessCommandLine has 'Start' and  InitiatingProcessCommandLine has_any (regparams6))\nor (InitiatingProcessCommandLine has_any (regparams1) and InitiatingProcessCommandLine has_any (regparams2) and InitiatingProcessCommandLine has_any (regparams7)) \nor (InitiatingProcessCommandLine has_any(\"start\") and InitiatingProcessCommandLine has \"config\" and InitiatingProcessCommandLine has_any (regparams3) and InitiatingProcessCommandLine has_any (regparams4))\n| extend Account = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName), Computer = DeviceName\n| project TimeGenerated, Computer, Account, AccountDomain, ProcessName = InitiatingProcessFileName, ProcessNameFullPath = FolderPath, Activity = ActionType, CommandLine = InitiatingProcessCommandLine, Type, InitiatingProcessParentFileName\n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer", "attributes": {"description": "'Identifies potential tampering related to Microsoft security related products and services.'\n", "techniques": ["T1562.001"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/PrivilegedAccountPasswordChanges.yaml", "query_name": "Privileged Account Password Changes", "query": "let priority_threshold = 5;\nlet admins = (IdentityInfo\n| where AssignedRoles contains \"Admin\"\n| summarize by tolower(AccountUPN));\nAuditLogs\n| where Category =~ \"UserManagement\"\n| where OperationName has_any (\"password\", \"security info\")\n| extend AccountUPN = tolower(tostring(TargetResources[0].userPrincipalName))\n| where AccountUPN in (admins)\n| join kind=inner (BehaviorAnalytics | where InvestigationPriority > priority_threshold | where isnotempty(UserPrincipalName)| summarize by UserPrincipalName | extend AccountUPN = tolower(UserPrincipalName)) on AccountUPN\n| extend AccountCustomEntity = AccountUPN\n", "attributes": {"description": "'Identifies where Privileged Accounts have updated passwords or security information. This is joined with UEBA alerts to filter to only those accounts with a high investigation priority.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/PrivilegedAccountsLockedOut.yaml", "query_name": "Privileged Accounts Locked Out", "query": "let admins = (IdentityInfo\n| where AssignedRoles contains \"Admin\"\n| summarize by tolower(AccountUPN));\nSigninLogs\n| where ResultType == 50053\n| extend AccountUPN = tolower(UserPrincipalName)\n| extend AltUPN = tolower(AlternateSignInName)\n| where AccountUPN in (admins) or AltUPN in (admins)\n| extend AccountCustomEntity = AccountUPN, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Identifies privileged accounts that have been locked out. Verify these lockout are due to legitimate user activity and not due to threat actors attempting to access the accounts.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/RareDNSLookupWithDataTransfer.yaml", "query_name": "RareDNSLookupWithDataTransfer", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nlet lookupThreshold = 21;\nlet lookbackint = 7;\nlet binvalue = 1;\nlet bintime = make_timespan(binvalue,0);\nlet avgCalc = starttime/1h;\n// Identify all domain lookups before start time and after lookback time\nlet DomainLookups = DnsEvents\n| where TimeGenerated between(ago(lookback)..starttime)\n| where SubType == \"LookupQuery\"\n| where isnotempty(IPAddresses)\n| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)\n| summarize DomainCount = count() by Domain\n| project Domain, DailyAvgLookupCountOverLookback = DomainCount/lookbackint;\n// Common lookups should not include items that occurred more rarely over the lookback period.\nlet CommonLookups = DomainLookups\n| where DailyAvgLookupCountOverLookback > lookupThreshold;\n// Get current lookups to compare against the lookback period\nlet TodayLookups = DnsEvents\n| where TimeGenerated between(starttime..endtime)\n| where SubType == \"LookupQuery\"\n| where isnotempty(IPAddresses)\n| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)\n| summarize LookupStartTime = min(TimeGenerated), LookupEndTime = max(TimeGenerated), LookupCountToday = count() by ClientIP, Domain, IPAddresses\n| project LookupStartTime, LookupEndTime, ClientIP, LookupCountToday, Domain, IPAddresses;\n// Remove Common Lookups from lookback period from Todays lookups\nlet UncommonLookupsToday = TodayLookups\n| join kind=leftanti (\nCommonLookups\n)\non Domain;\n// Join back the Daily Average Lookup Count to add context to rarity over lookback period\nlet RareLookups = UncommonLookupsToday | join kind= innerunique (\nDomainLookups\n) on Domain\n| project LookupStartTime, LookupEndTime, ClientIP, Domain, IPAddresses, LookupCountToday, DailyAvgLookupCountOverLookback;\nlet DNSIPBreakout = RareLookups\n| extend DnsIPAddress = iff(IPAddresses has \",\", split(IPAddresses, \",\"), todynamic(IPAddresses))\n| mvexpand DnsIPAddress\n| extend DnsIPAddress = tostring(DnsIPAddress)\n| distinct LookupStartTime, LookupEndTime, ClientIP, Domain, DnsIPAddress, LookupCountToday, DailyAvgLookupCountOverLookback\n| extend IPCustomEntity = DnsIPAddress\n| where ipv4_is_private(DnsIPAddress) == false\n;\nlet DataMovement = ( union isfuzzy=true\n(CommonSecurityLog\n| where TimeGenerated between(starttime..endtime)\n| where DeviceVendor ==\"Palo Alto Networks\" and Activity == \"TRAFFIC\"\n| where ipv4_is_private(DestinationIP) == false\n| project DataType = DeviceVendor, TimeGenerated, SourceIP , SourcePort , DestinationIP, DestinationPort, ReceivedBytes, SentBytes\n| sort by SourceIP asc, SourcePort asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc\n| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort\n| extend IPCustomEntity = DestinationIP\n| sort by sum_SentBytes desc\n),\n(WireData\n| where TimeGenerated between(starttime..endtime)\n| where Direction == \"Outbound\"\n| where ipv4_is_private(RemoteIP) == false\n| project DataType = Type, TimeGenerated , SourceIP = LocalIP , SourcePort = LocalPortNumber , DestinationIP = RemoteIP, DestinationPort = RemotePortNumber, ReceivedBytes, SentBytes\n| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, SourcePort, DestinationIP, DestinationPort\n| extend IPCustomEntity = DestinationIP\n| extend DataType = Type\n| sort by sum_SentBytes desc\n),\n(VMConnection\n| where TimeGenerated between(starttime..endtime)\n| where Direction == \"outbound\"\n| where ipv4_is_private(DestinationIp) == false\n| project DataType = Type, TimeGenerated, SourceIP = SourceIp , DestinationIP = DestinationIp, DestinationPort, ReceivedBytes = BytesReceived, SentBytes = BytesSent\n| summarize sum(ReceivedBytes), sum(SentBytes), ConnectionCount = count() by DataType, SourceIP, DestinationIP, DestinationPort\n| sort by sum_SentBytes desc\n| extend IPCustomEntity = DestinationIP\n)\n);\nDNSIPBreakout | join kind = leftouter (\nDataMovement\n) on $left.DnsIPAddress == $right.DestinationIP and $left.ClientIP == $right.SourceIP\n| project-away DnsIPAddress, ClientIP\n// The below condition can be removed to see all DNS results.\n// This is used here as the goal of the query is to connect rare DNS lookups to a data type that can show byte transfers to that given DestinationIP\n| where isnotempty(DataType)\n| extend timestamp = LookupStartTime, IPCustomEntity = DestinationIP\n", "attributes": {"description": "'This query is designed to help identify rare DNS connections and resulting data transfer to/from the associated domain.\nThis can help identify unexpected large data transfers to or from internal systems which may indicate data exfil or malicious tool download.\nFeel free to add additional data sources to connect DNS results too various network data that has byte transfer information included.'\n", "techniques": ["T1071", "T1048"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/RareDomainsInCloudLogs.yaml", "query_name": "Rare domains seen in Cloud Logs", "query": "\n// Provide customLimit value with default above domainLimit value so it will not block unless changed\nlet customLimit = 11;\nlet domainLimit = 10;\nlet domainLookback = union isfuzzy=true\n(AuditLogs\n| extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n// parse out AuditLog values for various locations where UPN could be\n| extend UserPrincipalName = iff(isnotempty(UserPrincipalName),\nUserPrincipalName, \niif((tostring(InitiatedBy.user.userPrincipalName)=='unknown'), \nextract(\"Email: ([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+)\", 1, tostring(parse_json(TargetResources)[0].displayName)), \nInitiatedBy.user.userPrincipalName))\n| where UserPrincipalName has \"@\" or UserPrincipalName startswith \"NT AUTHORITY\"\n| extend RareDomain = toupper(tostring(split(UserPrincipalName, \"@\")[-1]))\n| where isnotempty(RareDomain) \n| summarize RareDomainCount = count() by Type, RareDomain\n| where RareDomainCount <= domainLimit\n| extend AccountCustomEntity = UserPrincipalName\n// remove comment from below if you would like to have a lower limit for RareDomainCount specific to AuditLog\n//| where RareDomainCount <= customLimit\n),\n(OfficeActivity\n| extend UserPrincipalName = tolower(UserId)\n| where UserPrincipalName has \"@\" or UserPrincipalName startswith \"NT AUTHORITY\"\n| extend RareDomain = toupper(tostring(split(UserPrincipalName, \"@\")[-1]))\n| summarize RareDomainCount = count() by Type, RareDomain\n| where RareDomainCount <= domainLimit\n| extend AccountCustomEntity = UserPrincipalName\n// remove comment from below if you would like to have a lower limit for RareDomainCount specific to OfficeActivity\n//| where RareDomainCount <= customLimit\n),\n(SigninLogs\n| where UserPrincipalName has \"@\" or UserPrincipalName startswith \"NT AUTHORITY\"\n| extend RareDomain = toupper(tostring(split(UserPrincipalName, \"@\")[-1]))\n| summarize RareDomainCount = count() by Type, RareDomain\n| where RareDomainCount <= domainLimit\n// remove comment from below if you would like to have a lower limit for RareDomainCount specific to SigninLogs\n//| where RareDomainCount <= customLimit\n);\nlet AuditLogsRef = domainLookback | join (\n   AuditLogs\n   | extend UserPrincipalName = tolower(tostring(TargetResources.[0].userPrincipalName))\n   | extend UserPrincipalName = iff(isempty(UserPrincipalName), tostring(InitiatedBy.user.userPrincipalName), UserPrincipalName)\n   | extend RareDomain = toupper(tostring(split(UserPrincipalName, \"@\")[-1]))\n   | where isnotempty(RareDomain) \n   | summarize UPNRefCount = count() by TimeGenerated, Type, RareDomain, UserPrincipalName, OperationName, Category, Result\n   | extend AccountCustomEntity = UserPrincipalName\n) on Type, RareDomain;\nlet OfficeActivityRef = domainLookback | join (\n    OfficeActivity\n    | extend UserPrincipalName = tolower(UserId)\n    | where UserPrincipalName has \"@\" or UserPrincipalName startswith \"NT AUTHORITY\"\n    | extend RareDomain = toupper(tostring(split(UserPrincipalName, \"@\")[-1]))\n    | summarize UPNRefCount = count() by TimeGenerated, Type, RareDomain, UserPrincipalName, OperationName = Operation, Category = OfficeWorkload, Result = ResultStatus\n    | extend AccountCustomEntity = UserPrincipalName\n) on Type, RareDomain;\nlet SigninLogsRef = domainLookback | join (\n    SigninLogs\n    | extend UserPrincipalName = tolower(UserId)\n    | where UserPrincipalName has \"@\" or UserPrincipalName startswith \"NT AUTHORITY\"\n    | extend RareDomain = toupper(tostring(split(UserPrincipalName, \"@\")[-1]))\n    | summarize UPNRefCount = count() by TimeGenerated, Type, RareDomain, UserPrincipalName, OperationName, Category = AppDisplayName, Result = ResultType\n    | extend AccountCustomEntity = UserPrincipalName\n) on Type, RareDomain;\nlet Results = union isfuzzy=true\nAuditLogsRef,OfficeActivityRef,SigninLogsRef;\nResults | project TimeGenerated, Type, RareDomain, UserPrincipalName, OperationName, Category, Result, UPNRefCount \n| order by TimeGenerated asc \n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName", "attributes": {"description": "'This will identify rare domain accounts accessing or attempting to access cloud resources by examining the AuditLogs, OfficeActivity and SigninLogs\nRare does not mean malicious, but it may be something you would be interested in investigating further\nAdditionally, it is possible that there may be many domains if you have allowed access by 3rd party domain accounts.\nLower the domainLimit value as needed.  For example, if you only want to see domains that have an access attempt count of 2 or less,\nthen set domainLimit = 2 below.  If you need to set it lower only for a given log, then use customLimit in the same way and uncomment \nthat line in the script.'\n", "techniques": ["T1190", "T1087", "T1114"], "tactics": ["InitialAccess", "Discovery", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/ReconActivitywithInteractiveLogonCorrelation.yaml", "query_name": "Recon Activity with Interactive Logon Correlation", "query": "SecurityAlert\n| where AlertName has_any ('Atypical travel','Unfamiliar sign-in properties','Anonymous IP address','Malware linked IP address','Malicious IP address','Password Spray','Targeted port scans')\n| summarize count(),make_set(AlertName) by WorkspaceSubscriptionId,CompromisedEntity= toupper(CompromisedEntity),TimeGenerated\n| extend number_alerts = array_length(set_AlertName)\n| join kind=inner\n(\nSecurityEvent\n| where EventID == 4624 and LogonType == 10\n  | project  Account = tolower(Account), Computer = toupper(Computer), IpAddress, AccountType, Activity, LogonTypeName,Interactivelogontime=TimeGenerated\n  ) on  $left.CompromisedEntity==$right.Computer\n  | project TimeGenerated,Interactivelogontime,AccountCustomEntity=Account,AccountType,CompromisedEntity,Activity,IpAddress\n  | extend TimeWindow = TimeGenerated + 15m\n  | where Interactivelogontime between (TimeGenerated .. TimeWindow)\n", "attributes": {"description": "'This query looks at correlating different reconnaissance alerts with interactive logon logs to help analysts investigate initial possible compromise activity'\n", "techniques": ["T1190", "T1078"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/SolarWindsInventory.yaml", "query_name": "SolarWinds Inventory", "query": "\n(union isfuzzy=true \n( \nSecurityEvent  \n| where EventID == '4688' \n| where tolower(NewProcessName) has 'solarwinds' \n| extend MachineName = Computer , Process = NewProcessName\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), MachineCount = dcount(MachineName), AccountCount = dcount(Account), MachineNames = make_set(MachineName), Accounts = make_set(Account) by Process, Type\n), \n( \nWindowsEvent  \n| where EventID == '4688' and EventData has \"solarwinds\"\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| where tolower(NewProcessName) has 'solarwinds' \n| extend MachineName = Computer , Process = NewProcessName\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), MachineCount = dcount(MachineName), AccountCount = dcount(Account), MachineNames = make_set(MachineName), Accounts = make_set(Account) by Process, Type\n), \n( \nDeviceProcessEvents \n| where tolower(InitiatingProcessFolderPath) has 'solarwinds' \n| extend MachineName = DeviceName , Process = InitiatingProcessFolderPath, Account = AccountName\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), MachineCount = dcount(MachineName), AccountCount = dcount(Account), MachineNames = make_set(MachineName), Accounts = make_set(Account)  by Process, Type\n), \n( \nEvent \n| where Source == \"Microsoft-Windows-Sysmon\" \n| where EventID == 1 \n| extend Image = EventDetail.[4].[\"#text\"] \n| where tolower(Image) has 'solarwinds' \n| extend MachineName = Computer , Process = Image, Account = UserName\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), MachineCount = dcount(MachineName), AccountCount = dcount(Account), MachineNames = make_set(MachineName), Accounts = make_set(Account)  by Process, Type\n) \n) \n", "attributes": {"description": "'Beyond your internal software management systems, it is possible you may not have visibility into your entire footprint of SolarWinds installations.  This is intended to help use process exection information to discovery any systems that have SolarWinds processes'\n", "techniques": ["T1072"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/SQLAlertCorrelationwithCommonSecurityLogsandAuditLogs.yaml", "query_name": "SQL Alert Correlation with CommonSecurityLogs and AuditLogs", "query": "SecurityAlert\n| where AlertName has_any ('Potential SQL Injection', 'A possible vulnerability to SQL Injection')\n| extend EntitiesDynamicArray = parse_json(Entities)\n| mv-expand EntitiesDynamicArray\n| extend EntityType = tostring(parse_json(EntitiesDynamicArray).Type), EntityAddress = tostring(EntitiesDynamicArray.Address)\n| extend IpAddress = iif(EntityType == 'ip', EntityAddress, '')\n| where isnotempty(IpAddress) \n| join kind=inner (\nCommonSecurityLog \n| where DeviceVendor =~ \"Palo Alto Networks\" and Activity =~ \"TRAFFIC\" and DeviceAction != \"deny\"\n| summarize count() by DeviceName, SourceIP, DestinationIP, DestinationPort, Protocol, SourcePort\n)\non $left.IpAddress == $right.SourceIP\n| join kind=inner (\nAuditLogs\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"RoleManagement\"\n| extend IpAddress = case(\nisnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), \nisnotempty(tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.app)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.app)).ipAddress),'Not Available')\n| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \ntostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName)), UserRoles = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))  \n) on IpAddress\n| summarize count () by TimeGenerated,IpAddress,UserRoles,SourcePort,DestinationPort,AccountCustomEntity=InitiatedBy\n", "attributes": {"description": "'This query combines different SQL alerts with CommonSecurityLogs and AuditLogs helping analysts /investigate any possible SQL related attacks faster\n thus reducing Mean Time To Respond'\n", "techniques": ["T1190", "T1078"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/StorageAccountKeyEnumerationWithSigninandAuditlogs.yaml", "query_name": "Storage Account Key Enumeration", "query": "SigninLogs \n | where ResultType == \"0\" \n | where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\", \"Office 365 SharePoint Online\")\n | project  SuccessLogonTime = TimeGenerated,UserPrincipalName, IPAddress,SuccessAppDisplayName = AppDisplayName\n |  join kind=inner\n (\n AzureActivity\n | where tolower(OperationNameValue) endswith \"listkeys/action\"\n | where ActivityStatus =~ \"Succeeded\"\n | project CallerIpAddress, _ResourceId, SubscriptionId, ActivityStatus, Category, Authorization,OperationName\n )\n on $left.IPAddress == $right. CallerIpAddress\n | project SubscriptionId, ActivityStatus, IPAddress, OperationName, UserPrincipalName\n | join kind=inner \n (\n AuditLogs\n | where LoggedByService =~ \"Core Directory\"\n | where Category =~ \"RoleManagement\"\n | extend IpAddress = case(\n  isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), \n isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.app)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.app)).ipAddress),'Not Available')\n | extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n   tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName)), UserRoles = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n | extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))  \n ) \n on $left. IPAddress == $right. IpAddress\n | summarize count () by TimeGenerated,IPCustomEntity=IpAddress,UserRoles,AccountCustomEntity=InitiatedBy,TargetResourceName\n", "attributes": {"description": "'This query identifies attackers trying to enumerate the Storage keys as well as updating roles using AzureActivity,SigninLogs \nand  AuditLogs'\n", "techniques": ["T1586", "T1570"], "tactics": ["InitialAccess", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/StorageAlertCorrelationwithCommonSecurityLogsandAuditLogs.yaml", "query_name": "Storage Alerts Correlation with CommonSecurityLogs & AuditLogs", "query": "SecurityAlert\n| where AlertName has_any ('Access from  a suspicious IP to a storage file share','\tAccess from a Tor exit node to a storage blob container')\n| extend EntitiesDynamicArray = parse_json(Entities) | mv-expand EntitiesDynamicArray\n// Parsing relevant entity column extract hostname and IP address\n| extend EntityType = tostring(parse_json(EntitiesDynamicArray).Type), EntityAddress = tostring(EntitiesDynamicArray.Address)\n| extend IpAddress = iif(EntityType == 'ip', EntityAddress, '')\n| where isnotempty(IpAddress) \n| join kind=inner (\nCommonSecurityLog \n| where DeviceVendor =~ \"Fortinet\"\n| where ApplicationProtocol has_any (\"SSL\",\"RDP\")\n| where LogSeverity has_any (\"2\",\"3\")\n| where isnotempty(SourceIP) and isnotempty(DestinationIP) and SourceIP != \"0.0.0.0\"\n| where DeviceAction !in (\"close\", \"client-rst\", \"server-rst\", \"deny\") and DestinationPort != 161\n| project DeviceProduct,LogSeverity,DestinationPort,DestinationIP,Message,SourceIP,SourcePort,Activity,SentBytes,ReceivedBytes\n) on $left.IpAddress == $right.DestinationIP\n| join kind=inner (\nAuditLogs\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"RoleManagement\"\n| extend IpAddress = case(\nisnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), \nisnotempty(tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.app)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.app)).ipAddress),\n'Not Available')\n| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \ntostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName)), UserRoles = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName)) \n)\non IpAddress\n| summarize count () by TimeGenerated,IpAddress, UserRoles,SourcePort, DestinationPort, AccountCustomEntity =InitiatedBy\n", "attributes": {"description": "'This query combines different Storage alerts with CommonSecurityLogs and AuditLogs helping analysts investigate any possible storage related attacks faster\n thus reducing Mean Time To Respond'\n", "techniques": ["T1190", "T1078"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/StorageAlertCorrelationwithCommonSecurityLogsandStorageLogs.yaml", "query_name": "Storage Alert Correlation with CommonSecurityLogs and StorageLogs", "query": "SecurityAlert\n| where DisplayName has_any (\"Potential malware uploaded to a storage blob container\",\"Storage account identified as source for distribution of malware\")\n| extend Entities = parse_json(Entities)\n| mv-expand Entities\n| where Entities['Type'] =~ \"ip\"\n| extend AttackerIP = tostring(Entities['Address']), AttackerCountry = tostring(Entities['Location']['CountryName'])\n| join kind=inner (\nunion\nStorageFileLogs,\nStorageBlobLogs\n//File upload operations\n| where StatusText =~ \"Success\"\n| where OperationName =~ \"PutBlob\" or OperationName =~ \"PutRange\"\n| extend ClientIP = tostring(CallerIpAddress)\n) on $left.AttackerIP == $right.ClientIP\n| project AlertTimeGenerated = TimeGenerated, AttackerIP, AttackerCountry\n| join kind=inner (\nCommonSecurityLog\n| where DeviceVendor =~ \"Fortinet\"\n| where ApplicationProtocol has_any (\"SSL\",\"RDP\")\n| where LogSeverity has_any (\"2\",\"3\")\n| where isnotempty(SourceIP) and isnotempty(DestinationIP) and SourceIP != \"0.0.0.0\"\n| where DeviceAction !in (\"close\", \"client-rst\", \"server-rst\", \"deny\") and DestinationPort != 161\n| project DeviceProduct,LogSeverity,DestinationPort,DestinationIP,Message,SourceIP,SourcePort,Activity,SentBytes,ReceivedBytes)\n on $left.AttackerIP==$right.DestinationIP\n| summarize count() by AlertTimeGenerated,IpAddress=DestinationIP,SentBytes,ReceivedBytes,AttackerCountry\n", "attributes": {"description": "'This query combines different Storage alerts with CommonSecurityLogs and StorageLogs helping analysts  triage and investigate any \npossible Storage related attacks faster thus reducing Mean Time To Respond'\n", "techniques": ["T1586", "T1570"], "tactics": ["InitialAccess", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/STRONTIUM_IOC_RetroHunt.yaml", "query_name": "Retrospective hunt for STRONTIUM IP IOCs", "query": "\nlet STRONTIUM_IPS = dynamic([\"82.118.242.171\" , \"167.114.153.55\" , \"94.237.37.28\", \"31.220.61.251\" , \"128.199.199.187\" ]);\n(union isfuzzy=true\n(CommonSecurityLog\n| where TimeGenerated between (startofday(datetime(2019-02-01)) .. endofday(datetime(2019-08-05)))\n| where SourceIP in (STRONTIUM_IPS) or DestinationIP in (STRONTIUM_IPS)\n| extend IPCustomEntity = SourceIP\n),\n(SecurityAlert\n| where TimeGenerated between (startofday(datetime(2019-02-01)) .. endofday(datetime(2019-08-05)))\n| extend RemoteAddress = iff(ExtendedProperties has \"RemoteAddress\", tostring(parse_json(ExtendedProperties)[\"RemoteAddress\"]), \"None\")\n| where RemoteAddress != \"None\"\n| where RemoteAddress in (STRONTIUM_IPS)\n| extend IPCustomEntity = RemoteAddress\n) \n)\n| extend timestamp = TimeGenerated", "attributes": {"description": "'Matches domain name IOCs related to Strontium group activity with CommonSecurityLog and SecurityAlert dataTypes.\nThe query is scoped in the time window that these IOCs were active.\nReferences: https://blogs.microsoft.com/on-the-issues/2019/07/17/new-cyberthreats-require-new-ways-to-protect-democracy.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/TrackingPasswordChanges.yaml", "query_name": "Tracking Password Changes", "query": "\nlet action = dynamic([\"change \", \"changed \", \"reset \"]);\nlet pWord = dynamic([\"password \", \"credentials \"]);\n(union isfuzzy=true\n  (SecurityEvent\n| where EventID in (4723,4724)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(Activity), ActionCount = count() by Resource = Computer, OperationName = strcat(\"TargetAccount: \", TargetUserName), UserId = Account, Type\n),\n(WindowsEvent\n| where EventID in (4723,4724)\n| extend Activity=iff(EventID=='4723',\"4723 - An attempt was made to change an account\",\"4724 - An attempt was made to reset an account\")\n| extend TargetUserName = tostring(EventData.TargetUserName)\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(Activity), ActionCount = count() by Resource = Computer, OperationName = strcat(\"TargetAccount: \", TargetUserName), UserId = Account, Type\n),\n(AuditLogs\n| where OperationName has_any (pWord) and OperationName has_any (action)\n| extend InitiatedBy = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName) \n| extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName) \n| where ResultDescription != \"None\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(ResultDescription), CorrelationIds = makeset(CorrelationId), ActionCount = count() by OperationName = strcat(Category, \" - \", OperationName, \" - \", Result), Resource, UserId = TargetUserPrincipalName, Type\n| extend ResultDescriptions = tostring(ResultDescriptions)\n),\n(OfficeActivity\n| where (ExtendedProperties has_any (pWord) or ModifiedProperties has_any (pWord)) and (ExtendedProperties has_any (action) or ModifiedProperties has_any (action))\n| extend ResultDescriptions = case(\nOfficeWorkload =~ \"AzureActiveDirectory\", tostring(ExtendedProperties),\nOfficeWorkload has_any (\"Exchange\",\"OneDrive\"), OfficeObjectId,\nRecordType) \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(ResultDescriptions), ActionCount = count() by Resource = OfficeWorkload, OperationName = strcat(Operation, \" - \", ResultStatus), IPAddress = ClientIP, UserId, Type\n),\n(Syslog\n| where SyslogMessage has_any (pWord) and SyslogMessage has_any (action)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(SyslogMessage), ActionCount = count() by Resource = HostName, OperationName = Facility , IPAddress = HostIP, ProcessName, Type\n),\n(SigninLogs\n| where OperationName =~ \"Sign-in activity\" and ResultType has_any (\"50125\", \"50133\")\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ResultDescriptions = makeset(ResultDescription), CorrelationIds = makeset(CorrelationId), ActionCount = count() by Resource, OperationName = strcat(OperationName, \" - \", ResultType), IPAddress, UserId = UserPrincipalName, Type\n)\n)\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = IPAddress", "attributes": {"description": "'Identifies when a password change or reset occurs across multiple host and cloud based sources. \nAccount manipulation including password changes and resets may aid adversaries in maintaining access to credentials \nand certain permission levels within an environment.'\n", "techniques": ["T1078", "T1110"], "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/TrackingPrivAccounts.yaml", "query_name": "Tracking Privileged Account Rare Activity", "query": "\n\nlet LocalSID = \"S-1-5-32-5[0-9][0-9]$\";\nlet GroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$\";\nlet p_Accounts = SecurityEvent\n| where EventID in (\"4728\", \"4732\", \"4756\") and AccountType == \"User\" and MemberName == \"-\"\n// Exclude Remote Desktop Users group: S-1-5-32-555 and IIS Users group S-1-5-32-568\n| where TargetSid !in (\"S-1-5-32-555\", \"S-1-5-32-568\")\n| where TargetSid matches regex LocalSID or TargetSid matches regex GroupSID\n| summarize by DomainSlashAccount = tolower(SubjectAccount), NtDomain = SubjectDomainName,\nAccountAtDomain = tolower(strcat(SubjectUserName,\"@\",SubjectDomainName)), AccountName = tolower(SubjectUserName);\n// Build custom high value account list\nlet cust_Accounts = datatable(Account:string, NtDomain:string, Domain:string)[\n\"john\", \"Contoso\", \"contoso.com\",  \"greg\", \"Contoso\", \"contoso.com\",  \"larry\", \"Domain\", \"contoso.com\"];\nlet c_Accounts = cust_Accounts\n| extend AccountAtDomain = tolower(strcat(Account,\"@\",Domain)), AccountName = tolower(Account),\nDomainSlashAccount = tolower(strcat(NtDomain,\"\\\\\",Account));\nlet AccountFormat = p_Accounts | union c_Accounts | project AccountName, AccountAtDomain, DomainSlashAccount;\n// Normalize activity from diverse sources into common schema using a function\nlet activity = view (a_StartTime:datetime, a_EndTime:datetime) {\n(union isfuzzy=true\n(AccountFormat | join kind=inner\n(AWSCloudTrail\n| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime\n| extend ClientIP = \"-\", AccountName = tolower(UserIdentityUserName), WinSecEventDomain = \"-\"\n| project-rename EventType = EventName, ServiceOrSystem = EventSource)\non AccountName),\n(AccountFormat | join kind=inner\n(SigninLogs\n| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime\n| extend AccountName = tolower(split(UserPrincipalName, \"@\")[0]), WinSecEventDomain = \"-\"\n| project-rename EventType = strcat(OperationName, \"-\", ResultType, \"-\", ResultDescription), ServiceOrSystem = AppDisplayName, ClientIP = IPAddress)\non AccountName),\n(AccountFormat | join kind=inner\n(OfficeActivity\n| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime\n| extend AccountName = tolower(split(UserId, \"@\")[0]), WinSecEventDomain = \"-\"\n| project-rename EventType = strcat(Operation, \"-\", ResultStatus), ServiceOrSystem = OfficeWorkload)\non AccountName),\n(AccountFormat | join kind=inner\n(SecurityEvent\n| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime\n| where EventID in (4624, 4625)\n| extend ClientIP = \"-\"\n| extend AccountName = tolower(split(Account,\"\\\\\")[1]), Domain = tolower(split(Account,\"\\\\\")[0])\n| project-rename EventType = Activity, ServiceOrSystem = Computer, WinSecEventDomain = Domain)\non AccountName),\n(AccountFormat | join kind=inner\n(W3CIISLog\n| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime\n| where csUserName != \"-\" and isnotempty(csUserName)\n| extend AccountName = tolower(csUserName), WinSecEventDomain = \"-\"\n| project-rename EventType = csMethod, ServiceOrSystem = sSiteName, ClientIP = cIP)\non AccountName),\n(AccountFormat | join kind=inner\n(W3CIISLog\n| where TimeGenerated >= a_StartTime and TimeGenerated <= a_EndTime\n| where csUserName != \"-\" and isnotempty(csUserName)\n| extend AccountAtDomain = tolower(csUserName), WinSecEventDomain = \"-\"\n| project-rename EventType = csMethod, ServiceOrSystem = sSiteName, ClientIP = cIP)\non AccountAtDomain));\n};\n// Rare activity today versus prior week\nlet LastDay = startofday(ago(1d));\nlet PrevDay = endofday(ago(2d));\nlet Prev7Day = startofday(ago(8d));\nlet ra_LastDay = activity(LastDay, now())\n| summarize ra_StartTime = min(TimeGenerated), ra_EndTime = max(TimeGenerated),\nra_Count = count() by Type, AccountName, EventType, ClientIP, ServiceOrSystem, WinSecEventDomain;\nlet a_7day = activity(Prev7Day, PrevDay)\n| summarize ha_Count = count() by Type, AccountName, EventType, ClientIP, ServiceOrSystem, WinSecEventDomain;\nlet ra_Today = ra_LastDay | join kind=leftanti (a_7day) on Type, AccountName, ServiceOrSystem\n| extend RareServiceOrSystem = ServiceOrSystem;\n// Retrieve related activity as context\nlet a_Related =\n(union isfuzzy=true\n(// Make sure we at least publish the unusual activity we identified above - even if no related context activity is found in the subsequent union\nra_Today),\n// Remaining elements of the union look for related activity\n(ra_Today | join kind=inner\n(OfficeActivity\n| where TimeGenerated > LastDay\n| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(OfficeWorkload),\nrel_ServiceOrSystemSet = makeset(OfficeWorkload), rel_ClientIPSet = makeset(ClientIP),\nrel_Count = count() by AccountName = tolower(UserId), rel_EventType = Operation, Type\n) on AccountName),\n(ra_Today | join kind=inner\n(SecurityEvent | where TimeGenerated > LastDay\n| where EventID in (4624, 4625)\n| where AccountType == \"User\"\n| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(Computer),\nrel_ServiceOrSystemSet = makeset(Computer), rel_ClientIPSet = makeset(\"-\"),\nrel_Count = count() by DomainSlashAccount = tolower(Account), rel_EventType = Activity, Type\n) on DomainSlashAccount),\n(ra_Today | join kind=inner\n(Event | where TimeGenerated > LastDay\n// 7045: A service was installed in the system\n| where EventID == 7045\n| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(Computer),\nrel_ServiceOrSystemSet = makeset(Computer), rel_ClientIPSet = makeset(\"-\"),\nrel_Count = count() by DomainSlashAccount = tolower(UserName), rel_EventType = strcat(EventID, \"-\", tostring(split(RenderedDescription,\".\")[0])), Type\n) on DomainSlashAccount),\n(ra_Today | join kind=inner\n(SecurityEvent | where TimeGenerated > LastDay\n// 4720: Account created, 4726: Account deleted\n| where EventID in (4720,4726)\n| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(UserPrincipalName),\nrel_ServiceOrSystemSet = makeset(UserPrincipalName), rel_ClientIPSet = makeset(\"-\"),\nrel_Count = count() by DomainSlashAccount = tolower(Account), rel_EventType = Activity, Type\n) on DomainSlashAccount),\n(ra_Today | join kind=inner\n(SigninLogs | where TimeGenerated > LastDay\n| extend RemoteHost = tolower(tostring(parse_json(DeviceDetail.[\"displayName\"])))\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser, StatusCode = tostring(Status.errorCode),\nStatusDetails = tostring(Status.additionalDetails), State = tostring(LocationDetails.state)\n| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), a_RelatedRemoteHostSet = makeset(RemoteHost),\nrel_ServiceOrSystemSet = makeset(AppDisplayName), rel_ServiceOrSystemCount = dcount(AppDisplayName), rel_ClientIPSet = makeset(IPAddress),\nrel_StateSet = makeset(State),\nrel_Count = count() by AccountAtDomain = tolower(UserPrincipalName), rel_EventType = iff(isnotempty(ResultDescription), ResultDescription, StatusDetails), Type\n) on AccountAtDomain),\n(ra_Today | join kind=inner\n(AWSCloudTrail | where TimeGenerated > LastDay\n| summarize rel_StartTime = min(TimeGenerated),rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemSet = makeset(EventSource),\nrel_ServiceOrSystemCount = dcount(EventSource), rel_ClientIPSet = makeset(\"-\"),\nrel_Count= count() by AccountName = tolower(UserIdentityUserName), rel_EventType = EventName, Type\n) on AccountName),\n(ra_Today | join kind=inner\n(SecurityAlert | where TimeGenerated > LastDay\n| extend ExtProps=parse_json(ExtendedProperties)\n| extend AccountName = tostring(ExtProps.[\"user name\"])\n| summarize rel_StartTime = min(TimeGenerated), rel_EndTime = max(TimeGenerated), rel_ServiceOrSystemCount = dcount(AlertType),\nrel_ServiceOrSystemSet = makeset(AlertType),\nrel_Count = count() by DomainSlashAccount = tolower(AccountName), rel_EventType = ProductName, Type\n) on DomainSlashAccount)\n);\na_Related\n| project Type, RareActivtyStartTimeUtc = ra_StartTime, RareActivityEndTimeUtc = ra_EndTime, RareActivityCount = ra_Count,\nAccountName, WinSecEventDomain, EventType, RareServiceOrSystem, RelatedActivityStartTimeUtc = rel_StartTime,\nRelatedActivityEndTimeUtc = rel_EndTime, RelatedActivityEventType = rel_EventType, RelatedActivityClientIPSet = rel_ClientIPSet,\nRelatedActivityServiceOrSystemCount = rel_ServiceOrSystemCount, RelatedActivityServiceOrSystemSet = rel_ServiceOrSystemSet, RelatedActivityCount = rel_Count\n| extend timestamp = RareActivtyStartTimeUtc, AccountCustomEntity = AccountName", "attributes": {"description": "'This query will determine rare activity by a high-value account carried out on a system or service.\nHigh Value accounts are determined by Group Membership to High Value groups via events listed below.\nRare here means an activity type seen in the last day which has not been seen in the previous 7 days.\nIf any account with such rare activity is found, the query will attempt to retrieve related activity\nfrom that account on that same day and summarize the information.\n4728 - A member was added to a security-enabled global group\n4732 - A member was added to a security-enabled local group\n4756 - A member was added to a security-enabled universal group'\n", "techniques": ["T1078", "T1087"], "tactics": ["PrivilegeEscalation", "Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/UnfamiliarsignincorrelationwithPortalSigninandAuditlogs.yaml", "query_name": "Unfamiliar Signin Correlation with AzurePortal Signin Attempts and AuditLogs", "query": "SecurityAlert \n| where AlertName == \"Unfamiliar sign-in properties\"\n| extend Extprop = parsejson(Entities)\n| mv-expand Extprop\n| extend Extprop = parsejson(Extprop)\n| extend CmdLine = iff(Extprop['Type']==\"process\", Extprop['CommandLine'], '')\n| extend File = iff(Extprop['Type']==\"file\", Extprop['Name'], '')\n| extend Account = Extprop['Name']\n| extend Domain = Extprop['UPNSuffix']\n| extend Account = iif(isnotempty(Domain) and Extprop['Type']==\"account\", tolower(strcat(Account, \"@\", Domain)), iif(Extprop['Type']==\"account\", tolower(Account), \"\"))\n| extend IpAddress = iff(Extprop[\"Type\"] == \"ip\",Extprop['Address'], '')\n| extend Process = iff(isnotempty(CmdLine), CmdLine, File)\n| summarize count() by AlertName,AlertSeverity,CompromisedEntity,Account\n| join kind=inner\n(\nSigninLogs\n| where AppDisplayName == \"Azure Portal\"\n// 50126 - Invalid username or password, or invalid on-premises username or password.\n| where ResultType == \"50126\"\n| extend OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)\n| project  UserDisplayName, UserPrincipalName, AppDisplayName, ResultType, ResultDescription, StatusCode, StatusDetails, Location, State,IPAddress\n| extend AccountCustomEntity = UserPrincipalName\n) on $left.Account == $right.AccountCustomEntity\n| project AccountCustomEntity = tolower(AccountCustomEntity),State,StatusCode,StatusDetails,IPAddress,ResultDescription,AppDisplayName,Location,AlertName\n| join kind=inner\n(\nAuditLogs\n| where Category =~ \"RoleManagement\"\n| where OperationName has_any (\"Add member to role\",\"Add member to role in PIM requested (permanent)\")\n| extend IpAddress = case(\n  isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), \n  isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.app)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.app)).ipAddress),\n  'Not Available')\n| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \n  tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName)), UserRoles = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName)) \n| project InitiatedBy = tolower(InitiatedBy), ActivityDateTime, ActivityDisplayName,IpAddress, AADOperationType, AADTenantId\n) on $left.AccountCustomEntity == $right.InitiatedBy\n| project AccountCustomEntity,AppDisplayName,IPAddress,Location,StatusCode,StatusDetails\n  entityMappings:\n- entityType: IP\n  fieldMappings:\n    - identifier: Address\n      columnName: IPAddress\n- entityType: Account\n  fieldMappings:\n    - identifier: FullName\n      columnName: AccountCustomEntity\n", "attributes": {"description": "'This query looks for unfamiliar Sign-in's thats not seen recently for the given user\n with azure portal login attempts and audit logs to help detect and reduce the analysis timeline for defenders'\n", "techniques": ["T1190", "T1078"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/UnicodeObfuscationInCommandLine.yaml", "query_name": "Unicode Obfuscation in Command Line", "query": "let lolbins = dynamic([\"cmd.exe\", \"powershell.exe\", \"find.exe\", \"PowerShell_ISE.exe\", \"wmic.exe\", \"winrs.exe\", \"winrm.cmd\", \"whoami.exe\", \"wevtutil.exe\", \"vssadmin.exe\", \"vbc.exe\", \"tasklist.exe\", \"takeown.exe\", \"taskkill.exe\", \"systeminfo.exe\", \"schtasks.exe\", \"sc.exe\", \"route.exe\", \"robocopy.cmd\", \"regsrv32.exe\", \"ping.exe\", \"nslookup.exe\", \"netstat.exe\", \"netsh.exe\", \"net.exe\", \"msiexec.exe\", \"mpcmdrun.exe\", \"jsc.exe\", \"ipconfig.exe\", \"icals.exe\", \"forfiles.exe\", \"fltmc.exe\", \"findstr.exe\", \"curl.exe\", \"csc.exe\", \"cmstp.exe\", \"cmdkey.exe\", \"certutils.exe\", \"cacls.exe\", \"bitsadmin.exe\", \"at.exe\", \"arp.exe\"]);\n(union isfuzzy=true\n(SecurityEvent\n| where Process in~ (lolbins)\n| where isnotempty(CommandLine)\n| extend CommandLine = translate('\u2013\u201d\u201c', '-\"\"', CommandLine)\n| extend ASCII = isascii(CommandLine)\n| where ASCII == false),\n(DeviceProcessEvents\n| where isnotempty(InitiatingProcessCommandLine)\n| extend CommandLine = translate('\u2013\u201d\u201c', '-\"\"', InitiatingProcessCommandLine)\n| extend ASCII = isascii(CommandLine)\n| where ASCII == false\n| extend Account = AccountName, Computer = DeviceName),\n(imProcessCreate\n| where isnotempty(ActingProcessCommandLine)\n| extend CommandLine = translate('\u2013\u201d\u201c', '-\"\"', ActingProcessCommandLine)\n| extend ASCII = isascii(CommandLine)\n| where ASCII == false\n| extend Account = ActorUsername, Computer = DvcHostname))\n| summarize Computers=make_set(Computer), Users=make_set(Account), NumberOfTimesRun = count(TimeGenerated), FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated) by Process, CommandLine\n| extend NumberOfComputers = array_length(Computers), NumberOfUsers = array_length(Users)\n| project-reorder FirstSeen, LastSeen, CommandLine, Process, NumberOfComputers, NumberOfComputers, NumberOfTimesRun, Computers, Users\n| extend timestamp = FirstSeen\n", "attributes": {"description": "'The query looks for Command Lines that contain non ASCII characaters. Insertion of these characters could be used to evade detections.\nCommand lines should be reviewed to determine whether inclusion of non ASCII characters was deliberate or not.\nRef: https://www.wietzebeukema.nl/blog/windows-command-line-obfuscation'\n", "techniques": ["T1027"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/UseragentExploitPentest.yaml", "query_name": "Exploit and Pentest Framework User Agent", "query": "\nlet UserAgentList = \"Internet Explorer |Mozilla/4\\\\.0 \\\\(compatible; MSIE 6\\\\.0; Windows NT 5\\\\.1; SV1; InfoPath\\\\.2\\\\)|Mozilla/5\\\\.0 \\\\(Windows NT 10\\\\.0; Win32; x32; rv:60\\\\.0\\\\)|Mozilla/4\\\\.0 \\\\(compatible; Metasploit RSPEC\\\\)|Mozilla/4\\\\.0 \\\\(compatible; MSIE 6\\\\.1; Windows NT\\\\)|Mozilla/4\\\\.0 \\\\(compatible; MSIE 6\\\\.0; Windows NT 5\\\\.1\\\\)|Mozilla/4\\\\.0 \\\\(compatible; MSIE 8\\\\.0; Windows NT 6\\\\.0; Trident/4\\\\.0\\\\)|Mozilla/4\\\\.0 \\\\(compatible; MSIE 7\\\\.0; Windows NT 6\\\\.0; Trident/4\\\\.0; SIMBAR={7DB0F6DE-8DE7-4841-9084-28FA914B0F2E}; SLCC1; \\\\.N|Mozilla/5\\\\.0 \\\\(Windows; U; Windows NT 5\\\\.1; en-US\\\\) AppleWebKit/525\\\\.13 \\\\(KHTML, like Gecko\\\\) Chrome/4\\\\.0\\\\.221\\\\.6 Safari/525\\\\.13|Mozilla/5\\\\.0 \\\\(compatible; MSIE 9\\\\.0; Windows NT 6\\\\.1; WOW64; Trident/5\\\\.0; MAAU\\\\)|Mozilla/5\\\\.0[^\\\\s]|Mozilla/4\\\\.0 \\\\(compatible; SPIPE/1\\\\.0|Mozilla/5\\\\.0 \\\\(Windows NT 6\\\\.3; rv:39\\\\.0\\\\) Gecko/20100101 Firefox/35\\\\.0|Sametime Community Agent|X-FORWARDED-FOR|DotDotPwn v2\\\\.1|SIPDROID|wordpress hash grabber|exploit|okhttp/\";\n// Excluding for IIS, as the main malicious usage for okhttp that we have seen was in the OfficeActivity logs and this can create noise for IIS.\nlet ExcludeIIS = \"okhttp/\";\n(union isfuzzy=true\n(OfficeActivity\n| where ExtendedProperties has \"UserAgent\"\n| extend UserAgent = extractjson(\"$[0].Value\", ExtendedProperties, typeof(string))\n| where UserAgent matches regex UserAgentList\n| project TimeGenerated, Type, UserAgent, SourceIP\n| extend IPCustomEntity = SourceIP\n),\n(\nW3CIISLog\n| extend UserAgent = replace('\\\\+', ' ', csUserAgent) \n| where UserAgent matches regex UserAgentList\n| where UserAgent !startswith ExcludeIIS\n| extend SourceIP = cIP\n| project TimeGenerated, Type, UserAgent, SourceIP\n| extend IPCustomEntity = SourceIP\n),\n(\nAWSCloudTrail\n| where UserAgent matches regex UserAgentList\n| extend SourceIP = SourceIpAddress\n| project TimeGenerated, Type, UserAgent, SourceIP\n))\n| summarize min(TimeGenerated), max(TimeGenerated), count() by Type, UserAgent, SourceIP\n| extend timestamp = min_TimeGenerated, IPCustomEntity = SourceIP\n", "attributes": {"description": "'There are several exploit and pen test frameworks that are being used by pen testers as well as attackers to \ncompromise an environment and achieve their objective. The query tries to detect suspicious user agent strings \nused by these frameworks in some of the data sources that contain UserAgent field. \nThis is based out of sigma rules described in references.\nReferences: https://github.com/Neo23x0/sigma/blob/master/rules/proxy/proxy_ua_frameworks.yml'\n", "techniques": ["T1189", "T1071", "T1203"], "tactics": ["InitialAccess", "CommandAndControl", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/MultipleDataSources/UserGrantedAccess_CreatesResources.yaml", "query_name": "User Granted Access and created resources", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet auditLookback = starttime-14d;\nlet opName = dynamic([\"Add user\", \"Invite external user\"]);\n// Helper function to extract relevant fields from AuditLog events\nlet auditLogEvents = view (startTimeSpan:timespan, operation:dynamic)  {\n    AuditLogs | where TimeGenerated >= auditLookback\n    | where OperationName in~ (operation)\n    | extend ModProps = iff(TargetResources.[0].modifiedProperties != \"[]\", TargetResources.[0].modifiedProperties, todynamic(\"NoValues\"))\n    | extend IpAddress = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)),\n    tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), tostring(parse_json(tostring(InitiatedBy.app)).ipAddress))\n    | extend InitiatedByFull = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)),\n    tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n    | extend InitiatedBy = replace(\"_\",\"@\",tostring(split(InitiatedByFull, \"#\")[0]))\n    | extend TargetUserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetResourceName = case(\n    isempty(tostring(TargetResources.[0].displayName)), TargetUserPrincipalName,\n    isnotempty(tostring(TargetResources.[0].displayName)) and tostring(TargetResources.[0].displayName) startswith \"upn:\", tolower(tostring(TargetResources.[0].displayName)),\n    tolower(tostring(TargetResources.[0].displayName))\n    )\n    | extend TargetUserName = replace(\"_\",\"@\",tostring(split(TargetUserPrincipalName, \"#\")[0]))\n    | extend TargetUserName = iff(isempty(TargetUserName), tostring(split(split(TargetResourceName, \",\")[0], \" \")[1]), TargetUserName )\n    | mvexpand ModProps\n    | extend PropertyName = tostring(ModProps.displayName), newValue = replace(\"\\\"\",\"\",tostring(ModProps.newValue));\n};\nlet UserAdd = auditLogEvents(auditLookback, opName)\n| project Action = \"User Added\", TimeGenerated, Type, InitiatedBy_Caller = InitiatedBy, IpAddress, TargetUserName = tolower(TargetUserName), OperationName, PropertyName_ResourceId = PropertyName, Value = newValue;\n// Get the simple list of creatd users so we can use later to get just the associated resource creation events\nlet SimpleUserList = UserAdd | project TimeGenerated, TargetUserName;\nlet ResourceCreation = AzureActivity\n| where TimeGenerated >= auditLookback\n// We look for any Operation that created and then succeeded where ActivityStatus has a value so that we can provide context\n| where OperationName has \"Create\"\n| where ActivityStatus has \"Succeeded\"\n| project Action = \"Resource Created\", ResourceCreationTimeGenerated = TimeGenerated, Type, InitiatedBy_Caller = tolower(Caller), IpAddress = CallerIpAddress, OperationName, Value = OperationNameValue, PropertyName_ResourceId = ResourceId;\n// Get just the Resources added by the new user\nlet ResourceMatch = SimpleUserList | join kind= innerunique (\n   ResourceCreation\n) on $left.TargetUserName == $right.InitiatedBy_Caller\n// where the resource creation is after (greater than) the user addition\n| where TimeGenerated < ResourceCreationTimeGenerated\n| project-away TimeGenerated\n| project-rename TimeGenerated = ResourceCreationTimeGenerated\n;\nlet SimpleResourceMatch = ResourceMatch | project InitiatedBy_Caller;\n// Get only resource add, remove, change by the new user\nlet UserAddWithResource = SimpleResourceMatch | join kind= rightsemi (\n   UserAdd\n) on $left.InitiatedBy_Caller == $right.TargetUserName;\n// union the user addition events and resource addition events and provide common column names, additionally pack the value, property and resource info to reduce result set.\nUserAddWithResource\n| union isfuzzy=true(ResourceMatch\n| extend PropertySet = pack(\"Value\", Value, \"PropertyName_ResourceId\", PropertyName_ResourceId)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makeset(PropertySet)  by Action, Type, TargetUserName, InitiatedBy_Caller, IpAddress, OperationName\n| order by StartTimeUtc asc)\n| extend timestamp = StartTimeUtc, AccountCustomEntity = TargetUserName, IPCustomEntity = IpAddress", "attributes": {"description": "'Identifies when a new user is granted access and starts creating resources in Azure.  This can help you identify rogue or malicious user behavior.'\n", "techniques": ["T1098", "T1078", "T1496"], "tactics": ["Persistence", "PrivilegeEscalation", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/AnomolousUserAccessingOtherUsersMailbox.yaml", "query_name": "Anomalous access to other user's mailboxes", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*2);\n//Adjust this value to alter how many mailbox (other than their own) a user needs to access before being included in results\nlet user_threshold = 1;\n//Adjust this value to alter how many mailbox folders in other's email accounts a users needs to access before being included in results.\nlet folder_threshold = 5;\n//Exclude historical as known good (set lookback and timeframe to same value to skip this)\nOfficeActivity\n| where TimeGenerated between(ago(lookback)..starttime)\n| where Operation =~ \"MailItemsAccessed\"\n| where ResultStatus =~ \"Succeeded\"\n| where tolower(MailboxOwnerUPN) != tolower(UserId)\n| join kind=rightanti(\nOfficeActivity\n| where TimeGenerated between(starttime..endtime)\n| where Operation =~ \"MailItemsAccessed\"\n| where ResultStatus =~ \"Succeeded\"\n| where tolower(MailboxOwnerUPN) != tolower(UserId)) on MailboxOwnerUPN, UserId\n| where isnotempty(Folders)\n| mv-expand parse_json(Folders)\n| extend folders = tostring(Folders.Path)\n| extend ClientIP = iif(Client_IPAddress startswith \"[\", extract(\"\\\\[([^\\\\]]*)\", 1, Client_IPAddress), Client_IPAddress)\n| summarize StartTime=max(TimeGenerated), EndTime=min(TimeGenerated), make_set(folders), make_set(ClientInfoString), make_set(ClientIP), make_set(MailboxGuid), make_set(MailboxOwnerUPN)  by UserId\n| extend folder_count = array_length(set_folders)\n| extend user_count = array_length(set_MailboxGuid)\n| where user_count > user_threshold or folder_count > folder_threshold\n| extend Reason = case(user_count > user_threshold and folder_count > folder_threshold, \"Both User and Folder Threshold Exceeded\", folder_count > folder_threshold and user_count < user_threshold, \"Folder Count Threshold Exceeded\",\"User Threshold Exceeded\")\n| sort by user_count desc\n| project-reorder UserId, user_count, folder_count, set_MailboxOwnerUPN, set_ClientIP, set_ClientInfoString, set_folders\n| extend timestamp = StartTime, AccountCustomEntity = UserId\n", "attributes": {"description": "'Looks for users accessing multiple other user's mailboxes or accessing multiple folders in another users mailbox'\n", "techniques": ["T1114.002"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/double_file_ext_exes.yaml", "query_name": "Exes with double file extension and access summary", "query": "\nlet known_ext = dynamic([\"lnk\",\"log\",\"option\",\"config\", \"manifest\", \"partial\"]);\nlet excluded_users = dynamic([\"app@sharepoint\"]);\nOfficeActivity\n| where RecordType =~ \"SharePointFileOperation\" and isnotempty(SourceFileName)\n| where OfficeObjectId has \".exe.\" and SourceFileExtension !in~ (known_ext)\n| extend Extension = extract(\"[^.]*.[^.]*$\",0, OfficeObjectId)\n| join kind= leftouter ( \n  OfficeActivity\n    | where RecordType =~ \"SharePointFileOperation\" and (Operation =~ \"FileDownloaded\" or Operation =~ \"FileAccessed\") \n    | where SourceFileExtension !in~ (known_ext)\n) on OfficeObjectId \n| where UserId1 !in~ (excluded_users)\n| extend userBag = pack(UserId1, ClientIP1) \n| summarize makeset(UserId1), make_bag(userBag), Start=max(TimeGenerated), End=min(TimeGenerated) by UserId, OfficeObjectId, SourceFileName, Extension \n| extend NumberOfUsers = array_length(bag_keys(bag_userBag))\n| project UploadTime=Start, Uploader=UserId, FileLocation=OfficeObjectId, FileName=SourceFileName, AccessedBy=bag_userBag, Extension, NumberOfUsers\n| extend timestamp = UploadTime, AccountCustomEntity = Uploader\n", "attributes": {"description": "'Provides a summary of executable files with double file extensions in SharePoint \n and the users and IP addresses that have accessed them.'\n", "techniques": ["T1036"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/ExternalUserAddedRemovedInTeams_HuntVersion.yaml", "query_name": "External user added and removed in a short timeframe - Hunt Version", "query": "\n// If you want to look at user added further than 7 days ago adjust this value\n// If you want to change the timeframe of how quickly accounts need to be added and removed change this value\nlet time_delta = 1h;\nOfficeActivity\n| where OfficeWorkload =~ \"MicrosoftTeams\" \n| where Operation =~ \"MemberAdded\"\n| extend UPN = tostring(parse_json(Members)[0].UPN)\n| where UPN contains (\"#EXT#\")\n| project TimeAdded=TimeGenerated, Operation, UPN, UserWhoAdded = UserId, TeamName, TeamGuid\n| join (\nOfficeActivity\n| where OfficeWorkload =~ \"MicrosoftTeams\" \n| where Operation =~ \"MemberRemoved\"\n| extend UPN = tostring(parse_json(Members)[0].UPN)\n| where UPN contains (\"#EXT#\")\n| project TimeDeleted=TimeGenerated, Operation, UPN, UserWhoDeleted = UserId, TeamName, TeamGuid) on UPN, TeamGuid\n| where TimeDeleted < (TimeAdded + time_delta)\n| project TimeAdded, TimeDeleted, UPN, UserWhoAdded, UserWhoDeleted, TeamName, TeamGuid\n| extend timestamp = TimeAdded, AccountCustomEntity = UPN\n", "attributes": {"description": "'This hunting query identifies external user accounts that are added to a Team and then removed within one hour.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/ExternalUserFromNewOrgAddedToTeams.yaml", "query_name": "External user from a new organisation added to Teams", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nlet known_orgs = (\nOfficeActivity\n| where TimeGenerated between(ago(lookback)..starttime)\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n| where Operation =~ \"MemberAdded\" or Operation =~ \"TeamsSessionStarted\"\n// Extract the correct UPN and parse our external organization domain\n| extend UPN = iif(Operation == \"MemberAdded\", tostring(Members[0].UPN), UserId)\n| extend Organization = tostring(split(split(UPN, \"_\")[1], \"#\")[0])\n| where isnotempty(Organization)\n| summarize by Organization);\nOfficeActivity\n| where TimeGenerated between(starttime..endtime)\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n| where Operation =~ \"MemberAdded\"\n| extend UPN = tostring(parse_json(Members)[0].UPN)\n| extend Organization = tostring(split(split(UPN, \"_\")[1], \"#\")[0])\n| where isnotempty(Organization)\n| where Organization !in (known_orgs)\n| extend timestamp = TimeGenerated, AccountCustomEntity = UPN\n", "attributes": {"description": "'This query identifies external users added to Teams where the user's domain is not one previously seen in Teams data.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/Mail_redirect_via_ExO_transport_rule_hunting.yaml", "query_name": "Mail redirect via ExO transport rule", "query": "\nOfficeActivity\n| where OfficeWorkload == \"Exchange\"\n| where Operation in~ (\"New-TransportRule\", \"Set-TransportRule\")\n| mv-apply DynamicParameters = todynamic(Parameters) on (summarize ParsedParameters = make_bag(pack(tostring(DynamicParameters.Name), DynamicParameters.Value)))\n| extend RuleName = case(\n    Operation =~ \"Set-TransportRule\", OfficeObjectId,\n    Operation =~ \"New-TransportRule\", ParsedParameters.Name,\n    \"Unknown\")\n| mv-expand ExpandedParameters = todynamic(Parameters)\n| where ExpandedParameters.Name in~ (\"BlindCopyTo\", \"RedirectMessageTo\") and isnotempty(ExpandedParameters.Value)\n| extend RedirectTo = ExpandedParameters.Value\n| extend ClientIPValues = extract_all(@'\\[?(::ffff:)?(?P<IPAddress>(\\d+\\.\\d+\\.\\d+\\.\\d+)|[^\\]]+)\\]?([-:](?P<Port>\\d+))?', dynamic([\"IPAddress\", \"Port\"]), ClientIP)[0]\n| project TimeGenerated, RedirectTo, IPAddress = tostring(ClientIPValues[0]), Port = tostring(ClientIPValues[1]), UserId, Operation, RuleName, Parameters\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = IPAddress\n  \n", "attributes": {"description": "'Identifies when Exchange Online transport rule configured to forward emails.\nThis could be an adversary mailbox configured to collect mail from multiple user accounts.'\n", "techniques": ["T1114", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/MultipleTeamsDeletes.yaml", "query_name": "Multiple Teams deleted by a single user", "query": "\n// Adjust this value to change how many Teams should be deleted before including\nlet max_delete = 3;\nlet deleting_users = (\nOfficeActivity\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n| where Operation =~ \"TeamDeleted\"\n| summarize count() by UserId\n| where count_ > max_delete\n| project UserId);\nOfficeActivity\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n| where Operation =~ \"TeamDeleted\"\n| where UserId in (deleting_users)\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId\n", "attributes": {"description": "'This hunting query identifies where multiple Teams have been deleted by a single user in a short timeframe.'\n", "techniques": ["T1485", "T1489"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/MultiTeamBot.yaml", "query_name": "Bots added to multiple teams", "query": "\n// Adjust these thresholds to suit your environment.\nlet threshold = 2;\nlet time_threshold = timespan(5m);\nOfficeActivity\n  | where OfficeWorkload =~ \"MicrosoftTeams\"\n  | where Operation =~ \"BotAddedToTeam\"\n  | summarize Start=max(TimeGenerated), End=min(TimeGenerated), Teams = makeset(TeamName)\n  | extend CountOfTeams = array_length(Teams)\n  | extend TimeDelta = End - Start \n  | where CountOfTeams > threshold\n  | where TimeDelta >= time_threshold\n  | project Start, End, Teams, CountOfTeams\n  | extend timestamp = Start", "attributes": {"description": "'This hunting query helps identify bots added to multiple Teams in a short space of time.'\n", "techniques": ["T1176", "T1119"], "tactics": ["Persistence", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/MultiTeamOwner.yaml", "query_name": "User made Owner of multiple teams", "query": "\n// Adjust this value to change how many teams a user is made owner of before detecting\nlet max_owner_count = 3;\n// Change this value to adjust how larger timeframe the query is run over.\nlet high_owner_count = (OfficeActivity\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n| where Operation =~ \"MemberRoleChanged\"\n| extend Member = tostring(parse_json(Members)[0].UPN) \n| extend NewRole = toint(parse_json(Members)[0].Role) \n| where NewRole == 2\n| summarize dcount(TeamName) by Member\n| where dcount_TeamName > max_owner_count\n| project Member);\nOfficeActivity\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n| where Operation =~ \"MemberRoleChanged\"\n| extend Member = tostring(parse_json(Members)[0].UPN) \n| extend NewRole = toint(parse_json(Members)[0].Role) \n| where NewRole == 2\n| where Member in (high_owner_count)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Member\n", "attributes": {"description": "'This hunting query identifies users who have been made Owner of multiple Teams.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/NewBotAddedToTeams.yaml", "query_name": "Previously unseen bot or application added to Teams", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet historical_bots = (\nOfficeActivity\n| where TimeGenerated between(lookback..starttime)\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n| where isnotempty(AddonName)\n| project AddonName);\nOfficeActivity\n| where TimeGenerated between(starttime..endtime)\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n// Look for add-ins we have never seen before\n| where AddonName in (historical_bots)\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId\n", "attributes": {"description": "'This hunting query helps identify new, and potentially unapproved applications or bots being added to Teams.'\n", "techniques": ["T1176", "T1119"], "tactics": ["Persistence", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/new_adminaccountactivity.yaml", "query_name": "New Admin account activity seen which was not seen historically", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet historicalActivity=\nOfficeActivity\n| where TimeGenerated between(lookback..starttime)\n| where RecordType==\"ExchangeAdmin\" and UserType in (\"Admin\",\"DcAdmin\")\n| summarize historicalCount=count() by UserId;\nlet recentActivity = OfficeActivity\n| where TimeGenerated between(starttime..endtime)\n| where UserType in (\"Admin\",\"DcAdmin\")\n| summarize recentCount=count() by UserId;\nrecentActivity | join kind = leftanti (\n   historicalActivity\n) on UserId\n| project UserId,recentCount\n| order by recentCount asc, UserId\n| join kind = rightsemi\n(OfficeActivity\n| where TimeGenerated between(starttime..endtime)\n| where RecordType == \"ExchangeAdmin\" | where UserType in (\"Admin\",\"DcAdmin\"))\non UserId\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), count() by RecordType, Operation, UserType, UserId, OriginatingServer, ResultStatus\n| extend timestamp = StartTime, AccountCustomEntity = UserId\n", "attributes": {"description": "'This will help you discover any new admin account activity which was seen and were not seen historically.\nAny new accounts seen in the results can be validated and investigated for any suspicious activities.'\n", "techniques": ["T1078", "T1114"], "tactics": ["PrivilegeEscalation", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/new_sharepoint_downloads_by_IP.yaml", "query_name": "SharePointFileOperation via previously unseen IPs", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet BLOCK_THRESHOLD = 1.0;\nlet HighBlockRateASNs =\nSigninLogs\n| where TimeGenerated > lookback\n| where isnotempty(AutonomousSystemNumber)\n| summarize make_set(IPAddress), TotalIps = dcount(IPAddress), BlockedSignins= countif(ResultType == \"50053\"), TotalSignins = count() by AutonomousSystemNumber\n| extend BlockRatio = 1.00 * BlockedSignins/TotalSignins\n| where BlockRatio >= BLOCK_THRESHOLD\n| distinct AutonomousSystemNumber\n;\nlet ASNIPs=\nSigninLogs\n| where TimeGenerated > lookback\n| where AutonomousSystemNumber in (HighBlockRateASNs)\n| distinct IPAddress, AutonomousSystemNumber\n;\nOfficeActivity\n| where TimeGenerated between(starttime .. endtime)\n| where  RecordType == \"SharePointFileOperation\"\n| where Operation in (\"FileDownloaded\", \"FileUploaded\")\n| where ClientIP in (ASNIPs)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), RecentFileActivities = count() by ClientIP\n| extend timestamp = StartTime, IPCustomEntity = ClientIP\n", "attributes": {"description": "'Shows volume of documents uploaded to or downloaded from Sharepoint by IPs with ASNs associated with high user lockout or malicious activity.\nIn stable environments such connections by new IPs may be unauthorized, especially if associated with\nspikes in volume which could be associated with large-scale document exfiltration.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/new_sharepoint_downloads_by_UserAgent.yaml", "query_name": "SharePointFileOperation via devices with previously unseen user agents", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet MINIMUM_BLOCKS = 10;\nlet SUCCESS_THRESHOLD = 0.2;\nlet HistoricalActivity = \nSigninLogs\n| where TimeGenerated > lookback\n| where isnotempty(UserAgent)\n| summarize SuccessfulSignins=countif(ResultType==\"0\"), BlockedSignins=countif(ResultType==\"50053\") by UserAgent\n| extend SuccessBlockRatio = 1.00 * SuccessfulSignins / BlockedSignins\n| where SuccessBlockRatio < SUCCESS_THRESHOLD\n| where BlockedSignins > MINIMUM_BLOCKS \n;\nOfficeActivity\n| where TimeGenerated between (starttime .. endtime)\n| where  RecordType == \"SharePointFileOperation\"\n| where Operation in (\"FileDownloaded\", \"FileUploaded\")\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), RecentFileActivities=count() by UserAgent\n| join (HistoricalActivity) on UserAgent\n| project-away UserAgent1\n| extend timestamp = StartTime, UserAgentCustomEntity = UserAgent\n", "attributes": {"description": "'Tracking via user agent is one way to differentiate between types of connecting device.\nIn homogeneous enterprise environments the user agent associated with an attacker device may stand out as unusual.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/New_WindowsReservedFileNamesOnOfficeFileServices.yaml", "query_name": "New Windows Reserved Filenames staged on Office file services", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\n// a threshold can be enabled, see commented line below for PrevSeenCount\nlet threshold = 1;\n// Reserved FileNames/Extension for Windows\nlet Reserved = dynamic(['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9']);\nOfficeActivity | where TimeGenerated between(starttime..endtime)\n| where isnotempty(SourceFileExtension)\n| where SourceFileName !~ SourceFileExtension\n| where SourceFileExtension in~ (Reserved) or SourceFileName in~ (Reserved)\n| where UserAgent !has \"Mac OS\"\n| project TimeGenerated, OfficeId, OfficeWorkload, RecordType, Operation, UserType, UserKey, UserId, ClientIP, UserAgent, Site_Url, SourceRelativeUrl, SourceFileName, SourceFileExtension\n| join kind= leftanti (\nOfficeActivity | where TimeGenerated between (ago(lookback)..starttime)\n| where isnotempty(SourceFileExtension)\n| where SourceFileName !~ SourceFileExtension\n| where SourceFileExtension in~ (Reserved) or SourceFileName in~ (Reserved)\n| where UserAgent !has \"Mac OS\"\n| summarize SourceRelativeUrl = make_set(SourceRelativeUrl), UserId = make_set(UserId), SourceFileName = make_set(SourceFileName) , PrevSeenCount = count() by SourceFileExtension\n// To exclude previous matches when only above a specific count, change threshold above and uncomment the line below\n//| where PrevSeenCount > threshold\n| mvexpand SourceRelativeUrl, UserId, SourceFileName\n| extend SourceRelativeUrl = tostring(SourceRelativeUrl), UserId = tostring(UserId), SourceFileName = tostring(SourceFileName)\n) on SourceFileExtension\n| extend SiteUrlUserFolder = tolower(split(Site_Url, '/')[-2])\n| extend UserIdUserFolderFormat = tolower(replace('@|\\\\.', '_',UserId))\n// identify when UserId is not a match to the specific site url personal folder reference\n| extend UserIdDiffThanUserFolder = iff(Site_Url has '/personal/' and SiteUrlUserFolder != UserIdUserFolderFormat, true , false )\n| summarize TimeGenerated = make_list(TimeGenerated), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), Operations = make_list(Operation), UserAgents = make_list(UserAgent),\nOfficeIds = make_list(OfficeId), SourceRelativeUrls = make_list(SourceRelativeUrl), FileNames = make_list(SourceFileName)\nby OfficeWorkload, RecordType, UserType, UserKey, UserId, ClientIP, Site_Url, SourceFileExtension, SiteUrlUserFolder, UserIdUserFolderFormat, UserIdDiffThanUserFolder\n// Use mvexpand on any list items and you can expand out the exact time and other metadata about the hit\n| extend timestamp = StartTime, AccountCustomEntity = UserId, IPCustomEntity = ClientIP\n", "attributes": {"description": "'Identifies when new Windows Reserved Filenames show up on Office services such as SharePoint and OneDrive in relation to the previous 7 days.\nList currently includes 'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6',\n'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9' file extensions.\nAdditionally, identifies when a given user is uploading these files to another users workspace.\nThis may be indication of a staging location for malware or other malicious activity.\nReferences: https://docs.microsoft.com/windows/win32/fileio/naming-a-file'\n", "techniques": ["T1105"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/nonowner_MailboxLogin.yaml", "query_name": "Non-owner mailbox login activity", "query": "\nOfficeActivity\n| where Operation == \"MailboxLogin\" and Logon_Type != \"Owner\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by Operation, OrganizationName, UserType, UserId, MailboxOwnerUPN, Logon_Type, ClientIP\n| extend timestamp = StartTime, AccountCustomEntity = UserId, IPCustomEntity = ClientIP\n", "attributes": {"description": "'This will help you determine if mailbox access observed with Admin/Delegate Logontype. \nThe logon type indicates mailbox accessed from non-owner user. Exchange allows Admin \nand delegate permissions to access other user's inbox.\nIf your organization has valid admin, delegate access given to users, you can whitelist those and investigate other results.\nReferences: https://docs.microsoft.com/office/office-365-management-api/office-365-management-activity-api-schema#logontype'\n", "techniques": ["T1114", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/OfficeMailForwarding_hunting.yaml", "query_name": "Office Mail Forwarding - Hunting Version", "query": "\nOfficeActivity\n| where (Operation =~ \"Set-Mailbox\" and Parameters contains 'ForwardingSmtpAddress') \nor (Operation in~ ('New-InboxRule','Set-InboxRule') and (Parameters contains 'ForwardTo' or Parameters contains 'RedirectTo'))\n| extend parsed=parse_json(Parameters)\n| extend fwdingDestination_initial = (iif(Operation=~\"Set-Mailbox\", tostring(parsed[1].Value), tostring(parsed[2].Value)))\n| where isnotempty(fwdingDestination_initial)\n| extend fwdingDestination = iff(fwdingDestination_initial has \"smtp\", (split(fwdingDestination_initial,\":\")[1]), fwdingDestination_initial )\n| parse fwdingDestination with * '@' ForwardedtoDomain \n| parse UserId with *'@' UserDomain\n| extend subDomain = ((split(strcat(tostring(split(UserDomain, '.')[-2]),'.',tostring(split(UserDomain, '.')[-1])), '.') [0]))\n| where ForwardedtoDomain !contains subDomain\n| extend Result = iff( ForwardedtoDomain != UserDomain ,\"Mailbox rule created to forward to External Domain\", \"Forward rule for Internal domain\")\n| extend ClientIPAddress = case( ClientIP has \".\", tostring(split(ClientIP,\":\")[0]), ClientIP has \"[\", tostring(trim_start(@'[[]',tostring(split(ClientIP,\"]\")[0]))), ClientIP )\n| extend Port = case(\nClientIP has \".\", (split(ClientIP,\":\")[1]),\nClientIP has \"[\", tostring(split(ClientIP,\"]:\")[1]),\nClientIP\n)\n| project TimeGenerated, UserId, UserDomain, subDomain, Operation, ForwardedtoDomain, ClientIPAddress, Result, Port, OriginatingServer, OfficeObjectId, fwdingDestination\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIPAddress, HostCustomEntity = OriginatingServer\n", "attributes": {"description": "'Adversaries often abuse email-forwarding rules to monitor activities of a victim, steal information and further gain intelligence on\nvictim or victim's organization.This query over Office Activity data highlights cases where user mail is being forwarded and shows if \nit is being forwarded to external domains as well.'\n", "techniques": ["T1114", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/powershell_or_nonbrowser_MailboxLogin.yaml", "query_name": "Powershell or non-browser mailbox login activity", "query": "\nOfficeActivity\n| where Operation == \"MailboxLogin\"\n| where ClientInfoString == \"Client=Microsoft.Exchange.Powershell; Microsoft WinRM Client\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by Operation, OrganizationName, UserType, UserId, MailboxOwnerUPN, Logon_Type, ClientInfoString\n| extend timestamp = StartTime, AccountCustomEntity = UserId\n", "attributes": {"description": "'This will help you determine if mailbox login was done from Exchange Powershell session. \nBy default, all accounts you create in Office 365 are allowed to use Exchange Online PowerShell. \nAdministrators can use Exchange Online PowerShell to enable or disable a user's ability to connect to Exchange Online PowerShell.\nWhitelist any benign scheduled activities using exchange powershell if applicable in your environment.\nReferences: https://docs.microsoft.com/powershell/exchange/exchange-online/connect-to-exchange-online-powershell/connect-to-exchange-online-powershell?view=exchange-ps'\n", "techniques": ["T1059", "T1098", "T1114"], "tactics": ["Execution", "Persistence", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/sharepoint_downloads.yaml", "query_name": "SharePointFileOperation via clientIP with previously unseen user agents", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet historicalUA=\nOfficeActivity\n| where  RecordType == \"SharePointFileOperation\"\n| where Operation in (\"FileDownloaded\", \"FileUploaded\")\n| where TimeGenerated between(lookback..starttime)\n| summarize by ClientIP, UserAgent;\nlet recentUA = OfficeActivity\n| where  RecordType == \"SharePointFileOperation\"\n| where Operation in (\"FileDownloaded\", \"FileUploaded\")\n| where TimeGenerated between(starttime..endtime)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by ClientIP, UserAgent;\nrecentUA | join kind=leftanti (\n   historicalUA\n) on ClientIP, UserAgent\n// Some OfficeActivity records do not contain ClientIP information - exclude these for fewer results\n| where not(isempty(ClientIP))\n| extend timestamp = StartTime, IPCustomEntity = ClientIP\n", "attributes": {"description": "'New user agents associated with a clientIP for sharepoint file uploads/downloads.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/TeamsFilesUploaded.yaml", "query_name": "Files uploaded to teams and access summary", "query": "\nOfficeActivity \n| where RecordType =~ \"SharePointFileOperation\"\n| where Operation =~ \"FileUploaded\" \n| where UserId != \"app@sharepoint\"\n| where SourceRelativeUrl has \"Microsoft Teams Chat Files\" \n| join kind= leftouter ( \n   OfficeActivity \n    | where RecordType =~ \"SharePointFileOperation\"\n    | where Operation =~ \"FileDownloaded\" or Operation =~ \"FileAccessed\" \n    | where UserId != \"app@sharepoint\"\n    | where SourceRelativeUrl has \"Microsoft Teams Chat Files\" \n) on OfficeObjectId \n| extend userBag = pack(UserId1, ClientIP1) \n| summarize makeset(UserId1), make_bag(userBag) by TimeGenerated, UserId, OfficeObjectId, SourceFileName \n| extend NumberUsers = array_length(bag_keys(bag_userBag))\n| project timestamp=TimeGenerated, AccountCustomEntity=UserId, FileLocation=OfficeObjectId, FileName=SourceFileName, AccessedBy=bag_userBag, NumberOfUsersAccessed=NumberUsers\n", "attributes": {"description": "'This hunting queries identifies files uploaded to SharePoint via a Teams chat and\nsummarizes users and IP addresses that have accessed these files. This allows for \nidentification of anomolous file sharing patterns.'\n", "techniques": ["T1199", "T1102", "T1078"], "tactics": ["InitialAccess", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/UserAddToTeamsAndUploadsFile.yaml", "query_name": "User added to Team and immediately uploads file", "query": "\nlet threshold = 1m;\nOfficeActivity\n| where OfficeWorkload =~ \"MicrosoftTeams\"\n| where Operation == \"MemberAdded\"\n| extend TeamName = iff(isempty(TeamName), Members[0].UPN, TeamName)\n| project TimeGenerated, UploaderID=UserId, TeamName\n| join (\n  OfficeActivity\n  | where RecordType == \"SharePointFileOperation\"\n  | where SourceRelativeUrl has \"Microsoft Teams Chat Files\"\n  | where Operation == \"FileUploaded\"\n  | project UploadTime=TimeGenerated, UploaderID=UserId, FileLocation=OfficeObjectId, FileName=SourceFileName\n  ) on UploaderID\n| where UploadTime > TimeGenerated and UploadTime < TimeGenerated+threshold\n| project-away UploaderID1\n| extend timestamp=TimeGenerated, AccountCustomEntity = UploaderID \n", "attributes": {"description": "'This hunting queries identifies users who are added to a Team or Teams chat\nand within 1 minute of being added upload a file via the chat. This might be\nan indicator of suspicious activity.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/OfficeActivity/WindowsReservedFileNamesOnOfficeFileServices.yaml", "query_name": "Windows Reserved Filenames staged on Office file services", "query": "\n// Reserved FileNames/Extension for Windows\nlet Reserved = dynamic(['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9']);\nOfficeActivity\n| where isnotempty(SourceFileExtension)\n| where SourceFileExtension in~ (Reserved) or SourceFileName in~ (Reserved)\n| where UserAgent !has \"Mac OS\" \n| extend SiteUrlUserFolder = tolower(split(Site_Url, '/')[-2])\n| extend UserIdUserFolderFormat = tolower(replace('@|\\\\.', '_',UserId))\n// identify when UserId is not a match to the specific site url personal folder reference\n| extend UserIdDiffThanUserFolder = iff(Site_Url has '/personal/' and SiteUrlUserFolder != UserIdUserFolderFormat, true , false ) \n| summarize TimeGenerated = make_list(TimeGenerated), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), Operations = make_list(Operation), UserAgents = make_list(UserAgent), \nOfficeIds = make_list(OfficeId), SourceRelativeUrls = make_list(SourceRelativeUrl), FileNames = make_list(SourceFileName)\nby OfficeWorkload, RecordType, UserType, UserKey, UserId, ClientIP, Site_Url, SourceFileExtension,SiteUrlUserFolder, UserIdUserFolderFormat, UserIdDiffThanUserFolder\n// Use mvexpand on any list items and you can expand out the exact time and other metadata about the hit\n| extend timestamp = StartTime, AccountCustomEntity = UserId, IPCustomEntity = ClientIP\n", "attributes": {"description": "'Identifies when Windows Reserved Filenames show up on Office services such as SharePoint and OneDrive.\nList currently includes 'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', \n'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9' file extensions.\nAdditionally, identifies when a given user is uploading these files to another users workspace.\nThis may be indication of a staging location for malware or other malicious activity.\nReferences: https://docs.microsoft.com/windows/win32/fileio/naming-a-file'\n", "techniques": ["T1105"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODHighScoreAdultValue.yaml", "query_name": "ProofpointPOD - Emails with high score of 'adult' filter classifier value", "query": "let scoreThreshold = 80;\nProofpointPOD\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| where todynamic(FilterModulesSpamScoresClassifiers).adult > scoreThreshold", "attributes": {"description": "'Search for emails with high score of 'adult' filter classifier value.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODHighScoreMalwareValue.yaml", "query_name": "ProofpointPOD - Emails with high score of 'malware' filter classifier value", "query": "let scoreThreshold = 80;\nProofpointPOD\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| where todynamic(FilterModulesSpamScoresClassifiers).malware > scoreThreshold", "attributes": {"description": "'Search for emails with high score of 'malware' filter classifier value.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODHighScorePhishValue.yaml", "query_name": "ProofpointPOD - Emails with high score of 'phish' filter classifier value", "query": "let scoreThreshold = 80;\nProofpointPOD\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| where todynamic(FilterModulesSpamScoresClassifiers).phish > scoreThreshold", "attributes": {"description": "'Search for emails with high score of 'phish' filter classifier value.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODHighScoreSpamValue.yaml", "query_name": "ProofpointPOD - Emails with high score of 'spam' filter classifier value", "query": "let scoreThreshold = 80;\nProofpointPOD\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| where todynamic(FilterModulesSpamScoresClassifiers).spam > scoreThreshold", "attributes": {"description": "'Search for emails with high score of 'spam' filter classifier value.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODHighScoreSuspectValue.yaml", "query_name": "ProofpointPOD - Emails with high score of 'suspect' filter classifier value", "query": "let scoreThreshold = 80;\nProofpointPOD\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| where todynamic(FilterModulesSpamScoresClassifiers).suspect > scoreThreshold", "attributes": {"description": "'Search for emails with high score of 'suspect' filter classifier value.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODLargeOutboundEmails.yaml", "query_name": "ProofpointPOD - Large size outbound emails", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet out_msg = ProofpointPOD\n| where TimeGenerated between (lookback..starttime)\n| where EventType == 'message'\n| where NetworkDirection == 'outbound'\n| where SrcUserUpn != '';\nProofpointPOD\n| where TimeGenerated between(starttime..endtime)\n| where EventType == 'message'\n| where NetworkDirection == 'outbound'\n| where SrcUserUpn != ''\n| summarize AvgMsgSize = toint(avg(NetworkBytes_real)) by SrcUserUpn\n| join out_msg on SrcUserUpn\n| where NetworkBytes_real > AvgMsgSize*2\n| project SrcUserUpn, AvgMsgSize, NetworkBytes_real\n| extend AccountCustomEntity = SrcUserUpn", "attributes": {"description": "'Search for emails which size is 2 times grater than average size of outbound email for user.'\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODRecipientsHighNumberDiscardReject.yaml", "query_name": "ProofpointPOD - Recipients with high number of discarded or rejected emails", "query": "let threshold = 10;\nProofpointPOD\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| where FilterDisposition !in ('reject', 'discard')\n| summarize count() by DstUserUpn\n| where count_ > threshold\n| extend AccountCustomEntity = DstUserUpn", "attributes": {"description": "'Search for recipients with high number of discarded or rejected emails.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODRecipientsLargeNumberOfCorruptedEmails.yaml", "query_name": "ProofpointPOD - Recipients with large number of corrupted emails", "query": "ProofpointPOD\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| extend isCorrupted = todynamic(MsgParts)[0]['isCorrupted']\n| where isCorrupted == 'true'\n| summarize count() by DstUserUpn\n| sort by count_\n| where count_ > 10", "attributes": {"description": "'Search for recipients with large number of corrupted emails.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODSendersLargeNumberOfCorruptedEmails.yaml", "query_name": "ProofpointPOD - Senders with large number of corrupted messages", "query": "ProofpointPOD\n| where EventType == 'message'\n| where NetworkDirection == 'outbound'\n| extend isCorrupted = todynamic(MsgParts)[0]['isCorrupted']\n| where isCorrupted == 'true'\n| summarize count() by SrcUserUpn\n| sort by count_\n| where count_ > 10", "attributes": {"description": "'Search for senders with large number of corrupted messages.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ProofpointPOD/ProofpointPODSuspiciousFileTypesInAttachments.yaml", "query_name": "ProofpointPOD - Suspicious file types in attachments", "query": "ProofpointPOD\n| where EventType == 'message'\n| where NetworkDirection == 'inbound'\n| extend attachedFileType = todynamic(MsgParts)[0]['detectedExt']\n| summarize count() by tostring(attachedFileType)\n| sort by count_", "attributes": {"description": "'Hunting for suspicious file types in attachments.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsForIP.yaml", "query_name": "Alerts related to IP", "query": "\nlet GetAllAlertsWithIp = (suspiciousEventTime:datetime, v_ipAddress:string){\n//-3d and +6h as some alerts fire after accumulation of events\nlet v_StartTime = suspiciousEventTime-3d;\nlet v_EndTime = suspiciousEventTime+6h;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n// expand JSON properties\n| extend Extprop = parse_json(Entities)\n| mv-expand Extprop\n| extend Extprop = parse_json(Extprop)\n| extend IpAddress = iff(Extprop[\"Type\"] == \"ip\",Extprop['Address'], '')\n| where IpAddress == v_ipAddress\n| extend Account = Extprop['Name']\n| extend Domain = Extprop['UPNSuffix']\n| extend Account = iif(isnotempty(Domain) and Extprop['Type']==\"account\", tolower(strcat(Account, \"@\", Domain)), iif(Extprop['Type']==\"account\", tolower(Account), \"\"))\n| extend Computer = iff(Extprop['Type']==\"host\", Extprop['HostName'], '')\n| project StartTimeUtc = StartTime, EndTimeUtc = EndTime, AlertName, Computer, Account, IpAddress, ExtendedProperties, Entities\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n};\n// change datetime value and <ipaddress> value below\nGetAllAlertsWithIp(datetime('2019-02-05T10:02:51.000'), (\"<ipaddress>\"))\n", "attributes": {"description": "'Any Alerts that fired related to a given IpAddress during the range of +6h and -3d'\n", "techniques": NaN, "tactics": ["Persistence", "Discovery", "LateralMovement", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsForUser.yaml", "query_name": "Alerts related to account", "query": "\nlet GetAllAlertsForUser = (suspiciousEventTime:datetime, v_User:string){\n//-3d and +6h as some alerts fire after accumulation of events\nlet v_StartTime = suspiciousEventTime-3d;\nlet v_EndTime = suspiciousEventTime+6h;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n| extend Extprop = parse_json(Entities)\n| mv-expand Extprop\n| extend Extprop = parse_json(Extprop)\n| extend Account = Extprop['Name']\n| extend Domain = Extprop['UPNSuffix']\n| extend Account = iif(isnotempty(Domain) and Extprop['Type']==\"account\", tolower(strcat(Account, \"@\", Domain)), iif(Extprop['Type']==\"account\", tolower(Account), \"\"))\n| where Account contains v_User\n| extend Computer = iff(Extprop['Type']==\"host\", Extprop['HostName'], '')\n| extend IpAddress = iff(Extprop[\"Type\"] == \"ip\",Extprop['Address'], '') \n| project TimeGenerated, AlertName, Computer, Account, IpAddress, ExtendedProperties \n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n};\n// change datetime value and username value below\nGetAllAlertsForUser(datetime('2019-01-20T10:02:51.000'), toupper(\"<username>\"))\n", "attributes": {"description": "'Any Alerts that fired related to a given account during the range of +6h and -3d'\n", "techniques": NaN, "tactics": ["Persistence", "Discovery", "LateralMovement", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsOnHost.yaml", "query_name": "Alerts On Host", "query": "\nlet GetAllAlertsOnHost = (suspiciousEventTime:datetime, v_Host:string){\n//-3d and +6h as some alerts fire after accumulation of events\nlet v_StartTime = suspiciousEventTime-3d;\nlet v_EndTime = suspiciousEventTime+6h;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n| where Computer contains v_Host\n// expand JSON properties\n| extend Extprop = parse_json(ExtendedProperties)\n| extend Computer = iff(isnotempty(toupper(tostring(Extprop[\"Compromised Host\"]))), toupper(tostring(Extprop[\"Compromised Host\"])), tostring(parse_json(Entities)[0].HostName))\n| extend Account = iff(isnotempty(tolower(tostring(Extprop[\"User Name\"]))), tolower(tostring(Extprop[\"User Name\"])), tolower(tostring(Extprop[\"user name\"])))\n| extend IpAddress = tostring(parse_json(ExtendedProperties).[\"Client Address\"]) \n| project TimeGenerated, AlertName, Computer, Account, IpAddress, ExtendedProperties\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n};\n// change datetime value and hostname value below\nGetAllAlertsOnHost(datetime('2019-01-20T10:02:51.000'), toupper(\"<hostname>\"))\n", "attributes": {"description": "'Any Alerts that fired on a given host during the range of +6h and -3d'\n", "techniques": NaN, "tactics": ["Persistence", "Discovery", "LateralMovement", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsWithFile.yaml", "query_name": "Alerts related to File", "query": "\nlet GetAllAlertsWithFile = (suspiciousEventTime:datetime, v_File:string){\nlet v_StartTime = suspiciousEventTime-1d;\nlet v_EndTime = suspiciousEventTime+1d;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n| where ExtendedProperties has v_File\n| extend Computer = iff(isnotempty(toupper(tostring(Extprop[\"Compromised Host\"]))), toupper(tostring(Extprop[\"Compromised Host\"])), tostring(parse_json(Entities)[0].HostName))\n| extend Account = iff(isnotempty(tolower(tostring(Extprop[\"User Name\"]))), tolower(tostring(Extprop[\"User Name\"])), tolower(tostring(Extprop[\"user name\"])))\n| extend IpAddress = tostring(parse_json(ExtendedProperties).[\"Client Address\"]) \n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n};\n// change datetime value and <filename> value below\nGetAllAlertsWithFile(datetime('2019-01-18T10:36:07Z'), \"<filename>\")\n", "attributes": {"description": "'Any Alerts that fired related to a given File during the range of +6h and -3d'\n", "techniques": NaN, "tactics": ["Persistence", "Discovery", "LateralMovement", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/AlertsWithProcess.yaml", "query_name": "Alerts With This Process", "query": "\nlet GetAllAlertsWithProcess = (suspiciousEventTime:datetime, v_Process:string){\nlet v_StartTime = suspiciousEventTime-1d;\nlet v_EndTime = suspiciousEventTime+1d;\nSecurityAlert\n| where TimeGenerated between (v_StartTime .. v_EndTime)\n| where Entities has v_Process\n| extend Extprop = parse_json(Entities)\n| mv-expand Extprop\n| extend Extprop = parse_json(Extprop)\n| extend CmdLine = iff(Extprop['Type']==\"process\", Extprop['CommandLine'], '')\n| extend File = iff(Extprop['Type']==\"file\", Extprop['Name'], '')\n| extend Account = Extprop['Name']\n| extend Domain = Extprop['UPNSuffix']\n| extend Account = iif(isnotempty(Domain) and Extprop['Type']==\"account\", tolower(strcat(Account, \"@\", Domain)), iif(Extprop['Type']==\"account\", tolower(Account), \"\"))\n| extend Computer = iff(Extprop['Type']==\"host\", Extprop['HostName'], '')\n| extend IpAddress = iff(Extprop[\"Type\"] == \"ip\",Extprop['Address'], '')\n| extend Process = iff(isnotempty(CmdLine), CmdLine, File)\n| summarize max(TimeGenerated), make_set(AlertName), make_set(Process), make_set(Computer), make_set(Account), make_set(IpAddress), make_set(Entities) by SystemAlertId\n| project TimeGenerated = max_TimeGenerated, AlertName=set_AlertName[0], Process=set_Process[1], Account = set_Account[1], Computer=set_Computer[0], IPAddress = set_IpAddress[1], Entities=set_Entities\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IPAddress\n| top 10 by TimeGenerated desc nulls last\n};\n// change datetime value and <processname> value below\nGetAllAlertsWithProcess(datetime('2019-01-18T10:36:07Z'), \"<processname>\")\n", "attributes": {"description": "'Any Alerts that fired on any host with this same process in the range of +-1d'\n", "techniques": NaN, "tactics": ["Persistence", "Discovery", "LateralMovement", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/WebShellCommandAlertEnrich.yaml", "query_name": "Web shell command alert enrichment", "query": "let scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\", \".cfm\", \".shtml\"]);\nlet lookupWindow = 1m;  \nlet lookupBin = lookupWindow / 2.0; \nlet distinctIpThreshold = 3; \nlet alerts = SecurityAlert  \n| extend alertData = parse_json(Entities), recordGuid = new_guid(); \nlet shellAlerts = alerts \n| where ProviderName =~ \"MDATP\"  \n| mvexpand alertData \n| where alertData.Type =~ \"file\" and alertData.Name =~ \"w3wp.exe\" \n| distinct SystemAlertId \n| join kind=inner (alerts) on SystemAlertId; \nlet alldata = shellAlerts  \n| mvexpand alertData \n| extend Type = alertData.Type; \nlet filedata = alldata  \n| extend id = tostring(alertData.$id)  \n| extend ImageName = alertData.Name  \n| where Type =~ \"file\" and ImageName != \"w3wp.exe\" \n| extend imagefileref = id;  \nlet commanddata = alldata  \n| extend CommandLine = tostring(alertData.CommandLine)  \n| extend creationtime = tostring(alertData.CreationTimeUtc)  \n| where Type =~ \"process\"  \n| where isnotempty(CommandLine)  \n| extend imagefileref = tostring(alertData.ImageFile.$ref); \nlet hostdata = alldata \n| where Type =~ \"host\" \n| project HostName = tostring(alertData.HostName), DnsDomain = tostring(alertData.DnsDomain), SystemAlertId \n| distinct HostName, DnsDomain, SystemAlertId; \nlet commandKeyedData = filedata \n| join kind=inner (  \ncommanddata  \n) on imagefileref \n| join kind=inner (hostdata) on SystemAlertId \n| project recordGuid, TimeGenerated, ImageName, CommandLine, TimeKey = bin(TimeGenerated, lookupBin), HostName, DnsDomain \n| extend Start = TimeGenerated; \nlet baseline = W3CIISLog  \n| project-rename SourceIP=cIP, PageAccessed=csUriStem \n| summarize dcount(SourceIP) by PageAccessed \n| where dcount_SourceIP <= distinctIpThreshold; \ncommandKeyedData \n| join kind=inner ( \nW3CIISLog   \n| where csUriStem has_any(scriptExtensions)  \n| extend splitUriStem = split(csUriStem, \"/\")  \n| extend FileName = splitUriStem[-1] | extend firstDir = splitUriStem[-2] | extend TimeKey = range(bin(TimeGenerated-lookupWindow, lookupBin), bin(TimeGenerated, lookupBin),lookupBin)  \n| mv-expand TimeKey to typeof(datetime)  \n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Site=sSiteName, HostName=sComputerName, AttackerIP=cIP, AttackerUserAgent=csUserAgent, csUriStem, filename=tostring(FileName), tostring(firstDir), TimeKey \n) on TimeKey, HostName \n| where (StartTime - EndTime) between (0min .. lookupWindow) \n| extend IPCustomEntity = AttackerIP, timestamp = StartTime\n| extend attackerP = pack(AttackerIP, AttackerUserAgent)  \n| summarize Site=make_set(Site), Attacker=make_bag(attackerP) by csUriStem, filename, tostring(ImageName), CommandLine, HostName, IPCustomEntity, timestamp\n| project Site, ShellLocation=csUriStem, ShellName=filename, ParentProcess=ImageName, CommandLine, Attacker, HostName, IPCustomEntity, timestamp\n| join kind=inner (baseline) on $left.ShellLocation == $right.PageAccessed", "attributes": {"description": "'Extracts MDATP Alerts that indicate a command was executed by a web shell. Uses time window based querying to idneitfy the potential web shell location on the server, then enriches with Attacker IP and User Agent'\n", "techniques": NaN, "tactics": ["PrivilegeEscalation", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityAlert/WebShellFileAlertEnrich.yaml", "query_name": "Web shell file alert enrichment", "query": "let scriptExtensions = dynamic([\".php\", \".jsp\", \".js\", \".aspx\", \".asmx\", \".asax\", \".cfm\", \".shtml\"]);  \nSecurityAlert   \n| where ProviderName =~ \"MDATP\" \n| extend alertData = parse_json(Entities)  \n| mvexpand alertData  \n// Get only the file type from the JSON, this gives us the file name\n| where alertData.Type =~ \"file\"  \n// This can be expanded to include other script extensions \n| where alertData.Name has_any(scriptExtensions)\n| extend FileName = alertData.Name \n| project TimeGenerated, tostring(FileName), alertData.Directory \n| join (  \nW3CIISLog    \n| where csUriStem has_any(scriptExtensions) \n| extend splitUriStem = split(csUriStem, \"/\")  \n| extend FileName = splitUriStem[-1] \n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by AttackerIP=cIP, AttackerUserAgent=csUserAgent, SiteName=sSiteName, ShellLocation=csUriStem, tostring(FileName)  \n) on FileName \n| project StartTime, EndTime, AttackerIP, AttackerUserAgent, SiteName, ShellLocation\n| extend timestamp = StartTime, IPCustomEntity = AttackerIP  \n", "attributes": {"description": "'Extracts MDATP Alert for a web shell being placed on the server and then enriches this event with information from W3CIISLog to idnetigy the Attacker that placed the shell'\n", "techniques": NaN, "tactics": ["PrivilegeEscalation", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/ADAccountLockouts.yaml", "query_name": "AD Account Lockout", "query": "SecurityEvent\n| where EventID == 4740\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), LockoutsCount = count() by Activity, Account, TargetSid, TargetDomainName, SourceComputerId, SourceDomainController = Computer\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = TargetDomainName\n", "attributes": {"description": "'Detects Active Directory account lockouts'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/ADFSDBLocalSqlStatements.yaml", "query_name": "AD FS Database Local SQL Statements", "query": "Event\n| where EventLog =~ 'Application'\n| where Source == 'MSSQL$MICROSOFT##WID' and EventID == '33205'\n| where RenderedDescription has_all ('database_name:AdfsConfigurationV4','schema_name:IdentityServerPolicy','object_name:ServiceSettings')\n| extend action_id = extract(\"action_id:([\\\\S]+)\", 1, RenderedDescription)\n| extend session_server_principal_name = extract(\"session_server_principal_name:([\\\\S]+)\", 1, RenderedDescription)\n| extend server_principal_name = extract(\"session_server_principal_name:([\\\\S]+)\", 1, RenderedDescription)\n| extend HostCustomEntity = Computer, AccountCustomEntity = split(server_principal_name, '\\\\')[1]\n", "attributes": {"description": "'This hunting query uses Application events from the \"MSSQL$MICROSOFT##WID\" provider to collect SQL statements run against an AD FS database (e.g Windows Internal Database (WID)).\nA threat actor might want to extract the AD FS data configuration settings with a SQL statement or modify it with an UPDATE SQL statement.\nIn order to use this query you need to create a server audit and database audit specification on your AD FS database.\nReference: https://github.com/Azure/SimuLand/blob/main/3_simulate_detect/credential-access/exportADFSTokenSigningCertificate.md\nReference: https://o365blog.com/post/adfs/\n'\n", "techniques": ["T1005"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Certutil-LOLBins.yaml", "query_name": "Certutil (LOLBins and LOLScripts)", "query": "Event\n//This query uses sysmon data depending on table name used this may need updataing\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend RenderedDescription = tostring(split(RenderedDescription, \":\")[0])\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| extend RuleName = column_ifexists(\"RuleName\", \"\"), TechniqueId = column_ifexists(\"TechniqueId\", \"\"),  TechniqueName = column_ifexists(\"TechniqueName\", \"\")\n| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName\n| where Image has \"certutil.exe\"\n// Uncomment the next line and add your commandLine Whitelisted/ignore terms.For example \"urlcache\"\n// | where CommandLine !contains (\"urlcache\") \n| extend HostCustomEntity = Computer, AccountCustomEntity = UserName\n", "attributes": {"description": "'This detection uses Sysmon telemetry to hunt Certutil activities'\n", "techniques": ["T1105"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/CommandsexecutedbyWMIonnewhosts-potentialImpacket.yaml", "query_name": "Commands executed by WMI on new hosts - potential Impacket", "query": "// Remove items from the artifacts list in order to expand hunting\n  let impacket_artifacts = dynamic([\"cmd.exe\", \"/c\", \"2>&1\", \"127.0.0.1\\\\ADMIN$\"]);\n  let starttime = todatetime('{{StartTimeISO}}');\n  let endtime = todatetime('{{EndTimeISO}}');\n  let lookback = starttime - 7d;\n  let wmi_hosts = (SecurityEvent\n  | where TimeGenerated between(lookback..starttime)\n  | where EventID == 4688\n  | where ParentProcessName endswith \"wmiprvse.exe\"\n  | where CommandLine has_all (impacket_artifacts)\n  | summarize by Computer);\n  SecurityEvent\n  | where TimeGenerated between(starttime..endtime)\n  | where EventID == 4688\n  | where Computer !in (wmi_hosts)\n  | where ParentProcessName endswith \"wmiprvse.exe\"\n  | where CommandLine has_all (impacket_artifacts)\n  | project-reorder TimeGenerated, Computer, CommandLine, Account\n", "attributes": {"description": "'This query looks for hosts where commands are run via WMI, where this has not happened in the preceding 7 days. \n  It also filters to command line arguments associated with Impacket wmiexec. These filters can be adjusted to broaden or narrow hunting as required.'\n", "techniques": ["T1047", "T1021.006"], "tactics": ["Execution", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Crashdumpdisabledonhost.yaml", "query_name": "Crash dump disabled on host", "query": "SecurityEvent\n  | where EventID == 4657\n  | parse ObjectName with \"\\\\REGISTRY\\\\\" KeyPrefix \"\\\\\" RegistryKey\n  | project-reorder RegistryKey\n  | where RegistryKey has \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\CrashControl\"\n  | where ObjectValueName =~ \"CrashDumpEnabled\"\n  | extend  RegistryValueData = iff (OperationType == \"%%1906\", OldValue, NewValue)\n  | where RegistryValueData == 0\n", "attributes": {"description": "'This detection looks the prevention of crash dumps being created. This can be used to limit reporting by malware, look for suspicious processes setting this registry key.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/cscript_summary.yaml", "query_name": "Cscript script daily summary breakdown", "query": "\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| project EventTime=TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, AccountDomain=SubjectDomainName,\nFileName=tostring(split(NewProcessName, '\\\\')[-1]),  ProcessCommandLine = CommandLine, \nInitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine=\"\",InitiatingProcessParentFileName=\"\";\nprocessEvents;\n};\n// Daily summary of cscript activity - extracting script name and parameters from commandline:\nProcessCreationEvents \n| where FileName =~ \"cscript.exe\"\n// remove commandline switches\n| project EventTime, ComputerName, AccountName, removeSwitches = replace(@\"/+[a-zA-Z0-9:]+\", \"\", ProcessCommandLine)\n// remove the leading cscript.exe process name \n| project EventTime, ComputerName, AccountName, CommandLine = trim(@\"[a-zA-Z0-9\\\\:\"\"]*cscript(.exe)?(\"\")?(\\s)+\", removeSwitches)\n// extract the script name:\n| project EventTime, ComputerName, AccountName, \n// handle case where script name is enclosed in \" characters or is not enclosed in quotes \nScriptName= iff(CommandLine startswith @\"\"\"\", \nextract(@\"([:\\\\a-zA-Z_\\-\\s0-9\\.()]+)(\"\"?)\", 0, CommandLine), \nextract(@\"([:\\\\a-zA-Z_\\-0-9\\.()]+)(\"\"?)\", 0, CommandLine)), CommandLine \n| project EventTime, ComputerName, AccountName, ScriptName=trim(@\"\"\"\", ScriptName) , ScriptNameLength=strlen(ScriptName), CommandLine \n// extract remainder of commandline as script parameters: \n| project EventTime, ComputerName, AccountName, ScriptName, ScriptParams = iff(ScriptNameLength < strlen(CommandLine), substring(CommandLine, ScriptNameLength +1), \"\")\n| summarize min(EventTime), count() by ComputerName, AccountName, ScriptName, ScriptParams\n| order by count_ asc nulls last \n| extend timestamp = min_EventTime, HostCustomEntity = ComputerName, AccountCustomEntity = AccountName", "attributes": {"description": "'breakdown of scripts running in the environment'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/CustomUserList_FailedLogons.yaml", "query_name": "VIP account more than 6 failed logons in 10", "query": "\n// Create DataTable with your own values, example below shows dummy usernames and domain\nlet List = datatable(VIPUser:string, Domain:string)[\"Bob\", \"Domain\", \"joe\", \"domain\", \"MATT\", \"DOMAIN\", \"administrator\", \"\"];\nlet timeframe = 10m;\nList\n| project TargetUserName = tolower(VIPUser), TargetDomainName = toupper(Domain)\n| join kind= rightsemi ( \nSecurityEvent \n| where TimeGenerated > ago(2*timeframe) \n| where EventID == \"4625\"\n| where AccountType == \"User\"\n) on TargetUserName, TargetDomainName\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FailedVIPLogons = count() by EventID, Activity, WorkstationName, Account, TargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, SubStatus\n| where FailedVIPLogons >= 6\n// map the most common ntstatus codes\n| extend StatusDesc = case(\nStatus =~ \"0x80090302\", \"SEC_E_UNSUPPORTED_FUNCTION\",\nStatus =~ \"0x80090308\", \"SEC_E_INVALID_TOKEN\",\nStatus =~ \"0x8009030E\", \"SEC_E_NO_CREDENTIALS\",\nStatus =~ \"0xC0000008\", \"STATUS_INVALID_HANDLE\",\nStatus =~ \"0xC0000017\", \"STATUS_NO_MEMORY\",\nStatus =~ \"0xC0000022\", \"STATUS_ACCESS_DENIED\",\nStatus =~ \"0xC0000034\", \"STATUS_OBJECT_NAME_NOT_FOUND\",\nStatus =~ \"0xC000005E\", \"STATUS_NO_LOGON_SERVERS\",\nStatus =~ \"0xC000006A\", \"STATUS_WRONG_PASSWORD\",\nStatus =~ \"0xC000006D\", \"STATUS_LOGON_FAILURE\",\nStatus =~ \"0xC000006E\", \"STATUS_ACCOUNT_RESTRICTION\",\nStatus =~ \"0xC0000073\", \"STATUS_NONE_MAPPED\",\nStatus =~ \"0xC00000FE\", \"STATUS_NO_SUCH_PACKAGE\",\nStatus =~ \"0xC000009A\", \"STATUS_INSUFFICIENT_RESOURCES\",\nStatus =~ \"0xC00000DC\", \"STATUS_INVALID_SERVER_STATE\",\nStatus =~ \"0xC0000106\", \"STATUS_NAME_TOO_LONG\",\nStatus =~ \"0xC000010B\", \"STATUS_INVALID_LOGON_TYPE\",\nStatus =~ \"0xC000015B\", \"STATUS_LOGON_TYPE_NOT_GRANTED\",\nStatus =~ \"0xC000018B\", \"STATUS_NO_TRUST_SAM_ACCOUNT\",\nStatus =~ \"0xC0000224\", \"STATUS_PASSWORD_MUST_CHANGE\",\nStatus =~ \"0xC0000234\", \"STATUS_ACCOUNT_LOCKED_OUT\",\nStatus =~ \"0xC00002EE\", \"STATUS_UNFINISHED_CONTEXT_DELETED\",\n\"See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55\"\n)\n| extend SubStatusDesc = case(\nSubStatus =~ \"0x80090325\", \"SEC_E_UNTRUSTED_ROOT\",\nSubStatus =~ \"0xC0000008\", \"STATUS_INVALID_HANDLE\",\nSubStatus =~ \"0xC0000022\", \"STATUS_ACCESS_DENIED\",\nSubStatus =~ \"0xC0000064\", \"STATUS_NO_SUCH_USER\",\nSubStatus =~ \"0xC000006A\", \"STATUS_WRONG_PASSWORD\",\nSubStatus =~ \"0xC000006D\", \"STATUS_LOGON_FAILURE\",\nSubStatus =~ \"0xC000006E\", \"STATUS_ACCOUNT_RESTRICTION\",\nSubStatus =~ \"0xC000006F\", \"STATUS_INVALID_LOGON_HOURS\",\nSubStatus =~ \"0xC0000070\", \"STATUS_INVALID_WORKSTATION\",\nSubStatus =~ \"0xC0000071\", \"STATUS_PASSWORD_EXPIRED\",\nSubStatus =~ \"0xC0000072\", \"STATUS_ACCOUNT_DISABLED\",\nSubStatus =~ \"0xC0000073\", \"STATUS_NONE_MAPPED\",\nSubStatus =~ \"0xC00000DC\", \"STATUS_INVALID_SERVER_STATE\",\nSubStatus =~ \"0xC0000133\", \"STATUS_TIME_DIFFERENCE_AT_DC\",\nSubStatus =~ \"0xC000018D\", \"STATUS_TRUSTED_RELATIONSHIP_FAILURE\",\nSubStatus =~ \"0xC0000193\", \"STATUS_ACCOUNT_EXPIRED\",\nSubStatus =~ \"0xC0000380\", \"STATUS_SMARTCARD_WRONG_PIN\",\nSubStatus =~ \"0xC0000381\", \"STATUS_SMARTCARD_CARD_BLOCKED\",\nSubStatus =~ \"0xC0000382\", \"STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED\",\nSubStatus =~ \"0xC0000383\", \"STATUS_SMARTCARD_NO_CARD\",\nSubStatus =~ \"0xC0000384\", \"STATUS_SMARTCARD_NO_KEY_CONTAINER\",\nSubStatus =~ \"0xC0000385\", \"STATUS_SMARTCARD_NO_CERTIFICATE\",\nSubStatus =~ \"0xC0000386\", \"STATUS_SMARTCARD_NO_KEYSET\",\nSubStatus =~ \"0xC0000387\", \"STATUS_SMARTCARD_IO_ERROR\",\nSubStatus =~ \"0xC0000388\", \"STATUS_DOWNGRADE_DETECTED\",\nSubStatus =~ \"0xC0000389\", \"STATUS_SMARTCARD_CERT_REVOKED\",\n\"See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55\"\n)\n| project StartTimeUtc, EndTimeUtc, FailedVIPLogons, EventID, Activity, WorkstationName, Account, TargetAccount, TargetUserName, TargetDomainName, LogonType, LogonTypeName, LogonProcessName, Status, StatusDesc, SubStatus, SubStatusDesc\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account\n", "attributes": {"description": "'VIP Account with more than 6 failed logon attempts in 10 minutes, include your own VIP list in the table below\n NTSTATUS codes - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/DecoyUserAccountAuthenticationAttempt.yaml", "query_name": "Decoy User Account Authentication Attempt", "query": "// Enter a reference list of decoy users (usernames) \"Case Sensitive\"\n   let DecoyUserNameList = dynamic ([\"DecoyUser1\",\"DecoyUser2\"]);\nSecurityEvent\n | where TargetUserName in (DecoyUserNameList)\n | where EventID in (4624,4625)\n | summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, TargetUserName, LogonTypeName, IpAddress\n", "attributes": {"description": "'The query detects authentication attempts from a decoy user account. \nA decoy user account is explicitly created and monitored to alert the SOC, indicating a malicious activity when the account is in use.\nRef: https://fidelissecurity.com/threatgeek/deception/best-deception-protection-for-active-directory'\n", "techniques": ["T1021"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Discorddownloadinvokedfromcmdline.yaml", "query_name": "Discord download invoked from cmd line", "query": "SecurityEvent\n| where EventID == 4688\n| where Process has_any (\"powershell.exe\", \"powershell_ise.exe\", \"cmd.exe\") or CommandLine has \"powershell\"\n| where CommandLine has_any (\"cdn.discordapp.com\", \"moc.ppadrocsid.ndc\")\n| project-reorder TimeGenerated, Computer, Account, Process, CommandLine\n", "attributes": {"description": "'This hunting query looks for hosts that have attempted to interact with the Discord CDN. This activity is not normally invoked from the command line and could indicate C2, exfiltration, or malware delivery activity.'\n", "techniques": ["T1204", "T1102", "T1567"], "tactics": ["Execution", "CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/enumeration_user_and_group.yaml", "query_name": "Enumeration of users and groups", "query": "\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,\nFileName=tostring(split(NewProcessName, '\\\\')[-1]),\nProcessCommandLine = CommandLine, \nFolderPath = \"\",\nInitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine=\"\",InitiatingProcessParentFileName=\"\";\nprocessEvents};\nProcessCreationEvents\n| where FileName == 'net.exe' and AccountName != \"\" and ProcessCommandLine !contains '\\\\'  and ProcessCommandLine !contains '/add' \n| where (ProcessCommandLine contains ' user ' or ProcessCommandLine contains ' group ') and (ProcessCommandLine endswith ' /do' or ProcessCommandLine endswith ' /domain') \n| extend Target = extract(\"(?i)[user|group] (\\\"*[a-zA-Z0-9-_ ]+\\\"*)\", 1, ProcessCommandLine) | filter Target  != '' \n| summarize minTimeGenerated=min(TimeGenerated), maxTimeGenerated=max(TimeGenerated), count() by AccountName, Target, ProcessCommandLine, ComputerName\n| project minTimeGenerated, maxTimeGenerated, count_, AccountName, Target, ProcessCommandLine, ComputerName\n| sort by AccountName, Target\n| extend timestamp = minTimeGenerated, AccountCustomEntity = AccountName, HostCustomEntity = ComputerName\n", "attributes": {"description": "'Finds attempts to list users or groups using the built-in Windows 'net' tool '\n", "techniques": NaN, "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/ExchangePowerShellSnapin.yaml", "query_name": "Exchange PowerShell Snapin Added", "query": "SecurityEvent\n| where EventID == 4688\n| where Process has_any (\"cmd.exe\", \"powershell.exe\", \"PowerShell_ISE.exe\")\n| where isnotempty(CommandLine)\n| where CommandLine contains \"Add-PSSnapin Microsoft.Exchange.Management.Powershell.Snapin\"\n| summarize FirstSeen = min(TimeGenerated), LastSeen = max(TimeGenerated) by Computer, Account, CommandLine \n| extend timestamp = FirstSeen, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'The Exchange Powershell Snapin was loaded on a host, this allows for a Exchange server management via PowerShell. Whilst this is a legitimate administrative tool it is abused by attackers to performs actions on a compromised Exchange server. Hunt for unusual activity related to this Snapin including it being added on new hosts or by new accounts.'\n", "techniques": ["T1119"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/ExternalIPaddressinCommandLine.yaml", "query_name": "External IP address in Command Line", "query": "// Add any expected range prefixes here\n  let exclusion_ranges = dynamic([\"\"]);\n  let ipv4_regex = \"([^ ](\\\\b25[0-5]|\\\\b2[0-4][0-9]|\\\\b[01]?[0-9][0-9]?)(\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|(\\\\b25[0-5]|\\\\b2[0-4][0-9]|\\\\b[01]?[0-9][0-9]?)(\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}[^ ])\";\n  let processes = dynamic([\"cmd.exe\", \"powershell\"]);\n  SecurityEvent\n  | where EventID == 4688\n  | where Process has_any(processes)\n  | extend IP = extract(ipv4_regex, 1, CommandLine)\n  | where isnotempty(IP)\n  | where not(ipv4_is_private(IP))\n  | where not(has_any_ipv4_prefix(IP, exclusion_ranges))\n  | summarize FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated), Hosts=makeset(Computer), Accounts=makeset(Account) by IP, CommandLine, Process\n  | extend Host_count = array_length(Hosts)\n  | sort by Host_count desc\n  | project-reorder Host_count, IP, Process, CommandLine\n", "attributes": {"description": "'This query looks for command lines that contain a public IP address. Attackers may use a hard coded IP for C2 or exfiltration.\n  This query can be filtered to exclude network prefixes that are known to be legitimate.'\n", "techniques": ["T1041", "T1071"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/FailedUserLogons.yaml", "query_name": "Summary of failed user logons by reason of failure", "query": "\nSecurityEvent\n| where AccountType == 'User' and EventID == 4625\n| extend Reason = case(\nSubStatus == '0xc000005e', 'No logon servers available to service the logon request',\nSubStatus == '0xc0000062', 'Account name is not properly formatted',\nSubStatus == '0xc0000064', 'Account name does not exist',\nSubStatus == '0xc000006a', 'Incorrect password',    SubStatus == '0xc000006d', 'Bad user name or password',\nSubStatus == '0xc000006f', 'User logon blocked by account restriction',\nSubStatus == '0xc000006f', 'User logon outside of restricted logon hours',\nSubStatus == '0xc0000070', 'User logon blocked by workstation restriction',\nSubStatus == '0xc0000071', 'Password has expired',\nSubStatus == '0xc0000072', 'Account is disabled',\nSubStatus == '0xc0000133', 'Clocks between DC and other computer too far out of sync',\nSubStatus == '0xc000015b', 'The user has not been granted the requested logon right at this machine',\nSubStatus == '0xc0000193', 'Account has expirated',\nSubStatus == '0xc0000224', 'User is required to change password at next logon',\nSubStatus == '0xc0000234', 'Account is currently locked out',\nstrcat('Unknown reason substatus: ', SubStatus))\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Reason\n| extend timestamp = StartTimeUtc\n", "attributes": {"description": "'A summary of failed logons can be used to infer lateral movement with the intention of discovering credentials and sensitive data'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/FakeComputerAccountAuthenticationAttempt.yaml", "query_name": "Fake computer account authentication attempt", "query": "SecurityEvent\n  | where TargetUserName endswith \"$\" and EventID in (4624,4625) and LogonTypeName in (2,7,10)\n  | summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, TargetUserName, TargetLogonId, LogonTypeName, IpAddress\n", "attributes": {"description": "'This query detects authentication attempt from a fake computer account(username ends with $). \nComputer accounts are normally not authenticating via interactive logon or remote desktop neither they are unlocking the systems.\nRef: https://blog.menasec.net/2019/02/threat-hunting-6-hiding-in-plain-sights.html'\n", "techniques": ["T1564"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/FileExecutionWithOneCharacterInTheName.yaml", "query_name": "Execution of File with One Character in the Name", "query": "Event\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID==1\n| parse EventData with * 'CommandLine\">' CommandLine \"<\" *\n| where CommandLine matches regex @'\\\\[a-zA-Z0-9]\\.[a-zA-Z0-9]{2,5}[\"]{1}'\n| parse EventData with * 'ProcessGuid\">' ProcessGuid \"<\" * 'Image\">' Image \"<\" * 'Description\">' Description \"<\" * 'OriginalFileName\">' OriginalFileName \"<\" * 'CommandLine\">' CommandLine \"<\" * 'CurrentDirectory\">' CurrentDirectory \"<\" * 'User\">' User \"<\" * 'LogonGuid\">' LogonGuid \"<\" * 'IntegrityLevel\">' IntegrityLevel \"<\" * 'Hashes\">' Hashes \"<\" * 'ParentProcessGuid\">' ParentProcessGuid \"<\" * 'ParentImage\">' ParentImage \"<\" * 'ParentCommandLine\">' ParentCommandLine \"<\" * 'ParentUser\">' ParentUser \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, User, ParentImage, ParentProcessGuid, ParentCommandLine, ParentUser, Image, ProcessGuid, CommandLine, Description, OriginalFileName, CurrentDirectory, Hashes\n", "attributes": {"description": "'This query detects execution of files with one character in the name (e.g, a.exe, 7.ps1, g.vbs etc.). \nNormally files that are executed have more characters in the name and this can indicate a malicious file.\nRef: https://www.mandiant.com/resources/tactics-techniques-procedures-associated-with-maze-ransomware-incidents'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/GroupAddedToPrivlegeGroup.yaml", "query_name": "Group added to Built in Domain Local or Global Group", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 7d;\n// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups\nlet WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\n// The SIDs for DnsAdmins and DnsUpdateProxy can be different than *-1102 and -*1103. Check these SIDs in your domain before running the query\nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$\";\nlet GroupAddition = SecurityEvent\n| where TimeGenerated between(lookback..starttime)\n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group\n| where EventID in (\"4728\", \"4732\", \"4756\")\n| where AccountType == \"User\" and MemberName == \"-\"\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| where TargetSid !in (\"S-1-5-32-555\")\n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n| project GroupAddTime = TimeGenerated, GroupAddEventID = EventID, GroupAddActivity = Activity, GroupAddComputer = Computer,\nGroupAddTargetUserName = TargetUserName, GroupAddTargetDomainName = TargetDomainName, GroupAddTargetSid = TargetSid,\nGroupAddSubjectUserName = SubjectUserName, GroupAddSubjectUserSid = SubjectUserSid, GroupSid = MemberSid, Account, Computer\n| extend AccountCustomEntity = Account, HostCustomEntity = Computer;\nlet GroupCreated = SecurityEvent\n| where TimeGenerated between(starttime..endtime)\n// 4727 - A security-enabled global group was created\n// 4731 - A security-enabled local group was created\n// 4754 - A security-enabled universal group was created\n| where EventID in (\"4727\", \"4731\", \"4754\")\n| where AccountType == \"User\"\n| project GroupCreateTime = TimeGenerated, GroupCreateEventID = EventID, GroupCreateActivity = Activity, GroupCreateComputer = Computer,\nGroupCreateTargetUserName = TargetUserName, GroupCreateTargetDomainName = TargetDomainName, GroupCreateSubjectUserName = SubjectUserName,\nGroupCreateSubjectDomainName = SubjectDomainName, GroupCreateSubjectUserSid = SubjectUserSid, GroupSid = TargetSid, Account, Computer;\nGroupCreated\n| join (\nGroupAddition\n) on GroupSid\n| extend timestamp = GroupCreateTime, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'A Group created in the last 7 days was added to a privileged built in domain local group or global group such as the\nEnterprise Admins, Cert Publishers or DnsAdmins.  Be sure to verify this is an expected addition'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/HostExportingMailboxAndRemovingExport.yaml", "query_name": "Host Exporting Mailbox and Removing Export", "query": "\n// Adjust the timeframe to change the window events need to occur within to alert\nlet timeframe = 1h;\nSecurityEvent\n| where EventID == 4688\n| where Process in~ (\"powershell.exe\", \"cmd.exe\")\n| where CommandLine contains 'New-MailboxExportRequest'\n| summarize by Computer, timekey = bin(TimeGenerated, timeframe), CommandLine, SubjectUserName\n| join kind=inner (SecurityEvent\n| where EventID == 4688\n| where Process in~ (\"powershell.exe\", \"cmd.exe\")\n| where CommandLine contains 'Remove-MailboxExportRequest'\n| summarize by Computer, timekey = bin(TimeGenerated, timeframe), CommandLine, SubjectUserName) on Computer, timekey, SubjectUserName\n| extend commands = pack_array(CommandLine1, CommandLine)\n| summarize by timekey, Computer, tostring(commands), SubjectUserName\n| project-reorder timekey, Computer, SubjectUserName, ['commands']\n| extend HostCustomEntity = Computer, AccountCustomEntity = SubjectUserName\n", "attributes": {"description": "'This hunting query looks for hosts exporting a mailbox from an on-prem Exchange server, followed by\nthat same host removing the export within a short time window. This pattern has been observed by attackers \nwhen exfiltrating emails from a target environment. A Mailbox export is unlikely to be a common command run so look for\nactivity from unexpected hosts and accounts.\nReference: https://www.volexity.com/blog/2020/12/14/dark-halo-leverages-solarwinds-compromise-to-breach-organizations/'\n", "techniques": ["T1114"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/HostsWithNewLogons.yaml", "query_name": "Hosts with new logons", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nlet LogonEvents=() {\nlet logonSuccess=SecurityEvent\n| where TimeGenerated between(ago(lookback)..endtime)\n| where EventID==4624\n| project TimeGenerated, ComputerName=Computer, AccountName=TargetUserName, AccountDomain=TargetDomainName, IpAddress, ActionType='Logon';\nlet logonFail=SecurityEvent\n| where TimeGenerated between(ago(lookback)..endtime)\n| where EventID==4625\n| project TimeGenerated, ComputerName=Computer, AccountName=TargetUserName, AccountDomain=TargetDomainName, IpAddress, ActionType='LogonFailure';\nlogonFail\n| union logonSuccess\n};\nLogonEvents\n| where TimeGenerated between(ago(lookback)..starttime)\n| where ActionType == 'Logon'\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by ComputerName, AccountName\n| join kind=leftanti (\nLogonEvents\n| where TimeGenerated between(starttime..endtime)\n| where ActionType == 'Logon'\n| summarize count() by ComputerName, AccountName\n) on ComputerName, AccountName\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), HostCount=dcount(ComputerName), HostSet=makeset(ComputerName, 10)  by AccountName, ComputerName\n| extend timestamp = StartTimeUtc, AccountCustomEntity = AccountName\n", "attributes": {"description": "'Shows new accounts that have logged onto a host for the first time - this may clearly be benign activity but an account\nlogging onto multiple hosts for the first time can also be used to look for evidence of that account being used to move\nlaterally across a network.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/hunt_LOLBins.yaml", "query_name": "Suspicious command line tokens in LolBins or LolScripts", "query": "let Bin = externaldata(Binary: string) [@\"https://raw.githubusercontent.com/sonnyakhere/LOLBAS_to_CSV/main/lolbas.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet ioc = dynamic([\"http\", \"ftp\"]);\nSecurityEvent\n| where EventID == 4688\n| where TimeGenerated between ( ago(1d) .. now() )\n// Looking to exclude system initiated activity\n| where SubjectUserName !endswith \"$\"\n| where SubjectUserName != \"SYSTEM\"\n| where ParentProcessName has_any (Bin)\n// Looking to only include details of those that have command line activities matching 1 or more of the defined IOCs\n| where ProcessCommandLine  has_any (ioc)\n| project TimeGenerated, SubjectMachineName, SubjectUserName, ParentProcessName, Process, ProcessCommandLine\n| sort by TimeGenerated asc\n", "attributes": {"description": "'This query identifies Microsoft-signed Binaries and Scripts that are not system initiated. This technique is commonly used in phishing attacks'\n", "techniques": ["T1218"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Invoke-PowerShellTcpOneLine.yaml", "query_name": "Invoke-PowerShellTcpOneLine Usage.", "query": "SecurityEvent\n| where EventID == 4688\n| where Process has_any (\"powershell.exe\", \"PowerShell_ISE.exe\", \"cmd.exe\")\n| where CommandLine has \"$client = New-Object System.Net.Sockets.TCPClient\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress\n", "attributes": {"description": "'Invoke-PowerShellTcpOneLine is a PowerShell script to create a simple and small reverse shell. It can be abused by attackers to exfiltrate data. This query looks for command line activity similar to Invoke-PowerShellTcpOneLine.'\n", "techniques": ["T1011"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/LargeScaleMalwareDeploymentGPOScheduledTask.yaml", "query_name": "Large Scale Malware Deployment via GPO Scheduled Task Modification", "query": "SecurityEvent\n   | where EventID == 5145 \n   | where ShareName == \"\\\\\\\\*\\\\SYSVOL\" and RelativeTargetName endswith \"ScheduledTasks.xml\" and AccessList contains \"%%4417\"\n   | summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, SubjectDomainName, SubjectUserName, SubjectLogonId, ShareName, RelativeTargetName, AccessList, IpAddress\n", "attributes": {"description": "'This query detects lateral movement using GPO scheduled task usually used to deploy ransomware at scale.\n It monitors whether a scheduled task is modified within the Sysvol folder in GPO.\n Ref: https://bogusecurity.com/2019/12/26/persistence-and-execution-at-scale-via-gpo-scheduled-task/'\n", "techniques": ["T1484"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Least_Common_Parent_Child_Process.yaml", "query_name": "Least Common Parent And Child Process Pairs", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 7d;\nlet Allowlist = dynamic (['foo.exe', 'baz.exe']);\nlet Sensitivity = 5;\nSecurityEvent\n| where TimeGenerated between(lookback..endtime)\n| where EventID == 4688 and isnotnull(ParentProcessName)\n| extend ProcArray = split(NewProcessName, '\\\\'), ParentProcArray = split(ParentProcessName, '\\\\')\n// ProcArrayLength is Folder Depth\n| extend ProcArrayLength = arraylength(ProcArray), ParentProcArrayLength = arraylength(ParentProcArray)\n| extend LastIndex = ProcArrayLength - 1, ParentLastIndex = ParentProcArrayLength - 1\n| extend Proc = ProcArray[LastIndex], ParentProc = ParentProcArray[ParentLastIndex]\n| where Proc !in (Allowlist)\n| extend ParentChildPair = strcat(ParentProc , ' > ', Proc)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by ParentChildPair\n| where TimesSeen < Sensitivity\n| extend timestamp = StartTimeUtc\n", "attributes": {"description": "'Looks across your environment for least common Parent/Child process combinations.\nWill possibly find some malicious activity disguised as well known process names.\nBy ZanCo'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Least_Common_Process_Command_Lines.yaml", "query_name": "Least Common Processes by Command Line", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 7d;\nlet Allowlist = dynamic (['foo.exe', 'baz.exe']);\nlet Sensitivity = 5;\nSecurityEvent\n| where TimeGenerated between(lookback..endtime)\n| where EventID == 4688 and NewProcessName !endswith 'conhost.exe'\n| extend ProcArray = split(NewProcessName, '\\\\')\n// ProcArrayLength is Folder Depth\n| extend ProcArrayLength = arraylength(ProcArray)\n| extend LastIndex = ProcArrayLength - 1\n| extend Proc = ProcArray[LastIndex]\n| where Proc !in (Allowlist)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by CommandLine\n| where TimesSeen < Sensitivity\n| extend timestamp = StartTimeUtc\n", "attributes": {"description": "'Looks across your environment for least common Process Command Lines, may be noisy and require allowlisting.  By ZanCo'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Least_Common_Process_With_Depth.yaml", "query_name": "Least Common Processes Including Folder Depth", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 7d;\nlet Allowlist = dynamic (['foo.exe', 'baz.exe']);\nlet Sensitivity = 15;\nSecurityEvent\n| where TimeGenerated between(lookback..endtime)\n| where EventID == 4688\n| extend ProcArray = split(NewProcessName, '\\\\')\n// ProcArrayLength is Folder Depth\n| extend ProcArrayLength = arraylength(ProcArray)\n| extend LastIndex = ProcArrayLength - 1\n| extend Proc = ProcArray[LastIndex]\n| where Proc !in (Allowlist)\n// ProcArray[0] is the proc's Drive\n| extend DriveDepthProc = strcat(ProcArray[0], '-', ProcArrayLength, '-', Proc)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), TimesSeen = count(), HostCount = dcount(Computer), Hosts = makeset(Computer), UserCount = dcount(SubjectUserName), Users = makeset(SubjectUserName) by DriveDepthProc\n| where TimesSeen < Sensitivity\n| extend timestamp = StartTimeUtc\n", "attributes": {"description": "'Looks across your environment for least common Process Command Lines, may be noisy and require allowlisting.  By ZanCo'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/masquerading_files.yaml", "query_name": "Masquerading files", "query": "\nSecurityEvent\n| where NewProcessName endswith \"\\\\svchost.exe\"\n| where SubjectUserSid !in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\")\n| where NewProcessName !contains \":\\\\Windows\\\\System32\"\n| where NewProcessName !contains \":\\\\Windows\\\\Syswow64\"\n| summarize minTimeGenerated=min(TimeGenerated), maxTimeGenerated=max(TimeGenerated), count() by Computer, SubjectUserName, NewProcessName, CommandLine, Account\n| project minTimeGenerated , maxTimeGenerated , count_ , Computer , SubjectUserName , NewProcessName , CommandLine, Account \n| extend timestamp = minTimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n", "attributes": {"description": "'Malware writers often use windows system process names for their malicious process names to make them blend \nin with other legitimate commands that the Windows system executes.\nAn analyst can create a simple query looking for a process named svchost.exe. \nIt is recommended to filter out well-known security identifiers (SIDs) that are used to launch the legitimate svchost.exe process. \nThe query also filters out the legitimate locations from which svchost.exe is launched.'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/MSRPRN_Printer_Bug_Exploitation.yaml", "query_name": "Potential Exploitation of MS-RPRN printer bug", "query": "// Enter a reference list of hostnames for your DC servers\n// let DCServersList = dynamic ([\"DC01.domain.local\",\"DC02.domain.local\"]);\n// Enter a reference list of IP addresses for your unconstrained delegation servers\n// let UnconstrainedServersIPList = dynamic ([\"10.1.0.7\",\"10.1.0.45\"]);\nSecurityEvent\n// | where Computer in (DCServersList)\n// | where IpAddress  in (UnconstrainedServersIPList)\n| where EventID == 5145 and ShareName == \"\\\\\\\\*\\\\IPC$\" and RelativeTargetName == \"spoolss\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Computer, SubjectUserName, IpAddress, ShareName, RelativeTargetName, Type, SubjectUserSid\n", "attributes": {"description": "'This query detects potential attempts to remotely access to the print spooler service on Active Directory Domain Controllers which could indicate an exploitation of MS-RPRN printer bug from a server that is configured with unconstrained delegation.\n This query searches for the event id 5145 on Domain Controllers where the ShareName is \"\\\\\\*\\IPC$\" and the RelativeTargetName is \"spoolss\".\n Ref: https://medium.com/@riccardo.ancarani94/exploiting-unconstrained-delegation-a81eabbd6976#:~:text=The%20exploitation%20of%20unconstrained%20delegation,system%20with%20the%20delegation%20enabled.&text=but%20before%20doing%20that%20we,listen%20for%20incoming%20authenticated%20connections.'\n", "techniques": ["T1134"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/MultipleExplicitCredentialUsage4648Events.yaml", "query_name": "Multiple explicit credential usage - 4648 events", "query": "\nlet WellKnownLocalSIDs = \"S-1-5-[0-9][0-9]$\";\nlet protocols = dynamic(['cifs', 'ldap', 'RPCSS', 'host' , 'HTTP', 'RestrictedKrbHost', 'TERMSRV', 'msomsdksvc', 'mssqlsvc']);\nSecurityEvent\n| where EventID == 4648\n| where SubjectUserSid != 'S-1-0-0' // this is the Nobody SID which really means No security principal was included.\n| where not(SubjectUserSid matches regex WellKnownLocalSIDs) //excluding system account/service account as this is generally normal\n| where TargetInfo has '/' //looking for only items that indicate an interesting protocol is included\n| where Computer !has tostring(split(TargetServerName,'$')[0])\n| where TargetAccount !~ tostring(split(SubjectAccount,'$')[0])\n| extend TargetInfoProtocol = tolower(split(TargetInfo, '/')[0]), TargetInfoMachine = toupper(split(TargetInfo, '/')[1])\n| extend TargetAccount = tolower(TargetAccount), SubjectAccount = tolower(SubjectAccount)\n| extend UncommonProtocol = case(not(TargetInfoProtocol has_any (protocols)), TargetInfoProtocol, 'NotApplicable')\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AccountsUsedCount = dcount(TargetAccount), AccountsUsed = make_set(TargetAccount), TargetMachineCount = dcount(TargetInfoMachine), \nTargetMachines = make_set(TargetInfoMachine), TargetProtocols = dcount(TargetInfoProtocol), Protocols = make_set(TargetInfoProtocol), Processes = make_set(Process) by Computer, SubjectAccount, UncommonProtocol\n| where TargetMachineCount > 1 or UncommonProtocol != 'NotApplicable'\n| extend ProtocolCount = array_length(Protocols)\n| extend ProtocolScore = case(\n  Protocols has 'rpcss' and Protocols has 'host' and Protocols has 'cifs', 10, //observed in Solorigate and depending on which are used together the higher the score\n  Protocols has 'rpcss' and Protocols has 'host', 5,\n  Protocols has 'rpcss' and Protocols has 'cifs', 5,\n  Protocols has 'host' and Protocols has 'cifs', 5,\n  Protocols has 'ldap' or Protocols has 'rpcss' or Protocols has 'host' or Protocols has 'cifs', 1, //ldap is more commonly seen in general, this was also seen with Solorigate but not usually to the same machines as the others above\n  UncommonProtocol != 'NotApplicable', 3,\n  0 //other protocols may be of interest, but in relation to observations for enumeration/execution in Solorigate they receive 0\n)\n| extend Score = ProtocolScore + ProtocolCount + AccountsUsedCount\n| where Score >= 9 or (UncommonProtocol != 'NotApplicable' and Score >= 4) // Score must be 9 or better as this will include 5 points for atleast 2 of the interesting protocols + the count of protocols (min 2) + the number of accounts used for execution (min 2) = min of 9 OR score must be 4 or greater for an uncommon protocol\n| extend TimePeriod = EndTime - StartTime //This identifies the time between start and finish for the use of the explicit credentials, shorter time period may indicate scripted executions\n| project-away UncommonProtocol\n| extend timestamp = StartTime, AccountCustomEntity = SubjectAccount, HostCustomEntity = Computer\n| order by Score desc\n  \n", "attributes": {"description": "'Based on recent investigations related to Solorigate, adversaries were seen to obtain and abuse credentials of multiple accounts \n to connect to multiple machines. This query uses Security Event 4648 (A logon was attempted using explicit credentials) \n to find machines in an environment, from where different accounts were used to connect to multiple hosts. Scoring is done based on \n protocols seen in Solorigate. While this mentions Solorigate, this hunting query can be used to identify this type of pattern for \n any attacker.\n Reference - https://docs.microsoft.com/windows/security/threat-protection/auditing/event-4648'\n", "techniques": ["T1078"], "tactics": ["Discovery", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/NewChildProcessOfW3WP.yaml", "query_name": "New Child Process of W3WP.exe", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet known_procs = (\nSecurityEvent\n| where TimeGenerated between(lookback..starttime)\n| where EventID == 4688\n| where ParentProcessName hassuffix \"w3wp.exe\"\n| extend ProcessHost = strcat(Process, \"-\", Computer)\n| summarize by ProcessHost);\nSecurityEvent\n| where TimeGenerated between(starttime..endtime)\n| where EventID == 4688\n| where ParentProcessName hassuffix \"w3wp.exe\"\n| extend ProcessHost = strcat(Process, \"-\", Computer)\n| where ProcessHost !in (known_procs)\n| project-reorder TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n", "attributes": {"description": "'This Hunting Query looks for child processes of w3wp.exe that have not been seen as a child process on that host within the last 14 days.\nw3wp.exe running suspicious processes such as 'cmd.exe /c echo', 'certutil.exe', or 'powershell.exe' that result in the creation of script files in web -accessible folders is a rare event and is, thus, typically a strong sign of web server compromise and web shell installation.\nRef: https://www.microsoft.com/security/blog/2021/02/11/web-shell-attacks-continue-to-rise/'\n", "techniques": ["T1203"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/new_processes.yaml", "query_name": "New processes observed in last 24 hours", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where TimeGenerated between(lookback..endtime)\n| where EventID==4688\n| project TimeGenerated, Computer, Account, FileName=tostring(split(NewProcessName, @'')[(-1)]), NewProcessName, ProcessCommandLine = CommandLine, InitiatingProcessFileName=ParentProcessName;\nprocessEvents};\nProcessCreationEvents\n| where TimeGenerated between(lookback..starttime)\n| summarize HostCount=dcount(Computer) by FileName\n| join kind=rightanti (\n    ProcessCreationEvents\n    | where TimeGenerated between(starttime..endtime)\n    | summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), Computers = makeset(Computer) , HostCount=dcount(Computer) by Account, NewProcessName, FileName, ProcessCommandLine, InitiatingProcessFileName\n) on FileName\n| extend timestamp = StartTime, AccountCustomEntity = Account\n", "attributes": {"description": "'These new processes could be benign new programs installed on hosts; however, especially in normally stable environments,\nthese new processes could provide an indication of an unauthorized/malicious binary that has been installed and run.\nReviewing the wider context of the logon sessions in which these binaries ran can provide a good starting point for identifying possible attacks.'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/NishangReverseTCPShellBase64.yaml", "query_name": "Nishang Reverse TCP Shell in Base64", "query": "SecurityEvent\n| where EventID == 4688\n| where Process in(\"powershell.exe\",\"powershell_ise.exe\") and CommandLine contains \"-e\" \n| mvexpand SS = split(CommandLine, \" \") \n| where SS matches regex \"[A-Za-z0-9+/]{50,}[=]{0,2}\" \n| extend DecodeString = base64_decodestring(tostring(SS)) \n| extend FinalString = replace(\"\\\\0\", \"\", DecodeString) \n| where FinalString has \"tcpclient\" and FinalString contains \"$\" and (FinalString contains \"invoke\" or FinalString contains \"iex\") \n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'Looks for Base64-encoded commands associated with the Nishang reverse TCP shell.\nRef: https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1'\n", "techniques": ["T1011"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/persistence_create_account.yaml", "query_name": "Summary of users created using uncommon/undocumented commandline switches", "query": "\nSecurityEvent\n| where EventID==4688\n| project TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName, \n    AccountDomain=SubjectDomainName, FileName=tostring(split(NewProcessName, '\\\\')[-1]), \n    ProcessCommandLine = CommandLine, \n    FolderPath = \"\", InitiatingProcessFileName=ParentProcessName,\n    InitiatingProcessCommandLine=\"\",InitiatingProcessParentFileName=\"\"\n| where FileName in~ (\"net.exe\", \"net1.exe\")\n| parse kind=regex flags=iU ProcessCommandLine with * \"user \" CreatedUser \" \" * \"/ad\"\n| where not(FileName =~ \"net1.exe\" and InitiatingProcessFileName =~ \"net.exe\" and replace(\"net\", \"net1\", InitiatingProcessCommandLine) =~ ProcessCommandLine)\n| extend CreatedOnLocalMachine=(ProcessCommandLine !contains \"/do\")\n| where ProcessCommandLine contains \"/add\" or (CreatedOnLocalMachine == 0 and ProcessCommandLine !contains \"/domain\")\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), MachineCount=dcount(ComputerName) by CreatedUser, CreatedOnLocalMachine, InitiatingProcessFileName, FileName, ProcessCommandLine, InitiatingProcessCommandLine\n| extend timestamp = StartTimeUtc, AccountCustomEntity = CreatedUser\n", "attributes": {"description": "'Summarizes uses of uncommon & undocumented commandline switches to create persistence\nUser accounts may be created to achieve persistence on a machine.\nRead more here: https://attack.mitre.org/wiki/Technique/T1136\nQuery for users being created using \"net user\" command\n\"net user\" commands are noisy, so needs to be joined with another signal -\ne.g. in this example we look for some undocumented variations (e.g. /ad instead of /add)'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/PotentialImpacketExecution.yaml", "query_name": "Potential Impacket Execution", "query": "(union isfuzzy=true\n(SecurityEvent\n| where EventID == '5145'\n| where RelativeTargetName has 'SYSTEM32' and RelativeTargetName endswith @\".tmp\"\n| where ShareName has \"\\\\\\\\*\\\\ADMIN$\"\n),\n(WindowsEvent\n| where EventID == '5145' \n| extend RelativeTargetName= tostring(EventData.RelativeTargetName)\n| extend ShareName= tostring(EventData.ShareName)\n| where RelativeTargetName has 'SYSTEM32' and RelativeTargetName endswith @\".tmp\"\n| where ShareName has \"\\\\\\\\*\\\\ADMIN$\"\n| extend Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n)\n)\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'This hunting query identifies execution of Impacket tool. Impacket is a popular tool used by attackers for remote service execution, Kerberos manipulation and Windows credential dumping.\n Refrence: https://twitter.com/SBousseaden/status/1286750095296335883'\n", "techniques": ["T1003"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/PotentialLocalExploitationForPrivilegeEscalation.yaml", "query_name": "Potential Local Exploitation for Privilege Escalation", "query": "Event\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID==1\n| parse EventData with * 'IntegrityLevel\">' IntegrityLevel \"<\" * 'ParentUser\">' ParentUser \"<\" *\n| where IntegrityLevel in (\"System\") and not(ParentUser in (\"NT AUTHORITY\\\\NETWORK SERVICE\",\"-\",\"NT AUTHORITY\\\\SYSTEM\",\"NT AUTHORITY\\\\LOCAL SERVICE\")) \n| parse EventData with * 'ProcessGuid\">' ProcessGuid \"<\" * 'Image\">' Image \"<\" * 'CommandLine\">' CommandLine \"<\" * 'ParentProcessGuid\">' ParentProcessGuid \"<\" * 'ParentImage\">' ParentImage \"<\" * 'ParentCommandLine\">' ParentCommandLine \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, ParentUser, ParentImage, ParentCommandLine, ParentProcessGuid, IntegrityLevel, UserName, Image, CommandLine, ProcessGuid\n", "attributes": {"description": "'This query detects a process that runs under SYSTEM user's security context and was spawned by a process that was running under a lower security context indicating an exploitation for privilege escalation.\nRef: https://attack.mitre.org/techniques/T1068/'\n", "techniques": ["T1068"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/PotentialProcessDoppelganging.yaml", "query_name": "Potential Process Doppelganging", "query": "// Enter a reference list of trusted processes\nlet TrustedProcessList = dynamic ([ \"c:\\\\windows\\\\system32\\\\svchost.exe\",\"c:\\\\windows\\\\system32\\\\lsass.exe\",\"c:\\\\windows\\\\servicing\\\\TrustedInstaller.exe\",\"c:\\\\windows\\\\system32\\\\poqexec.exe\",\"TiWorker.exe\",\"C:\\\\Windows\\\\System32\\\\inetsrv\\\\appcmd.exe\",\"C:\\\\Windows\\\\System32\\\\inetsrv\\\\InetMgr.exe\",\"C:\\\\Windows\\\\System32\\\\wsmprovhost.exe\",\"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\2019\\Enterprise\\\\Common7\\\\IDE\\\\devenv.exe\"]);\nSecurityEvent\n| where EventID == 4985 and not (ProcessName has_any (TrustedProcessList)) and SubjectLogonId !=\"0x3e7\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, ProcessName, SubjectUserName\n", "attributes": {"description": "'This query detects Process Doppelganging, a technique that calls several APIs related to NTFS transactions which allow to substitute the PE content before the process is even created.\nRef: https://attack.mitre.org/techniques/T1055/013/'\n", "techniques": ["T1055.013"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/PowerCatDownload.yaml", "query_name": "Powercat Download", "query": "SecurityEvent\n| where EventID == 4688\n| where Process has_any (\"cmd.exe\", \"powershell.exe\", \"PowerShell_ISE.exe\")\n| where CommandLine hassuffix \"powercat.ps1\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'Powercat is a PowerShell implementation of netcat. Whilst it can be used as a legitimate administrative tool it can be abused by attackers to exfiltrate data. This query looks for command line activity downloading PowerCat.'\n", "techniques": ["T1011"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/powershell_downloads.yaml", "query_name": "PowerShell downloads", "query": "\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n| project  TimeGenerated, ComputerName=Computer,AccountName=SubjectUserName,        AccountDomain=SubjectDomainName,\n  FileName=tostring(split(NewProcessName, '\\\\')[-1]),\nProcessCommandLine = CommandLine, \nInitiatingProcessFileName=ParentProcessName,InitiatingProcessCommandLine=\"\",InitiatingProcessParentFileName=\"\";\nprocessEvents};\nProcessCreationEvents\n| where FileName in~ (\"powershell.exe\", \"powershell_ise.exe\",\"pwsh.exe\")\n| where ProcessCommandLine has \"Net.WebClient\"\n   or ProcessCommandLine has \"DownloadFile\"\n   or ProcessCommandLine has \"Invoke-WebRequest\"\n   or ProcessCommandLine has \"Invoke-Shellcode\"\n   or ProcessCommandLine contains \"http:\"\n| project TimeGenerated, ComputerName, AccountName, InitiatingProcessFileName, FileName, ProcessCommandLine\n| top 100 by TimeGenerated\n| extend timestamp = TimeGenerated, HostCustomEntity = ComputerName, AccountCustomEntity = AccountName\n", "attributes": {"description": "'Finds PowerShell execution events that could involve a download'\n", "techniques": NaN, "tactics": ["Execution", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/powershell_newencodedscipts.yaml", "query_name": "New PowerShell scripts encoded on the commandline", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*3);\nlet midlookback = totimespan((endtime-starttime)*2);\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where TimeGenerated between(ago(lookback)..endtime)\n| where EventID==4688\n| where NewProcessName has_any (\"powershell.exe\",\"pwsh.exe\")\n| project TimeGenerated, Computer, Account, NewProcessName, FileName=tostring(split(NewProcessName, '\\\\')[-1]), ProcessCommandLine = CommandLine, ParentProcessName;\nprocessEvents};\nlet encodedPSScripts =\nProcessCreationEvents\n| where TimeGenerated between(ago(midlookback)..starttime)\n| where FileName in~ (\"powershell.exe\",\"pwsh.exe\")\n| where ProcessCommandLine has \"-encodedCommand\";\nencodedPSScripts\n| where TimeGenerated between(starttime..endtime)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by Computer, Account, NewProcessName, FileName, ProcessCommandLine, ParentProcessName\n| parse kind=regex flags=i ProcessCommandLine with * \"-EncodedCommand \" encodedCommand\n| extend decodedCommand = base64_decode_tostring(substring(encodedCommand, 0, strlen(encodedCommand) - (strlen(encodedCommand) %8)))\n| join kind=leftanti (\n  encodedPSScripts\n  | where TimeGenerated between(ago(lookback)..starttime)\n  | summarize count() by ProcessCommandLine\n  | parse kind=regex flags=i ProcessCommandLine with * \"-EncodedCommand \" encodedCommand\n  | extend decodedCommand = base64_decode_tostring(substring(encodedCommand, 0, strlen(encodedCommand) - (strlen(encodedCommand) %8)))\n) on encodedCommand, decodedCommand\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'Identify and decode new encoded powershell scripts this week versus previous 14 days'\n", "techniques": NaN, "tactics": ["Execution", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/ProcessEntropy.yaml", "query_name": "Entropy for Processes for a given Host", "query": "\n// exclude when over # of machines have the process\nlet excludeThreshold = 10;\n// exclude when more than percent (default 10%)\nlet ratioHighCount = 0.1;\n// exclude when less than percent (default 3%)\nlet ratioMidCount = 0.03;\n// Process count limit in one day per machine, perf improvement (default every 20 minutes for 24 hours - 3*24 = 72)\nlet procLimit = 3*24;\n// Decrease possibility of hitting memory limit by removing high process count items across all machines (default every 10 minutes for 24 hours - 6*24 = 144)\nlet maxLimit = 6*24;\nlet removeHigh = SecurityEvent \n| where TimeGenerated >= ago(1d)\n| where EventID == 4688 | summarize count() by NewProcessName = tolower(NewProcessName) | where count_ > maxLimit\n| summarize make_set(NewProcessName);\nlet SecEvents = SecurityEvent\n| where TimeGenerated >= ago(1d)\n| where EventID == 4688 | where tolower(NewProcessName) !in~ (removeHigh)\n// removing common items that may still show up in small environments, add here if you have additional exclusions \n| where NewProcessName !has ':\\\\Windows\\\\System32\\\\conhost.exe' and ParentProcessName !has ':\\\\Windows\\\\System32\\\\conhost.exe' \n| where ParentProcessName !has ':\\\\Windows\\\\System32\\\\wuauclt.exe' and NewProcessName !has':\\\\Windows\\\\System32\\\\wuauclt.exe' and NewProcessName !startswith 'C:\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\AM_Delta_Patch_' \n| where ParentProcessName !has ':\\\\WindowsAzure\\\\GuestAgent_' and NewProcessName !has ':\\\\WindowsAzure\\\\GuestAgent_' \n| where ParentProcessName !has ':\\\\WindowsAzure\\\\WindowsAzureNetAgent_' and NewProcessName !has ':\\\\WindowsAzure\\\\WindowsAzureNetAgent_' \n| where ParentProcessName !has ':\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\' and NewProcessName !has \"\\\\Windows Defender Advanced Threat Protection\\\\SenseCncProxy.exe\" and NewProcessName !has \"\\\\Windows Defender Advanced Threat Protection\\\\SenseIR.exe.exe\" \n| where NewProcessName !has ':\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\' \n| where NewProcessName !has ':\\\\Windows\\\\Microsoft.NET\\\\Framework' and not(NewProcessName endswith '\\\\ngentask.exe' or NewProcessName endswith '\\\\ngen.exe') \n| where ParentProcessName !has ':\\\\Windows\\\\Microsoft.NET\\\\Framework' and not(ParentProcessName endswith '\\\\ngentask.exe' or ParentProcessName endswith '\\\\ngen.exe') \n| where NewProcessName !has ':\\\\Windows\\\\System32\\\\taskhostw.exe' and ParentProcessName !has ':\\\\Windows\\\\System32\\\\taskhostw.exe' \n| where ParentProcessName !has ':\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\' and not(NewProcessName endswith '\\\\MpSigStub.exe') \n| where NewProcessName !has ':\\\\Program Files\\\\Microsoft Monitoring Agent\\\\Agent\\\\Health Service State\\\\' and ParentProcessName !has ':\\\\Program Files\\\\Microsoft Monitoring Agent\\\\Agent\\\\MonitoringHost.exe' \n| where NewProcessName !has ':\\\\Windows\\\\servicing\\\\trustedinstaller.exe' \n| where ParentProcessName !has ':\\\\Program Files\\\\Microsoft Dependency Agent\\\\bin\\\\MicrosoftDependencyAgent.exe' \n| where ParentProcessName !has ':\\\\Program Files (x86)\\\\Microsoft\\\\EdgeUpdate\\\\MicrosoftEdgeUpdate.exe'\n| project TimeGenerated, EventID, Computer, SubjectUserSid, Account, AccountType, Process, NewProcessName, CommandLine, ParentProcessName, _ResourceId, SourceComputerId;\nlet Exclude = SecEvents \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ExcludeCompCount = dcount(Computer), ExcludeProcCount = count() by Process \n// Removing general limit for noise in one day \n| extend timediff = iff(datetime_diff('day', EndTime, StartTime) > 0, datetime_diff('day', EndTime, StartTime), 1) \n// Default exclude of 48 (2 per hour) or more executions in 24 hours on a given machine \n| where ExcludeProcCount > procLimit*timediff \n// Removing noisy processes for an environment, adjust as needed \n| extend compRatio = ExcludeCompCount/toreal(ExcludeProcCount) \n| where compRatio == 0 or (ExcludeCompCount > excludeThreshold and compRatio < ratioHighCount) or (ExcludeCompCount between (2 .. excludeThreshold) and compRatio < ratioMidCount);\nlet AllSecEvents =  \nSecEvents | project Computer, Process \n| join kind= leftanti (  \nSecEvents \n// Removing general limit for noise in one day \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), procCount = count() by Computer, Process \n| extend timediff = iff(datetime_diff('day', EndTime, StartTime) > 0, datetime_diff('day', EndTime, StartTime), 1) \n// Default exclude 48 (2 per hour) or more executions in 24 hours on a given machine to remove them from overall comparison list \n| where procCount > procLimit*timediff \n) on Computer, Process \n| project Computer, Process;\n// Removing noisy process from full list \nlet Include = materialize(AllSecEvents \n| join kind= leftanti ( \nExclude \n) on Process);\n// Identifying prevalence for a given process in the environment \nlet DCwPC = materialize(Include \n| summarize DistinctHostsProcessCount = dcount(Computer) by Process \n| join kind=inner ( \nInclude \n) on Process \n| distinct Computer, Process, DistinctHostsProcessCount);\n// Getting the Total process count on each host to use as the denominator in the entropy calc \nlet AHPC = materialize(Include \n| summarize AllHostsProcessCount = count() by Computer \n| join kind=inner ( \nInclude \n) on Computer \n| distinct Computer, Process, AllHostsProcessCount \n//Getting a decimal value for later computation \n| extend AHPCValue = todecimal(AllHostsProcessCount));\n// Need the count of each class in my bucket or also said as count of ProcName(Class) per Host(Bucket) for use in the entropy calc \nlet PCoH = Include \n| summarize ProcessCountOnHost = count() by Computer, Process \n| join kind=inner ( \nInclude \n) on Computer,Process \n| distinct Computer, Process, ProcessCountOnHost \n//Getting a decimal value for later computation \n| extend PCoHValue = todecimal(ProcessCountOnHost); \nlet Combined = DCwPC \n| join ( \nAHPC \n) on Computer, Process \n| join ( \nPCoH \n) on Computer, Process;\nlet Results = Combined \n// Entropy calculation \n| extend ProcessEntropy = -log2(PCoHValue/AHPCValue)*(PCoHValue/AHPCValue) \n// Calculating Weight, see details in description \n| extend Weight = toreal(ProcessEntropy*ProcessCountOnHost*DistinctHostsProcessCount) \n// Remove or increase value to see processes with low entropy, meaning more common. \n| where Weight <= 100\n| project Computer, Process, Weight , ProcessEntropy, AllHostsProcessCount, ProcessCountOnHost, DistinctHostsProcessCount; \n// Join back full entry \nResults \n| join kind= inner ( \nSecEvents\n| project TimeGenerated, EventID, Computer, SubjectUserSid, Account, AccountType, Process, NewProcessName, CommandLine, ParentProcessName, _ResourceId, SourceComputerId \n) on Computer, Process \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ResultCount = count() by EventID, Computer, SubjectUserSid, Account, AccountType, Weight, ProcessEntropy,  \nProcess, NewProcessName, CommandLine, ParentProcessName, AllHostsProcessCount, ProcessCountOnHost, DistinctHostsProcessCount, _ResourceId, SourceComputerId\n| project-reorder StartTime, EndTime, ResultCount, EventID, Computer, SubjectUserSid, Account, AccountType, Weight, ProcessEntropy,  \nProcess, NewProcessName, CommandLine, ParentProcessName, AllHostsProcessCount, ProcessCountOnHost, DistinctHostsProcessCount, _ResourceId, SourceComputerId\n| sort by Weight asc, ProcessEntropy asc, NewProcessName asc \n| extend timestamp = StartTime, HostCustomEntity = Computer, AccountCustomEntity = Account\n", "attributes": {"description": "'Entropy calculation used to help identify Hosts where they have a high variety of processes(a high entropy process list on a given Host over time).\nThis helps us identify rare processes on a given Host. Rare here means a process shows up on the Host relatively few times in the the last 7days.\nThe Weight is calculated based on the Entropy, Process Count and Distinct Hosts with that Process. The lower the Weight/ProcessEntropy the, more interesting.\nThe Weight calculation increases the Weight if the process executes more than once on the Host or has executed on more than 1 Hosts.\nIn general, this should identify processes on a Host that are rare and rare for the environment.\nReferences: https://medium.com/udacity/shannon-entropy-information-gain-and-picking-balls-from-buckets-5810d35d54b4\nhttps://en.wiktionary.org/wiki/Shannon_entropy'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RareProcbyServiceAccount.yaml", "query_name": "Rare processes run by Service accounts", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet excludeList = dynamic ( [\"NT AUTHORITY\",\"Local System\", \"Local Service\", \"Network Service\"] );\nlet List1 = datatable(AccountName:string)[\"MSSQLSERVER\", \"ReportServer\", \"MSDTSServer100\", \"IUSR\"];\n// Provide a list of service account/ built-in accounts in an environment.\nlet List2 = SecurityEvent\n// Self generating a list of Service account using event Id :4624\n| where TimeGenerated between(starttime..endtime)\n| where EventID == 4624\n| where LogonType == \"5\"\n| where not(Account has_any (excludeList))\n| extend AccountName = Account\n| distinct AccountName;\nlet Accounts = List1 | union (List2 | distinct AccountName);\nlet ProcessCreationEvents=() {\n    let processEvents=SecurityEvent\n\t| where TimeGenerated between(starttime..endtime)\n    | where EventID==4688\n    // filter out common randomly named files related to MSI installers and browsers\n    | where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{3}\\.tmp\")\n    | where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{4}\\.tmp\")\n    | where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{3}\\.tmp\")\n    | where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{4}\\.tmp\")\n    | project TimeGenerated,\n      ComputerName=Computer,\n      AccountName=SubjectUserName,\n      AccountDomain=SubjectDomainName,\n      FileName=tostring(split(NewProcessName, '\\\\')[-1]),\n      ProcessCommandLine = CommandLine,\n      InitiatingProcessFileName=ParentProcessName,\n      InitiatingProcessCommandLine=\"\",\n      InitiatingProcessParentFileName=\"\";\n    processEvents;\n    };\n    let normalizedProcesses = ProcessCreationEvents\n       // normalize guids\n       | project TimeGenerated, AccountName, FileName = replace(\"[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}\", \"<guid>\", FileName)\n       // normalize digits away\n       | project TimeGenerated, AccountName, FileName=replace(@'\\d', 'n', FileName);\nlet freqs = normalizedProcesses\n    | summarize frequency = count() by FileName\n    | join kind= leftouter (\n       normalizedProcesses\n       | summarize Since=min(TimeGenerated), LastSeen=max(TimeGenerated)  by FileName, AccountName\n    ) on FileName;\n   let Finalfreqs = freqs\n    | where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 10))\n    | order by frequency asc\n    | project FileName, frequency, Since, LastSeen , AccountName\n    // restrict results to unusual processes seen in last day\n    | where LastSeen between(starttime..endtime);\nAccounts\n    | join kind= inner (\n        Finalfreqs\n) on AccountName\n| where frequency < 10\n| project-away AccountName1\n| extend AccountCustomEntity = AccountName", "attributes": {"description": "'Service accounts normally are supposed to perform a limited set of tasks in a stable environment.\nThe query collects a list of service account and then joins them with rare processes in an environment to detect anomalous behaviours.'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RareProcessPath.yaml", "query_name": "Rare Process Path", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nlet processEvents=\nSecurityEvent\n| where TimeGenerated between(ago(lookback)..endtime)\n| where EventID==4688\n// excluding well known processes\n| where NewProcessName !endswith ':\\\\Windows\\\\System32\\\\conhost.exe' and ParentProcessName !endswith ':\\\\Windows\\\\System32\\\\conhost.exe'\n| where ParentProcessName !endswith \":\\\\Windows\\\\System32\\\\wuauclt.exe\" and NewProcessName !startswith \"C:\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\AM_Delta_Patch_\"\n| where NewProcessName !has \":\\\\Windows\\\\WinSxS\\\\amd64_microsoft-windows-servicingstack_\" and ParentProcessName !has \":\\\\Windows\\\\WinSxS\\\\amd64_microsoft-windows-servicingstack_\"\n| where NewProcessName !endswith \":\\\\WindowsAzure\\\\SecAgent\\\\WaSecAgentProv.exe\"\n| where ParentProcessName !has \":\\\\WindowsAzure\\\\GuestAgent_\" and NewProcessName !has \":\\\\WindowsAzure\\\\GuestAgent_\"\n| where ParentProcessName !has \":\\\\WindowsAzure\\\\WindowsAzureNetAgent_\" and NewProcessName !has \":\\\\WindowsAzure\\\\WindowsAzureNetAgent_\"\n| where ParentProcessName !has \":\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\\" and ParentProcessName !endswith \"\\\\MpCmdRun.exe\"\n| where NewProcessName !has \":\\\\ProgramData\\\\Microsoft\\\\Windows Defender\\\\platform\\\\\" and NewProcessName !endswith \"\\\\MpCmdRun.exe\"\n| where NewProcessName !has ':\\\\Program Files\\\\Microsoft Monitoring Agent\\\\Agent\\\\'\n// filter out common randomly named paths and files\n| where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{3}\\.tmp\")\n| where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{4}\\.tmp\")\n| where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{3}\\.tmp\")\n| where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{4}\\.tmp\")\n| where not(NewProcessName matches regex @\"\\\\Windows\\\\Temp\\\\[0-9A-Za-z-]*\\\\DismHost\\.exe\")\n| where not(NewProcessName matches regex @\"\\\\Users\\\\[0-9A-Za-z-_~\\.]*\\\\AppData\\\\Local\\\\Temp\\\\[0-9A-Za-z-]*\\\\DismHost\\.exe\")\n| where not(NewProcessName matches regex @\"\\\\Windows\\\\Temp\\\\[0-9A-Za-z-]*\\\\MpSigStub\\.exe\")\n| where not(NewProcessName matches regex @\"\\\\[0-9A-Za-z]*\\\\amd64\\\\setup\\.exe\") and (ParentProcessName !has \":\\\\Windows\\\\SoftwareDistribution\\\\Download\\\\Install\\\\\"\nor ParentProcessName !has \"\\\\AppData\\\\Local\\\\Temp\\\\mpam-\")\n| where not(NewProcessName matches regex @\"\\\\Windows\\\\Microsoft.NET\\\\(Framework|Framework64)\\\\v[0-9].[0-9].[0-9]*\\\\(csc\\.exe|cvtres\\.exe|mscorsvw\\.exe|ngentask\\.exe|ngen\\.exe)\")\n| where not(NewProcessName matches regex @\"\\\\WindowsAzure\\\\GuestAgent_[0-9].[0-9].[0-9]*.[0-9]*_[0-9]*-[0-9]*-[0-9]*_[0-9]*\\\\\")\nand not(ParentProcessName matches regex @\"\\\\WindowsAzure\\\\GuestAgent_[0-9].[0-9].[0-9]*.[0-9]*_[0-9]*-[0-9]*-[0-9]*_[0-9]*\\\\\")\n| where not(NewProcessName matches regex @\"\\\\[0-9A-Za-z]*\\\\epplauncher.exe\")\n| where not(NewProcessName matches regex @\"\\\\Packages\\\\Plugins\\\\Microsoft\\.\")\n| extend path_parts = parse_path(NewProcessName)\n| extend ProcessPath = tostring(path_parts.DirectoryPath)\n;\nlet normalizedProcessPath = processEvents\n| extend NormalizedProcessPath = ProcessPath\n// normalize guids\n| project TimeGenerated, Computer, Account, Process, ProcessPath,\nNormalizedProcessPath = replace(\"[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}\", \"<guid>\", NormalizedProcessPath)\n// normalize digits away\n| project TimeGenerated, Computer, Account, Process, ProcessPath, NormalizedProcessPath = replace(@'\\d', '#', NormalizedProcessPath)\n;\nlet freqs = normalizedProcessPath\n| summarize makelist(Computer), makelist(Account), makelist(ProcessPath), frequency=count() by NormalizedProcessPath, Process\n| join kind= leftouter (\nnormalizedProcessPath\n| summarize StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated) by NormalizedProcessPath, Process\n) on NormalizedProcessPath, Process;\nfreqs\n| where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 5))\n| order by frequency asc\n| mvexpand Computer = list_Computer, Account = list_Account, ProcessPath = list_ProcessPath\n| project StartTimeUtc, EndTimeUtc, frequency, Process, NormalizedProcessPath, tostring(ProcessPath), tostring(Computer), tostring(Account)", "attributes": {"description": "'Identifies when a process is running from a rare path. This could indicate malicious or unexpected activity as attacks\noften try to use common process names running from non-standard locations'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RareProcessWithCmdLine.yaml", "query_name": "Hosts running a rare process with commandline", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet basic=materialize(\n  SecurityEvent\n    | where TimeGenerated >= lookback\n    | where EventID == 4688\n    | where isnotempty(CommandLine) and NewProcessName !endswith \":\\\\windows\\\\system32\\\\conhost.exe\" and CommandLine !~ NewProcessName and CommandLine !~ strcat('\\\"',NewProcessName,'\\\"',\" \")\n    | extend CommandLine=tolower(CommandLine)\n    | summarize FullCount = count()\n                , Count= countif(TimeGenerated between (starttime .. endtime))\n                , min_TimeGenerated=min(TimeGenerated)\n                , max_TimeGenerated=max(TimeGenerated)\n                      by Computer, NewProcessName, CommandLine\n    | where Count > 0 and Count < 100);\nlet basic_avg = basic\n    | summarize Avg = avg(FullCount) by  NewProcessName, CommandLine;\nbasic | project-away FullCount\n  | join kind=inner\nbasic_avg\n  on NewProcessName, CommandLine | project-away NewProcessName1, CommandLine1\n  | where Count < 7 or (Count <= Avg*0.01 and Count < 100)\n  | extend HostCustomEntity=Computer\n", "attributes": {"description": "Looking for hosts running a rare process. Less than 1% of the average for 30 days and less than a count of 100 on a given host or less than a 14 count on a given host from the last 7 days\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Discovery", "LateralMovement", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RareProcess_forWinHost.yaml", "query_name": "Hosts running a rare process", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 30d;\nlet basic=materialize(\n  SecurityEvent\n    | where TimeGenerated between(lookback..endtime)\n    | where EventID == 4688\n    | summarize FullCount = count()\n                , Count= countif(TimeGenerated between (starttime .. endtime))\n                , min_TimeGenerated=min(TimeGenerated)\n                , max_TimeGenerated=max(TimeGenerated)\n                      by Computer, NewProcessName\n    | where Count > 0 and Count < 100);\nlet basic_avg = basic\n    | summarize Avg = avg(FullCount) by  NewProcessName;\nbasic | project-away FullCount\n  | join kind=inner\nbasic_avg\n  on NewProcessName | project-away NewProcessName1\n  | where Count < 14 or (Count <= Avg*0.01 and Count < 100)\n  | extend HostCustomEntity=Computer", "attributes": {"description": "Looking for hosts running a rare process. Less than 1% of the average for 30 days and less than a count of 100 on a given host or less than a 14 count on a given host from the last 7 days\n", "techniques": NaN, "tactics": ["Execution", "Persistence", "Discovery", "LateralMovement", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RemoteLoginPerformedwithWMI.yaml", "query_name": "Remote Login Performed with WMI", "query": "SecurityEvent\n   | where EventID in (4624,4625) and ProcessName endswith_cs \"WmiPrvSE.exe\"\n   | summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, TargetUserName, TargetLogonId, LogonTypeName, IpAddress, ProcessName\n", "attributes": {"description": "'It detects authentication attempts performed with WMI. Adversaries may abuse WMI to execute malicious commands and payloads.\nRef: https://www.mandiant.com/resources/bypassing-network-restrictions-through-rdp-tunneling'\n", "techniques": ["T1047"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RemoteScheduledTaskCreationUpdateUsingATSVCNamedPipe.yaml", "query_name": "Remote Scheduled Task Creation or Update using ATSVC Named Pipe", "query": "SecurityEvent\n| where EventID == 5145 and ShareName==\"\\\\\\\\*\\\\IPC$\" and RelativeTargetName == \"atsvc\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, SubjectUserName, ShareName, RelativeTargetName, IpAddress\n", "attributes": {"description": "'This query detects a scheduled task, created/updated remotely, using the ATSVC name pipe. \nThreat actors are using scheduled tasks for establishing persistence and moving laterally through the network.\nRef: https://blog.menasec.net/2019/03/threat-hunting-25-scheduled-tasks-for.html'\n", "techniques": ["T1053.002"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RemoteScheduledTaskCreationUpdateviaSchtasks.yaml", "query_name": "Remote Task Creation/Update using Schtasks Process", "query": "SecurityEvent\n| where EventID == 4688 and NewProcessName == \"C:\\\\Windows\\\\System32\\\\schtasks.exe\" and CommandLine has \" /s \"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, SubjectUserName, CommandLine\n", "attributes": {"description": "'The query detects a scheduled task, created/updated remotely, using the Schtasks process. \nThreat actors are using scheduled tasks for establishing persistence and moving laterally through the network.\nRef: https://blog.menasec.net/2019/03/threat-hunting-25-scheduled-tasks-for.html'\n", "techniques": ["T1053"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/RIDHijacking.yaml", "query_name": "RID Hijacking", "query": "// Enter a reference list of default local administrators for your Windows systems\nlet LocalAdminsList = dynamic ([\"administrator\",\"admin\"]);\nSecurityEvent\n| where EventID in (4624,4625) and TargetUserSid endswith \"-500\" and TargetUserName !in (LocalAdminsList)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Computer, TargetUserName, TargetUserSid, TargetLogonId, IpAddress, LogonTypeName\n", "attributes": {"description": "'This query detects all authentication attempts of non administrator accounts that their RID is ending in *-500.\nRef: https://stealthbits.com/blog/rid-hijacking-when-guests-become-admins/'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/ScheduledTaskCreationUpdateFromUserWritableDrectory.yaml", "query_name": "Scheduled Task Creation or Update from User Writable Directory", "query": "// Enter a reference list for writable user paths\"\nlet WritableUserPaths = dynamic ([\"\\\"C:\\\\Users\\\\\",\"\\\"C:\\\\ProgramData\\\\\"]);\nSecurityEvent\n| where EventID in (4698,4702) and EventData has_any (WritableUserPaths)\n| parse EventData with * 'Command&gt;' Command \"&lt\" *\n| parse EventData with * 'Arguments&gt;' Arguments \"&lt\" *\n| where Command has_any (WritableUserPaths) or Arguments has_any (WritableUserPaths)\n| parse EventData with * 'SubjectUserName\">' SubjectUserName \"<\" * 'SubjectDomainName\">' SubjectDomainName \"<\" * 'TaskName\">' TaskName \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Activity, Computer, SubjectUserName, SubjectDomainName, TaskName, Command, Arguments\n", "attributes": {"description": "'This query triggers when a scheduled task is created or updated and it is going to run programs from writable user paths.\nRef: https://blog.menasec.net/2019/03/threat-hunting-25-scheduled-tasks-for.html'\n", "techniques": ["T1053.005"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/ServiceInstallationFromUsersWritableDirectory.yaml", "query_name": "Service installation from user writable directory", "query": "// Enter a reference list for writable user paths\"\nlet WritableUserPaths = dynamic ([\"\\\"C:\\\\Users\\\\\",\"\\\"C:\\\\ProgramData\\\\\"]);\nEvent\n| where Source == \"Service Control Manager\" and EventID == 7045\n| parse EventData with * 'ServiceName\">' ServiceName \"<\" * 'ImagePath\">' ImagePath \"<\" *\n| where ImagePath has_any (WritableUserPaths)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, ImagePath, ServiceName, UserName\n", "attributes": {"description": "'This query detects a service installation that is originated from a user writable directory.\nRef: https://attack.mitre.org/techniques/T1569/002/'\n", "techniques": ["T1569.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/SignedBinaryProxyExecutionRundll32.yaml", "query_name": "Rundll32 (LOLBins and LOLScripts)", "query": "Event\n//This query uses sysmon data depending on table name used this may need updataing\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend RenderedDescription = tostring(split(RenderedDescription, \":\")[0])\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| extend RuleName = column_ifexists(\"RuleName\", \"\"), TechniqueId = column_ifexists(\"TechniqueId\", \"\"),  TechniqueName = column_ifexists(\"TechniqueName\", \"\")\n| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName\n| where Image has \"rundll32.exe\"\n// Uncomment the next line and add your commandLine Whitelisted/ignore terms.For example \"payload.dll\"\n// | where CommandLine !contains (\"payload.dll\") \n| extend HostCustomEntity = Computer, AccountCustomEntity = UserName\n", "attributes": {"description": "'This detection uses Sysmon telemetry to hunt Signed Binary Proxy Execution: Rundll32 activities'\n", "techniques": ["T1218.011"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/SuspectedLSASSDump.yaml", "query_name": "Suspected LSASS Dump", "query": "SecurityEvent \n| where EventID == 4688\n| where CommandLine has_all (\"procdump\", \"lsass\") or CommandLine has_all (\"rundll32\", \"comsvcs\", \"MiniDump\")\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer\n", "attributes": {"description": "'Look for evidence of the LSASS process being dumped either using Procdump or comsvcs.dll. Often used by attackers to access credentials stored on a system.\nRef: https://risksense.com/blog/hidden-gems-in-windows-the-hunt-is-on/ & https://docs.microsoft.com/sysinternals/downloads/procdump'\n", "techniques": ["T1003"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Suspicious_enumeration_using_adfind.yaml", "query_name": "Suspicious enumeration using Adfind tool", "query": "let lookupwindow = 2m;\nlet threshold = 3; //number of commandlines in the set below\nlet DCADFSServersList = dynamic ([\"DCServer01\", \"DCServer02\", \"ADFSServer01\"]); // Enter a reference list of hostnames for your DC/ADFS servers\nlet tokens = dynamic([\"objectcategory\",\"domainlist\",\"dcmodes\",\"adinfo\",\"trustdmp\",\"computers_pwdnotreqd\",\"Domain Admins\", \"objectcategory=person\", \"objectcategory=computer\", \"objectcategory=*\"]);\nSecurityEvent\n//| where Computer in (DCADFSServersList) // Uncomment to limit it to your DC/ADFS servers list if specified above or any pattern in hostnames (startswith, matches regex, etc).\n| where EventID == 4688\n| where CommandLine has_any (tokens)\n| where CommandLine matches regex \"(.*)>(.*)\"\n| summarize Commandlines = make_set(CommandLine), LastObserved=max(TimeGenerated) by bin(TimeGenerated, lookupwindow), Account, Computer, ParentProcessName, NewProcessName\n| extend Count = array_length(Commandlines)\n| where Count > threshold\n", "attributes": {"description": "Attackers can use Adfind which is administrative tool to gather information about Domain controllers, ADFS Servers. They may also rename executables with other benign tools on the system.\nBelow query will look for adfind usage in commandline arguments irrespective of executable name in short span of time. You can limit query this to your DC and ADFS servers.\nBelow references talk about suspicious use of adfind by adversaries.\n- https://thedfirreport.com/2020/05/08/adfind-recon/\n- https://www.fireeye.com/blog/threat-research/2020/05/tactics-techniques-procedures-associated-with-maze-ransomware-incidents.html\n- https://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/\n", "techniques": ["T1059", "T1087", "T1482", "T1201", "T1069", "T1074"], "tactics": ["Execution", "Discovery", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/Suspicious_Windows_Login_outside_normal_hours.yaml", "query_name": "Suspicious Windows Login outside normal hours", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet AllLogonEvents = materialize(\nSecurityEvent\n| where TimeGenerated between (lookback..starttime)\n| where EventID in (4624, 4625)\n| where LogonTypeName in~ ('2 - Interactive','10 - RemoteInteractive')\n| where AccountType =~ 'User'\n| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)\n| extend DayofWeek = case(\nDayNumberofWeek == \"00:00:00\", \"Sunday\",\nDayNumberofWeek == \"1.00:00:00\", \"Monday\",\nDayNumberofWeek == \"2.00:00:00\", \"Tuesday\",\nDayNumberofWeek == \"3.00:00:00\", \"Wednesday\",\nDayNumberofWeek == \"4.00:00:00\", \"Thursday\",\nDayNumberofWeek == \"5.00:00:00\", \"Friday\",\nDayNumberofWeek == \"6.00:00:00\", \"Saturday\",\"InvalidTimeStamp\")\n// map the most common ntstatus codes\n| extend StatusDesc = case(\nStatus =~ \"0x80090302\", \"SEC_E_UNSUPPORTED_FUNCTION\",\nStatus =~ \"0x80090308\", \"SEC_E_INVALID_TOKEN\",\nStatus =~ \"0x8009030E\", \"SEC_E_NO_CREDENTIALS\",\nStatus =~ \"0xC0000008\", \"STATUS_INVALID_HANDLE\",\nStatus =~ \"0xC0000017\", \"STATUS_NO_MEMORY\",\nStatus =~ \"0xC0000022\", \"STATUS_ACCESS_DENIED\",\nStatus =~ \"0xC0000034\", \"STATUS_OBJECT_NAME_NOT_FOUND\",\nStatus =~ \"0xC000005E\", \"STATUS_NO_LOGON_SERVERS\",\nStatus =~ \"0xC000006A\", \"STATUS_WRONG_PASSWORD\",\nStatus =~ \"0xC000006D\", \"STATUS_LOGON_FAILURE\",\nStatus =~ \"0xC000006E\", \"STATUS_ACCOUNT_RESTRICTION\",\nStatus =~ \"0xC0000073\", \"STATUS_NONE_MAPPED\",\nStatus =~ \"0xC00000FE\", \"STATUS_NO_SUCH_PACKAGE\",\nStatus =~ \"0xC000009A\", \"STATUS_INSUFFICIENT_RESOURCES\",\nStatus =~ \"0xC00000DC\", \"STATUS_INVALID_SERVER_STATE\",\nStatus =~ \"0xC0000106\", \"STATUS_NAME_TOO_LONG\",\nStatus =~ \"0xC000010B\", \"STATUS_INVALID_LOGON_TYPE\",\nStatus =~ \"0xC000015B\", \"STATUS_LOGON_TYPE_NOT_GRANTED\",\nStatus =~ \"0xC000018B\", \"STATUS_NO_TRUST_SAM_ACCOUNT\",\nStatus =~ \"0xC0000224\", \"STATUS_PASSWORD_MUST_CHANGE\",\nStatus =~ \"0xC0000234\", \"STATUS_ACCOUNT_LOCKED_OUT\",\nStatus =~ \"0xC00002EE\", \"STATUS_UNFINISHED_CONTEXT_DELETED\",\nEventID == 4624, \"Success\",\n\"See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55\"\n)\n| extend SubStatusDesc = case(\nSubStatus =~ \"0x80090325\", \"SEC_E_UNTRUSTED_ROOT\",\nSubStatus =~ \"0xC0000008\", \"STATUS_INVALID_HANDLE\",\nSubStatus =~ \"0xC0000022\", \"STATUS_ACCESS_DENIED\",\nSubStatus =~ \"0xC0000064\", \"STATUS_NO_SUCH_USER\",\nSubStatus =~ \"0xC000006A\", \"STATUS_WRONG_PASSWORD\",\nSubStatus =~ \"0xC000006D\", \"STATUS_LOGON_FAILURE\",\nSubStatus =~ \"0xC000006E\", \"STATUS_ACCOUNT_RESTRICTION\",\nSubStatus =~ \"0xC000006F\", \"STATUS_INVALID_LOGON_HOURS\",\nSubStatus =~ \"0xC0000070\", \"STATUS_INVALID_WORKSTATION\",\nSubStatus =~ \"0xC0000071\", \"STATUS_PASSWORD_EXPIRED\",\nSubStatus =~ \"0xC0000072\", \"STATUS_ACCOUNT_DISABLED\",\nSubStatus =~ \"0xC0000073\", \"STATUS_NONE_MAPPED\",\nSubStatus =~ \"0xC00000DC\", \"STATUS_INVALID_SERVER_STATE\",\nSubStatus =~ \"0xC0000133\", \"STATUS_TIME_DIFFERENCE_AT_DC\",\nSubStatus =~ \"0xC000018D\", \"STATUS_TRUSTED_RELATIONSHIP_FAILURE\",\nSubStatus =~ \"0xC0000193\", \"STATUS_ACCOUNT_EXPIRED\",\nSubStatus =~ \"0xC0000380\", \"STATUS_SMARTCARD_WRONG_PIN\",\nSubStatus =~ \"0xC0000381\", \"STATUS_SMARTCARD_CARD_BLOCKED\",\nSubStatus =~ \"0xC0000382\", \"STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED\",\nSubStatus =~ \"0xC0000383\", \"STATUS_SMARTCARD_NO_CARD\",\nSubStatus =~ \"0xC0000384\", \"STATUS_SMARTCARD_NO_KEY_CONTAINER\",\nSubStatus =~ \"0xC0000385\", \"STATUS_SMARTCARD_NO_CERTIFICATE\",\nSubStatus =~ \"0xC0000386\", \"STATUS_SMARTCARD_NO_KEYSET\",\nSubStatus =~ \"0xC0000387\", \"STATUS_SMARTCARD_IO_ERROR\",\nSubStatus =~ \"0xC0000388\", \"STATUS_DOWNGRADE_DETECTED\",\nSubStatus =~ \"0xC0000389\", \"STATUS_SMARTCARD_CERT_REVOKED\",\nEventID == 4624, \"Success\",\n\"See - https://docs.microsoft.com/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55\"\n)\n| project StartTime = TimeGenerated, DayofWeek, HourOfLogin, EventID, Activity, IpAddress, WorkstationName, Computer, TargetUserName, TargetDomainName, ProcessName, SubjectUserName, PrivilegeList, LogonTypeName, StatusDesc, SubStatusDesc\n);\nAllLogonEvents\n| where TargetDomainName !in (\"Window Manager\",\"Font Driver Host\")\n| summarize max(HourOfLogin), min(HourOfLogin), historical_DayofWeek=make_set(DayofWeek) by TargetUserName\n| join kind= inner\n(\n    AllLogonEvents\n    | where StartTime between(starttime..endtime)\n)\non TargetUserName\n// Filtering for logon events based on range of max and min of historical logon hour values seen\n| where HourOfLogin > max_HourOfLogin or HourOfLogin < min_HourOfLogin\n// Also populating additional column showing historical days of week when logon was seen\n| extend historical_DayofWeek = tostring(historical_DayofWeek)\n| summarize Total= count(), max(HourOfLogin), min(HourOfLogin), current_DayofWeek =make_set(DayofWeek), StartTime=max(StartTime), EndTime = min(StartTime), SourceIP = make_set(IpAddress), SourceHost = make_set(WorkstationName), SubjectUserName = make_set(SubjectUserName), HostLoggedOn = make_set(Computer) by EventID, Activity, TargetDomainName, TargetUserName , ProcessName , LogonTypeName, StatusDesc, SubStatusDesc, historical_DayofWeek\n| extend historical_DayofWeek = todynamic(historical_DayofWeek)\n| extend timestamp = StartTime, AccountCustomEntity = TargetUserName", "attributes": {"description": "Looking for suspiciopus interactive logon events which are outside normal logon hours for the user. Current day logon events are comapred with last 14 days activity\nand filtered for events which are above or below of historical logon hour range seen for the user.\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/uncommon_processes.yaml", "query_name": "Uncommon processes - bottom 5%", "query": "\nlet ProcessCreationEvents=() {\nlet processEvents=SecurityEvent\n| where EventID==4688\n// filter out common randomly named files related to MSI installers and browsers\n| where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{3}\\.tmp\")\n| where not(NewProcessName matches regex @\"\\\\TRA[0-9A-Fa-f]{4}\\.tmp\")\n| where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{3}\\.tmp\")\n| where not(NewProcessName matches regex @\"Installer\\\\MSI[0-9A-Fa-f]{4}\\.tmp\")\n| project TimeGenerated, ComputerName=Computer, AccountName=SubjectUserName, AccountDomain=SubjectDomainName,\nFileName=tostring(split(NewProcessName, '\\\\')[-1]), ProcessCommandLine = CommandLine, \nInitiatingProcessFileName=ParentProcessName, InitiatingProcessCommandLine=\"\", InitiatingProcessParentFileName=\"\";\nprocessEvents;\n};\nlet normalizedProcesses = ProcessCreationEvents \n// normalize guids\n| project TimeGenerated, FileName = replace(\"[0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12}\", \"<guid>\", FileName)\n// normalize digits away\n| project TimeGenerated, FileName=replace(@'\\d', 'n', FileName); \nlet freqs = normalizedProcesses\n| summarize frequency=count() by FileName\n| join kind= leftouter (\nnormalizedProcesses\n| summarize Since=min(TimeGenerated), LastSeen=max(TimeGenerated) by FileName\n) on FileName;\nfreqs \n| where frequency <= toscalar( freqs | serialize | project frequency | summarize percentiles(frequency, 5))\n| order by frequency asc\n| project FileName, frequency, Since, LastSeen \n// restrict results to unusual processes seen in last day \n| where LastSeen >= ago(1d)\n| extend timestamp = LastSeen \n", "attributes": {"description": "'Shows the rarest processes seen running for the first time. (Performs best over longer time ranges - eg 3+ days rather than 24 hours!)\nThese new processes could be benign new programs installed on hosts; \nHowever, especially in normally stable environments, these new processes could provide an indication of an unauthorized/malicious binary that has been installed and run. \nReviewing the wider context of the logon sessions in which these binaries ran can provide a good starting point for identifying possible attacks.'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/User%20Logons%20By%20Logon%20Type.yaml", "query_name": "Summary of user logons by logon type", "query": "\nSecurityEvent\n| where EventID in (4624, 4625)\n| where AccountType == 'User' \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Amount = count() by LogonTypeName\n| extend timestamp = StartTimeUtc", "attributes": {"description": "'Comparing succesful and nonsuccessful logon attempts can be used to identify attempts to move laterally within the \nenvironment with the intention of discovering credentials and sensitive data.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/UserAccountAddedToPrivlegeGroup.yaml", "query_name": "User Account added to Built in Domain Local or Global Group", "query": "\n// For AD SID mappings - https://docs.microsoft.com/windows/security/identity-protection/access-control/active-directory-security-groups\nlet WellKnownLocalSID = \"S-1-5-32-5[0-9][0-9]$\";\nlet WellKnownGroupSID = \"S-1-5-21-[0-9]*-[0-9]*-[0-9]*-5[0-9][0-9]$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1102$|S-1-5-21-[0-9]*-[0-9]*-[0-9]*-1103$\";\nSecurityEvent \n| where AccountType == \"User\"\n// 4728 - A member was added to a security-enabled global group\n// 4732 - A member was added to a security-enabled local group\n// 4756 - A member was added to a security-enabled universal group\n| where EventID in (\"4728\", \"4732\", \"4756\")   \n| where TargetSid matches regex WellKnownLocalSID or TargetSid matches regex WellKnownGroupSID\n// Exclude Remote Desktop Users group: S-1-5-32-555\n| where TargetSid !in (\"S-1-5-32-555\")\n| project StartTimeUtc = TimeGenerated, EventID, Activity, Computer, TargetUserName, TargetDomainName, TargetSid, UserPrincipalName, SubjectUserName, SubjectUserSid \n| extend timestamp = StartTimeUtc, HostCustomEntity = Computer, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'User account was added to a privileged built in domain local group or global group such as the Enterprise Adminis, Cert Publishers or DnsAdmins\nBe sure to verify this is an expected addition.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/UserAccountCreatedDeleted.yaml", "query_name": "Long lookback User Account Created and Deleted within 10mins", "query": "\n// TimeDelta is the difference between when the account was created and when it was deleted, default is set to 10min or less\nlet timedelta = 10m;\nSecurityEvent \n// A user account was created\n| where EventID == \"4720\"\n| where AccountType == \"User\"\n| project creationTime = TimeGenerated, CreateEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToCreate = SubjectUserName, TargetSid, SubjectUserSid \n| join kind= inner (\n   SecurityEvent\n   // A user account was deleted \n   | where EventID == \"4726\" \n| where AccountType == \"User\"\n| project deletionTime = TimeGenerated, DeleteEventID = EventID, Activity, Computer, TargetUserName, UserPrincipalName, \nAccountUsedToDelete = SubjectUserName, TargetSid, SubjectUserSid \n) on Computer, TargetUserName\n| where deletionTime - creationTime < timedelta\n| extend TimeDelta = deletionTime - creationTime\n| where tolong(TimeDelta) >= 0\n| project TimeDelta, creationTime, CreateEventID, Computer, TargetUserName, UserPrincipalName, AccountUsedToCreate, \ndeletionTime, DeleteEventID, AccountUsedToDelete\n| extend timestamp = creationTime, HostCustomEntity = Computer, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'User account created and then deleted within 10 minutes across last 14 days'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/UserAdd_RemToGroupByUnauthorizedUser.yaml", "query_name": "User account added or removed from a security group by an unauthorized user", "query": "\n// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain\nlet List = datatable(AuthorizedUser:string, Domain:string)[\"Bob\", \"Domain\", \"joe\", \"domain\", \"MATT\", \"DOMAIN\"];\nSecurityEvent\n| where EventID in (4728, 4729, 4732, 4733, 4746, 4747, 4751, 4752, 4756, 4757, 4761, 4762)\n| join kind= leftanti (\n    List\n    | project SubjectUserName = tolower(AuthorizedUser), SubjectDomainName = toupper(Domain)\n) on SubjectUserName, SubjectDomainName\n| project TimeGenerated, Computer, Account, SubjectUserName, SubjectDomainName, TargetAccount, EventID, Activity\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n", "attributes": {"description": "'User account added or removed from a security group by an unauthorized user, pass in a list'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/UserCreatedByUnauthorizedUser.yaml", "query_name": "User created by unauthorized user", "query": "\n// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain\nlet List = datatable(AuthorizedUser:string, Domain:string)[\"Bob\", \"Domain\", \"joe\", \"domain\", \"MATT\", \"DOMAIN\"];\nSecurityEvent\n| where EventID == 4720\n| where AccountType == \"User\"\n| join kind= leftanti (\n    List\n    | project SubjectUserName = tolower(AuthorizedUser), SubjectDomainName = toupper(Domain)\n) on SubjectUserName, SubjectDomainName\n| project TimeGenerated, Computer, Account, SubjectUserName, SubjectDomainName, TargetAccount, EventID, Activity\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n", "attributes": {"description": "'User account created by an unauthorized user, pass in a list'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/UsersOpenReadDeviceIdentityKey.yaml", "query_name": "Users Opening and Reading the Local Device Identity Key", "query": "// Activities: \n//   5058 - Key file operation\n//   5061 - Cryptographic operation (Event does not provide enough information to filter out potential false positives)\n// KeyType:\n//   %%2499 -> Machine Key\n// Operation:\n//   %%2458 -> Read persisted key from file\n//   %%2480 -> Open Key\n// Machine Keys:\n//   f686aace6942fb7f7ceb231212eef4a4 -> TSSECKeySet1\nlet filterList = dynamic([\"TSSecKeySet1\", \"iisCngWasKey\", \"iisCngConfigurationKey\", \"ConfigMgrPrimaryKey\"]);\nSecurityEvent\n| where Activity == '5058 - Key file operation.'\n| extend EventData = parse_xml(EventData).EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, Computer, EventID)\n| where KeyType == '%%2499' and SubjectLogonId !in ('0x3e7', '0x3e4')\n| where KeyFilePath has 'Microsoft\\\\Crypto\\\\Keys\\\\'\n| where KeyName !in (filterList)\n| extend ProcessId = ClientProcessId, KeyName = tostring(KeyName), SubjectLogonId = tostring(SubjectLogonId)", "attributes": {"description": "'This detection uses Windows security events to look for users reading the local Device Identity Key (Machine Key).\n This information can be correlated with other events for additional context and get to use-cases where a\n machine key with a transport key together can be used to impersonate an AAD joined or registered machine.\n Reference: https://o365blog.com/post/deviceidentity/'\n", "techniques": ["T1552"], "tactics": ["Credential Access"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/VIPAccountFailedLogons.yaml", "query_name": "VIP account more than 6 failed logons in 10", "query": "\n// Create DataTable with your own values, example below shows dummy usernames that are authorized and for what domain\nlet List = datatable(VIPUser:string, Domain:string)[\"Bob\", \"Domain\", \"joe\", \"domain\", \"MATT\", \"DOMAIN\"];\nList | extend Account = strcat(Domain,\"\\\\\",VIPUser) | join kind= inner (\nSecurityEvent \n| where EventID == \"4625\"\n| where AccountType == \"User\"\n| where LogonType == \"2\" or LogonType == \"3\"\n) on Account \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), FailedVIPLogons = count() by LogonType, Account\n| where FailedVIPLogons >= 6\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account\n", "attributes": {"description": "'VIP Account with more than 6 failed logon attempts in 10 minutes, include your own VIP list in the table below'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/WindowsSystemShutdown-Reboot.yaml", "query_name": "Windows System Shutdown/Reboot(Sysmon)", "query": "Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend RenderedDescription = tostring(split(RenderedDescription, \":\")[0])\n| extend EventData = parse_xml(EventData).DataItem.EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key=tostring(['@Name']), Value=['#text']\n| evaluate pivot(Key, any(Value), TimeGenerated, Source, EventLog, Computer, EventLevel, EventLevelName, EventID, UserName, RenderedDescription, MG, ManagementGroupName, Type, _ResourceId)\n| extend RuleName = column_ifexists(\"RuleName\", \"\"), TechniqueId = column_ifexists(\"TechniqueId\", \"\"),  TechniqueName = column_ifexists(\"TechniqueName\", \"\")\n| parse RuleName with * 'technique_id=' TechniqueId ',' * 'technique_name=' TechniqueName\n| where Image has \"shutdown.exe\"\n| extend HostCustomEntity = Computer, AccountCustomEntity = UserName\n", "attributes": {"description": "'This detection uses Sysmon telemetry to detect System Shutdown/Reboot (MITRE Technique: T1529)'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SecurityEvent/WindowsSystemTimeChange.yaml", "query_name": "Windows System Time changed on hosts", "query": "\nSecurityEvent\n| where EventID == 4616\n| where not(ProcessName has_any (\":\\\\Windows\\\\System32\\\\svchost.exe\", \":\\\\Program Files\\\\VMware\\\\VMware Tools\\\\vmtoolsd.exe\"))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by Computer, EventID, Activity, Account, AccountType, NewTime, PreviousTime, ProcessName, ProcessId, SubjectAccount, SubjectUserSid, SourceComputerId, _ResourceId\n| extend timestamp = StartTime, HostCustomEntity = Computer, AccountCustomEntity = SubjectAccount\n", "attributes": {"description": "'Identifies when the system time was changed on a Windows host which can indicate potential timestomping activities.\nReference: Event ID 4616 is only available when the full event collection is enabled - https://docs.microsoft.com/azure/sentinel/connect-windows-security-events'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AADSuspectedBruteForce.yaml", "query_name": "Suspected Brute force attack Investigation", "query": "let successCodes = dynamic([\"0\", \"50125\", \"50140\", \"70043\", \"70044\"]);\nlet aadFunc = (tableName:string){\n  table(tableName)\n | extend FailureOrSuccess = iff(ResultType in (successCodes), \"Success\", \"Failure\")\n | summarize FailureCount = countif(FailureOrSuccess==\"Failure\"), SuccessCount = countif(FailureOrSuccess==\"Success\") by bin(TimeGenerated, 1h),UserPrincipalName, UserDisplayName, IPAddress\n | where FailureCount > 100\n | where SuccessCount > 0\n | order by UserPrincipalName, TimeGenerated asc\n | extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Summarize all the failures and success events for all users in the last 24 hours, \nonly identify users with more than 100 failures in the set period'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AdministratorsAuthenticatingtoAnotherAzureADTenant.yaml", "query_name": "Administrators Authenticating to Another Azure AD Tenant", "query": "let admin_users = (IdentityInfo\n  | summarize arg_max(TimeGenerated, *) by AccountUPN\n  | where AssignedRoles contains \"admin\"\n  | summarize by tolower(AccountUPN));\n  SigninLogs\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where ResultType == 0\n  | where tolower(UserPrincipalName) in (admin_users)\n  | where HomeTenantId != ResourceTenantId\n  | summarize by UserPrincipalName, ResourceTenantId\n  | join kind=rightanti (SigninLogs\n  | where TimeGenerated > ago(1d)\n  | where ResultType == 0\n  | where tolower(UserPrincipalName) in (admin_users)\n  | where HomeTenantId != ResourceTenantId\n  | where isnotempty(HomeTenantId) and isnotempty(ResourceTenantId)) on UserPrincipalName, ResourceTenantId\n  | where RiskLevelAggregated != \"none\"\n", "attributes": {"description": "'Detects when a privileged user account successfully authenticates from to another Azure AD Tenant.\n  Authentication attempts should be investigated to ensure the activity was legitimate and if there is other similar activity.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AnomalousUserAppSigninLocationIncrease.yaml", "query_name": "Anomalous sign-in location by user account and authenticating application", "query": "\nSigninLogs \n// Forces Log Analytics to recognize that the query should be run over full time range\n| extend  locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\") \n| project TimeGenerated, AppDisplayName, UserPrincipalName, locationString \n// Create time series \n| make-series dLocationCount = dcount(locationString) on TimeGenerated step 1d\nby UserPrincipalName, AppDisplayName \n// Compute best fit line for each entry \n| extend (RSquare, Slope, Variance, RVariance, Interception, LineFit) = series_fit_line(dLocationCount) \n// Chart the 3 most interesting lines  \n// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application\n| top 3 by Slope desc\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName \n| render timechart\n", "attributes": {"description": "'This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active \nDirectory application and picks out the most anomalous change in location profile for a user within an \nindividual application. The intent is to hunt for user account compromise, possibly via a specific application\nvector.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/AnomalousUserAppSigninLocationIncreaseDetail.yaml", "query_name": "Anomalous sign-in location by user account and authenticating application - with sign-in details", "query": "\nSigninLogs \n// Forces Log Analytics to recognize that the query should be run over full time range\n| extend  locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\") \n| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString \n// Create time series \n| make-series dLocationCount = dcount(locationString) on TimeGenerated step 1d \nby UserPrincipalName, AppDisplayName \n// Compute best fit line for each entry \n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) \n// Chart the 3 most interesting lines  \n// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application\n| top 3 by Slope desc  \n// Extract the set of locations for each top user:\n| join kind=inner (SigninLogs\n| extend  locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\")\n| summarize locationList = makeset(locationString), threeDayWindowLocationCount=dcount(locationString) by AppDisplayName, UserPrincipalName, \ntimerange=bin(TimeGenerated, 3d)) on AppDisplayName, UserPrincipalName\n| order by UserPrincipalName, timerange asc\n| project timerange, AppDisplayName , UserPrincipalName, threeDayWindowLocationCount, locationList \n| order by AppDisplayName, UserPrincipalName, timerange asc\n| extend timestamp = timerange, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active \nDirectory application and picks out the most anomalous change in location profile for a user within an \nindividual application. The intent is to hunt for user account compromise, possibly via a specific application\nvector.\nThis variation of the query joins the results back onto the original sign-in data to allow review of the \nlocation set with each identified user in tabular form.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/anomalous_app_azuread_signin.yaml", "query_name": "Anomalous Azure Active Directory apps based on authentication location", "query": "\nlet azureSignIns = \nSigninLogs\n| where SourceSystem == \"Azure AD\"\n| where OperationName == \"Sign-in activity\"\n| project TimeGenerated, OperationName, AppDisplayName , Identity, UserId, UserPrincipalName, Location, LocationDetails, \nClientAppUsed, DeviceDetail, ConditionalAccessPolicies;\nazureSignIns\n| extend locationString = strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", \ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]), \";\" , tostring(LocationDetails[\"geoCoordinates\"]))\n| summarize rawSigninCount = count(), countByAccount = dcount(UserId), locationCount = dcount(locationString) by AppDisplayName\n// tail - pick a threshold to rule out the very-high volume Azure AD apps\n| where rawSigninCount < 1000\n// more locations than accounts\n| where locationCount>countByAccount\n// almost as many / more locations than sign-ins!\n| where 1.0*rawSigninCount / locationCount > 0.8 \n| order by rawSigninCount  desc\n| join kind = leftouter (\n   azureSignIns \n) on AppDisplayName \n| project AppDisplayName, TimeGenerated , Identity, rawSigninCount, countByAccount, locationCount,  \nlocationString = strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\", \ntostring(LocationDetails[\"city\"]), \";\" , tostring(LocationDetails[\"geoCoordinates\"])), UserPrincipalName\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName \n| order by AppDisplayName, TimeGenerated desc\n", "attributes": {"description": "'This query over Azure AD sign-in activity highlights Azure AD apps with \nan unusually high ratio of distinct geolocations versus total number of authentications'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/DisabledAccountSigninAttempts.yaml", "query_name": "Attempts to sign in to disabled accounts by account name", "query": "\nSigninLogs \n| where ResultType == \"50057\" \n| where ResultDescription == \"User account is disabled. The account has been disabled by an administrator.\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by AppDisplayName, UserPrincipalName\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName\n| order by count_ desc\n", "attributes": {"description": "'Failed attempts to sign in to disabled accounts summarized by account name'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/DisabledAccountSigninAttemptsByIP.yaml", "query_name": "Attempts to sign in to disabled accounts by IP address", "query": "\nSigninLogs \n| where ResultType == \"50057\" \n| where ResultDescription == \"User account is disabled. The account has been disabled by an administrator.\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), numberAccountsTargeted = dcount(UserPrincipalName), \nnumberApplicationsTargeted = dcount(AppDisplayName), accountSet = makeset(UserPrincipalName), applicationSet=makeset(AppDisplayName), \nnumberLoginAttempts = count() by IPAddress\n| extend timestamp = StartTime, IPCustomEntity = IPAddress\n| order by numberLoginAttempts desc\n", "attributes": {"description": "'Failed attempts to sign in to disabled accounts summarized by the IP address from from the sign-in attempts originate'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/InactiveAccounts.yaml", "query_name": "Inactive or new account signins", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet midtime = starttime - 7d;\nlet SigninsSummary = SigninLogs\n| where TimeGenerated between(starttime..endtime)\n// successful sign-in only\n| where ResultType == 0\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), SigninLogs_ItemIds = make_set(_ItemId), loginCountToday=count() by UserPrincipalName, UserId, UserType, IPAddress\n| join kind=leftanti (\n   SigninLogs\n   // historical successful sign-in\n   | where TimeGenerated between(lookback..starttime)\n   | where ResultType == 0\n   | summarize by UserId\n) on UserId;\n// need to help BehaviorAnalytics query to limit only to Signins we are interested in\nlet onlyInactive = SigninsSummary | summarize make_set(UserPrincipalName);\nlet SigninsWithUEBA =\nBehaviorAnalytics\n| where TimeGenerated between(starttime..endtime)\n| where ActionType in ('Sign-in','InteractiveLogon')\n| where UserPrincipalName in~ (onlyInactive)\n| extend ActivityInsights = parse_xml(ActivityInsights)\n// only looked where FirstTimeUser items are True\n| where ActivityInsights matches regex '\\\"FirstTimeUser([A-Za-z0-9]+)\\\":\\\"True\\\"'\n// only exclude when Uncommon Among Peers is false as this helps remove expected first time usage, exception is we always show FirstTimeUserConnectedFromCountry == True\n// also always keep InvestigationPriority if 1 or more\n| where (not(ActivityInsights.FirstTimeUserUsedApp == 'True' and ActivityInsights.AppUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)\n| where (not(ActivityInsights.FirstTimeUserConnectedViaBrowser == 'True' and ActivityInsights.BrowserUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)\n| where (not(ActivityInsights.FirstTimeUserAccessedResource == 'True' and ActivityInsights.ResourceUncommonlyUsedAmongPeers == 'False') or InvestigationPriority > 0)\n// for ISP, it makes more sense to exclude if Uncommon in Tenant or Uncommon among peers is false.\n| where (not(ActivityInsights.FirstTimeUserConnectedViaISP == 'True' and (ActivityInsights.ISPUncommonlyUsedInTenant == 'False' or ActivityInsights.ISPUncommonlyUsedAmongPeers == 'False')) or InvestigationPriority > 0)\n| extend UEBA_Insights = pack_dictionary(\"TimeGenerated\", TimeGenerated, \"ActivityInsights\", ActivityInsights, \"UsersInsights\", UsersInsights, \"DevicesInsights\", DevicesInsights)\n| summarize UEBA_ItemIds = make_set(_ItemId), UEBA_SourceRecordIds = make_set(SourceRecordId), UEBA_Insights = make_set(UEBA_Insights) by\nUEBA_UserPrincipalName = UserPrincipalName, JoinedWithType = Type, UEBA_ActionType = ActionType, UEBA_SourceIPAddress = SourceIPAddress, UEBA_SourceIPLocation = SourceIPLocation, UEBA_InvestigationPriority = InvestigationPriority\n| extend UEBA_Info = pack_dictionary(\"UEBA_Insights\", UEBA_Insights, \"UEBA_ItemIds\", UEBA_ItemIds, \"UEBA_SourceRecordIds\", UEBA_SourceRecordIds)\n| project-away UEBA_ItemIds, UEBA_SourceRecordIds, UEBA_Insights\n| join kind=inner ( \n  SigninsSummary\n) on $left.UEBA_UserPrincipalName == $right.UserPrincipalName, $left.UEBA_SourceIPAddress == $right.IPAddress\n| project-reorder StartTime, EndTime, UserPrincipalName, UserId, IPAddress, UserType, loginCountToday, JoinedWithType\n;\nSigninsWithUEBA \n| join kind= leftanti (\n   // filter out newly created user accounts from last 7 days\n   AuditLogs\n   | where TimeGenerated between(midtime..endtime)\n   | where OperationName == \"Add user\"\n   | summarize by NewUserId = tostring(TargetResources[0].id)\n) on $left.UserId == $right.NewUserId\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Query for accounts seen signing in for the first time. These could be associated with stale/inactive accounts that ought to have been deleted \nbut were not and may have been subsequently compromised.\nUEBA is used to filter out based on ActivityInsights where we see certain First Time User events identified as true.\nResults for user accounts created in the last 7 days are filtered out.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LegacyAuthAttempt.yaml", "query_name": "Login attempts using Legacy Auth", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = totimespan((endtime-starttime)*7);\nlet legacy_auth_protocols = dynamic([\"Authenticated SMTP\", \"AutoDiscover\", \"Exchange ActiveSync\", \"Exchange Online PowerShell\", \"Exchange Web Services\", \"IMAP4\", \"MAPI Over HTTP\", \"Outlook Anywhere (RPC over HTTP)\", \"Outlook Service\", \"POP3\", \"Reporting Web Services\", \"Other clients\"]);\nlet legacyAuthentications =\nSigninLogs\n| where TimeGenerated >= ago(lookback)\n// success logons only\n| where ResultType == 0\n| extend ClientAppUsed = iff(isempty(ClientAppUsed)==true,\"Unknown\" ,ClientAppUsed)\n| extend isLegacyAuth = iff(ClientAppUsed in (legacy_auth_protocols), \"Yes\", \"No\")\n| where isLegacyAuth==\"Yes\";\nlegacyAuthentications\n| where TimeGenerated >= starttime\n// Don't alert for accounts already seen using legacy auth in prior 7 days\n| join kind=leftanti (\n   legacyAuthentications\n   | where TimeGenerated between(ago(lookback)..starttime)\n) on UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend LocationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\",\ntostring(LocationDetails[\"state\"]), \"/\", tostring(LocationDetails[\"city\"]))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), AttemptCount = count()\nby UserPrincipalName, ClientAppUsed, AppDisplayName, IPAddress, isLegacyAuth, tostring(OS), tostring(Browser), LocationString\n| sort by AttemptCount desc nulls last\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'This query over Azure AD sign-in activity highlights use of legacy authentication protocol in the\nenvironment. Because conditional access policies are not evaluated when legacy authentication is used,\nlegacy authentication can be used to circumvent all Azure Conditional Access policies.'\n", "techniques": ["T1078", "T1098"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LoginSpikeWithIncreaseFailureRate.yaml", "query_name": "Login spike with increase failure rate", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet failureThreshold = 15;\nlet percentageChangeThreshold = 50;\nSigninLogs\n//Collect number of users logging in for each hour\n| where TimeGenerated >= lookback\n| summarize dcount(UserPrincipalName) by bin(TimeGenerated, 1h)\n| extend hour = datetime_part(\"Hour\",TimeGenerated)\n| extend day = dayofweek(TimeGenerated)\n//Exclude Saturday and Sunday as they skew the data, change depending on your weekend days\n| where day != 6d and day != 7d\n| order by TimeGenerated asc\n//Summarise users trying to authenticate by each hour of the day\n| summarize make_list(dcount_UserPrincipalName), make_list(TimeGenerated), avg(dcount_UserPrincipalName), make_list(day) by hour\n//Find outlier hours where the number of users trying to authenticate spikes, expand and then keep only anomalous rows\n| extend series_decompose_anomalies(list_dcount_UserPrincipalName)\n| mv-expand list_dcount_UserPrincipalName, series_decompose_anomalies_list_dcount_UserPrincipalName_ad_flag, list_TimeGenerated, list_day\n| where series_decompose_anomalies_list_dcount_UserPrincipalName_ad_flag == 1\n//Calculate the percentage change between the spike and the average users authenticating\n| project TimeGenerated=todatetime(list_TimeGenerated), Hour=hour, WeekDay=list_day, AccountsAuthenticating=list_dcount_UserPrincipalName, AverageAccountsAuthenticatin=round(avg_dcount_UserPrincipalName, 0), PercentageChange = round  ((list_dcount_UserPrincipalName - avg_dcount_UserPrincipalName) / avg_dcount_UserPrincipalName * 100,   2)\n| order by PercentageChange desc\n//As an additional feature we collect successful and unsuccessful logins during the 1h windows with anomalies\n| join kind=inner(\nSigninLogs\n| where TimeGenerated >= lookback\n| where ResultType == \"0\"\n| summarize Success=dcount(UserPrincipalName), SuccessAccounts=make_set(UserPrincipalName) by bin(TimeGenerated, 1h)\n| join kind=inner(\n    SigninLogs\n    | where TimeGenerated >= lookback\n    //Failed sign-ins based on failed username/password combos or failed MFA\n    | where ResultType in (\"50126\", \"50074\", \"50057\", \"51004\")\n    | summarize Failed=dcount(UserPrincipalName), FailedAccounts=make_set(UserPrincipalName) by bin(TimeGenerated, 1h)\n) on TimeGenerated\n| project-away TimeGenerated1\n| extend Total = Failed + Success\n| project TimeGenerated, SuccessRate = round((toreal(Success) / toreal(Total)) *100) , round(FailureRate = (toreal(Failed) / toreal(Total)) *100), SuccessAccounts, FailedAccounts\n) on TimeGenerated\n| order by PercentageChange\n| project-away TimeGenerated1\n//Thresholds, 15% account authentication failure rate at a 50% increase in accounts attempting to authenticate by default\n//Comment out line below to see all anomalous results\n| where FailureRate >= failureThreshold and PercentageChange >= percentageChangeThreshold\n| extend timestamp = TimeGenerated\n", "attributes": {"description": "'This query over SiginLogs will summarise the total number of login attempts for each hour of the day on week days, this can be edited.\nThe query then uses Kusto anomaly detection to find login spikes for each hour across all days. The query will then calculate the\npercentage change between the anomalous period and the average logins for that period. Finally the query will determine the success\nand failure rate for logins for the given 1 hour period, if a specified % change in logins is detected alongside a specified failure rate\na result is presented.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/LowAndSlowPasswordAttempt.yaml", "query_name": "Low & slow password attempts with volatile IP addresses", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet timeRange = 365d;\nlet UnsuccessfulLoginCountryThreshold = 5; // Number of failed countries attempting to login, good way to filter.\nSigninLogs\n| where TimeGenerated between(starttime..endtime)\n// Limit to username/password failure errors, most common when bruteforcing/spraying\n| where ResultType has_any(\"50055\",\"50126\")\n// Find instances where an IP has only been used once\n| summarize IPLogins=count(), make_list(TimeGenerated) by IPAddress, Location, UserPrincipalName \n| where IPLogins == 1\n// We only keep instances where there is 1 event, so we know there will only be one datetime in the list\n| extend LoginAttemptTime = format_datetime(todatetime(list_TimeGenerated[0]), 'dd-MM-yyyy')\n// So far we've only collected failures, we join back to the log to ensure there were no successful logins from the IP\n| join kind=leftouter (\n    SigninLogs\n    | where TimeGenerated > ago(timeRange)\n    | where ResultType == 0\n    | summarize count() by IPAddress, UserPrincipalNameSuccess=UserPrincipalName\n) on $left.IPAddress == $right.IPAddress\n// Where there have been fewer than 2 successful logins from the IP\n| where count_ < 2 or isempty(count_)\n// Confirm that the result is for the same account where possible\n| where UserPrincipalName == UserPrincipalNameSuccess or isempty(UserPrincipalNameSuccess)\n// Summarize the collected details around the users email address\n| mv-expand list_TimeGenerated to typeof(datetime)\n| summarize IPs=dcount(IPAddress), UnsuccessfulLoginCountryCount=dcount(Location), make_list(IPAddress), make_list(Location), DaysWithAttempts=dcount(LoginAttemptTime), Failures=count(), StartTime=min(list_TimeGenerated), EndTime=max(list_TimeGenerated) by UserPrincipalName\n| project UserPrincipalName, StartTime, EndTime, Failures, IPs, UnsuccessfulLoginCountryCount, DaysWithAttempts, IPAddresses=list_IPAddress, IPAddressLocations=list_Location\n// Join back to get countries the user has successfully authenticated from to compare with failures\n| join kind=leftouter (\n    SigninLogs\n    | where TimeGenerated > ago(timeRange)\n    | where ResultType == 0\n    // If there is no location make the output pretty\n    | extend Location = iff(isempty(Location), \"NODATA\", Location)\n    | summarize SuccessfulLoginCountries=make_set(Location), SuccessfulLoginCountryCount=dcount(Location) by UserPrincipalName\n) on $left.UserPrincipalName == $right.UserPrincipalName\n| project-away UserPrincipalName1\n| order by UnsuccessfulLoginCountryCount desc\n// Calculate the difference between countries with successful vs. failed logins\n| extend IPIncreaseOnSuccess = UnsuccessfulLoginCountryCount - SuccessfulLoginCountryCount\n// The below line can be removed if the actor is using IPs in one country\n| where UnsuccessfulLoginCountryCount > UnsuccessfulLoginCountryThreshold\n| project StartTime, EndTime, UserPrincipalName, Failures, IPs, DaysWithAttempts, UnsuccessfulLoginCountryCount, UnuccessfulLoginCountries=IPAddressLocations, SuccessfulLoginCountries, FailureIPAddresses=IPAddresses\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddresses\n", "attributes": {"description": "'This hunting query will identify instances where a single user account has seen a high incidence of failed attempts from highly volatile IP addresses\n Changing IP address for every password attempt is becoming a more common technique amongst sophisticated threat groups. Often threat groups will randomise \n the user agent they are using as well as IP address. This technique has been enabled by the emergence of services providing huge numbers of residential IP \n addresses. These services are often enabled through malicious browser plugins. This query is best executed over longer timeframes.\n Reduce the timeRange if you have too much data. Results with the highest \"IPs\", \"Failures\" and \"DaysWithAttempts\" are good candidates for further\n investigation. This query intentionally does not cluster on UserAgent, IP etc. This query is clustering on the highly volatile IP behaviour.'\n", "techniques": ["T1078", "T1078.004", "T1110", "T1110.004", "T1110.003"], "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/MFAUserBlocked.yaml", "query_name": "Login attempt by Blocked MFA user", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 7d;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet MFABlocked = SigninLogs\n| where TimeGenerated between(starttime..endtime)\n| where ResultType != \"0\"\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails), Status = strcat(ResultType, \": \", ResultDescription)\n| where StatusDetails =~ \"MFA denied; user is blocked\"\n| extend Unresolved = iff(Identity matches regex isGUID, true, false);\n// Lookup up resolved identities from last 7 days\nlet identityLookup = SigninLogs\n| where TimeGenerated between(lookback..starttime)\n| where not(Identity matches regex isGUID)\n| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;\n// Join resolved names to unresolved list from MFABlocked signins\nlet unresolvedNames = MFABlocked | where Unresolved == true | join kind= inner (\n identityLookup\n) on UserId\n| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName\n| project-away lu_UserDisplayName, lu_UserPrincipalName;\n// Join Signins that had resolved names with list of unresolved that now have a resolved name\nlet u_MFABlocked = MFABlocked | where Unresolved == false | union unresolvedNames;\nu_MFABlocked\n| extend OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)\n| extend FullLocation = strcat(Location,'|', LocationDetails.state, '|', LocationDetails.city)\n| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress),\n  AttemptCount = count() by UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation , CorrelationId\n| mvexpand TimeGenerated, IPAddresses, Status\n| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)\n| project-away IPAddresses\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status,  IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'An account could be blocked if there are too many failed authentication attempts in a row. This hunting query identifies if a MFA user account that is set to blocked tries to login to Azure AD.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/multipleAADAdminRemovals.yaml", "query_name": "Multiple AAD Admins Removed", "query": "let removedAccountsThreshold = 5;\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nAuditLogs\n| where TimeGenerated between (starttime .. endtime)\n| where OperationName in~ (\"Remove member from role\", \"Remove eligible member from role\")\n| where Identity !has \"MS-PIM\"\n| extend roleName = trim('\"' , tostring(TargetResources[0].modifiedProperties[1].oldValue))\n| where roleName in~ (\"Company Administrator\", \"Global Administrator\") // Add more roles you found interesting here\n| where TargetResources[0].type =~ \"User\"\n| extend Actor = tostring(TargetResources[0].id), removedUserUpn = tostring(TargetResources[0].userPrincipalName)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), removedAccounts = dcount(removedUserUpn), removedUserUPN=make_set(removedUserUpn) by Actor\n| where removedAccounts > removedAccountsThreshold\n| extend timestamp = StartTime, AccountCustomEntity = Actor\n", "attributes": {"description": "'Looks for multiple users that had their admin role removed by a single user within a certain period.\nThe default threshold is 5 removals, this can be edited in the query.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/new_locations_azuread_signin.yaml", "query_name": "Azure Active Directory signins from new locations", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet countThreshold = 1;\nSigninLogs\n| where TimeGenerated between(starttime..endtime)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), perIdentityAuthCount = count()\nby UserPrincipalName, locationString = strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\",\ntostring(LocationDetails[\"city\"]), \";\" , tostring(LocationDetails[\"geoCoordinates\"]))\n| summarize StartTime = min(StartTimeUtc), EndTime = max(EndTimeUtc), distinctAccountCount = count(), identityList=makeset(UserPrincipalName) by locationString\n| extend identityList = iff(distinctAccountCount<10, identityList, \"multiple (>10)\")\n| join kind= anti (\nSigninLogs\n  | where TimeGenerated between(lookback..starttime)\n  | project locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\", tostring(LocationDetails[\"state\"]), \"/\",\n  tostring(LocationDetails[\"city\"]), \";\" , tostring(LocationDetails[\"geoCoordinates\"]))\n  | summarize priorCount = count() by locationString\n)\non locationString\n// select threshold above which #new accounts from a new location is deemed suspicious\n| where distinctAccountCount > countThreshold\n| mv-expand todynamic(identityList)\n| extend timestamp = StartTime, AccountCustomEntity = identityList\n", "attributes": {"description": "'New Azure Active Directory signin locations today versus historical Azure Active Directory signin data.\nIn the case of password spraying or brute force attacks one might see authentication attempts for many\naccounts from a new location.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithDeviceRegistration.yaml", "query_name": "Risky Sign-in with Device Registration", "query": "let timeDelta = 6h;\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet registeredDevices=AuditLogs\n| where TimeGenerated between (starttime .. endtime)\n| where OperationName =~ \"Add registered owner to device\" \n| where Identity =~ \"Device Registration Service\" \n| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)\n| extend AccountObjectId = tostring(TargetResources[0].id)\n| extend DeviceObjectId = trim('\"', tostring(TargetResources[0].modifiedProperties[0].newValue))\n| extend DeviceDisplayName = trim('\"', tostring(TargetResources[0].modifiedProperties[1].newValue))\n| project DeviceRegistrationTimestamp=TimeGenerated,CorrelationId,AccountUpn,AccountObjectId,DeviceObjectId,DeviceDisplayName;\nlet registeringUser= \nregisteredDevices \n| distinct AccountObjectId;\nlet hasRegisteringUser = isnotempty(toscalar(registeringUser));\nlet riskySignins=SigninLogs\n| where TimeGenerated between ((starttime-timeDelta) .. endtime)\n| where hasRegisteringUser\n| where UserId in (registeringUser) \n| where RiskLevelDuringSignIn has_any ('medium', 'high')\n| where AppDisplayName in~ (\"Office 365 Exchange Online\", \"OfficeHome\") \n| where isnotempty(Id) \n| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn \n| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;\nregisteredDevices \n| join riskySignins on AccountObjectId \n| where DeviceRegistrationTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h \n| project-away AccountObjectId1\n| extend timestamp = DeviceRegistrationTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Looks for new device registrations following a risky user account sign-in. By default the\nquery will use a 6 hour lookback period, this can be configured within the query.'\n", "techniques": ["T1078.004"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/riskSignInWithNewMFAMethod.yaml", "query_name": "Risky Sign-in with new MFA method", "query": "let timeDelta = 6h;\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet mfaMethodAdded=AuditLogs\n| where TimeGenerated between (starttime .. endtime)\n| where OperationName =~ \"Update user\" \n| where TargetResources has \"StrongAuthenticationPhoneAppDetail\"\n| extend AccountUpn = tostring(TargetResources[0].userPrincipalName)\n| extend AccountObjectId = tostring(TargetResources[0].id)\n| project MfaAddedTimestamp=TimeGenerated,AccountUpn,AccountObjectId;\nlet usersWithNewMFAMethod=mfaMethodAdded\n| distinct AccountObjectId;\nlet hasusersWithNewMFAMethod = isnotempty(toscalar(usersWithNewMFAMethod));\nlet riskySignins=SigninLogs\n| where TimeGenerated between ((starttime-timeDelta) .. endtime)\n| where hasusersWithNewMFAMethod\n| where UserId in (usersWithNewMFAMethod) \n| where RiskLevelDuringSignIn has_any ('medium', 'high')\n| where AppDisplayName in~ (\"Office 365 Exchange Online\", \"OfficeHome\") \n| where isnotempty(Id) \n| project SignInTimestamp=TimeGenerated, AppDisplayName, CorrelationId, AccountObjectId=UserId, IPAddress, RiskLevelDuringSignIn \n| summarize SignInTimestamp=argmin(SignInTimestamp,*) by AppDisplayName, CorrelationId, AccountObjectId, IPAddress, RiskLevelDuringSignIn;\nmfaMethodAdded \n| join riskySignins on AccountObjectId \n| where  MfaAddedTimestamp - SignInTimestamp < timeDelta //Time delta between risky sign-in and device registration less than 6h \n| project-away AccountObjectId1\n| extend timestamp = MfaAddedTimestamp, AccountCustomEntity = AccountUpn, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Looks for a new MFA method added to an account that was preceded by medium or high risk\nsign-in session for the same user within maximum 6h timeframe'\n", "techniques": ["T1078.004"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/signinBurstFromMultipleLocations.yaml", "query_name": "Azure Active Directory sign-in burst from multiple locations", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet common_locations = (SigninLogs\n  | where TimeGenerated between(starttime..endtime)\n  | extend locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\",\n  tostring(LocationDetails[\"state\"]))\n  | where locationString != \"//\"\n  | summarize count() by locationString\n  | take 100\n  | project locationString);\nlet signIns = (SigninLogs\n  | where TimeGenerated between(starttime..endtime)\n  | extend locationString= strcat(tostring(LocationDetails[\"countryOrRegion\"]), \"/\",\n  tostring(LocationDetails[\"state\"]))\n  | where locationString != \"//\" and locationString !endswith \"/\"\n  | where locationString !in (common_locations));\n// Adjust these to tune query\nlet lookupWindow = 10m;\nlet lookupBin = lookupWindow / 2.0; // lookup bin = equal to 1/2 of the lookup window\nlet threshold = 2;\nlet users = (signIns\n| summarize dcount(locationString) by Identity\n| where dcount_locationString > threshold\n| project Identity);\n  signIns\n  | where Identity in (users)\n  | project-rename Start=TimeGenerated\n  | extend TimeKey = bin(Start, lookupBin)\n  | join kind = inner (\n  signIns\n  | project-rename End=TimeGenerated, EndLocationString=locationString\n    // TimeKey on the right side of the join - emulates this authentication appearing several times\n    | extend TimeKey = range(bin(End - lookupWindow, lookupBin),\n    bin(End, lookupBin), lookupBin)\n    | mvexpand TimeKey to typeof(datetime) // translate TimeKey arrange range to a column\n  ) on Identity, TimeKey\n  | where End > Start\n  | project tostring(Start), tostring(End), locationString, EndLocationString, UserPrincipalName, timeSpan = End - Start, Identity, IPAddress, UserAgent\n  | where locationString != EndLocationString\n  | summarize ips=makeset(IPAddress), UAs=makeset(UserAgent) by timeSpan, Identity, locationString, EndLocationString, Start, End, UserPrincipalName\n  | extend timestamp = Start, AccountCustomEntity = UserPrincipalName\n  | order by Identity\n", "attributes": {"description": "'Highlights accounts associated with multiple authentications from different geographical locations in a short period of time.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SignInLogsWithExpandedPolicies.yaml", "query_name": "Signin Logs with expanded Conditional Access Policies", "query": "\nSigninLogs \n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend ConditionalAccessPol0Name = tostring(ConditionalAccessPolicies[0].displayName), ConditionalAccessPol0Result = tostring(ConditionalAccessPolicies[0].result)\n| extend ConditionalAccessPol1Name = tostring(ConditionalAccessPolicies[1].displayName), ConditionalAccessPol1Result = tostring(ConditionalAccessPolicies[1].result)\n| extend ConditionalAccessPol2Name = tostring(ConditionalAccessPolicies[2].displayName), ConditionalAccessPol2Result = tostring(ConditionalAccessPolicies[2].result)\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)\n| extend Date = startofday(TimeGenerated), Hour = datetime_part(\"Hour\", TimeGenerated)\n| summarize count() by Date, Identity, UserDisplayName, UserPrincipalName, IPAddress, ResultType, ResultDescription, StatusCode, StatusDetails, \nConditionalAccessPol0Name, ConditionalAccessPol0Result, ConditionalAccessPol1Name, ConditionalAccessPol1Result, ConditionalAccessPol2Name, ConditionalAccessPol2Result, \nLocation, State, City\n| extend timestamp = Date, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n| sort by Date \n", "attributes": {"description": "'Example query for SigninLogs showing how to break out packed fields.  In this case extending conditional access Policies '\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/Signins-from-NordVPN-Providers.yaml", "query_name": "Signins from Nord VPN Providers", "query": "let nord_vpn_feed = (externaldata(id:int,ip_address: string,search_keywords: dynamic,categories:dynamic,name: string,domain:string,price:int,flag:string,country:string,location:dynamic ,load: int ,features:dynamic)\n  [@\"https://raw.githubusercontent.com/microsoft/mstic/master/nordvpn-servers.csv\"] with (format=\"csv\", ignoreFirstRecord=True));\nSigninLogs \n  | where TimeGenerated > ago(4h) \n  | where ResultType == 0 \n  | summarize TotalEvents = count(), AppList = make_set(AppDisplayName),  StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by IPAddress, UserPrincipalName, ClientAppUsed, ConditionalAccessStatus, AuthenticationRequirement, RiskDetail \n  | join kind= inner nord_vpn_feed on $left.IPAddress == $right.ip_address\n  | project StartTime , EndTime, IPAddress, UserPrincipalName, AppList, ClientAppUsed, ConditionalAccessStatus, AuthenticationRequirement, RiskDetail, categories, domain, country\n  | extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'This query looks for sign-in activity from Nord VPN providers using the Public feed leveraging NordVPN API which is updated daily. \nInvestigation any unknown sign-in attempts from VPN providers such as Nord VPN unless it is commonly seen from users in the organization'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/Signins-From-VPS-Providers.yaml", "query_name": "Signins From VPS Providers", "query": "\nlet IP_Data = (externaldata(network:string)\n[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/VPS_Networks.csv\"] with (format=\"csv\"));\nSigninLogs\n| where ResultType == 0\n| extend additionalDetails = tostring(Status.additionalDetails)\n| evaluate ipv4_lookup(IP_Data, IPAddress, network, return_unmatched = false)\n| summarize make_set(additionalDetails), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by IPAddress, UserPrincipalName\n// Uncomment the remaining lines to only see logons from VPS providers with token only logons.\n//| where array_length(set_additionalDetails) == 2\n//| where (set_additionalDetails[1] == \"MFA requirement satisfied by claim in the token\" and set_additionalDetails[0] == \"MFA requirement satisfied by claim provided by external provider\") or (set_additionalDetails[0] == \"MFA requirement satisfied by claim in the token\" and set_additionalDetails[1] == \"MFA requirement satisfied by claim provided by external provider\")\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Looks for successful logons from known VPS provider network ranges with suspicious token based logon patterns.\nThis is not an exhaustive list of VPS provider ranges but covers some of the most prevelent providers observed.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SmartLockouts.yaml", "query_name": "Smart Lockouts", "query": "SigninLogs\n| where ResultType == 50053\n| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Identifies accounts that have been locked out by smart lockout policies. Review this results for patterns that might suggest that a password spray is triggering these smart lockout events.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SpikeInFailedSignInAttempts.yaml", "query_name": "Spike in failed sign-in events", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet auditLookback = starttime - 14d;\nlet ts_data = (SigninLogs\n| where TimeGenerated between (auditLookback..endtime)\n| where ResultType != 0\n| make-series count() on TimeGenerated step 1h by UserPrincipalName\n| extend series_decompose(count_)\n| extend NoLogons = count_);\nlet TimeSeriesAlerts=ts_data\n  | extend (anomalies, score, baseline) = series_decompose_anomalies(count_, 1.5, -1, 'linefit',0, 'ctukey', 0.7)\n  | mv-expand NoLogons to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)\n  | where anomalies > 0\n  | project UserPrincipalName, TimeGenerated, NoLogons, baseline, anomalies, score;\nTimeSeriesAlerts\n  | join kind=inner (\n  SigninLogs\n  | where TimeGenerated between (auditLookback..endtime)\n  | summarize ResultTypeCount=count(),ResultTypes=make_set(ResultType), Locations=make_set(Location), Apps=make_set(AppDisplayName), Ips=make_set( IPAddress) by UserPrincipalName, bin(TimeGenerated, 1h)\n  ) on UserPrincipalName, TimeGenerated\n  | summarize AnomolyTimes = make_set(TimeGenerated), Ips = make_set(Ips), Apps = make_set(Apps), sum(anomalies), Locations=make_set(Locations) by UserPrincipalName\n  | sort by sum_anomalies desc\n  | extend timestamp = tostring(AnomolyTimes[0]), AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'Identifies spikes in failed sign-in events based on the volume of failed sign-in events over time. Use to identify patterns of suspicious behavior such as unusually high failed sign-in attempts from certain users.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuccessfulAccount-SigninAttemptsByIPviaDisabledAccounts.yaml", "query_name": "Sign-ins from IPs that attempt sign-ins to disabled accounts", "query": "let threshold = 100;\nSigninLogs \n| where ResultType == \"50057\" \n| where ResultDescription == \"User account is disabled. The account has been disabled by an administrator.\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), disabledAccountLoginAttempts = count(), \ndisabledAccountsTargeted = dcount(UserPrincipalName), applicationsTargeted = dcount(AppDisplayName), disabledAccountSet = makeset(UserPrincipalName), \napplicationSet = makeset(AppDisplayName) by IPAddress\n| order by disabledAccountLoginAttempts desc\n| join kind= leftouter (\n    // Consider these IPs suspicious - and alert any related  successful sign-ins\n    SigninLogs\n    | where ResultType == 0\n    | summarize successSigninStart = min(TimeGenerated), successSigninEnd = max(TimeGenerated), successfulAccountSigninCount = dcount(UserPrincipalName), successfulAccountSigninSet = makeset(UserPrincipalName, 15) by IPAddress\n    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe\n    | where successfulAccountSigninCount < threshold\n) on IPAddress  \n// IPs from which attempts to authenticate as disabled user accounts originated, and had a non-zero success rate for some other account\n| where successfulAccountSigninCount != 0\n// Successful Account Signins occur within the same lookback period as the failed \n| extend SuccessBeforeFailure = iff(successSigninStart >= StartTime and successSigninEnd <= EndTime, true, false)  \n| project StartTime, EndTime, IPAddress, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet, \nsuccessfulAccountSigninCount, successfulAccountSigninSet\n| order by disabledAccountLoginAttempts\n// Break up the string of Succesfully signed into accounts into individual events\n| mvexpand successfulAccountSigninSet\n| extend timestamp = StartTime, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Identifies IPs with failed attempts to sign in to one or more disabled accounts signed in successfully to another account.\nThis analytic will additionally identify the successful signed in accounts as the mapped account entities for investigation.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n50057 - User account is disabled. The account has been disabled by an administrator.'\n", "techniques": ["T1078", "T1098"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuccessfulSigninFromNon-CompliantDevice.yaml", "query_name": "Successful Signin From Non-Compliant Device", "query": "SigninLogs\n  | where ResultType == 0\n  | where tostring(DeviceDetail.isCompliant) == \"false\"\n", "attributes": {"description": "'Detects successful sign ins from devices marked non-compliant.\n  Best practice is to block sign ins from non-complaint devices, however if allowed monitor these events to ensure they do not lead to other risky activity.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-devices#non-compliant-device-sign-in'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuccessThenFail_SameUserDiffApp.yaml", "query_name": "Same User - Successful logon for a given App and failure on another App within 1m and low distribution", "query": "\nlet logonDiff = 1m;\nlet Success = SigninLogs\n| where ResultType == \"0\"\n| where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\", \"Office 365 SharePoint Online\")\n| project SuccessLogonTime = TimeGenerated, UserPrincipalName, IPAddress , SuccessAppDisplayName = AppDisplayName;\nlet Fail = SigninLogs\n| where ResultType !in (\"0\", \"50140\")\n| where ResultDescription !~ \"Other\"\n| where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\", \"Office 365 SharePoint Online\")\n| project FailedLogonTime = TimeGenerated, UserPrincipalName, IPAddress , FailedAppDisplayName = AppDisplayName, ResultType, ResultDescription;\nlet InitialDataSet =\nSuccess | join kind= inner (\nFail\n) on UserPrincipalName, IPAddress\n| where isnotempty(FailedAppDisplayName)\n| where SuccessLogonTime < FailedLogonTime and FailedLogonTime - SuccessLogonTime <= logonDiff and SuccessAppDisplayName != FailedAppDisplayName;\nlet InitialHits =\nInitialDataSet\n| summarize FailedLogonTime = min(FailedLogonTime), SuccessLogonTime = min(SuccessLogonTime)\nby UserPrincipalName, SuccessAppDisplayName, FailedAppDisplayName, IPAddress, ResultType, ResultDescription;\n// Only take hits where there is 5 or less distinct AppDisplayNames on the success side as this limits highly active applications where failures occur more regularly\nlet Distribution =\nInitialDataSet\n| summarize count(SuccessAppDisplayName) by SuccessAppDisplayName, ResultType\n| where count_SuccessAppDisplayName <= 5;\nInitialHits | join (\n   Distribution\n) on SuccessAppDisplayName, ResultType\n| project UserPrincipalName, SuccessLogonTime, IPAddress, SuccessAppDisplayName, FailedLogonTime, FailedAppDisplayName, ResultType, ResultDescription\n| extend timestamp = SuccessLogonTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'This identifies when a user account successfully logs onto a given App and within 1 minute fails to logon to a different App.\nThis may indicate a malicious attempt at accessing disallowed Apps for discovery or potential lateral movement'\n", "techniques": ["T1087", "T1021"], "tactics": ["Discovery", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/SuspiciousSignintoPrivilegedAccount.yaml", "query_name": "Suspicious Sign-in to Privileged Account", "query": "let priv_users = ('_GetWatchlist(\"VIPUsers\")') ;\n(union isfuzzy=true\n(SigninLogs //when a device is registered/joined without MFA \n| where AuthenticationRequirement == \"multiFactorAuthentication\"\n| where ResourceDisplayName == \"Device Registration Service\" \n| where ConditionalAccessStatus == \"success\"\n| extend AccountName = tolower(split(UserPrincipalName, \"@\")[0]), WinSecEventDomain = \"-\"\n| where AccountName in (priv_users)\n| project-rename  ServiceOrSystem = AppDisplayName, ClientIP = IPAddress), \n(\n(SigninLogs //Sign-ins by non-compliant devices\n| where DeviceDetail.isCompliant == false\n| where ConditionalAccessStatus == \"success\"\n  | extend AccountName = tolower(split(UserPrincipalName, \"@\")[0]), WinSecEventDomain = \"-\"\n  | where AccountName in (priv_users)\n  | project-rename  ServiceOrSystem = AppDisplayName, ClientIP = IPAddress)\n),\n(SigninLogs //Sign-ins by unknown devices\n| where isempty(DeviceDetail.deviceId)\n| where AuthenticationRequirement == \"singleFactorAuthentication\"\n| where ResultType == \"0\"\n| where NetworkLocationDetails == \"[]\"\n| extend AccountName = tolower(split(UserPrincipalName, \"@\")[0]), WinSecEventDomain = \"-\"\n| where AccountName in (priv_users)\n| project-rename  ServiceOrSystem = AppDisplayName, ClientIP = IPAddress)\n)\n| project AccountCustomEntity = AccountName, AppId, Category, IPCustomEntity = ClientIP, CorrelationId, ResourceCustomEntity = ResourceId, Identity\n", "attributes": {"description": "'This query will help detect any Sign-in's from non-compliant device/device registered without MFA(Multi-factor Authentication)/unknown device to privileged account using pre-built watchlist to identify accounts.\nMicrosoft Sentinel now provides built-in watchlist templates, that can be customized for your environment and used during investigations.\nReference: https://techcommunity.microsoft.com/t5/azure-sentinel/what-s-new-watchlists-templates-are-now-in-public-preview/ba-p/2614340'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UnauthUser_AzurePortal.yaml", "query_name": "Failed attempt to access Azure Portal", "query": "\nSigninLogs\n| where AppDisplayName contains \"Azure Portal\"\n// 50126 - Invalid username or password, or invalid on-premises username or password.\n// 50020? - The user doesn't exist in the tenant.\n| where ResultType in ( \"50126\" , \"50020\")\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), IPAddresses = makeset(IPAddress), DistinctIPCount = dcount(IPAddress), \nmakeset(OS), makeset(Browser), makeset(City), AttemptCount = count() \nby UserDisplayName, UserPrincipalName, AppDisplayName, ResultType, ResultDescription, StatusCode, StatusDetails, Location, State\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName\n| sort by AttemptCount\n", "attributes": {"description": "'Access attempts to Azure Portal from an unauthorized user. Either invalid password or the user account does not exist.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-BlockedAccounts.yaml", "query_name": "User Accounts - Blocked Accounts", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 7d;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet aadFunc = (tableName:string){\n  table(tableName)\n  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n  | where not(Identity matches regex isGUID)\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nlet blocked_users = \nunion isfuzzy=true aadSignin, aadNonInt \n// Blocked or locked account due to failed attempts for various reasons.\n| where ResultType != \"0\"\n| where ResultDescription has_any (\"blocked\", \"locked\")  or ResultType in (50053, 50131, 53003, 500121)\n| summarize FirstBlockedAttempt = min(TimeGenerated), LastBlockedAttempt = max(TimeGenerated) by UserPrincipalName, ResultDescription, ResultType;\nblocked_users\n| join kind= inner (\nunion isfuzzy=true aadSignin, aadNonInt\n| where ResultType == 0\n| summarize FirstSuccessfulSignin = min(TimeGenerated), LastSuccessfulSignin = max(TimeGenerated), make_set(IPAddress), make_set(ClientAppUsed), make_set(UserAgent), make_set(AppDisplayName) by UserPrincipalName, UserDisplayName\n) on UserPrincipalName\n| where LastSuccessfulSignin > LastBlockedAttempt //Checking if successul login is after lastblockedattempts\n| extend timestamp = LastSuccessfulSignin, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'An account could be blocked/locked out due to multiple reasons. This hunting query summarize blocked/lockout accounts and checks if most recent signin events for them is after last blocked accounts\nRef: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-NewSingleFactorAuth.yaml", "query_name": "User Accounts - New Single Factor Auth", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet lookback = starttime - 7d;\nlet aadFunc = (tableName:string){\n  table(tableName)\n  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n  | where not(Identity matches regex isGUID)\n  | where ResultType == 0\n  | where AuthenticationDetails != \"[]\"\n  | extend AuthenticationMethod = tostring(todynamic(AuthenticationDetails)[0].authenticationMethod)\n  | where AuthenticationMethod != \"Previously satisfied\"\n  | summarize count(), make_set(AuthenticationRequirement), make_set(AuthenticationMethod), make_set(IPAddress), make_set(Location), LastLogin = max(TimeGenerated) by UserPrincipalName\n  | extend noofAuthMehods = array_length(set_AuthenticationMethod), noofAuthReqs = array_length(set_AuthenticationRequirement)\n  | where noofAuthMehods > 1 or noofAuthReqs > 1\n  | extend timestamp = LastLogin, AccountCustomEntity = UserPrincipalName\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt \n", "attributes": {"description": "'Identifies users whose single Factor Auth Events in scenarios where it has not been seen before, or where only multi factor auth has been observed.\nRef: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccounts-UnusualLogonTimes.yaml", "query_name": "User Accounts - Unusual authentications occurring when countries do not conduct normal business operations.", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet userthreshold = 25;\nlet HistLogons = SigninLogs\n| where IsInteractive == true\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)\n| extend DayofWeek = case(\n  DayNumberofWeek == \"00:00:00\", \"Sunday\", \n  DayNumberofWeek == \"1.00:00:00\", \"Monday\", \n  DayNumberofWeek == \"2.00:00:00\", \"Tuesday\", \n  DayNumberofWeek == \"3.00:00:00\", \"Wednesday\", \n  DayNumberofWeek == \"4.00:00:00\", \"Thursday\", \n  DayNumberofWeek == \"5.00:00:00\", \"Friday\", \n  DayNumberofWeek == \"6.00:00:00\", \"Saturday\",\"InvalidTimeStamp\")\n| summarize UserCount = dcount(UserPrincipalName) by HourOfLogin, Location, DayofWeek\n| where UserCount > userthreshold;\nHistLogons\n| join kind = rightanti (\nSigninLogs\n| where IsInteractive == true\n| where TimeGenerated > ago(1d)\n| extend HourOfLogin = hourofday(TimeGenerated), DayNumberofWeek = dayofweek(TimeGenerated)\n| extend DayofWeek = case(\n  DayNumberofWeek == \"00:00:00\", \"Sunday\", \n  DayNumberofWeek == \"1.00:00:00\", \"Monday\", \n  DayNumberofWeek == \"2.00:00:00\", \"Tuesday\", \n  DayNumberofWeek == \"3.00:00:00\", \"Wednesday\", \n  DayNumberofWeek == \"4.00:00:00\", \"Thursday\", \n  DayNumberofWeek == \"5.00:00:00\", \"Friday\", \n  DayNumberofWeek == \"6.00:00:00\", \"Saturday\",\"InvalidTimeStamp\")\n  | summarize count(), FirstSuccessfulSignin = min(TimeGenerated), LastSuccessfulSignin = max(TimeGenerated), make_set(IPAddress), make_set(ClientAppUsed), make_set(UserAgent), make_set(AppDisplayName) by HourOfLogin, Location, DayofWeek, UserPrincipalName\n  ) on Location, DayofWeek , HourOfLogin\n  | extend timestamp = LastSuccessfulSignin, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'Identifies users whose single Factor Auth Events in scenarios where it has not been seen before, or where only multi factor auth has been observed.\nRef: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserAccountsMeasurableincreaseofsuccessfulsignins.yaml", "query_name": "User Accounts - Successful Sign in Spikes", "query": "let starttime = 14d;\nlet timeframe = 1d;\nlet scorethreshold = 5;\nlet baselinethreshold = 25;\nlet aadFunc = (tableName:string){\n  // Succesful signins.\n  table(tableName)\n  | where TimeGenerated between (startofday(ago(starttime))..startofday(ago(timeframe)))\n  | where ResultType == 0\n  | extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nlet allSignins = union isfuzzy=true aadSignin, aadNonInt ;\nlet TimeSeriesData = union isfuzzy=true aadSignin, aadNonInt \n| project TimeGenerated, UserPrincipalName\n| make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by UserPrincipalName\n| project  TimeGenerated, UserPrincipalName, HourlyCount;\nlet TimeSeriesAlerts = TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')\n| mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)\n| where anomalies > 0 | extend AnomalyHour = TimeGenerated\n| where baseline > baselinethreshold // Filtering low count events per baselinethreshold\n| project UserPrincipalName, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;\nlet AnomalyHours = TimeSeriesAlerts | where TimeGenerated > ago(2d) | project TimeGenerated;\n// Filter the alerts for specified timeframe\nTimeSeriesAlerts\n| where TimeGenerated > ago(2d)\n| join kind=inner ( \nunion isfuzzy=true aadSignin, aadNonInt\n| where TimeGenerated > ago(2d)\n| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour\n| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours\n | summarize HourlyCount=count(), LatestAnomalyTime = arg_max(timestamp,*) by bin(TimeGenerated,1h),  OperationName, Category, ResultType, ResultDescription, UserPrincipalName, UserDisplayName, AppDisplayName, ClientAppUsed, IPAddress, ResourceDisplayName\n) on UserPrincipalName\n| project LatestAnomalyTime,  OperationName, Category, UserPrincipalName, UserDisplayName, ResultType, ResultDescription, AppDisplayName, ClientAppUsed, UserAgent, IPAddress, Location, AuthenticationRequirement, ConditionalAccessStatus, ResourceDisplayName, HourlyCount, baseline, anomalies, score\n| extend timestamp = LatestAnomalyTime, IPCustomEntity = IPAddress, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "' Identifies measureable increase in successful sign-ins from user accounts.\nSpike is determined based on Time series anomaly which will look at historical baseline values.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-successful-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SigninLogs/UserLoginIPAddressTeleportation.yaml", "query_name": "User Login IP Address Teleportation", "query": "\nlet windowTime = 20min / 2; //Window to lookup anomalous logins within\nlet excludeKnownVPN = dynamic(['127.0.0.1', '0.0.0.0']); //Known VPN IP addresses to exclude\nSigninLogs\n| where ConditionalAccessStatus =~ \"success\"\n| extend country = LocationDetails['countryOrRegion']\n| where country != \"\"\n| summarize count() by tostring(country)\n| join (\n    //Get the total number of logins from any country and join it to the previous count in a single table\n    SigninLogs\n    | where ConditionalAccessStatus =~ \"success\"\n    | extend country = LocationDetails['countryOrRegion']\n    | where country != \"\"\n    | summarize count(), make_list(tostring(country))\n    | mv-expand list_country\n    | extend country = tostring(list_country)\n) on country\n| summarize by country, count_, count_1\n//Now calculate each countries prevalence within login events\n| extend prevalence = toreal(count_) / toreal(count_1) * 100\n| project-away count_1\n| where prevalence < 0.01\n| join kind=rightsemi(\n    SigninLogs\n    //Enable to limit to o365 exchange logins\n    //| where AppDisplayName =~ \"Office 365 Exchange Online\"\n    | where ConditionalAccessStatus =~ \"success\"\n    | where IPAddress != \"\"\n    | extend country = tostring(LocationDetails['countryOrRegion'])\n    | summarize count() by TimeGenerated, UserPrincipalName, country, IPAddress\n) on country\n| join kind=leftouter (\n    SigninLogs\n    //Enable to limit to o365 exchange logins\n    //| where AppDisplayName =~ \"Office 365 Exchange Online\"\n    | where ConditionalAccessStatus =~ \"success\"\n    | extend country = tostring(LocationDetails['countryOrRegion'])\n    | summarize by TimeGenerated, IPAddress, UserPrincipalName, country\n) on UserPrincipalName\n| where IPAddress != IPAddress1 and country != country1\n| extend WindowStart = TimeGenerated1 - windowTime\n| extend WindowEnd = TimeGenerated1 + windowTime\n| where TimeGenerated between (WindowStart .. WindowEnd)\n| project Account=UserPrincipalName, AnomalousIP=IPAddress, AnomalousLoginTime=TimeGenerated, AnomalousCountry=country, OtherLoginIP=IPAddress1, OtherLoginCountry=country1, OtherLoginWindowStart=WindowStart, OtherLoginWindowEnd=WindowEnd\n| where AnomalousIP !in(excludeKnownVPN) and OtherLoginIP !in(excludeKnownVPN)\n| extend timestamp = AnomalousLoginTime, AccountCustomEntity = Account, IPCustomEntity = AnomalousIP\n", "attributes": {"description": "'This query over SiginLogs will identify user accounts that have logged in from two different countries\nwithin a specified time window, by default this is a 10 minute window either side of the previous login.\nThis query will detect users roaming onto VPNs, it is possible to exclude known VPN IP address ranges.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-Failed%20SQL%20Logons.yaml", "query_name": "Failed Logon Attempts on SQL Server", "query": "\n// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.\n// The underlying table where the data exists is the Event table.\nSQLEvent\n| where LogonResult has \"failed\"\n| summarize count() by TimeGenerated, CurrentUser, Reason, ClientIP\n| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP\n", "attributes": {"description": "This query is based on the SQLEvent KQL Parser function (link below) and detects failed logons on SQL Server \nSQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever\nDetailed blog post on Monitoring SQL Server with Microsoft Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-MultipleFailedLogon_FromSameIP.yaml", "query_name": "Failed Logon on SQL Server from Same IPAddress in Short time Span", "query": "\n// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.\n// The underlying table where the data exists is the Event table.\n// the threshold can be changed below as per requirement.\n//\nlet failedThreshold = 3;\nSQLEvent\n| where LogonResult has \"failed\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), TotalFailedLogons = count() by ClientIP, CurrentUser, Computer\n| where TotalFailedLogons >= failedThreshold\n| project StartTime, ClientIP, TotalFailedLogons, CurrentUser, Computer\n| extend timestamp = StartTime, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP", "attributes": {"description": "This hunitng query identifies multiple failed logon attempts from same IP within short span of time.\nThis query is based on the SQLEvent KQL Parser function (link below)\nSQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever\nDetailed blog post on Monitoring SQL Server with Microsoft Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-MultipleFailedLogon_InShortSpan.yaml", "query_name": "Multiple Failed Logon on SQL Server in Short time Span", "query": "\n// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.\n// The underlying table where the data exists is the Event table.\n// the threshold can be changed below as per requirement\n//\nlet failedThreshold = 3;\nSQLEvent\n| where LogonResult has \"failed\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), TotalFailedLogons = count() by CurrentUser, ClientIP\n| where TotalFailedLogons >= failedThreshold\n| project StartTime, CurrentUser, TotalFailedLogons, ClientIP\n| extend timestamp = StartTime, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP", "attributes": {"description": "This hunting queries looks for multiple failed logon attempts in short span of time.\nThis query is based on the SQLEvent KQL Parser function (link below)\nSQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever\nDetailed blog post on Monitoring SQL Server with Microsoft Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-New_UserCreated.yaml", "query_name": "New User created on SQL Server", "query": "\n// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.\n// The underlying table where the data exists is the Event table.\n// This query checks for new user account created on SQL Server using the SQLEvent() parser\n//\nSQLEvent\n| where Statement has \"Create Login\"\n| parse Statement with \"CREATE LOGIN [\" TargetUser:string \"]\" *\n| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement\n| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP ", "attributes": {"description": "This hunting query identifies creation of a new user from SQL Server\nThis query is based on the SQLEvent KQL Parser function (link below) \nSQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever\nDetailed blog post on Monitoring SQL Server with Microsoft Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserAdded_to_SecurityAdmin.yaml", "query_name": "User added to SQL Server SecurityAdmin Group", "query": "\n// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.\n// The underlying table where the data exists is the Event table.\n// This query tracks user added into SecurityAdmingroup\nSQLEvent\n| where Statement has \"Alter Server role\" and Statement has \"add member\"\n| parse Statement with * \"ADD MEMBER [\" TargetUser:string \"]\" *\n| where ObjectName has \"securityadmin\"\n| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement \n| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP ", "attributes": {"description": "This hunting query identifies user added in the SecurityAdmin group of SQL Server\nThis query is based on the SQLEvent KQL Parser function (link below)\nSQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever\nDetailed blog post on Monitoring SQL Server with Microsoft Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserDeletedFromDatabase.yaml", "query_name": "SQL User deleted from Database", "query": "\n// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.\n// The underlying table where the data exists is the Event table.\n// This query checks for user removed from a database by parsing the statement field at the query time.\n//\nSQLEvent\n| where Statement has \"Alter role\" and Statement has \"drop member\"\n| parse Statement with * \"DROP MEMBER [\" TargetUser:string \"]\" *\n| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement\n| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP  ", "attributes": {"description": "This hunting query identifies deletion of user from SQL Database\nThis query is based on the SQLEvent KQL Parser function (link below)\nSQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever\nDetailed blog post on Monitoring SQL Server with Microsoft Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960\n", "techniques": ["T1098", "T1078", "T1496"], "tactics": ["Persistence", "PrivilegeEscalation", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserRemovedFromSecurityAdmin.yaml", "query_name": "User removed from SQL Server SecurityAdmin Group", "query": "\n// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.\n// The underlying table where the data exists is the Event table.\n// This query checks for user removed from SecurityAdmin Role\nSQLEvent\n| where Statement has \"Alter Server role\" and Statement has \"drop member\"\n| parse Statement with * \"DROP MEMBER [\" TargetUser:string \"]\" *\n| where ObjectName has \"securityadmin\"\n| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement \n| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP  ", "attributes": {"description": "This hunting query identifies user removed from the SecurityAdmin group of SQL Server\nThis query is based on the SQLEvent KQL Parser function (link below) \nSQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever\nDetailed blog post on Monitoring SQL Server with Microsoft Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960\n", "techniques": ["T1098", "T1078", "T1496"], "tactics": ["Persistence", "PrivilegeEscalation", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserRemovedFromServerRole.yaml", "query_name": "User removed from SQL Server Roles", "query": "\n// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.\n// The underlying table where the data exists is the Event table.\n// This query checks for user removed from a ServerRole\nSQLEvent\n| where Statement has \"Alter Server role\" and Statement has \"drop member\"\n| parse Statement with * \"DROP MEMBER [\" TargetUser:string \"]\" *\n| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement \n| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP  ", "attributes": {"description": "This hunting query identifies user removed from a SQL Server Role.\nThis query is based on the SQLEvent KQL Parser function (link below) \nSQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever\nDetailed blog post on Monitoring SQL Server with Microsoft Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960\n", "techniques": ["T1098", "T1078", "T1496"], "tactics": ["Persistence", "PrivilegeEscalation", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/SQLServer/SQL-UserRoleChanged.yaml", "query_name": "User Role altered on SQL Server", "query": "\n// SQLEvent is not the table name, it is the function name that should already be imported into your workspace.\n// The underlying table where the data exists is the Event table.\n// This query looking for Alter role commands and extracts username which was altered and target objectName\nSQLEvent\n| where Statement contains \"Alter role\" and Statement has \"add member\"\n| parse Statement with * \"ADD MEMBER [\" TargetUser:string \"]\" *\n| project TimeGenerated, Computer, Action, ClientIP, CurrentUser, DatabaseName, TargetUser, ObjectName, Statement\n| extend timestamp = TimeGenerated, AccountCustomEntity = CurrentUser, IPCustomEntity = ClientIP  \n", "attributes": {"description": "This hunting query identifies user role altered on SQL Server\nThis query is based on the SQLEvent KQL Parser function (link below) \nSQLEvent KQL Parser provided at https://github.com/Azure/Azure-Sentinel/tree/master/Parsers/SQLSever\nDetailed blog post on Monitoring SQL Server with Microsoft Sentinel https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-sql-server-with-azure-sentinel/ba-p/1502960\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/CryptoCurrencyMiners.yaml", "query_name": "Crypto currency miners EXECVE", "query": "// Extract EventType and EventData from AUOMS Syslog message\nSyslog\n| parse SyslogMessage with \"type=\" EventType \" audit(\" * \"): \" EventData\n| project TimeGenerated, EventType, Computer, EventData \n// Extract AUOMS_EXECVE details from EventData\n| where EventType =~ \"AUOMS_EXECVE\"\n| parse EventData with * \"syscall=\" syscall \" syscall_r=\" * \" success=\" success \" exit=\" exit \" a0\" * \" ppid=\" ppid \" pid=\" pid \" audit_user=\" audit_user \" auid=\" auid \" user=\" user \" uid=\" uid \" group=\" group \" gid=\" gid \"effective_user=\" effective_user \" euid=\" euid \" set_user=\" set_user \" suid=\" suid \" filesystem_user=\" filesystem_user \" fsuid=\" fsuid \" effective_group=\" effective_group \" egid=\" egid \" set_group=\" set_group \" sgid=\" sgid \" filesystem_group=\" filesystem_group \" fsgid=\" fsgid \" tty=\" tty \" ses=\" ses \" comm=\\\"\" comm \"\\\" exe=\\\"\" exe \"\\\"\" * \"cwd=\\\"\" cwd \"\\\"\" * \"name=\\\"\" name \"\\\"\" * \"cmdline=\\\"\" cmdline \"\\\" containerid=\" containerid\n// Find wget and curl commands\n| where comm in (\"wget\", \"curl\")\n// Find command lines featuring known crypto currency miner names\n| where cmdline contains \"nicehashminer\" or cmdline contains \"ethminer\" or cmdline contains \"equihash\" or cmdline contains \"NsCpuCNMiner64\" or cmdline contains \"minergate\" or cmdline contains \"minerd\" or cmdline contains \"cpuminer\" or cmdline contains \"xmr-stak-cpu\" or cmdline contains \"xmrig\" or cmdline contains \"stratum+tcp\" or cmdline contains \"cryptonight\" or cmdline contains \"monero\" or cmdline contains \"oceanhole\" or cmdline contains \"dockerminer\" or cmdline contains \"xmrdemo\"\n| project TimeGenerated, Computer, audit_user, user, cmdline\n| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated\n| sort by TimeGenerated desc\n", "attributes": {"description": "'This query hunts through EXECVE syslog data generated by AUOMS to find instances of crypto currency miners being\ndownloaded.  It returns a table of suspicious command lines.\nFind more details on collecting EXECVE data into Microsoft Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'\n", "techniques": ["T1059", "T1053"], "tactics": ["Persistence", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/disabled_account_squid_usage.yaml", "query_name": "Disabled accounts using Squid proxy", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet disabledAccounts = (){\nSigninLogs\n| where TimeGenerated between(lookback..starttime)\n| where ResultType == 50057\n| where ResultDescription =~ \"User account is disabled. The account has been disabled by an administrator.\"\n};\nlet proxyEvents = (){\nSyslog\n| where TimeGenerated between(starttime..endtime)\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage),\n         SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage),\n         Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage),\n         HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n         User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n         RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n         Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n         Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n         contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n};\nproxyEvents\n| where Status !contains 'DENIED'\n| join kind=inner disabledAccounts on $left.User == $right.UserPrincipalName\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, URLCustomEntity = URL\n", "attributes": {"description": "'Look for accounts that have a been recorded as disabled by AD in the previous time period but are still using the proxy during\nthe current time period. This query presumes the default squid log format is being used. http://www.squid-cache.org/Doc/config/access_log/'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/RareProcess_ForLxHost.yaml", "query_name": "Rare process running on a Linux host", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet count_threshold = 100;\nlet perc_threshold = 0.01;\nlet host_threshold = 14;\nlet basic=materialize(\nSyslog | where TimeGenerated >= lookback\n| summarize FullCount = count(), Count= countif(TimeGenerated between (starttime .. endtime)), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) \nby Computer, ProcessName\n| where Count > 0 and Count < count_threshold);\nlet basic_avg = basic\n| summarize Avg = avg(FullCount) by  ProcessName;\nbasic | project-away FullCount\n| join kind=inner\nbasic_avg\non ProcessName | project-away ProcessName1\n| where Count < host_threshold or (Count <= Avg*perc_threshold and Count < count_threshold)\n| extend timestamp = StartTime, HostCustomEntity=Computer\n", "attributes": {"description": "'Looks for rare processes that are running on Linux hosts. Looks for process seen less than 14 times in last 7 days,\n or observed rate is less than 1% of of the average for the environment and fewer than 100.'\n", "techniques": ["T1059", "T1053", "T1037"], "tactics": ["Execution", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/SchedTaskAggregation.yaml", "query_name": "Linux scheduled task Aggregation", "query": "\n// Pull messages from Syslog-cron where the process name is \"CRON\" or \"CROND\", the severity level is info, and the SyslogMessage contains \"CMD\".\n// It also parses out the user and commandline from the message.\nlet RawCommands = Syslog \n| where Facility =~ \"cron\" \n| where SeverityLevel =~ \"info\" \n| where ProcessName =~ \"CRON\" or ProcessName =~ \"CROND\"  \n| where SyslogMessage contains \"CMD \" \n| project TenantId, TimeGenerated, Computer, SeverityLevel, ProcessName, SyslogMessage\n| extend TrimmedSyslogMsg = trim_end(@\"\\)\", SyslogMessage)\n| parse TrimmedSyslogMsg with * \"(\" user  \") CMD (\" cmdline \n| project TenantId, TimeGenerated, Computer, user, cmdline; \n// Count how many times a particular commandline has been seen based on unique Computer, User, and cmdline sets\nlet CommandCount = RawCommands\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), CmdlineCount = count() by Computer, user, cmdline; \n// Count how many computers have run a particular user and cmdline pair\nlet DistComputerCount = RawCommands\n| summarize ComputerCount = dcount(Computer) by TenantId, user, cmdline; \n// Join above counts based on user and commandline pair\nlet CommandSummary = CommandCount | join (DistComputerCount) on user, cmdline\n| project StartTime, EndTime, TenantId, user, CmdlineCount, ComputerCount, cmdline;\n// Count the total number of computers reporting cron messages in the tenant\nlet TotalComputers = Syslog\n| where Facility =~ \"cron\"\n| summarize dcount(Computer) by TenantId ;\n// Join the previous counts with the total computers count. Calculate the percentage of total computers value.\nlet FinalSummary = CommandSummary | join kind= leftouter (TotalComputers) on TenantId\n| project StartTime, EndTime, user, TimesCmdlineSeen = CmdlineCount, CompsThatHaveRunCmdline = ComputerCount, \nAsPercentOfTotalComps = round(100 * (toreal(ComputerCount)/toreal(dcount_Computer)),2), cmdline\n| order by user asc, TimesCmdlineSeen desc;\nFinalSummary \n| extend timestamp = StartTime, AccountCustomEntity = user\n", "attributes": {"description": "'This query aggregates information about all of the scheduled tasks (Cron jobs) and presents the data in a chart.\nThe aggregation is done based on unique user-commandline pairs. It returns how many times a command line has\nbeen run from a particular user, how many computers that pair has run on, and what percentage that is of the\ntotal number of computers in the tenant.'\n", "techniques": ["T1059", "T1053", "T1037"], "tactics": ["Persistence", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/SchedTaskEditViaCrontab.yaml", "query_name": "Editing Linux scheduled tasks through Crontab", "query": "\n// Pull messages from Syslog-cron logs where the process is crontab and the severity level is \"info\". Extract the User and Action information from the SyslogMessage\nSyslog \n| where Facility =~ \"cron\" \n| where ProcessName =~ \"crontab\" \n| where SeverityLevel =~ \"info\" \n| project TimeGenerated, Computer, SeverityLevel, ProcessName, SyslogMessage\n| parse SyslogMessage with * \"(\" user  \") \" Action \" (\" *\n// Only look for messages that contain edit or replace\n| where Action contains \"EDIT\" or Action contains \"REPLACE\"\n//| summarize all the actions into a single set based on 10 minute time intervals\n| summarize ListOfActions = makeset(Action) by EventTime10MinInterval = bin(TimeGenerated, 10m), Computer, user   \n| order by Computer asc nulls last, EventTime10MinInterval asc\n| extend timestamp = EventTime10MinInterval, AccountCustomEntity = user, HostCustomEntity = Computer\n", "attributes": {"description": "'This query shows when users have edited or replaced the scheduled tasks using crontab. The events are bucketed into 10 minute intervals \nand all the actions that a particular used took are collected into the List of Actions. Default query is for seven days.'\n", "techniques": ["T1059", "T1053", "T1037"], "tactics": ["Persistence", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/squid_abused_tlds.yaml", "query_name": "Squid commonly abused TLDs", "query": "\nlet suspicious_tlds = dynamic([ \".click\", \".club\", \".download\",  \".xxx\", \".xyz\"]);\nSyslog\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n         SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n         Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n         HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n         User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n         RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n         Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where TLD in (suspicious_tlds)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), clientCount = dcount(SourceIP) by TLD, User, URL\n| order by TLD asc, clientCount desc\n| extend timestamp = StartTime, AccountCustomEntity = User, URLCustomEntity = URL\n", "attributes": {"description": "'Some top level domains (TLDs) are more commonly associated with malware for a range of reasons - including how easy domains on these TLDs are to obtain. \nMany of these may be undesirable from an enterprise policy perspective. The clientCount column provides an initial insight into how widespread the domain \nusage is across the estate. This query presumes the default squid log format is being used. http://www.squid-cache.org/Doc/config/access_log/'\n", "techniques": ["T1568", "T1008"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/squid_malformed_requests.yaml", "query_name": "Squid malformed requests", "query": "\nSyslog\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage), \n         SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage), \n         Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage), \n         HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n         User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n         RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n         Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n         Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n         contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where Domain !contains '.' and isnotempty(Domain)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), badRequestCount = count() by Domain, SourceIP, User, URL\n| order by badRequestCount desc\n| extend timestamp = StartTime, AccountCustomEntity = User, IPCustomEntity = SourceIP, URLCustomEntity = URL\n", "attributes": {"description": "'Malformed web requests are sometimes used for reconnaissance to detect the presence of network security devices.\nHunting for a large number of requests from a single source may assist in locating compromised hosts. Note: internal sites may\nbe detected by this query and may need excluding on a individual basis. This query presumes the default squid log format is\nbeing used.'\n", "techniques": ["T1046"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/Syslog/squid_volume_anomalies.yaml", "query_name": "Squid data volume timeseries anomalies", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet timeframe = 1h;\nlet TimeSeriesData =\nSyslog\n| where TimeGenerated between(starttime..endtime)\n| where ProcessName contains \"squid\"\n| extend URL = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :]*)\",3,SyslogMessage),\n         SourceIP = extract(\"([0-9]+ )(([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3})\\\\.([0-9]{1,3}))\",2,SyslogMessage),\n         Status = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))\",1,SyslogMessage),\n         HTTP_Status_Code = extract(\"(TCP_(([A-Z]+)(_[A-Z]+)*)|UDP_(([A-Z]+)(_[A-Z]+)*))/([0-9]{3})\",8,SyslogMessage),\n         User = extract(\"(CONNECT |GET )([^ ]* )([^ ]+)\",3,SyslogMessage),\n         RemotePort = extract(\"(CONNECT |GET )([^ ]*)(:)([0-9]*)\",4,SyslogMessage),\n         Domain = extract(\"(([A-Z]+ [a-z]{4,5}:\\\\/\\\\/)|[A-Z]+ )([^ :\\\\/]*)\",3,SyslogMessage),\n         Bytes = toint(extract(\"([A-Z]+\\\\/[0-9]{3} )([0-9]+)\",2,SyslogMessage)),\n         contentType = extract(\"([a-z/]+$)\",1,SyslogMessage)\n| extend TLD = extract(\"\\\\.[a-z]*$\",0,Domain)\n| where isnotempty(Bytes)\n| make-series TotalBytesSent=sum(Bytes) on TimeGenerated from startofday(starttime) to startofday(endtime) step timeframe by ProcessName;\nTimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(TotalBytesSent,3, -1, 'linefit')\n| extend timestamp = TimeGenerated\n| render timechart with (title=\"Squid Time Series anomalies\")\n", "attributes": {"description": "'Malware infections or data exfiltration activity often leads to anomalies in network data volume\nthis hunting query looks for anomalies in the volume of bytes traversing a squid proxy. Anomalies require further\ninvestigation to determine cause. This query presumes the default squid log format is being used.'\n", "techniques": ["T1071", "T1030"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_OfficeActivity.yaml", "query_name": "Preview - TI map File entity to OfficeActivity Event", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n| where isnotempty(FileName)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  OfficeActivity\n  | where TimeGenerated between(starttime..endtime)\n  | where isnotempty(SourceFileName)\n  | extend OfficeActivity_TimeGenerated = TimeGenerated\n)\non $left.FileName == $right.SourceFileName\n| where OfficeActivity_TimeGenerated < ExpirationDateTime\n| summarize OfficeActivity_TimeGenerated = arg_max(OfficeActivity_TimeGenerated, *) by IndicatorId, SourceFileName\n| project OfficeActivity_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, FileName, UserId, ClientIP, OfficeObjectId\n| extend timestamp = OfficeActivity_TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in OfficeActivity Event data from any FileName IOC from TI.\nAs File name matches can create noise, this is best as hunting query'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_SecurityEvent.yaml", "query_name": "Preview - TI map File entity to Security Event", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n| where isnotempty(FileName)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  SecurityEvent \n  | where TimeGenerated between(starttime..endtime)\n  | where EventID in (\"4688\",\"8002\",\"4648\",\"4673\")\n  | where isnotempty(Process)\n  | extend SecurityEvent_TimeGenerated = TimeGenerated, Event = EventID\n)\non $left.FileName == $right.Process\n| where SecurityEvent_TimeGenerated < ExpirationDateTime\n| summarize SecurityEvent_TimeGenerated = arg_max(SecurityEvent_TimeGenerated, *) by IndicatorId, Process\n| project SecurityEvent_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nFileName, Computer, IpAddress, Account, Event, Activity\n| extend timestamp = SecurityEvent_TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in Security Event data from any FileName IOC from TI.\nAs File name matches can create noise, this is best as hunting query'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_Syslog.yaml", "query_name": "Preview - TI map File entity to Syslog Event", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n| where isnotempty(FileName)\n| extend TI_ProcessEntity = tostring(split(FileName, \".\")[-2])\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  Syslog\n  | where TimeGenerated between(starttime..endtime)\n  | where isnotempty(ProcessName)\n  | extend Syslog_TimeGenerated = TimeGenerated\n)\non $left.TI_ProcessEntity == $right.ProcessName\n| where Syslog_TimeGenerated < ExpirationDateTime\n| summarize Syslog_TimeGenerated = arg_max(Syslog_TimeGenerated, *) by IndicatorId, ProcessName\n| project Syslog_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nFileName, Computer, HostIP, SyslogMessage\n| extend timestamp = Syslog_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = HostIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in Syslog Event data from any FileName IOC from TI.\nAs File name matches can create noise, this is best as hunting query'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_VMConnection.yaml", "query_name": "Preview - TI map File entity to VMConnection Event", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n| where isnotempty(FileName)\n| extend TI_ProcessEntity = tostring(split(FileName, \".\")[-2])\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  VMConnection \n  | where TimeGenerated between(starttime..endtime)\n  | where isnotempty(ProcessName)\n  | extend VMConnection_TimeGenerated = TimeGenerated\n)\non $left.TI_ProcessEntity == $right.ProcessName\n| where VMConnection_TimeGenerated < ExpirationDateTime\n| summarize VMConnection_TimeGenerated = arg_max(VMConnection_TimeGenerated, *) by IndicatorId, ProcessName\n| project VMConnection_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nFileName, Computer, Direction, SourceIp, DestinationIp, RemoteIp, DestinationPort, Protocol\n| extend timestamp = VMConnection_TimeGenerated, IPCustomEntity = RemoteIp, HostCustomEntity = Computer, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in VMConnection Event data from any FileName IOC from TI.\nAs File name matches can create noise, this is best as hunting query'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ThreatIntelligenceIndicator/FileEntity_WireData.yaml", "query_name": "Preview - TI map File entity to WireData Event", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n| where isnotempty(FileName)\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n  WireData \n  | where TimeGenerated between(starttime..endtime)\n  | where isnotempty(ProcessName)\n  | extend Process =reverse(substring(reverse(ProcessName), 0, indexof(reverse(ProcessName), \"\\\\\")))\n  | extend WireData_TimeGenerated = TimeGenerated\n)\non $left.FileName == $right.Process\n| where WireData_TimeGenerated < ExpirationDateTime\n| summarize WireData_TimeGenerated = arg_max(WireData_TimeGenerated, *) by IndicatorId, Process\n| project WireData_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nFileName, Computer, Direction, LocalIP, RemoteIP, LocalPortNumber, RemotePortNumber\n| extend timestamp = WireData_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = RemoteIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in WireData Event data from any FileName IOC from TI.\nAs File name matches can create noise, this is best as hunting query'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/ClientIPwithManyUserAgents.yaml", "query_name": "Same IP address with multiple csUserAgent", "query": "\nW3CIISLog\n| where scStatus !startswith \"20\" and scStatus !startswith \"30\" and cIP !startswith \"192.168.\" and cIP != sIP and cIP != \"::1\"\n//Exclude local addresses, using ipv4_is_private operator\n|where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), makeset(csUserAgent), ConnectionCount = count() \nby Computer, sSiteName, sIP, sPort, cIP, csMethod\n| extend csUserAgentPerIPCount = arraylength(set_csUserAgent)\n| where  csUserAgentPerIPCount between ( 2 .. 15 ) and ConnectionCount <=50\n| extend timestamp = StartTime, IPCustomEntity = cIP, HostCustomEntity = Computer\n", "attributes": {"description": "'This alerts when the same client IP (cIP) is connecting with more than 1 but less than 15 different useragent string (csUserAgent) in less than 1 hour.\nWe limit to 50 or less connections to avoid high traffic sites. This may indicate malicious activity as this is a method of probing an environment\nReferences: Status code mappings for your convenience\nIIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\nWin32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/ExchangeServerProxyLogonURI.yaml", "query_name": "Exchange Server ProxyLogon URIs", "query": "\nW3CIISLog\n//Exclude local addresses, using the ipv4_is_private operator\n| where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"\n| where (csUriStem matches regex @\"\\/owa\\/auth\\/[A-Za-z0-9]{1,30}\\.js\") or (csUriStem matches regex @\"\\/ecp\\/[A-Za-z0-9]{1,30}\\.(js|flt|css)\")\n| project TimeGenerated, sSiteName, csMethod, csUriStem, sPort, sIP, cIP, csUserAgent\n| extend timestamp = TimeGenerated, IPCustomEntity = cIP\n", "attributes": {"description": "'This query will detect paths suspicious associated with ProxyLogon exploitation'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/ExchangeServerSuspiciousURIsVisited.yaml", "query_name": "Exchange Server Suspicious URIs Visited", "query": "\n//Calculate number of suspicious URI stems visited by user\nW3CIISLog \n| where not(ipv4_is_private(cIP))\n| where (csUriStem matches regex @\"\\/owa\\/auth\\/[A-Za-z0-9]{1,30}\\.js\") or (csUriStem matches regex @\"\\/ecp\\/[A-Za-z0-9]{1,30}\\.(js|flt|css)\") or (csUriStem =~ \"/ews/exchange.asmx\")\n| extend userHash = hash_md5(strcat(cIP, csUserAgent))\n| summarize susCount=dcount(csUriStem), make_list(csUriStem), min(TimeGenerated), max(TimeGenerated) by userHash, cIP, csUserAgent\n| join kind=leftouter  (\n  //Calculate unique URI stems visited by each user\n  W3CIISLog\n  | where not(ipv4_is_private(cIP))\n  | extend userHash = hash_md5(strcat(cIP, csUserAgent))\n  | summarize allCount=dcount(csUriStem) by userHash\n) on userHash\n//Find instances where only a common endpoint was seen\n| extend containsDefault = iff(list_csUriStem contains \"/ews/exchange.asmx\", 1, 0)\n//If we only see the common endpoint and nothing else dump it\n| extend result = iff(containsDefault == 1, containsDefault+susCount, 0)\n| where result != 2\n| extend susPercentage = susCount / allCount * 100\n| where susPercentage > 90\n| project StartTime=min_TimeGenerated, EndTime=max_TimeGenerated, AttackerIP=cIP, AttackerUA=csUserAgent, URIsVisited=list_csUriStem, suspiciousPercentage=susPercentage, allUriCount=allCount, suspiciousUriCount=susCount\n| extend timestamp = StartTime, IPCustomEntity = AttackerIP\n", "attributes": {"description": "'This query will detect paths suspicious associated with ProxyLogon exploitation, it will then calculate the percentage of suspicious URIs\nthe user had visited in relation to the total number of URIs the user has visited. This query will assist in the detection of automated\nProxyLogon exploitation.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/PotentialWebshell.yaml", "query_name": "Web shell Detection", "query": "\nlet command = \"(?i)net(1)?(.exe)?(%20){1,}user|cmd(.exe)?(%20){1,}/c(%20){1,}\";\nW3CIISLog\n| where csMethod == \"GET\" \n| where ( csUriQuery has \"whoami\" or csUriQuery matches regex command ) or \n        ( csUriStem has \"whoami\" or csUriStem matches regex command ) or\n        ( csReferer has \"whoami\" or csReferer matches regex command )\n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), ConnectionCount = count() \nby Computer, sSiteName, sIP, cIP, csUserName, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status\n| extend timestamp = StartTime, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName \n", "attributes": {"description": "'Web shells are script that when uploaded to a web server can be used for remote administration. \nAttackers often use web shells to obtain unauthorized access, escalate //privilege as well as further compromise the environment. \nThe query detects web shells that use GET requests by keyword searches in URL strings. \nThis is based out of sigma rules described //here (https://github.com/Neo23x0/sigma/blob/master/rules/web/web_webshell_keyword.yml). \nThere could be some web sites like wikis with articles on os commands and pages that include the os //commands in the URLs that might cause FP.'\n", "techniques": ["T1505"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/Potential_IIS_BF.yaml", "query_name": "Potential IIS brute force", "query": "\nW3CIISLog\n| where scStatus in (\"401\",\"403\")\n| where cIP !startswith \"192.168.\" and cIP != sIP and cIP != \"::1\" //and csUserName != \"-\" \n// Handling Exchange specific items in IIS logs to remove the unique log identifier in the URI\n| extend csUriQuery = iff(csUriQuery startswith \"MailboxId=\", tostring(split(csUriQuery, \"&\")[0]) , csUriQuery )\n| extend csUriQuery = iff(csUriQuery startswith \"X-ARR-CACHE-HIT=\", strcat(tostring(split(csUriQuery, \"&\")[0]),tostring(split(csUriQuery, \"&\")[1])) , csUriQuery )\n| summarize FailStartTime = min(TimeGenerated), FailEndTime = max(TimeGenerated), makeset(sPort), makeset(csUserAgent), makeset(csUserName), csUserNameCount = dcount(csUserName), ConnectionCount = count() by Computer, sSiteName, sIP, cIP, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status\n| extend csUserAgentPerIPCount = arraylength(set_csUserAgent)\n| extend sPortCount = arraylength(set_sPort)\n| extend scStatusFull = strcat(scStatus, \".\",scSubStatus) \n// Map common IIS codes\n| extend scStatusFull_Friendly = case(\nscStatusFull == \"401.0\", \"Access denied.\",\nscStatusFull == \"401.1\", \"Logon failed.\",\nscStatusFull == \"401.2\", \"Logon failed due to server configuration.\",\nscStatusFull == \"401.3\", \"Unauthorized due to ACL on resource.\",\nscStatusFull == \"401.4\", \"Authorization failed by filter.\",\nscStatusFull == \"401.5\", \"Authorization failed by ISAPI/CGI application.\",\nscStatusFull == \"403.0\", \"Forbidden.\",\nscStatusFull == \"403.4\", \"SSL required.\",\n\"See - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\")\n// Mapping to Hex so can be mapped using website in comments above\n| extend scWin32Status_Hex = tohex(tolong(scWin32Status)) \n// Map common win32 codes\n| extend scWin32Status_Friendly = case(\nscWin32Status_Hex =~ \"52e\", \"Logon failure: Unknown user name or bad password.\", \nscWin32Status_Hex =~ \"533\", \"Logon failure: Account currently disabled.\", \nscWin32Status_Hex =~ \"2ee2\", \"The request has timed out.\", \nscWin32Status_Hex =~ \"0\", \"The operation completed successfully.\", \nscWin32Status_Hex =~ \"1\", \"Incorrect function.\", \nscWin32Status_Hex =~ \"2\", \"The system cannot find the file specified.\", \nscWin32Status_Hex =~ \"3\", \"The system cannot find the path specified.\", \nscWin32Status_Hex =~ \"4\", \"The system cannot open the file.\", \nscWin32Status_Hex =~ \"5\", \"Access is denied.\", \nscWin32Status_Hex =~ \"8009030e\", \"SEC_E_NO_CREDENTIALS\", \nscWin32Status_Hex =~ \"8009030C\", \"SEC_E_LOGON_DENIED\", \n\"See - https://msdn.microsoft.com/library/cc231199.aspx\")\n// decode URI when available\n| extend decodedUriQuery = url_decode(csUriQuery)\n| where (ConnectionCount >= 1200 and csUserAgentPerIPCount > 1) or (ConnectionCount >= 1200 and sPortCount > 1)\n// now join back to see if there is a successful logon after so many failures\n| join (\nW3CIISLog\n| where scStatus startswith \"20\"\n| where cIP !startswith \"192.168.\" and cIP != sIP and cIP != \"::1\"\n| extend LogonSuccessTime = TimeGenerated, Success_scStatus = scStatus\n| distinct LogonSuccessTime, Computer, sSiteName, sIP, cIP, Success_scStatus\n) on Computer, sSiteName, sIP, cIP\n| where FailEndTime < LogonSuccessTime and not(LogonSuccessTime between (FailStartTime .. FailEndTime))\n| summarize makeset(LogonSuccessTime) by FailStartTime, FailEndTime, Computer, sSiteName, sIP, cIP, tostring(set_csUserName), csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, tostring(set_sPort), tostring(set_csUserAgent), ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly\n| project FailStartTime, FailEndTime, set_LogonSuccessTime, Computer, sSiteName, sIP, cIP, set_csUserName, csUserNameCount, csUriQuery, csMethod, scStatus, scSubStatus, scWin32Status, set_sPort, set_csUserAgent, ConnectionCount, csUserAgentPerIPCount, sPortCount, scStatusFull, scStatusFull_Friendly, scWin32Status_Hex, scWin32Status_Friendly\n| extend timestamp = FailStartTime, IPCustomEntity = cIP, HostCustomEntity = Computer\n", "attributes": {"description": "'This query shows when 1200 (20 per minute) or more failed attempts by cIP per hour occur on a given server and then a successful logon by cIP. \nThis only includes when more than 1 user agent strings is used or more than 1 port is used.\nThis could be indicative of successful probing and password brute force success on your IIS servers. \nFeel free to adjust the threshold as needed - ConnectionCount >= 1200 \nReferences: Status code mappings for your convenience, also inline if the mapping is not available\nIIS status code mapping - https://support.microsoft.com/help/943891/the-http-status-code-in-iis-7-0-iis-7-5-and-iis-8-0\nWin32 Status code mapping - https://msdn.microsoft.com/library/cc231199.aspx'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/Potential_IIS_CodeInject.yaml", "query_name": "Potential IIS code injection attempt", "query": "\n// set cIP and csMethod count limit to indicate potentially noisy events, this will be listed at the top of the results \n// for any returns that are gt or equal to the default of 50\nlet cIP_MethodCountLimit = 50;\n// Exclude common csMethods, add/modify this list as needed for your environment\nlet csMethodExclude = dynamic(['GET', 'DEBUG', 'DELETE', 'LOCK', 'MKCOL', 'MOVE', 'PATCH', 'POST', 'PROPPATCH', \n'PUT', 'SEARCH', 'TRACE', 'TRACK', 'UNLOCK', 'OPTIONS', 'HEAD', 'RPC_IN_DATA', 'RPC_OUT_DATA', 'PROPFIND','BITS_POST','CCM_POST']);\n// Include in the list expected IPs where remote methods such as vuln scanning may be expected for your environment\nlet expectedIPs = dynamic(['X.X.X.X', 'Y.Y.Y.Y']);\nlet codeInjectionAttempts = W3CIISLog\n// Exclude private ip ranges from cIP list\n| where ipv4_is_private(cIP) == false\n| where cIP != \"::1\"\n| where cIP !in (expectedIPs)\n| project TimeGenerated, cIP, csUserName, csMethod, csCookie, csHost, sIP, scStatus, csUriStem, csUriQuery, csUserAgent, csReferer \n// Throwing entire record into a single string column for attributable string matching\n| extend pak = tostring(pack_all())\n// Adding \"arr\" column containing indicators of matched suspicious strings\n| extend arr = dynamic([])\n| extend arr = iff(pak contains '<script' , array_concat(arr, pack_array('STRING MATCH : script')), arr)\n| extend arr = iff(pak contains '%3Cscript' , array_concat(arr, pack_array('STRING MATCH : script')), arr)\n| extend arr = iff(pak contains '%73%63%72%69%70%74' , array_concat(arr, pack_array('STRING MATCH : encoded script')), arr)\n| extend arr = iff(pak contains '<img' , array_concat(arr, pack_array('STRING MATCH : img')), arr)\n| extend arr = iff(pak contains '%3Cimg' , array_concat(arr, pack_array('STRING MATCH : img')), arr)\n| extend arr = iff(pak contains 'passwd' , array_concat(arr, pack_array('STRING MATCH : passwd')), arr)\n| extend arr = iff(csUserAgent contains 'nmap' , array_concat(arr, pack_array('STRING MATCH : nmap')), arr)\n| extend arr = iff(csUserAgent contains 'nessus' , array_concat(arr, pack_array('STRING MATCH : nessus')), arr)\n| extend arr = iff(csUserAgent contains 'qualys' , array_concat(arr, pack_array('STRING MATCH : qualys')), arr)\n| extend arr = iff(csMethod !in (csMethodExclude), array_concat(arr, pack_array('INVALID HTTP METHOD')), arr)\n| extend arr = iff(csUriStem == '/current_config/passwd' , array_concat(arr, pack_array('STRING MATCH : dahua scan url' )), arr)\n| extend arr = iff(csUriQuery contains '..' and csUriQuery !endswith '...', array_concat(arr, pack_array('BACKTRACK ATTEMPT IN QUERY')), arr)\n| extend arr = iff(csUriQuery contains 'http://www.webscantest.com' , array_concat(arr, pack_array('STRING MATCH : webscantest')), arr)\n| extend arr = iff(csUriQuery contains 'http://appspidered.rapid7.com' , array_concat(arr, pack_array('STRING MATCH : appspider')), arr)\n| where array_length(arr) > 0\n| project-away pak;\nlet cIP_MethodHighCount = codeInjectionAttempts \n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), cIP_MethodCount = count() \nby cIP, tostring(arr), cIP_MethodCountType = \"High Count of cIP and csMethod, this may be noise\" \n| where cIP_MethodCount >=  cIP_MethodCountLimit;\nlet codeInjectAtt = \ncodeInjectionAttempts \n| summarize StartTime = max(TimeGenerated), EndTime = min(TimeGenerated), cIP_MethodCount = count() \nby cIP, cIP_MethodCountType = \"Count of repeated entries, this is to reduce rowsets returned\", csMethod, \ntostring(arr), csHost, scStatus, sIP, csUriStem, csUriQuery, csUserName, csUserAgent, csCookie, csReferer;\n// union the events and sort by cIP_MethodCount to identify potentially noisy entries.  Additionally, cIP_MethodCountType \n// indicates whether it is a high count or simply a count of repeated entries\n(union isfuzzy=true\ncIP_MethodHighCount, codeInjectAtt\n| sort by cIP_MethodCount desc, cIP desc, StartTime desc)\n| extend timestamp = StartTime, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName, URLCustomEntity = csUriQuery\n", "attributes": {"description": "'Potential code injection into web server roles via scan of IIS logs. This represents an attempt to gain initial access to a system using a \ndrive-by compromise technique.  This sort of attack happens routinely as part of security scans, of both authorized and malicious types. \nThe initial goal of this detection is to flag these events when they occur and give an opportunity to review the data and filter out authorized activity.'\n", "techniques": ["T1189", "T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/RareClientFileAccess.yaml", "query_name": "URI requests from single client", "query": "\n\nlet clientThreshold = 1;\nlet scriptExtensions = dynamic([\".php\", \".aspx\", \".asp\", \".cfml\"]);\nlet data = W3CIISLog\n| where csUriStem has_any(scriptExtensions)\n// find sucessfull connection \n|where scStatus == 200\n//Exclude local addresses, needs editing to match your network configuration using ipv4_is_private operator\n|where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"\n// excluded internal web page \n|where ipv4_is_private(sIP) == false   \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), makelist(cIP), count(TimeGenerated) by csUriStem, sSiteName, csUserAgent;\ndata\n| mvexpand list_cIP\n| distinct StartTime, EndTime, tostring(list_cIP), csUriStem, sSiteName, csUserAgent\n| summarize StartTime = min(StartTime), EndTime = max(StartTime), dcount(list_cIP), makelist(list_cIP), makelist(sSiteName) by csUriStem, csUserAgent\n| where dcount_list_cIP == clientThreshold \n//Selects user agent strings that are probably browsers, comment out to see all\n| where csUserAgent startswith \"Mozilla\"\n| extend timestamp = StartTime, UserAgentCustomEntity = csUserAgent\n", "attributes": {"description": "'This will look for connections to files on the server that are requested by only a single client. \nThis analytic will be effective where an actor is utilising relatively static operational IP addresses. The threshold can be modified. \nThe larger the execution window for this query the more reliable the results returned.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/RareUserAgentStrings.yaml", "query_name": "Rare User Agent strings", "query": "\nW3CIISLog\n//Exclude local addresses, using ipv4_is_private operator\n|where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"  \n| where isnotempty(csUserAgent) and csUserAgent !in~ (\"-\", \"MSRPC\")\n| extend csUserAgent_size = string_size(csUserAgent)\n| project TimeGenerated, sSiteName, sPort, csUserAgent, csUserAgent_size, csUserName , csMethod, csUriStem, sIP, cIP, scStatus, \nscSubStatus, scWin32Status, csHost \n| join (\n    W3CIISLog\n\t  // The below line can be used to exclude local IPs if these create noise\n    |where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"  \n    | where isnotempty(csUserAgent) and csUserAgent !in~ (\"-\", \"MSRPC\") \n    | extend csUserAgent_size = string_size(csUserAgent)\n    | summarize csUserAgent_count = count() by bin(csUserAgent_size, 1)\n    | top 20 by csUserAgent_count asc nulls last \n) on csUserAgent_size\n| project TimeGenerated, sSiteName, sPort, sIP, cIP, csUserAgent, csUserAgent_size, csUserAgent_count, csUserName , csMethod, csUriStem, \nscStatus, scSubStatus, scWin32Status, csHost\n| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = csHost, AccountCustomEntity = csUserName \n", "attributes": {"description": "'This will check for Rare User Agent strings over the last 3 days.  This can indicate potential probing of your IIS servers.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/SuspectedMailBoxExportHostonOWA.yaml", "query_name": "Suspect Mailbox Export on IIS/OWA", "query": "\nlet excludeIps = dynamic([\"127.0.0.1\", \"::1\"]);\nlet scriptingExt = dynamic([\"aspx\", \"ashx\", \"asp\"]);\nW3CIISLog\n| where csUriStem contains \"/owa/\"\n//The actor pulls a file back but won't send it any URI params\n| where isempty(csUriQuery)\n| extend file_ext = tostring(split(csUriStem, \".\")[-1])\n//Giving your file a known scripting extension will throw an error\n//rather than just serving the file as it will try to interpret the script\n| where file_ext !in~ (scriptingExt)\n//The actor was seen using image files, but we go wider in case they change this behaviour\n//| where file_ext in~ (\"jpg\", \"jpeg\", \"png\", \"bmp\")\n| extend file_name = tostring(split(csUriStem, \"/\")[-1])\n| where file_name != \"\"\n| where cIP !in~ (excludeIps)\n//Exclude local addresses, using the ipv4_is_private operator\n| where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"\n| project file_ext, csUriStem, file_name, Computer, cIP, sIP, TenantId, TimeGenerated\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), dcount(cIP), AccessingIPs=make_set(cIP), AccessTimes=make_set(TimeGenerated), Access=count() by TenantId, file_name, Computer, csUriStem\n//Collection of the exfiltration will occur only once, lets check for 2 accesses in case they mess up\n//Tailor this for hunting\n| where Access <= 2 and dcount_cIP == 1\n| extend timestamp = StartTime, HostCustomEntity = Computer\n", "attributes": {"description": "'The hunting query looks for suspicious files accessed on a IIS server that might indicate exfiltration hosting.\nThis technique has been observed when exporting mailbox files from OWA servers.\nReference: https://www.volexity.com/blog/2020/12/14/dark-halo-leverages-solarwinds-compromise-to-breach-organizations/'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/SuspectedProxyTokenExploitation.yaml", "query_name": "Suspected ProxyToken Exploitation", "query": "W3CIISLog\n//Exclude local addresses, using the ipv4_is_private operator\n| where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"\n| where csMethod =~ \"POST\"\n| where csUriStem has \"/ecp\"\n| where isnotempty(csCookie) and csCookie has \"SecurityToken\"\n| where csUriQuery has \"msExchEcpCanary\"\n| extend timestamp=TimeGenerated, HostCustomEntity=Computer, IPCustomEntity=cIP\n", "attributes": {"description": "'Looks for activity that might indicate exploitation of the ProxyToken vulnerability - CVE-2021-33766\nRef: https://www.zerodayinitiative.com/blog/2021/8/30/proxytoken-an-authentication-bypass-in-microsoft-exchange-server'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/W3CIISLog/WebShellActivity.yaml", "query_name": "Web Shell Activity", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - (3d);\nlet script_extensions = dynamic([\".asp\", \".aspx\", \".armx\", \".asax\", \".ashz\", \".asmx\", \".axd\", \".cshtml\", \".php\", \".phps\", \".php3\", \".php4\", \".php5\", \".php7\", \".jsp\", \".jspx\", \".cfm\", \".cfml\", \".phtml\"]);\nlet ignore_uristems = dynamic([\"/ews/exchange.asmx\"]);\nlet lookback_period = (\nW3CIISLog\n| where TimeGenerated between (lookback .. starttime)\n//Exclude local addresses, using the ipv4_is_private operator\n| where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"\n| summarize count() by cIP, csUserAgent\n| project cIP, csUserAgent\n);\nlet potential_webshell_activity = (W3CIISLog\n| where TimeGenerated between (starttime .. endtime)\n| extend csUriStem = tolower(csUriStem)\n| where csUriStem matches regex \"\\\\.[a-zA-Z][a-zA-Z0-9]+$\"\n| where csUriStem !in~ (ignore_uristems) // Remove noisy uri stems in the final results by editing the ignore_uristems variable\n| extend suffix = strcat(\".\", split(split(csUriStem, \"/\")[-1], \".\")[-1])\n| extend is_script = iff(suffix in (script_extensions), 1, 0)\n//Exclude local addresses using ipv4_is_private operator\n|where ipv4_is_private(cIP) == false and  cIP !startswith \"fe80\" and cIP !startswith \"::\" and cIP !startswith \"127.\"\n| extend status_xx = strcat(substring(tostring(scStatus), 0, 1), 'XX')\n| serialize cIP, csUserAgent, TimeGenerated\n| extend SessionStarted = row_window_session(TimeGenerated, 30s, 3s, (cIP != prev(cIP)) and (csUserAgent != prev(csUserAgent))));\nlet dynamic_scripts = (potential_webshell_activity\n| where is_script == 1\n| summarize set_dynamic_scripts = make_set(csUriStem) by cIP, csUserAgent, SessionStarted);\nlet non_dynamic_scripts = (potential_webshell_activity\n| where is_script == 0\n| summarize set_non_dynamic_scripts = make_set(csUriStem) by cIP, csUserAgent, SessionStarted);\npotential_webshell_activity\n| summarize num_non_dyn_scripts = count() - sum(is_script), num_dynamic_scripts = sum(is_script) by cIP, csUserAgent, SessionStarted\n| join kind=leftanti (lookback_period) on cIP, csUserAgent\n| join kind=inner (dynamic_scripts) on cIP, csUserAgent, SessionStarted\n| join kind=leftouter (non_dynamic_scripts) on cIP, csUserAgent, SessionStarted\n| extend dyn_to_non_dyn_ratio = iff(num_non_dyn_scripts == 0, 10000.0, 1.0 * num_dynamic_scripts/num_non_dyn_scripts)\n| project cIP, csUserAgent, SessionStarted,  num_dynamic_scripts, set_dynamic_scripts, num_non_dyn_scripts, set_non_dynamic_scripts,  dyn_to_non_dyn_ratio\n| sort by dyn_to_non_dyn_ratio desc, num_dynamic_scripts desc\n| extend summary = pack('IPCustomEntity', cIP, 'user_agent', csUserAgent, 'num_dynamic_scripts', num_dynamic_scripts, 'set_dynamic_scripts', set_dynamic_scripts, 'num_non_dyn_scripts', num_non_dyn_scripts, 'set_non_dynamic_scripts', set_non_dynamic_scripts, 'ratio', dyn_to_non_dyn_ratio, 'Session_StartTime', SessionStarted)\n| summarize summaries=make_list(summary), num_of_sessions_on_day = count() by cIP, csUserAgent\n| sort by num_of_sessions_on_day asc\n", "attributes": {"description": "'Web shells are scripts that, when uploaded to a web server, can be used to provide a backdoor to a compromised network.\nAttackers can use this entry point to leave malicious implants, such as obtaining unauthorized access, escalating privilege, and further compromising the environment.\n\nThis query hunts for web shells by analysing the distribution of commonly-used web shell scripts against regular scripts for those public client IPs which have not observed any W3CIIS activity in a fixed lookback period.\nThe results obtained summarise the public client IPs, user agents, and the distribution of the above scripts between the start and end time.'\n", "techniques": ["T1505"], "tactics": ["Persistence", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/WireData/WireDataBeacon.yaml", "query_name": "Detect beacon like pattern based on repetitive time intervals in Wire Data Traffic", "query": "\nlet lookback = 1d;\nlet TimeDeltaThreshold = 10;\nlet TotalEventsThreshold = 15;\nlet PercentBeaconThreshold = 95;\nWireData\n| where TimeGenerated > lookback\n| where ipv4_is_private(RemoteIP) == false\n| project TimeGenerated , LocalIP , LocalPortNumber , RemoteIP, RemotePortNumber, ReceivedBytes, SentBytes\n| sort by LocalIP asc,TimeGenerated asc, RemoteIP asc, RemotePortNumber asc\n| serialize\n| extend nextTimeGenerated = next(TimeGenerated, 1), nextLocalIP = next(LocalIP, 1)\n| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated)\n| where LocalIP == nextLocalIP\n//Whitelisting criteria/ threshold criteria\n| where TimeDeltainSeconds > TimeDeltaThreshold\n| where RemotePortNumber != \"0\"\n| project TimeGenerated, TimeDeltainSeconds, LocalIP, LocalPortNumber,RemoteIP,RemotePortNumber, ReceivedBytes, SentBytes\n| summarize count(), sum(ReceivedBytes), sum(SentBytes), make_list(TimeDeltainSeconds) by TimeDeltainSeconds, bin(TimeGenerated, 1h), LocalIP, RemoteIP, RemotePortNumber\n| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds)=arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSentBytes=sum(sum_SentBytes),TotalReceivedBytes=sum(sum_ReceivedBytes) by bin(TimeGenerated, 1h), LocalIP, RemoteIP, RemotePortNumber\n| where TotalEvents > TotalEventsThreshold\n| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100\n| where BeaconPercent > PercentBeaconThreshold\n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP\n", "attributes": {"description": "'This query will identify beaconing patterns from Wire Data logs based on timedelta patterns. The query leverages various KQL functions\nto calculate time delta and then compare it with total events observed in a day to find percentage of beaconing.\nResults of such beaconing patterns to untrusted public networks can be a good starting point for investigation.\nReferences: Blog about creating dataset to identify network beaconing via repetitive time intervals seen against total traffic\nbetween same source-destination pair.\nhttp://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/'\n", "techniques": ["T1071", "T1571"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ZoomLogs/HighCPURoom.yaml", "query_name": "Zoom room high CPU alerts", "query": "\nZoomLogs \n| where Event =~ \"zoomroom.alert\" \n| extend AlertType = toint(parse_json(RoomEvents).AlertType), AlertKind = toint(parse_json(RoomEvents).AlertKind) \n| extend RoomName = payload_object_room_name_s, User = payload_object_email_s\n| where AlertType == 1 and AlertKind == 1 \n| extend timestamp = TimeGenerated, AccountCustomEntity = User\n// Uncomment the lines below to analyse event over time\n//| summarize count() by bin(TimeGenerated, 1h), RoomName\n//| render timechart\n", "attributes": {"description": "'This hunting query identifies Zoom room systems with high CPU alerts that may be a sign of device compromise.'\n", "techniques": ["T1542"], "tactics": ["DefenseEvasion", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ZoomLogs/MultipleRegistrationDenies.yaml", "query_name": "User denied multiple registration events successfully registering", "query": "\nlet threshold = 2; \nlet failed_users = (\nZoomLogs \n| where Event =~ \"webinar.registration_denied\" or Event =~ \"recording.registration_denied\" \n| extend RegisteringUser = columnifexists('payload_object_registrant_email_s', payload_object_registrant_email_s)\n| extend ItemId = columnifexists('tostring(parse_json(WebinarEvents).WebinarId)',payload_object_uuid_s)\n| summarize dcount(ItemId) by RegisteringUser\n| where dcount_ItemId > threshold\n| project RegisteringUser);\nZoomLogs \n| where Event =~ \"webinar.registration_approved\" or Event =~ \"recording.registration_approved\" \n| extend RegisteringUser = columnifexists('payload_object_registrant_email_s', columnifexists('payload_object_registrant_email_s', \"\")) \n| extend ItemId = columnifexists('tostring(parse_json(WebinarEvents).WebinarId)',columnifexists('payload_object_uuid_s', \"\"))\n| extend EventName = columnifexists('tostring(parse_json(WebinarEvents).WebinarName)',columnifexists('payload_object_topic_s', \"\"))\n| extend EventHost = columnifexists('payload_object_host_id',\"\")\n| extend EventStart = columnifexists('tostring(parse_json(WebinarEvents).Start)',columnifexists('payload_object_start_time_s' ,\"\"))\n| where RegisteringUser !in (failed_users)\n| project TimeGenerated, RegisteringUser, EventName, ItemId, EventHost, EventStart\n| extend timestamp = TimeGenerated, AccountCustomEntity = RegisteringUser\n", "attributes": {"description": "'This hunting query identifies users that have attempted to register for multiple webinars or recordings and has been denied by the organizer but have also successfully register for at least one event. The number of events a user needs to be rejected from to be included in this query is adjusted with the threshold variable.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ZoomLogs/NewDomainAccess.yaml", "query_name": "New domain added to Whitelist", "query": "\nZoomLogs \n| where Event =~ \"account.settings_updated\"\n| extend NewDomains = columnifexists(\"payload_object_enforce_logon_domains\", \"\")\n| where isnotempty(NewDomains)\n| project TimeGenerated, Event, User, NewDomains\n| extend timestamp = TimeGenerated, AccountCustomEntity = User\n", "attributes": {"description": "'This hunting query identifies new domains added to the domain login whitelist in Zoom.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Hunting%20Queries/ZoomLogs/NewTZ.yaml", "query_name": "New time zone observed", "query": "\nlet previous_tz = (\n  ZoomLogs\n  | where Event =~ \"meeting.participant_joined\"\n  | extend TimeZone = columnifexists('payload_object_timezone_s', \"\")\n  | summarize by TimeZone\n);\nZoomLogs\n| where Event =~ \"meeting.participant_joined\"\n| extend TimeZone = columnifexists('payload_object_timezone_s', \"\")\n| where isnotempty(TimeZone) and TimeZone in (previous_tz)\n| extend timestamp = TimeGenerated, AccountCustomEntity = User\n", "attributes": {"description": "'This hunting query identifies users joining a meeting from a time zone that a user has not been observed from in the last 30 days.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AIShield%20AI%20Security%20Monitoring/Analytic%20Rules/ImageClassficationModelTheftVulnDetection.yaml", "query_name": "AIShield - Image classification model theft vulnerability detection", "query": "AIShield\n| where ServiceName has 'image_classification'\n| where Severity =~ 'High'\n", "attributes": {"description": "'This alert creates an incident when Image classification model theft vulnerability detected from the AIShield.'\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/ADAttacksPathways.yaml", "query_name": "Alsid Active Directory attacks pathways", "query": "let SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nlet codeNameList = datatable(Codename:string)[\"C-PRIV-ACCOUNTS-SPN\", \"C-SDPROP-CONSISTENCY\", \"C-DANG-PRIMGROUPID\", \"C-GPO-HARDENING\", \"C-DC-ACCESS-CONSISTENCY\", \"C-DANGEROUS-TRUST-RELATIONSHIP\", \"C-UNCONST-DELEG\", \"C-ABNORMAL-ENTRIES-IN-SCHEMA\"];\nafad_parser\n| where MessageType == 0 and Codename in~ (codeNameList)\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures related to Active Directory attacks pathways'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/DCShadow.yaml", "query_name": "Alsid DCShadow", "query": "afad_parser\n| where MessageType == 2 and Codename == \"DCShadow\"\n", "attributes": {"description": "'Searches for DCShadow attacks'\n", "techniques": ["T1207"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/DCSync.yaml", "query_name": "Alsid DCSync", "query": "afad_parser\n| where MessageType == 2 and Codename == \"DCSync\"\n", "attributes": {"description": "'Searches for DCSync attacks'\n", "techniques": ["T1003.006"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/GoldenTicket.yaml", "query_name": "Alsid Golden Ticket", "query": "afad_parser\n| where MessageType == 2 and Codename == \"Golden Ticket\"\n", "attributes": {"description": "'Searches for Golden Ticket attacks'\n", "techniques": ["T1558.001"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/IndicatorsOfAttack.yaml", "query_name": "Alsid Indicators of Attack", "query": "let SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nafad_parser\n| where MessageType == 2\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Attack'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/IndicatorsOfExposures.yaml", "query_name": "Alsid Indicators of Exposures", "query": "let SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nafad_parser\n| where MessageType == 0\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/LSASSMemory.yaml", "query_name": "Alsid LSASS Memory", "query": "afad_parser\n| where MessageType == 2 and Codename == \"OS Credential Dumping: LSASS Memory\"\n", "attributes": {"description": "'Searches for OS Credentials dumping attacks'\n", "techniques": ["T1003.001"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/PasswordGuessing.yaml", "query_name": "Alsid Password Guessing", "query": "afad_parser\n| where MessageType == 2 and Codename == \"Password Guessing\"\n", "attributes": {"description": "'Searches for bruteforce Password Guessing attacks'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/PasswordIssues.yaml", "query_name": "Alsid Password issues", "query": "let SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nlet codeNameList = datatable(Codename:string)[\"C-CLEARTEXT-PASSWORD\", \"C-PASSWORD-DONT-EXPIRE\", \"C-USER-REVER-PWDS\", \"C-PASSWORD-POLICY\", \"C-USER-PASSWORD\", \"C-KRBTGT-PASSWORD\", \"C-AAD-SSO-PASSWORD\", \"C-REVER-PWD-GPO\"];\nafad_parser\n| where MessageType == 0 and Codename in~ (codeNameList)\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures related to password issues'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/PasswordSpraying.yaml", "query_name": "Alsid Password Spraying", "query": "afad_parser\n| where MessageType == 2 and Codename == \"Password Spraying\"\n", "attributes": {"description": "'Searches for Password spraying attacks'\n", "techniques": ["T1110.003"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/PrivilegedAccountIssues.yaml", "query_name": "Alsid privileged accounts issues", "query": "let SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nlet codeNameList = datatable(Codename:string)[\"C-PRIV-ACCOUNTS-SPN\", \"C-NATIVE-ADM-GROUP-MEMBERS\", \"C-KRBTGT-PASSWORD\", \"C-PROTECTED-USERS-GROUP-UNUSED\", \"C-ADMINCOUNT-ACCOUNT-PROPS\", \"C-ADM-ACC-USAGE\", \"C-LAPS-UNSECURE-CONFIG\", \"C-DISABLED-ACCOUNTS-PRIV-GROUPS\"];\nafad_parser\n| where MessageType == 0 and Codename in~ (codeNameList)\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures related to privileged accounts issues'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Alsid%20For%20AD/Analytic%20Rules/UserAccountIssues.yaml", "query_name": "Alsid user accounts issues", "query": "let SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nlet codeNameList = datatable(Codename:string)[\"C-ACCOUNTS-DANG-SID-HISTORY\", \"C-PRE-WIN2000-ACCESS-MEMBERS\", \"C-PASSWORD-DONT-EXPIRE\", \"C-SLEEPING-ACCOUNTS\", \"C-DANG-PRIMGROUPID\", \"C-PASSWORD-NOT-REQUIRED\", \"C-USER-PASSWORD\"];\nafad_parser\n| where MessageType == 0 and Codename in~ (codeNameList)\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures related to user accounts issues'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Analytic%20Rules/AzureWAFmatching_log4j_vuln.yaml", "query_name": "Azure WAF matching for Log4j vuln(CVE-2021-44228)", "query": "AzureDiagnostics\n| where ResourceProvider == \"MICROSOFT.NETWORK\" and Category in (\"ApplicationGatewayFirewallLog\", \"FrontdoorWebApplicationFirewallLog\")\n| extend details_data_s = column_ifexists(\"details_data_s\", tostring(AdditionalFields.details_data))\n| where details_data_s has \"jndi:\"\n| parse details_data_s with * '${' MaliciousCommand '} ' *\n| extend EncodeCmd = iff(MaliciousCommand has 'Base64/', split(split(MaliciousCommand, \"Base64/\",1)[0], \"}\", 0)[0], \"\")\n| extend EncodeCmd1 = iff(MaliciousCommand has 'base64/', split(split(MaliciousCommand, \"base64/\",1)[0], \"}\", 0)[0], \"\")\n| extend CmdLine = iff( isnotempty(EncodeCmd), EncodeCmd, EncodeCmd1)\n| extend DecodedCmdLine = base64_decode_tostring(tostring(CmdLine))\n| extend DecodedCmdLine = iff( isnotempty(DecodedCmdLine), DecodedCmdLine, \"Unable to decode/Doesn't need decoding\")\n| project TimeGenerated, Target=column_ifexists(\"hostname_s\", tostring(AdditionalFields.hostname)), MaliciousHost = column_ifexists(\"clientIp_s\", tostring(AdditionalFields.clientIp)) , MaliciousCommand, details_data_s = column_ifexists(\"details_data_s\", tostring(AdditionalFields.details_data)), DecodedCmdLine, Message,\nruleSetType_s = column_ifexists(\"ruleSetType_s\", tostring(AdditionalFields.ruleSetType)), OperationName, SubscriptionId, details_message_s = column_ifexists(\"details_message_s\", tostring(AdditionalFields.details_message)), \ndetails_file_s = column_ifexists(\"details_message_s\", tostring(AdditionalFields.details_file))\n| extend IPCustomEntity = MaliciousHost, timestamp = TimeGenerated\n", "attributes": {"description": "'This query will alert on a positive pattern match by Azure WAF for CVE-2021-44228 log4j vulnerability exploitation attempt. If possible, it then decodes the malicious command for further analysis.\n Refrence: https://www.microsoft.com/security/blog/2021/12/11/guidance-for-preventing-detecting-and-hunting-for-cve-2021-44228-log4j-2-exploitation/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Analytic%20Rules/Log4jVulnerableMachines.yaml", "query_name": "Vulnerable Machines related to log4j CVE-2021-44228", "query": "SecurityNestedRecommendation\n| where RemediationDescription has 'CVE-2021-44228'\n| parse ResourceDetails with * 'virtualMachines/' VirtualMAchine '\"' *\n| summarize arg_min(TimeGenerated, *) by TenantId, RecommendationSubscriptionId, VirtualMAchine, RecommendationName,Description,RemediationDescription, tostring(AdditionalData),VulnerabilityId\n| extend Timestamp = TimeGenerated, HostCustomEntity = VirtualMAchine\n", "attributes": {"description": "'This query uses the Azure Defender Security Nested Recommendations data to find machines vulnerable to log4j CVE-2021-44228. Log4j is an open-source Apache logging library that is used in \n many Java-based applications. Security Nested Recommendations data is sent to Microsoft Sentinel using the continuous export feature of Azure Defender(refrence link below).\n Reference: https://msrc-blog.microsoft.com/2021/12/11/microsofts-response-to-cve-2021-44228-apache-log4j2/\n Reference: https://docs.microsoft.com/azure/security-center/continuous-export?tabs=azure-portal\n Reference: https://techcommunity.microsoft.com/t5/microsoft-defender-for-cloud/how-defender-for-cloud-displays-machines-affected-by-log4j/ba-p/3037271'\n", "techniques": ["T1190", "T1203"], "tactics": ["InitialAccess", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Analytic%20Rules/Log4J_IPIOC_Dec112021.yaml", "query_name": "Log4j vulnerability exploit aka Log4Shell IP IOC", "query": "\nlet IPList = externaldata(IPAddress:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Log4j_IOC_List.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet IPRegex = '[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}';\n//Network logs\nlet CSlogSourceIP = CommonSecurityLog | summarize by IPAddress = SourceIP, Type;\nlet CSlogDestIP = CommonSecurityLog | summarize by IPAddress = DestinationIP, Type;\nlet CSlogMsgIP = CommonSecurityLog | extend MessageIP = extract(IPRegex, 0, Message) | summarize by IPAddress = MessageIP, Type;\nlet DnsIP = DnsEvents | summarize by IPAddress = IPAddresses, Type;\n// If you have enabled the imDNS and/or imNetworkSession normalization in your workspace, you can uncomment one or both below.  Reference - https://docs.microsoft.com/azure/sentinel/normalization\n//let imDnsIP = imDns (response_has_any_prefix=IPList) | summarize by IPAddress = ResponseName, Type;\n//let imNetSessIP = imNetworkSession (dstipaddr_has_any_prefix=IPList) | summarize by IPAddress = DstIpAddr, Type;\n//Cloud service logs\nlet officeIP = OfficeActivity | summarize by IPAddress = ClientIP, Type;\nlet signinIP = SigninLogs | summarize by IPAddress, Type;\nlet nonintSigninIP = AADNonInteractiveUserSignInLogs | summarize by IPAddress, Type;\nlet azureActIP = AzureActivity | summarize by IPAddress = CallerIpAddress, Type;\nlet awsCtIP = AWSCloudTrail | summarize by IPAddress = SourceIpAddress, Type;\n//Device logs\nlet vmConnSourceIP = VMConnection | summarize by IPAddress = SourceIp, Type;\nlet vmConnDestIP = VMConnection | summarize by IPAddress = DestinationIp, Type;\nlet iisLogIP = W3CIISLog | summarize by IPAddress = cIP, Type;\nlet devNetIP = DeviceNetworkEvents | summarize by IPAddress = RemoteIP, Type;\n//need to parse to get IP\nlet azureDiagIP = AzureDiagnostics | where ResourceType == \"AZUREFIREWALLS\" | where Category in (\"AzureFirewallApplicationRule\", \"AzureFirewallNetworkRule\") \n| where msg_s has_any (IPList) | parse msg_s with Protocol 'request from ' SourceHost ':' SourcePort 'to ' DestinationHost ':' DestinationPort '. Action:' Action | summarize by IPAddress = DestinationHost, Type;\nlet sysEvtIP = Event | where Source == \"Microsoft-Windows-Sysmon\" | where EventID == 3 | where EventData has_any (IPList) | extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend SourceIP = tostring(EventDetail.[9].[\"#text\"]), DestinationIP = tostring(EventDetail.[14].[\"#text\"])\n| where SourceIP in (IPList) or DestinationIP in (IPList) | extend IPAddress = iff(SourceIP in (IPList), SourceIP, DestinationIP) | summarize by IPAddress, Type;\n// If you have enabled the imDNS and/or imNetworkSession normalization in your workdspace, you can uncomment below and include. Reference - https://docs.microsoft.com/azure/sentinel/normalization\n//let ipsort = union isfuzzy=true CSlogDestIP, CSlogMsgIP, CSlogSourceIP, DnsIP, officeIP, signinIP, nonintSigninIP, azureActIP, awsCtIP, vmConnDestIP, vmConnSourceIP, azureDiagIP, sysEvtIP, imDnsIP, imNetSessIP\n// If you uncomment above, then comment out the line below\nlet ipsort = union isfuzzy=true CSlogDestIP, CSlogMsgIP, CSlogSourceIP, DnsIP, officeIP, signinIP, nonintSigninIP, azureActIP, awsCtIP, vmConnDestIP, vmConnSourceIP, azureDiagIP, sysEvtIP\n| summarize by IPAddress\n| where isnotempty(IPAddress) | where not(ipv4_is_private(IPAddress)) and IPAddress !in ('0.0.0.0','127.0.0.1');\nlet ipMatch = ipsort | where IPAddress in (IPList);\n(union isfuzzy=true\n(CommonSecurityLog\n| where SourceIP in (ipMatch) or DestinationIP in (ipMatch) or Message has_any (ipMatch)\n| project TimeGenerated, SourceIP, DestinationIP, Message, SourceUserID, RequestURL, Type\n| extend MessageIP = extract(IPRegex, 0, Message)\n| extend IPMatch = case(SourceIP in (ipMatch), \"SourceIP\", DestinationIP in (ipMatch), \"DestinationIP\", MessageIP in (ipMatch), \"Message\", \"No Match\")\n| extend timestamp = TimeGenerated, IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, IPMatch == \"Message\", MessageIP, \"No Match\")\n),\n(OfficeActivity\n| where  ClientIP in (ipMatch)\n| project TimeGenerated, UserAgent, Operation, RecordType, UserId, ClientIP, Type\n| extend SourceIPAddress = ClientIP, Account = UserId\n| extend timestamp = TimeGenerated , IPCustomEntity = SourceIPAddress , AccountCustomEntity = Account\n),\n(DnsEvents\n| where  IPAddresses has_any (ipMatch)\n| project TimeGenerated, Computer, IPAddresses, Name, ClientIP, Type\n| extend DestinationIPAddress = IPAddresses,  Host = Computer\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host\n),\n(VMConnection\n| where SourceIp in (ipMatch) or DestinationIp in (ipMatch)\n| project TimeGenerated, Computer, SourceIp, DestinationIp, Type\n| extend IPMatch = case( SourceIp in (ipMatch), \"SourceIP\", DestinationIp in (ipMatch), \"DestinationIP\", \"None\")\n| extend timestamp = TimeGenerated , IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIp, IPMatch == \"DestinationIP\", DestinationIp, \"None\"), Host = Computer\n),\n(Event\n| where Source == \"Microsoft-Windows-Sysmon\"\n| where EventID == 3\n| where EventData has_any (ipMatch)\n| project TimeGenerated, EventData, UserName, Computer, Type\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend SourceIP = tostring(EventDetail.[9].[\"#text\"]), DestinationIP = tostring(EventDetail.[14].[\"#text\"])\n| where SourceIP in (ipMatch) or DestinationIP in (ipMatch)\n| extend IPMatch = case( SourceIP in (ipMatch), \"SourceIP\", DestinationIP in (ipMatch), \"DestinationIP\", \"None\")\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserName, HostCustomEntity = Computer , IPCustomEntity = case(IPMatch == \"SourceIP\", SourceIP, IPMatch == \"DestinationIP\", DestinationIP, \"None\")\n),\n(SigninLogs\n| where IPAddress in (ipMatch)\n| project TimeGenerated, UserPrincipalName, IPAddress, Type\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n),\n(AADNonInteractiveUserSignInLogs\n| where IPAddress in (ipMatch)\n| project TimeGenerated, UserPrincipalName, IPAddress, Type\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n),\n(W3CIISLog\n| where cIP in (ipMatch)\n| project TimeGenerated, Computer, cIP, csUserName, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = cIP, HostCustomEntity = Computer, AccountCustomEntity = csUserName\n),\n(AzureActivity\n| where CallerIpAddress in (ipMatch)\n| project TimeGenerated, CallerIpAddress, Caller, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = CallerIpAddress, AccountCustomEntity = Caller\n),\n(\nAWSCloudTrail\n| where SourceIpAddress in (ipMatch)\n| project TimeGenerated, SourceIpAddress, UserIdentityUserName, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIpAddress, AccountCustomEntity = UserIdentityUserName\n), \n( \nDeviceNetworkEvents\n| where RemoteIP in (ipMatch)\n| where ActionType == \"InboundConnectionAccepted\"\n| project TimeGenerated, RemoteIP, DeviceName, Type\n| extend timestamp = TimeGenerated, IPCustomEntity = RemoteIP, HostCustomEntity = DeviceName\n),\n(\nAzureDiagnostics\n| where ResourceType == \"AZUREFIREWALLS\"\n| where Category in (\"AzureFirewallApplicationRule\", \"AzureFirewallNetworkRule\")\n| where msg_s has_any (ipMatch)\n| project TimeGenerated, msg_s, Type\n| parse msg_s with Protocol 'request from ' SourceIP ':' SourcePort 'to ' DestinationIP ':' DestinationPort '. Action:' Action\n| where DestinationIP has_any (ipMatch)\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIP\n)\n// If you have enabled the imDNS and/or imNetworkSession normalization in your workdspace, you can uncomment below and include. Reference - https://docs.microsoft.com/azure/sentinel/normalization\n//,\n//(imDns (response_has_any_prefix=IPList)\n//| project TimeGenerated, ResponseName, SrcIpAddr, Type\n//| extend DestinationIPAddress = ResponseName,  Host = SrcIpAddr\n//| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIPAddress, HostCustomEntity = Host\n//),\n//(imNetworkSession (dstipaddr_has_any_prefix=IPList)\n//| project TimeGenerated, DstIpAddr, SrcIpAddr, Type\n//| extend timestamp = TimeGenerated, IPCustomEntity = DstIpAddr, HostCustomEntity = SrcIpAddr\n//)\n)\n", "attributes": {"description": "'Identifies a match across various data feeds for IP IOCs related to the Log4j vulnerability exploit aka Log4Shell described in CVE-2021-44228.  \n References: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-44228' \n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Analytic%20Rules/UserAgentSearch_log4j.yaml", "query_name": "User agent search for log4j exploitation attempt", "query": "let UserAgentString = dynamic ([\"${jndi:ldap:/\", \"${jndi:rmi:/\", \"${jndi:ldaps:/\", \"${jndi:dns:/\", \"${jndi:iiop:/\",\"${jndi:\",\"${jndi:nds:/\",\"${jndi:corba/\"]);\nlet UARegexMinimalString=dynamic(['{','%7b', '%7B']);\nlet UARegex = @'(\\\\$|%24)(\\\\{|%7B)([^jJ]*[jJ])([^nN]*[nN])([^dD]*[dD])([^iI]*[iI])(:|%3A|\\\\$|%24|}|%7D)';\n(union isfuzzy=true\n(OfficeActivity\n| where UserAgent has_any (UserAgentString) or UserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = ClientIP, Account = UserId, Type, Operation\n| extend timestamp = StartTime, AccountCustomEntity = Account, IPCustomEntity = SourceIP\n),\n(AzureDiagnostics\n| where Category in (\"FrontdoorWebApplicationFirewallLog\", \"FrontdoorAccessLog\", \"ApplicationGatewayFirewallLog\", \"ApplicationGatewayAccessLog\")\n| where userAgent_s has_any (UserAgentString) or userAgent_s matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent = userAgent_s, SourceIP = clientIP_s, Type, host_s, requestUri_s, httpStatus_d\n| extend timestamp = StartTime, IPCustomEntity = SourceIP, UrlCustomEntity = requestUri_s\n),\n(\nW3CIISLog\n| where csUserAgent has_any (UserAgentString) or csUserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent = csUserAgent, SourceIP = cIP, Account = csUserName, Type, sSiteName, csMethod, csUriStem\n| extend timestamp = StartTime, AccountCustomEntity = Account, IPCustomEntity = SourceIP, UrlCustomEntity = csUriStem\n),\n(\nAWSCloudTrail\n| where UserAgent has_any (UserAgentString) or UserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = SourceIpAddress, Account = UserIdentityUserName, Type, EventName\n| extend timestamp = StartTime, AccountCustomEntity = Account, IPCustomEntity = SourceIP\n),\n(SigninLogs\n| where UserAgent has_any (UserAgentString) or UserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = IPAddress, Account = UserPrincipalName, Type, Operation = OperationName, tostring(LocationDetails), tostring(DeviceDetail),    AppDisplayName, ClientAppUsed\n| extend timestamp = StartTime, AccountCustomEntity = Account, IPCustomEntity = SourceIP\n),\n(AADNonInteractiveUserSignInLogs \n| where UserAgent has_any (UserAgentString) or UserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = IPAddress, Account = UserPrincipalName, Type, Operation = OperationName, tostring(LocationDetails), tostring(DeviceDetail), AppDisplayName, ClientAppUsed\n| extend timestamp = StartTime, AccountCustomEntity = Account, IPCustomEntity = SourceIP\n),\n(_Im_WebSession (httpuseragent_has_any=array_concat(UserAgentString,UARegexMinimalString))\n| where HttpUserAgent has_any (UserAgentString) or HttpUserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by HttpUserAgent, SourceIP = SrcIpAddr, DstIpAddr, Account = SrcUsername, Url, Type\n| extend timestamp = StartTime, AccountCustomEntity = Account, IPCustomEntity = SourceIP, UrlCustomEntity = Url\n)\n)\n", "attributes": {"description": "'This query uses various log sources having user agent data to look for log4j CVE-2021-44228 exploitation attempt based on user agent pattern. Log4j is an open-source Apache logging library that is used in \n many Java-based applications. The regex and the string matching look for the most common attacks. This might not be comprehensive to detect every possible user agent variation.\n Reference: https://msrc-blog.microsoft.com/2021/12/11/microsofts-response-to-cve-2021-44228-apache-log4j2/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/Apache_log4j_Vulnerability.yaml", "query_name": "Possible exploitation of Apache log4j component detected", "query": "let log4j_execve=()\n{\n  Syslog\n  | where SyslogMessage has \"AUOMS_EXECVE\"\n  | where SyslogMessage has 'jndi' and SyslogMessage has_any ('ldap', 'dns', 'rmi', 'corba', 'iiop', 'nis', 'nds')\n  | parse SyslogMessage with \"type=\" EventType \" audit(\" * \"): \" EventData\n  | where EventType =~ \"AUOMS_EXECVE\"\n  | project TimeGenerated, EventType, Computer, EventData\n  | extend EventData = trim_end('containerid=',EventData)\n  | parse kind=regex EventData with * \"success=\" success \" exit=\" * \"ppid=\" ppid \"pid=\" pid\n  \"audit_user=\" audit_user \"auid=\" * \"user=\" user \" uid=\" uid \" group=\" * \"comm=\\\"\" comm \"\\\" exe=\\\"\" exe\n  \"\\\"\" * \"cwd=\\\"\" cwd \"\\\" name=\\\"\" name \"\\\" (inode|nametype)=\" * \"(proctitle|cmdline)=\" cmdline\n  | extend cmdline = trim_end('redactors=.*',cmdline)\n};\nlog4j_execve\n  | where comm has_any (\"wget\",\"curl\")\n  | where cmdline has_any (\"${jndi:ldap\",\"${jndi:dns\",\"${jndi:rmi\",\"${jndi:corba\",\"${jndi:iiop\",\"${jndi:nis\", \"${jndi:nds\")\n  | project TimeGenerated, Computer, audit_user, user, cmdline\n  | extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated\n  | sort by TimeGenerated desc\n", "attributes": {"description": "'This hunting query looks for possible attempts to exploit a remote code execution vulnerability in the Log4j component of Apache. \nAttackers may attempt to launch arbitrary code by passing specific commands to a server, which are then logged and executed by the Log4j component.\nFor more details on Apache Log4j Remote Code Execution Vulnerability - https://community.riskiq.com/article/505098fc/description\nFind more details on collecting EXECVE data into Microsoft Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'\n", "techniques": ["T1059", "T1053"], "tactics": ["Persistence", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/Base64_Download_Activity.yaml", "query_name": "Suspicious Base64 download activity detected", "query": "Syslog\n| where Facility == 'user'\n| where SyslogMessage has \"AUOMS_EXECVE\"\n| parse SyslogMessage with \"type=\" EventType \" audit(\" * \"): \" EventData\n| project TimeGenerated, EventType, Computer, EventData\n| where EventType =~ \"AUOMS_EXECVE\"\n| parse EventData with * \"syscall=\" syscall \" syscall_r=\" * \" success=\" success \" exit=\" exit \" a0\" * \" ppid=\" ppid \" pid=\" pid \" audit_user=\" audit_user \" auid=\" auid \" user=\" user \" uid=\" uid \" group=\" group \" gid=\" gid \"effective_user=\" effective_user \" euid=\" euid \" set_user=\" set_user \" suid=\" suid \" filesystem_user=\" filesystem_user \" fsuid=\" fsuid \" effective_group=\" effective_group \" egid=\" egid \" set_group=\" set_group \" sgid=\" sgid \" filesystem_group=\" filesystem_group \" fsgid=\" fsgid \" tty=\" tty \" ses=\" ses \" comm=\\\"\" comm \"\\\" exe=\\\"\" exe \"\\\"\" * \"cwd=\\\"\" cwd \"\\\"\" * \"name=\\\"\" name \"\\\"\" * \"cmdline=\\\"\" cmdline \"\\\" containerid=\" containerid\n| where cmdline has \"/Basic/Command/Base64/\"\n| where exe has_any (\"curl\", \"wget\")\n| parse cmdline with * \"Base64/\" OriginalEncodedCommand:string\n| extend EncodedCommand = extract(\"((?:[A-Za-z0-9+/-]{4})*(?:[A-Za-z0-9+/-]{2}==|[A-Za-z0-9+/-]{3}=|[A-Za-z0-9+/-]{4}))\", 1, OriginalEncodedCommand) \n| extend DecodedCommand = base64_decode_tostring(EncodedCommand) \n| project TimeGenerated, Computer, audit_user, user, cmdline, DecodedCommand, EncodedCommand\n| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated\n| sort by TimeGenerated desc\n", "attributes": {"description": "'This hunting query will help detect suspicious encoded Base64 obfuscated scripts that attackers use to encode payloads for downloading and executing malicious files.\nThis technique is often used by attackers and was recently used  to exploit a remote code execution vulnerability in the Log4j component of Apache in order to evade detection and stay persistent in the network.\nFor more details on Apache Log4j Remote Code Execution Vulnerability - https://community.riskiq.com/article/505098fc/description\nFind more details on collecting EXECVE data into Microsoft Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'\n", "techniques": ["T1059", "T1053"], "tactics": ["Persistence", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/Container_Miner_Activity.yaml", "query_name": "Possible Container Miner related artifacts detected", "query": "Syslog\n| where Facility == 'user'\n| where SyslogMessage has \"AUOMS_EXECVE\"\n| parse SyslogMessage with \"type=\" EventType \" audit(\" * \"): \" EventData\n| where EventType =~ \"AUOMS_EXECVE\"\n| parse EventData with * \"syscall=\" syscall \" syscall_r=\" * \" success=\" success \" exit=\" exit \" a0\" * \" ppid=\" ppid \" pid=\" pid \" audit_user=\" audit_user \" auid=\" auid \" user=\" user \" uid=\" uid \" group=\" group \" gid=\" gid \"effective_user=\" effective_user \" euid=\" euid \" set_user=\" set_user \" suid=\" suid \" filesystem_user=\" filesystem_user \" fsuid=\" fsuid \" effective_group=\" effective_group \" egid=\" egid \" set_group=\" set_group \" sgid=\" sgid \" filesystem_group=\" filesystem_group \" fsgid=\" fsgid \" tty=\" tty \" ses=\" ses \" comm=\\\"\" comm \"\\\" exe=\\\"\" exe \"\\\"\" * \"cwd=\\\"\" cwd \"\\\"\" * \"name=\\\"\" name \"\\\"\" * \"cmdline=\\\"\" cmdline \"\\\" containerid=\" containerid\n| where (exe has \"docker\" and cmdline has_any  (\"monero-miner\",\"minergate-cli\",\"aeon-miner\",\"xmr-miner\")) or (exe has_any (\"bash\",\"dash\") and cmdline has \"docker kill\" and cmdline has_any (\"gakeaws\",\"monero\",\"xmr\",\"pocosow\"))\n| project TimeGenerated, Computer, audit_user, user, cmdline\n| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated\n| sort by TimeGenerated desc\n", "attributes": {"description": "'This query uses syslog data to alert on possible artifacts associated with container running image related to digital cryptocurrency mining.\nAttackers may perform such operations post compromise as seen after CVE-2021-44228 log4j vulnerability exploitation to scope and prioritize post-compromise objectives.\nFor more details on Apache Log4j Remote Code Execution Vulnerability - https://community.riskiq.com/article/505098fc/description\nFind more details on collecting EXECVE data into Microsoft Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'\n", "techniques": ["T1496", "T1203"], "tactics": ["Impact", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/Firewall_Disable_Activity.yaml", "query_name": "Suspicious manipulation of firewall detected via Syslog data", "query": "Syslog\n| where Facility == 'user'\n| where SyslogMessage has \"AUOMS_EXECVE\"\n| parse SyslogMessage with \"type=\" EventType \" audit(\" * \"): \" EventData\n| where EventType =~ \"AUOMS_EXECVE\"\n| parse EventData with * \"syscall=\" syscall \" syscall_r=\" * \" success=\" success \" exit=\" exit \" a0\" * \" ppid=\" ppid \" pid=\" pid \" audit_user=\" audit_user \" auid=\" auid \" user=\" user \" uid=\" uid \" group=\" group \" gid=\" gid \"effective_user=\" effective_user \" euid=\" euid \" set_user=\" set_user \" suid=\" suid \" filesystem_user=\" filesystem_user \" fsuid=\" fsuid \" effective_group=\" effective_group \" egid=\" egid \" set_group=\" set_group \" sgid=\" sgid \" filesystem_group=\" filesystem_group \" fsgid=\" fsgid \" tty=\" tty \" ses=\" ses \" comm=\\\"\" comm \"\\\" exe=\\\"\" exe \"\\\"\" * \"cwd=\\\"\" cwd \"\\\"\" * \"name=\\\"\" name \"\\\"\" * \"cmdline=\\\"\" cmdline \"\\\" containerid=\" containerid\n| where cmdline has_any (\"SuSEfirewall2 stop\",\"reSuSEfirewall2 stop\",\"ufw stop\",\"ufw disable\")\n| project TimeGenerated, Computer, audit_user, user, cmdline\n| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated\n| sort by TimeGenerated desc\n", "attributes": {"description": "'This query uses syslog data to alert on any suspicious manipulation of firewall to evade defenses.\nAttackers often perform such operation as seen recently to exploit the remote code execution vulnerability in Log4j component of Apache for C2 communications or exfiltration.\nFor more details on Apache Log4j Remote Code Execution Vulnerability - https://community.riskiq.com/article/505098fc/description\nFind more details on collecting EXECVE data into Microsoft Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/Linux_Toolkit_Detected.yaml", "query_name": "Possible Linux attack toolkit detected via Syslog data", "query": "Syslog\n| where Facility == 'user'\n| where SyslogMessage has \"AUOMS_EXECVE\"\n| parse SyslogMessage with \"type=\" EventType \" audit(\" * \"): \" EventData\n| where EventType =~ \"AUOMS_EXECVE\"\n| parse EventData with * \"syscall=\" syscall \" syscall_r=\" * \" success=\" success \" exit=\" exit \" a0\" * \" ppid=\" ppid \" pid=\" pid \" audit_user=\" audit_user \" auid=\" auid \" user=\" user \" uid=\" uid \" group=\" group \" gid=\" gid \"effective_user=\" effective_user \" euid=\" euid \" set_user=\" set_user \" suid=\" suid \" filesystem_user=\" filesystem_user \" fsuid=\" fsuid \" effective_group=\" effective_group \" egid=\" egid \" set_group=\" set_group \" sgid=\" sgid \" filesystem_group=\" filesystem_group \" fsgid=\" fsgid \" tty=\" tty \" ses=\" ses \" comm=\\\"\" comm \"\\\" exe=\\\"\" exe \"\\\"\" * \"cwd=\\\"\" cwd \"\\\"\" * \"name=\\\"\" name \"\\\"\" * \"cmdline=\\\"\" cmdline \"\\\" containerid=\" containerid\n| where (exe has \"java\" and cmdline has \"JNDI-Injection-Exploit\") or (exe has \"javac\" and cmdline has \"log4j-payload-generator\") or (cmdline has \"LogMePwn\" and cmdline has \"git clone\")\n| project TimeGenerated, Computer, audit_user, user, cmdline\n| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated\n| sort by TimeGenerated desc\n", "attributes": {"description": "'This query uses syslog data to alert on any attack toolkits associated with massive scanning or exploitation attempts against a known vulnerability.\nAttackers may perform such operations as seen recently to exploit the remote code execution vulnerability in Log4j component of Apache to scope and prioritize post-compromise objectives.\nFor more details on Apache Log4j Remote Code Execution Vulnerability - https://community.riskiq.com/article/505098fc/description\nFind more details on collecting EXECVE data into Microsoft Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'\n", "techniques": ["T1595", "T1203"], "tactics": ["Reconnaissance", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/NetworkConnectionldap_log4j.yaml", "query_name": "Malicious Connection to LDAP port for CVE-2021-44228 vulnerability", "query": "let Port = dynamic(['389', '1389']); \n(union isfuzzy=true\n(DeviceNetworkEvents\n| where InitiatingProcessFileName has_any (\"javaw.exe\",\"java.exe\")\n| where ActionType has \"ConnectionSuccess\"\n| where RemotePort in ('389', '1389')\n| where InitiatingProcessCommandLine has_any ('curl', 'wget')\n| where RemoteIPType =~ 'Public'\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by ActionType, DestinationIP = RemoteIP, RemoteUrl, DestinationPort = RemotePort, SourceIP = LocalIP, Type, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath,  InitiatingProcessParentFileName, ProcessName = InitiatingProcessFileName, Computer = DeviceName\n| extend timestamp = StartTime, IPCustomEntity = DestinationIP, HostCustomEntity = Computer\n),\n(VMConnection\n| where ProcessName has_any (\"javaw\",\"java\")\n| where DestinationPort in ('389', '1389')\n| where ipv4_is_private(DestinationIP) == false\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by TimeGenerated, SourceIP = SourceIp , DestinationIP = DestinationIp, DestinationPort,  BytesReceived, BytesSent, ProcessName, Computer\n| extend timestamp = StartTime, IPCustomEntity = DestinationIP, HostCustomEntity = Computer\n)\n)\n", "attributes": {"description": "'This hunting query looks for connection to the default LDAP ports to find possible exploitation attempts for CVE-2021-44228 involving log4j vulnerability.\n The attack is not limited only to these ports. Log4j is an open-source Apache logging library that is used in many Java-based applications. \n Awareness of normal baseline traffic of an environment for java.exe while using this query will help determine normal from anomalous.\n Refrence: https://www.microsoft.com/security/blog/2021/12/11/guidance-for-preventing-detecting-and-hunting-for-cve-2021-44228-log4j-2-exploitation/'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/NetworkConnectionToNewExternalLDAPServer.yaml", "query_name": "Network Connection to New External LDAP Server", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 14d;\nlet legacy_ldap = (\nCommonSecurityLog\n| where TimeGenerated between(lookback..starttime)\n// Filter to LDAP connections only\n| where ApplicationProtocol =~ \"ldap\"\n// Check LDAP server is external\n| extend private =  ipv4_is_private(DestinationIP)\n| where private == false\n// Filter out events where network connection was blocked - change this to expand hunt\n| where DeviceAction has_any (\"allow\", \"accept\", \"allowed\")\n| summarize by DestinationIP);\nCommonSecurityLog\n| where TimeGenerated between(starttime..endtime)\n| where ApplicationProtocol =~ \"ldap\"\n| extend private =  ipv4_is_private(DestinationIP)\n| where private == false\n| where DestinationIP !in (legacy_ldap)\n| where DeviceAction has_any (\"allow\", \"accept\", \"allowed\")\n| project-reorder TimeGenerated, SourceIP, DestinationIP, ApplicationProtocol, DestinationPort, SentBytes, ReceivedBytes, DeviceAction\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP\n", "attributes": {"description": "'This hunting query looks for outbound network connections using the LDAP protocol to external IP addresses, where that IP address has not had an LDAP network connection to it in the 14 days preceding the query timeframe. This could indicate someone exploiting a vulnerability such as CVE-2021-44228 to trigger the connection to a malicious LDAP server.\nFor more details on Apache Log4j Remote Code Execution Vulnerability - https://community.riskiq.com/article/505098fc/description\nFind more details on collecting EXECVE data into Microsoft Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/Process_Termination_Activity.yaml", "query_name": "Linux security related process termination activity detected", "query": "Syslog\n| where Facility == 'user'\n| where SyslogMessage has \"AUOMS_EXECVE\"\n| parse SyslogMessage with \"type=\" EventType \" audit(\" * \"): \" EventData\n| where EventType =~ \"AUOMS_EXECVE\"\n| parse EventData with * \"syscall=\" syscall \" syscall_r=\" * \" success=\" success \" exit=\" exit \" a0\" * \" ppid=\" ppid \" pid=\" pid \" audit_user=\" audit_user \" auid=\" auid \" user=\" user \" uid=\" uid \" group=\" group \" gid=\" gid \"effective_user=\" effective_user \" euid=\" euid \" set_user=\" set_user \" suid=\" suid \" filesystem_user=\" filesystem_user \" fsuid=\" fsuid \" effective_group=\" effective_group \" egid=\" egid \" set_group=\" set_group \" sgid=\" sgid \" filesystem_group=\" filesystem_group \" fsgid=\" fsgid \" tty=\" tty \" ses=\" ses \" comm=\\\"\" comm \"\\\" exe=\\\"\" exe \"\\\"\" * \"cwd=\\\"\" cwd \"\\\"\" * \"name=\\\"\" name \"\\\"\" * \"cmdline=\\\"\" cmdline \"\\\" containerid=\" containerid\n| where cmdline has_any (\"service apparmor stop\",\"service aliyun.service stop\",\"systemctl disable apparmor\",\"systemctl disable aliyun.service\")\nor  (exe has \"pkill\" and cmdline has_any (\"omsagent\",\"auoms\",\"omiagent\",\"waagent\") and cmdline !has \"/omsagent/plugin/pi\"and cmdline !has \"/omsconfig/modules\")\n| project TimeGenerated, Computer, audit_user, user, cmdline\n| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated\n| sort by TimeGenerated desc\n", "attributes": {"description": "'This query will alert on any attempts to terminate processes related to security monitoring on the host. \nAttackers will often try to terminate such processes post-compromise as seen recently to exploit the remote code execution vulnerability in Log4j component of Apache.\nFor more details on Apache Log4j Remote Code Execution Vulnerability - https://community.riskiq.com/article/505098fc/description\nFind more details on collecting EXECVE data into Microsoft Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'\n", "techniques": ["T1489"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/Suspicious_ShellScript_Activity.yaml", "query_name": "Suspicious Shell script detected", "query": "Syslog\n| where Facility == 'user'\n| where SyslogMessage has \"AUOMS_EXECVE\"\n| parse SyslogMessage with \"type=\" EventType \" audit(\" * \"): \" EventData\n| where EventType =~ \"AUOMS_EXECVE\"\n| project TimeGenerated, EventType, Computer, EventData\n| parse EventData with * \"syscall=\" syscall \" syscall_r=\" * \" success=\" success \" exit=\" exit \" a0\" * \" ppid=\" ppid \" pid=\" pid \" audit_user=\" audit_user \" auid=\" auid \" user=\" user \" uid=\" uid \" group=\" group \" gid=\" gid \"effective_user=\" effective_user \" euid=\" euid \" set_user=\" set_user \" suid=\" suid \" filesystem_user=\" filesystem_user \" fsuid=\" fsuid \" effective_group=\" effective_group \" egid=\" egid \" set_group=\" set_group \" sgid=\" sgid \" filesystem_group=\" filesystem_group \" fsgid=\" fsgid \" tty=\" tty \" ses=\" ses \" comm=\\\"\" comm \"\\\" exe=\\\"\" exe \"\\\"\" * \"cwd=\\\"\" cwd \"\\\"\" * \"name=\\\"\" name \"\\\"\" * \"cmdline=\\\"\" cmdline \"\\\" containerid=\" containerid\n| where exe has_any (\"bash\",\"dash\")\n| where cmdline matches regex  \"[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\"\n| where cmdline has \"curl\" and cmdline has \"wget\"\n| project TimeGenerated, Computer, audit_user, user, cmdline\n| extend AccountCustomEntity = user, HostCustomEntity = Computer, timestamp = TimeGenerated\n| sort by TimeGenerated desc\n", "attributes": {"description": "'This hunting query will help detect post compromise suspicious shell scripts that attackers use for downloading and executing malicious files.\nThis technique is often used by attackers and was recently used  to exploit a remote code execution vulnerability in the Log4j component of Apache in order to evade detection and stay persistent or for more exploitation in the network.\nFor more details on Apache Log4j Remote Code Execution Vulnerability - https://community.riskiq.com/article/505098fc/description\nFind more details on collecting EXECVE data into Microsoft Sentinel - https://techcommunity.microsoft.com/t5/azure-sentinel/hunting-threats-on-linux-with-azure-sentinel/ba-p/1344431'\n", "techniques": ["T1059", "T1053"], "tactics": ["Persistence", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Apache%20Log4j%20Vulnerability%20Detection/Hunting%20Queries/WAF_log4j_vulnerability.yaml", "query_name": "Azure WAF Log4j CVE-2021-44228 hunting", "query": "let log4jcmdstring = dynamic([\"${jndi:ldap\",\"${jndi:dns\",\"${jndi:rmi\",\"${jndi:corba\",\"${jndi:iiop\",\"${jndi:nis\",\"${jndi:nds\"]);\nlet log4jRegex = @'(\\\\$|%24)(\\\\{|%7B)([^jJ]*[jJ])([^nN]*[nN])([^dD]*[dD])([^iI]*[iI])(:|%3A|\\\\$|%24|}|%7D)';\nAzureDiagnostics\n| where Category in (\"FrontdoorWebApplicationFirewallLog\", \"FrontdoorAccessLog\", \"ApplicationGatewayFirewallLog\", \"ApplicationGatewayAccessLog\")\n //Extending the columns to aviod failures.\n| extend originalRequestUriWithArgs_s = column_ifexists(\"originalRequestUriWithArgs_s\", \"\"), \n  userAgent_s = column_ifexists(\"userAgent_s\", \"\"), \n  clientIP_s = column_ifexists(\"clientIP_s\", \"\"),  \n  clientPort_d = column_ifexists(\"originalRequestUriWithArgs_s\", \"\"),\n  host_s = column_ifexists(\"host_s\", \"\"),\n  requestUri_s = column_ifexists(\"requestUri_s\", \"\"),\n  httpStatus_d = column_ifexists(\"httpStatus_d\",\"\"),\n  listenerName_s = column_ifexists(\"listenerName_s\", \"\"),\n  httpMethod_s = column_ifexists(\"httpMethod_s\", \"\")\n //The regex and the string matching look for the most common attacks. This is not supposed to be comprehensive.\n| where originalRequestUriWithArgs_s has_any (log4jcmdstring) or originalRequestUriWithArgs_s matches regex log4jRegex or userAgent_s has_any (log4jcmdstring) or  userAgent_s matches regex log4jRegex\n| extend CmdLine = iff(originalRequestUriWithArgs_s has 'Base64/', split(split(originalRequestUriWithArgs_s, \"Base64/\",1)[0], \"}\", 0)[0], split(split(userAgent_s, \"Base64/\",1)[0], \"}\", 0)[0])\n| extend CmdLine = base64_decode_tostring(tostring(CmdLine))\n| where CmdLine has_any (\"wget\",\"curl\")\n| summarize Total = count() by originalRequestUriWithArgs_s, userAgent_s, clientIP_s,clientPort_d, TimeGenerated, host_s, requestUri_s, httpStatus_d,listenerName_s, CmdLine, httpMethod_s, Category\n| extend IPCustomEntity = clientIP_s, timestamp = TimeGenerated\n", "attributes": {"description": "'This hunting query looks in Azure Web Application Firewall data to find possible exploitation attempts for CVE-2021-44228 involving log4j vulnerability.\n Refrence: https://www.microsoft.com/security/blog/2021/12/11/guidance-for-preventing-detecting-and-hunting-for-cve-2021-44228-log4j-2-exploitation/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApacheCommandInURI.yaml", "query_name": "Apache - Command in URI", "query": "let cmd_list = dynamic(['whoami', 'dpkg', 'useradd', 'sudo', 'cat']);\nApacheHTTPServer\n| where UrlOriginal has_any (cmd_list)\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects command in URI'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApacheCVE-2021-41773.yaml", "query_name": "Apache - Apache 2.4.49 flaw CVE-2021-41773", "query": "ApacheHTTPServer\n| where HttpRequestMethod =~ \"GET\"\n| where UrlOriginal has_all (\"/cgi-bin/\", \"/%2e%2e/\")\n| where HttpStatusCode == \"200\" \n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects using Apache 2.4.49 flaw CVE-2021-41773'\n", "techniques": ["T1190", "T1133", "T1210"], "tactics": ["InitialAccess", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApacheKnownMaliciousUserAgents.yaml", "query_name": "Apache - Known malicious user agent", "query": "let mal_uas = dynamic(['Metasploit', '360Spider', '404checker', 'AllSubmitter', 'BackDoorBot', 'CATExplorador', 'Nikto', 'havij']);\nApacheHTTPServer\n| where HttpUserAgentOriginal has_any (mal_uas)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects known malicious user agents'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApacheMultipleClientErrorsFromSingleIP.yaml", "query_name": "Apache - Multiple client errors from single IP", "query": "let threshold = 100;\nApacheHTTPServer\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499\n| summarize MultipleClientErrors = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where MultipleClientErrors > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple client errors from one source in short timeframe'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApacheMultipleServerErrorsRequestsFromSingleIP.yaml", "query_name": "Apache - Multiple server errors from single IP", "query": "let threshold = 100;\nApacheHTTPServer\n| where HttpStatusCode >= 500 and HttpStatusCode <= 599 \n| summarize MultipleServerErrors = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where MultipleServerErrors > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple server errors from one source in short timeframe'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApachePrivateIpInUrl.yaml", "query_name": "Apache - Private IP in URL", "query": "ApacheHTTPServer\n| where UrlOriginal matches regex @'(10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})|(172\\.1[6-9]\\.\\d{1,3}\\.\\d{1,3})|(172\\.2[0-9]\\.\\d{1,3}\\.\\d{1,3})|(172\\.3[0-1]\\.\\d{1,3}\\.\\d{1,3})|(192\\.168\\.\\d{1,3}\\.\\d{1,3})'\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects requests to unusual URL'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApachePutSuspiciousFiles.yaml", "query_name": "Apache - Put suspicious file", "query": "ApacheHTTPServer\n| where HttpRequestMethod in~ (\"POST\", \"PUT\") \n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| where File matches regex @\"([a-zA-Z0-9-_]+\\.)([a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+)\"\n| extend FileCustomEntity = File, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects PUT or POST of suspicious file'\n", "techniques": ["T1190", "T1133", "T1048"], "tactics": ["InitialAccess", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApacheRequestFromPrivateIP.yaml", "query_name": "Apache - Request from private IP", "query": "ApacheHTTPServer\n| where ipv4_is_private(SrcIpAddr)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests from private IP'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApacheRequestToRareFile.yaml", "query_name": "Apache - Requests to rare files", "query": "let lb_period_start = 14d;\nlet lb_period_end = 1d;\nlet known_files = ApacheHTTPServer\n| where TimeGenerated between (ago(lb_period_start) .. ago(lb_period_end))\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| summarize makeset(File);\nApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where File in~ (known_files)\n| extend FileCustomEntity = File, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Shows requests to rare files'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Analytic%20Rules/ApacheRequestToSensitiveFiles.yaml", "query_name": "Apache - Request to sensitive files", "query": "let forbidden_files = dynamic(['shadow', 'passwd', 'id_rsa']);\nApacheHTTPServer\n| where isnotempty(UrlOriginal)\n| extend File = extract(@'(.*\\/)?(.*)', 2, tostring(UrlOriginal))\n| where File in~ (forbidden_files)\n| extend FileCustomEntity = File, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects request to sensitive files.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheFilesErrorRequests.yaml", "query_name": "Apache - Top files requested with errors", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 599 \n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| summarize TotalFile = count() by File\n| top 20 by TotalFile desc\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows list of files with error requests.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheFilesRequested.yaml", "query_name": "Apache - Top Top files requested", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| summarize TotalFile = count() by File\n| top 20 by TotalFile desc\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows list of files requested'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheRareFilesRequested.yaml", "query_name": "Apache - Rare files requested", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| summarize RareFiles = count() by File\n| top 20 by RareFiles asc\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query detects rare files requested'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheRareUAWithClientErrors.yaml", "query_name": "Apache - Rare user agents with client errors", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499\n| summarize Total_UA_Count = count() by tostring(HttpUserAgentOriginal)\n| top 20 by Total_UA_Count desc\n| extend UrlCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Query shows rare user agent strings with client errors'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheRareURLsRequested.yaml", "query_name": "Apache - Rare URLs requested", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| where isnotempty(UrlOriginal)\n| summarize count() by tostring(UrlOriginal)\n| top 20 by count_ asc\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows rare URLs requested.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheRareUserAgents.yaml", "query_name": "Apache - Rare user agents", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| where isnotempty(HttpUserAgentOriginal)\n| summarize UAs = count() by (tostring(HttpUserAgentOriginal))\n| top 20 by UAs asc\n| extend UrlCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Query shows rare user agents'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheRequestsToUnexistingFiles.yaml", "query_name": "Apache - Requests to unexisting files", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| where EventType =~ \"ErrorLog\"\n| where EventMessage contains \"File does not exist\"\n| extend File = extract(@\"(.*\\/)(.*)\", 2, tostring(EventMessage))\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows list of requests to unexisting files'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheUnexpectedPostRequests.yaml", "query_name": "Apache - Unexpected Post Requests", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| where HttpRequestMethod in~ (\"POST\", \"PUT\")\n| project UrlOriginal, HttpStatusCode\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query detects Unexpected Post Requests'\n", "techniques": ["T1100", "T1505", "T1071"], "tactics": ["Persistence", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheUrlClienterrors.yaml", "query_name": "Apache - Top URLs with client errors", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499\n| summarize TopUrls = count() by (tostring(UrlOriginal))\n| top 20 by TopUrls desc\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows URLs list with client errors.'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ApacheHTTPServer/Hunting%20Queries/ApacheUrlServerErrors.yaml", "query_name": "Apache - Top URLs with server errors", "query": "ApacheHTTPServer\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 500 and HttpStatusCode <= 599\n| summarize TopUrls = count() by (tostring(UrlOriginal))\n| top 20 by TopUrls desc\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows URLs list with server errors.'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ARGOSCloudSecurity/Analytic%20Rules/ExploitableSecurityIssues.yaml", "query_name": "ARGOS Cloud Security - Exploitable Cloud Resources", "query": "ARGOS_CL | where exploitable_b\n", "attributes": {"description": "Exploitable Cloud Security Issues are ones that expose cloud resources to the internet and allow initial access to your environment.", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AristaAwakeSecurity/Analytic%20Rules/HighMatchCountsByDevice.yaml", "query_name": "Awake Security - High Match Counts By Device", "query": "CommonSecurityLog\n| where DeviceVendor == \"Arista Networks\" and DeviceProduct == \"Awake Security\"\n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), Models=make_set(Activity), ASPMatchURLs=make_set(DeviceCustomString2), SourceIPs=make_set(SourceIP),\n  DestinationIPs=make_set(DestinationIP), ModelMatchCount=sum(EventCount), MaxSeverity=max(toint(LogSeverity)) by SourceHostName\n| where ModelMatchCount > 1000 and MaxSeverity > 2\n| extend SeverityName=iff(MaxSeverity == 0, \"Informational\", iff(MaxSeverity < 5, \"Low\", iff(MaxSeverity < 8, \"Medium\", \"High\")))\n", "attributes": {"description": "This query searches for devices with unexpectedly large number of activity match.", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AristaAwakeSecurity/Analytic%20Rules/HighSeverityMatchesByDevice.yaml", "query_name": "Awake Security - High Severity Matches By Device", "query": "CommonSecurityLog\n| where DeviceVendor == \"Arista Networks\" and DeviceProduct == \"Awake Security\" and toint(LogSeverity) > 6\n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), Models=make_set(Activity), ASPMatchURLs=make_set(DeviceCustomString2), SourceIPs=make_set(SourceIP),\n  DestinationIPs=make_set(DestinationIP), ModelMatchCount=sum(EventCount), MaxSeverity=max(todecimal  (LogSeverity)) by SourceHostName\n", "attributes": {"description": "This query searches for devices with high severity event(s).", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AristaAwakeSecurity/Analytic%20Rules/ModelMatchesWithMultipleDestinationsByDevice.yaml", "query_name": "Awake Security - Model With Multiple Destinations", "query": "CommonSecurityLog | where DeviceVendor == \"Arista Networks\" and DeviceProduct == \"Awake Security\"\n| summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), Models=make_set(Activity), ASPMatchURLs=make_set(DeviceCustomString2), SourceIPs=make_set(SourceIP),\n  DestinationIPs=make_set(DestinationIP), ModelMatchCount=sum(EventCount), MaxSeverity=max(toint(LogSeverity)) by SourceHostName\n| where array_length(DestinationIPs) > 1\n", "attributes": {"description": "This query searches for devices with multiple possibly malicious destinations.", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Armorblox/Analytic%20Rules/ArmorbloxNeedsReviewAlert.yaml", "query_name": "Armorblox Needs Review Alert", "query": "Armorblox_CL| where remediation_actions_s contains \"Needs Review\"", "attributes": {"description": "'This rule generates an alert for an Armorblox incident where the remediation action is \"Needs Review\".'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraGlobalPermissionAdded.yaml", "query_name": "Jira - Global permission added", "query": "JiraAudit\n| where EventMessage =~ 'Global permission added'\n| project EventCreationTime, ObjectItemName, UserName, SrcIpAddr, ChangedValues\n| extend AccountCustomEntity = UserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when global permission added.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraNewPrivilegedUser.yaml", "query_name": "Jira - New site admin user", "query": "JiraAudit\n| where EventMessage =~ 'User added to group'\n| where ObjectItemName =~ 'site-admins'\n| extend user = todynamic(AssociatedItems)[0]['name']\n| extend AccountCustomEntity = user\n", "attributes": {"description": "'Detects new site admin user.'\n", "techniques": ["T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraNewUser.yaml", "query_name": "Jira - New user created", "query": "JiraAudit\n| where EventMessage =~ 'User created'\n| where ObjectItemTypeName =~ 'USER'\n| project EventCreationTime, UserName, SrcIpAddr, ObjectItemName, AssociatedItems\n| extend AccountCustomEntity = ObjectItemName\n", "attributes": {"description": "'Detects when new user was created.'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraPermissionSchemeUpdated.yaml", "query_name": "Jira - Permission scheme updated", "query": "JiraAudit\n| where EventMessage =~ 'Permission scheme updated'\n| project EventCreationTime, ObjectItemName, UserName, SrcIpAddr, ChangedValues\n| extend AccountCustomEntity = UserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when permission scheme was updated.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraPrivilegedUserPasswordChanged.yaml", "query_name": "Jira - New site admin user", "query": "let priv_users = JiraAudit\n| where TimeGenerated > ago(14d)\n| where EventMessage =~ 'User added to group'\n| where ObjectItemName =~ 'site-admins'\n| extend user = todynamic(AssociatedItems)[0]['name']\n| summarize makeset(user);\nJiraAudit\n| where EventMessage =~ \"User's password changed\"\n| extend user = todynamic(AssociatedItems)[0]['name']\n| where user in (priv_users)\n| extend AccountCustomEntity = user\n", "attributes": {"description": "'Detects new site admin user.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraProjectRolesChanged.yaml", "query_name": "Jira - Project roles changed", "query": "JiraAudit\n| where EventMessage =~ 'Project roles changed'\n| project EventCreationTime, ObjectItemName, UserName, SrcIpAddr, AssociatedItems\n| extend AccountCustomEntity = UserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when project roles were changed.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraUserPasswordChange.yaml", "query_name": "Jira - User's password changed multiple times", "query": "JiraAudit\n| where EventMessage =~ \"User's password changed\"\n| extend user = todynamic(AssociatedItems)[0]['name']\n| summarize ip_list = makeset(SrcIpAddr) by tostring(user), bin(TimeGenerated, 30m)\n| where array_length(ip_list) > 1\n| extend AccountCustomEntity = user, IPCustomEntity = ip_list\n", "attributes": {"description": "'Detects when user's password was changed multiple times from different IP addresses.'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraUserRemovedFromGroup.yaml", "query_name": "Jira - User removed from group", "query": "JiraAudit\n| where EventMessage =~ 'User removed from group'\n| extend user = todynamic(AssociatedItems)[0]['name']\n| project EventCreationTime, ObjectItemName, user\n| extend AccountCustomEntity = user\n", "attributes": {"description": "'Detects when a user was removed from group.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraUserRemovedFromProject.yaml", "query_name": "Jira - User removed from project", "query": "JiraAudit\n| where EventMessage =~ 'User removed from project'\n| extend user = todynamic(AssociatedItems)[0]['name']\n| project EventCreationTime, ObjectItemName, user\n| extend AccountCustomEntity = user\n", "attributes": {"description": "'Detects when a user was removed from project.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Analytic%20Rules/JiraWorkflowSchemeCopied.yaml", "query_name": "Jira - Workflow scheme copied", "query": "JiraAudit\n| where EventMessage =~ 'Workflow scheme copied'\n| extend workflow = todynamic(AssociatedItems)[0]['name']\n| project EventCreationTime, ObjectItemName, UserName, SrcIpAddr, workflow\n| extend AccountCustomEntity = UserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when workflow scheme was copied.'\n", "techniques": ["T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraBlockedTasks.yaml", "query_name": "Jira - Blocked tasks", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where EventMessage in ('Status updated', 'Status created')\n| where ObjectItemTypeName =~ 'STATUS'\n| where ObjectItemName =~ 'Blocked'\n| extend ProcessCustomEntity = ObjectItemName\n", "attributes": {"description": "'Query searches for blocked tasks.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraNewUsers.yaml", "query_name": "Jira - New users", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'User created'\n| where ObjectItemTypeName =~ 'USER'\n| project EventCreationTime, UserName, SrcIpAddr, ObjectItemName, AssociatedItems\n| extend AccountCustomEntity = ObjectItemName\n", "attributes": {"description": "'Query searches for new users created.'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraProjectVersionsReleased.yaml", "query_name": "Jira - Project versions released", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'Project version released'\n| project EventCreationTime, UserName, ObjectItemName, AssociatedItems\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for project versions released.'\n", "techniques": ["T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraUpdatedProjects.yaml", "query_name": "Jira - Updated projects", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'Project updated'\n| project EventCreationTime, UserName, SrcIpAddr, ObjectItemName, ChangedValues, AssociatedItems\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for updated projects.'\n", "techniques": ["T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraUpdatedProjectVersions.yaml", "query_name": "Jira - Project versions", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'Project version created'\n| project EventCreationTime, UserName, SrcIpAddr, ObjectItemName, ChangedValues, AssociatedItems\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for project versions.'\n", "techniques": ["T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraUpdatedUsers.yaml", "query_name": "Jira - Updated users", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'User updated'\n| project EventCreationTime, ObjectItemName, ChangedValues, AssociatedItems\n| extend AccountCustomEntity = ObjectItemName\n", "attributes": {"description": "'Query searches for updated users.'\n", "techniques": ["T1531", "T1078"], "tactics": ["PrivilegeEscalation", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraUpdatedWorkflows.yaml", "query_name": "Jira - Updated workflows", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'Workflow updated'\n| project EventCreationTime, UserName, SrcIpAddr, ObjectItemName, ChangedValues\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for updated workflows.'\n", "techniques": ["T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraUpdatedWorkflowSchemes.yaml", "query_name": "Jira - Updated workflow schemes", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'Workflow scheme updated'\n| project EventCreationTime, UserName, SrcIpAddr, ObjectItemName\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for updated workflow schemes.'\n", "techniques": ["T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraUserIPs.yaml", "query_name": "Jira - Users' IP addresses", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where isnotempty(SrcIpAddr)\n| where isnotempty(USerName)\n| summarize ip_list = makeset(SrcIpAddr) by UserName\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for users' IP addresses.'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AtlassianJiraAudit/Hunting%20Queries/JiraWorkflowAddedToProject.yaml", "query_name": "Jira - Workflow schemes added to projects", "query": "JiraAudit\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'Workflow scheme added to project'\n| project EventCreationTime, UserName, ObjectItemName, AssociatedItems\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for workflow schemes added to projects.'\n", "techniques": ["T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/AccountCreatedandDeletedinShortTimeframe.yaml", "query_name": "Account Created and Deleted in Short Timeframe", "query": "let queryfrequency = 1h;\nlet queryperiod = 1d;\nAuditLogs\n| where TimeGenerated > ago(queryfrequency)\n| where OperationName =~ \"Delete user\"\n//extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n| extend UserPrincipalName = extract(@'([a-f0-9]{32})?(.*)', 2, tostring(TargetResources[0].userPrincipalName))\n| extend DeletedByUser = tostring(InitiatedBy.user.userPrincipalName), DeletedByIPAddress = tostring(InitiatedBy.user.ipAddress)\n| extend DeletedByApp = tostring(InitiatedBy.app.displayName)\n| project Deletion_TimeGenerated = TimeGenerated, UserPrincipalName, DeletedByUser, DeletedByIPAddress, DeletedByApp, Deletion_AdditionalDetails = AdditionalDetails, Deletion_InitiatedBy = InitiatedBy, Deletion_TargetResources = TargetResources\n| join kind=inner (\n    AuditLogs\n    | where TimeGenerated > ago(queryperiod)\n    | where OperationName =~ \"Add user\"\n    | extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n    | project-rename Creation_TimeGenerated = TimeGenerated\n) on UserPrincipalName\n| extend TimeDelta = Deletion_TimeGenerated - Creation_TimeGenerated\n| where  TimeDelta between (time(0s) .. queryperiod)\n| extend CreatedByUser = tostring(InitiatedBy.user.userPrincipalName), CreatedByIPAddress = tostring(InitiatedBy.user.ipAddress)\n| extend CreatedByApp = tostring(InitiatedBy.app.displayName)\n| project Creation_TimeGenerated, Deletion_TimeGenerated, TimeDelta, UserPrincipalName, DeletedByUser, DeletedByIPAddress, DeletedByApp, CreatedByUser, CreatedByIPAddress, CreatedByApp, Creation_AdditionalDetails = AdditionalDetails, Creation_InitiatedBy = InitiatedBy, Creation_TargetResources = TargetResources, Deletion_AdditionalDetails, Deletion_InitiatedBy, Deletion_TargetResources\n| extend timestamp = Deletion_TimeGenerated, CustomAccountEntity = UserPrincipalName, IPCustomEntity = DeletedByIPAddress\n", "attributes": {"description": "'Search for user principal name (UPN) events. Look for accounts created and then deleted in under 24 hours. Attackers may create an account for their use, and then remove the account when no longer needed.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#short-lived-account'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/AccountCreatedDeletedByNonApprovedUser.yaml", "query_name": "Account created or deleted by non-approved user", "query": "// Add non-approved user principal names to the list below to search for their account creation/deletion activity\n// ex: dynamic([\"UPN1\", \"upn123\"])\nlet nonapproved_users = dynamic([]);\nAuditLogs\n| where OperationName == \"Add user\" or OperationName == \"Delete user\"\n| where Result == \"success\"\n| extend InitiatingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| where InitiatingUser has_any (nonapproved_users)\n| project-reorder TimeGenerated, ResourceId, OperationName, InitiatingUser, TargetResources\n| extend AccountCustomEntity = InitiatingUser, IPCustomEntity = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n", "attributes": {"description": "'Identifies accounts that were created or deleted by a defined list of non-approved user principal names. Add to this list before running the query for accurate results.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/ADFSDomainTrustMods.yaml", "query_name": "Modified domain federation trust settings", "query": "(union isfuzzy=true\n(\nAuditLogs\n| where OperationName =~ \"Set federation settings on domain\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-expand modifiedProperties\n| extend targetDisplayName = tostring(parse_json(modifiedProperties).displayName)\n| mv-expand AdditionalDetails\n),\n(\nAuditLogs\n| where OperationName =~ \"Set domain authentication\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-expand modifiedProperties\n| extend targetDisplayName = tostring(parse_json(modifiedProperties).displayName), NewDomainValue=tostring(parse_json(modifiedProperties).newValue)\n| where NewDomainValue has \"Federated\"\n)\n)\n| extend UserAgent = iff(AdditionalDetails.key == \"User-Agent\",tostring(AdditionalDetails.value),\"\")\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, AADOperationType, targetDisplayName, Result, InitiatingIpAddress, UserAgent, CorrelationId, TenantId, AADTenantId\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUserOrApp, IPCustomEntity = InitiatingIpAddress\n", "attributes": {"description": "'This will alert when a user or application modifies the federation settings on the domain or Update domain authentication from Managed to Federated.\nFor example, this alert will trigger when a new Active Directory Federated Service (ADFS) TrustedRealm object, such as a signing certificate, is added to the domain.\nModification to domain federation settings should be rare. Confirm the added or modified target domain/URL is legitimate administrator behavior.\nTo understand why an authorized user may update settings for a federated domain in Office 365, Azure, or Intune, see: https://docs.microsoft.com/office365/troubleshoot/active-directory/update-federated-domain-office-365.\nFor details on security realms that accept security tokens, see the ADFS Proxy Protocol (MS-ADFSPP) specification: https://docs.microsoft.com/openspecs/windows_protocols/ms-adfspp/e7b9ea73-1980-4318-96a6-da559486664b.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/ADFSSignInLogsPasswordSpray.yaml", "query_name": "Password spray attack against ADFSSignInLogs", "query": "let queryfrequency = 30m;\nlet accountthreshold = 10;\nlet successCodes = dynamic([0, 50144]);\nADFSSignInLogs\n| extend IngestionTime = ingestion_time()\n| where IngestionTime > ago(queryfrequency)\n| where not(todynamic(AuthenticationDetails)[0].authenticationMethod == \"Integrated Windows Authentication\")\n| summarize\n    DistinctFailureCount = dcountif(UserPrincipalName, ResultType !in (successCodes)),\n    DistinctSuccessCount = dcountif(UserPrincipalName, ResultType in (successCodes)),\n    SuccessAccounts = make_set_if(UserPrincipalName, ResultType in (successCodes), 250),\n    arg_min(TimeGenerated, *)\n    by IPAddress\n| where DistinctFailureCount > DistinctSuccessCount and DistinctFailureCount >= accountthreshold\n//| extend SuccessAccounts = iff(array_length(SuccessAccounts) != 0, SuccessAccounts, dynamic([\"null\"]))\n//| mv-expand SuccessAccounts\n| project TimeGenerated, Category, OperationName, IPAddress, DistinctFailureCount, DistinctSuccessCount, SuccessAccounts, AuthenticationRequirement, ConditionalAccessStatus, IsInteractive, UserAgent, NetworkLocationDetails, DeviceDetail, TokenIssuerType, TokenIssuerName, ResourceIdentity\n", "attributes": {"description": "'Identifies evidence of password spray activity against Connect Health for AD FS sign-in events by looking for failures from multiple accounts from the same IP address within a time window.\nReference: https://adfshelp.microsoft.com/References/ConnectHealthErrorCodeReference'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/AdminPromoAfterRoleMgmtAppPermissionGrant.yaml", "query_name": "Admin promotion after Role Management Application Permission Grant", "query": "AuditLogs\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where AADOperationType =~ \"Assign\"\n| where ActivityDisplayName =~ \"Add app role assignment to service principal\"\n| mv-expand TargetResources\n| mv-expand TargetResources.modifiedProperties\n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n| where displayName_ =~ \"AppRole.Value\"\n| extend AppRole = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n| where AppRole has \"RoleManagement.ReadWrite.Directory\"\n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n| extend Target = tostring(parse_json(tostring(TargetResources.modifiedProperties[4].newValue)))\n| extend TargetId = tostring(parse_json(tostring(TargetResources.modifiedProperties[3].newValue)))\n| project TimeGenerated, OperationName, Initiator, Target, TargetId, Result\n| join kind=innerunique (\n  AuditLogs\n  | where LoggedByService =~ \"Core Directory\"\n  | where Category =~ \"RoleManagement\"\n  | where AADOperationType in (\"Assign\", \"AssignEligibleRole\")\n  | where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n  | mv-expand TargetResources\n  | mv-expand TargetResources.modifiedProperties\n  | extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n  | where displayName_ =~ \"Role.DisplayName\"\n  | extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n  | where RoleName contains \"Admin\"\n  | extend Initiator = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n  | extend InitiatorId = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n  | extend TargetUser = tostring(TargetResources.userPrincipalName)\n  | extend Target = iif(isnotempty(TargetUser), TargetUser, tostring(TargetResources.displayName))\n  | extend TargetType = tostring(TargetResources.type)\n  | extend TargetId = tostring(TargetResources.id)\n  | project TimeGenerated, OperationName,  RoleName, Initiator, InitiatorId, Target, TargetId, TargetType, Result\n) on $left.TargetId == $right.InitiatorId\n| extend TimeRoleMgGrant = TimeGenerated, TimeAdminPromo = TimeGenerated1, ServicePrincipal = Initiator1, ServicePrincipalId = InitiatorId,\n  TargetObject = Target1, TargetObjectId = TargetId1, TargetObjectType = TargetType\n| where TimeRoleMgGrant < TimeAdminPromo\n| project TimeRoleMgGrant, TimeAdminPromo, RoleName, ServicePrincipal, ServicePrincipalId, TargetObject, TargetObjectId, TargetObjectType\n", "attributes": {"description": "'This rule looks for a service principal being granted the Microsoft Graph RoleManagement.ReadWrite.Directory (application) permission before being used to add an Azure AD object or user account to an Admin directory role (i.e. Global Administrators).\nThis is a known attack path that is usually abused when a service principal already has the AppRoleAssignment.ReadWrite.All permission granted. This permission Allows an app to manage permission grants for application permissions to any API.\nA service principal can promote itself or other service principals to admin roles (i.e. Global Administrators). This would be considered a privilege escalation technique.\nRef : https://docs.microsoft.com/graph/permissions-reference#role-management-permissions, https://docs.microsoft.com/graph/api/directoryrole-post-members?view=graph-rest-1.0&tabs=http'\n", "techniques": ["T1098.003", "T1078.004"], "tactics": ["PrivilegeEscalation", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/AnomalousUserAppSigninLocationIncrease-detection.yaml", "query_name": "Anomalous sign-in location by user account and authenticating application", "query": "\nlet lookBack_long = 7d;\nlet lookBack_med = 3d;\nlet lookBack = 1d;\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where TimeGenerated >= startofday(ago(lookBack_long))\n| extend DeviceDetail = todynamic(DeviceDetail), Status = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n| extend locationString = strcat(tostring(LocationDetails.countryOrRegion), \"/\", tostring(LocationDetails.state), \"/\", tostring(LocationDetails.city), \";\") \n| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString \n// Create time series \n| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack_long)),now(), 1d) \nby UserPrincipalName, AppDisplayName \n// Compute best fit line for each entry \n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount) \n// Chart the 3 most interesting lines  \n// A 0-value slope corresponds to an account being completely stable over time for a given Azure Active Directory application\n| where Slope > 0.3\n| top 50 by Slope desc\n| join kind = leftsemi (\ntable(tableName)\n| where TimeGenerated >= startofday(ago(lookBack_med))\n| extend DeviceDetail = todynamic(DeviceDetail), Status = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n| extend locationString = strcat(tostring(LocationDetails.countryOrRegion), \"/\", tostring(LocationDetails.state), \"/\", tostring(LocationDetails.city), \";\") \n| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString \n| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack_med)) ,now(), 1d) \nby UserPrincipalName, AppDisplayName \n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount)\n| where Slope > 0.3\n| top 50 by Slope desc\n) on UserPrincipalName, AppDisplayName\n| join kind = leftsemi (\ntable(tableName)\n| where TimeGenerated >= startofday(ago(lookBack))\n| extend DeviceDetail = todynamic(DeviceDetail), Status = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n| extend locationString = strcat(tostring(LocationDetails.countryOrRegion), \"/\", tostring(LocationDetails.state), \"/\", tostring(LocationDetails.city), \";\") \n| project TimeGenerated, AppDisplayName , UserPrincipalName, locationString \n| make-series dLocationCount = dcount(locationString) on TimeGenerated in range(startofday(ago(lookBack)) ,now(), 1d) \nby UserPrincipalName, AppDisplayName \n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(dLocationCount)\n| where Slope > 5\n| top 50 by Slope desc\n// Higher threshold requirement on last day anomaly\n) on UserPrincipalName, AppDisplayName\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active \nDirectory application and picks out the most anomalous change in location profile for a user within an \nindividual application. An alert is generated for recent sign-ins that have location counts that are anomalous\nover last day but also over the last 3-day and 7-day periods.\nPlease note that on workspaces with larger volume of Signin data (~10M+ events a day) may timeout when using this default query time period.\nIt is recommended that you test and tune this appropriately for the workspace.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/AuthenticationMethodsChangedforPrivilegedAccount.yaml", "query_name": "Authentication Methods Changed for Privileged Account", "query": "let queryperiod = 14d;\nlet queryfrequency = 2h;\nlet security_info_actions = dynamic([\"User registered security info\", \"User changed default security info\", \"User deleted security info\", \"Admin updated security info\", \"User reviewed security info\", \"Admin deleted security info\", \"Admin registered security info\"]);\nlet VIPUsers = (\n    IdentityInfo\n    | where TimeGenerated > ago(queryperiod)\n    | mv-expand AssignedRoles\n    | where AssignedRoles matches regex 'Admin'\n    | summarize by tolower(AccountUPN));\nAuditLogs\n| where TimeGenerated > ago(queryfrequency)\n| where Category =~ \"UserManagement\"\n| where ActivityDisplayName in (security_info_actions)\n| extend Initiator = tostring(InitiatedBy.user.userPrincipalName)\n| extend IP = tostring(InitiatedBy.user.ipAddress)\n| extend Target = tolower(tostring(TargetResources[0].userPrincipalName))\n| where Target in (VIPUsers)\n// Uncomment the line below if you are experiencing high volumes of Target entities. If this is uncommented, the Target column will not be mapped to an entity.\n//| summarize Start=min(TimeGenerated), End=max(TimeGenerated), Actions = make_set(ResultReason, MaxSize=8), Targets=make_set(Target, MaxSize=256) by Initiator, IP, Result\n// Comment out this line below, if line above is used.\n| summarize Start=min(TimeGenerated), End=max(TimeGenerated), Actions = make_set(ResultReason, MaxSize=8) by Initiator, IP, Result, Targets = Target\n", "attributes": {"description": "'Identifies authentication methods being changed for a privileged account. This could be an indication of an attacker adding an auth method to the account so they can have continued access.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/AzureAADPowerShellAnomaly.yaml", "query_name": "Azure Active Directory PowerShell accessing non-AAD resources", "query": "let aadFunc = (tableName:string){\ntable(tableName)\n| where AppId =~ \"1b730954-1685-4b74-9bfd-dac224a7b894\" // AppDisplayName IS Azure Active Directory PowerShell\n| where TokenIssuerType =~ \"AzureAD\"\n| where ResourceIdentity !in (\"00000002-0000-0000-c000-000000000000\", \"00000003-0000-0000-c000-000000000000\") // ResourceDisplayName IS NOT Windows Azure Active Directory OR Microsoft Graph\n| extend Status = todynamic(Status)\n| where Status.errorCode == 0 // Success\n| project-reorder IPAddress, UserAgent, ResourceDisplayName, UserDisplayName, UserId, UserPrincipalName, Type\n| order by TimeGenerated desc\n// New entity mapping\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'This will alert when a user or application signs in using Azure Active Directory PowerShell to access non-Active Directory resources, such as the Azure Key Vault, which may be undesired or unauthorized behavior.\nFor capabilities and expected behavior of the Azure Active Directory PowerShell module, see: https://docs.microsoft.com/powershell/module/azuread/?view=azureadps-2.0.\nFor further information on Azure Active Directory Signin activity reports, see: https://docs.microsoft.com/azure/active-directory/reports-monitoring/concept-sign-ins.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/AzureADRoleManagementPermissionGrant.yaml", "query_name": "Azure AD Role Management Permission Grant", "query": "AuditLogs\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where AADOperationType =~ \"Assign\"\n| where ActivityDisplayName has_any (\"Add delegated permission grant\",\"Add app role assignment to service principal\")\n| mv-expand TargetResources\n| mv-expand TargetResources.modifiedProperties\n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n| where displayName_ has_any (\"AppRole.Value\",\"DelegatedPermissionGrant.Scope\")\n| extend Permission = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n| where Permission has \"RoleManagement.ReadWrite.Directory\"\n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n| extend Target = tostring(parse_json(tostring(TargetResources.modifiedProperties[4].newValue)))\n| extend TargetId = iif(displayName_ =~ 'DelegatedPermissionGrant.Scope',\n  tostring(parse_json(tostring(TargetResources.modifiedProperties[2].newValue))),\n  tostring(parse_json(tostring(TargetResources.modifiedProperties[3].newValue))))\n| summarize by bin(TimeGenerated, 1h), OperationName, Initiator, Target, TargetId, Result\n", "attributes": {"description": "'Identifies when the Microsoft Graph RoleManagement.ReadWrite.Directory (Delegated or Application) permission is granted to a service principal.\nThis permission allows an application to read and manage the role-based access control (RBAC) settings for your company's directory.\nAn adversary could use this permission to add an Azure AD object to an Admin directory role and escalate privileges.\nRef : https://docs.microsoft.com/graph/permissions-reference#role-management-permissions\nRef : https://docs.microsoft.com/graph/api/directoryrole-post-members?view=graph-rest-1.0&tabs=http'\n", "techniques": ["T1098.003", "T1078.004"], "tactics": ["Persistence", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/AzurePortalSigninfromanotherAzureTenant.yaml", "query_name": "Azure Portal Signin from another Azure Tenant", "query": "// Get details of current Azure Ranges (note this URL updates regularly so will need to be manually updated over time)\n// You may find the name of the new JSON here: https://www.microsoft.com/download/details.aspx?id=56519\n// On the downloads page, click the 'details' button, and then replace just the filename in the URL below\nlet azure_ranges = externaldata(changeNumber: string, cloud: string, values: dynamic)\n[\"https://download.microsoft.com/download/7/1/D/71D86715-5596-4529-9B13-DA13A5DE5B63/ServiceTags_Public_20220321.json\"]\nwith(format='multijson')\n| mv-expand values\n| mv-expand values.properties.addressPrefixes\n| mv-expand values_properties_addressPrefixes\n| summarize by tostring(values_properties_addressPrefixes);\nSigninLogs\n// Limiting to Azure Portal really reduces false positives and helps focus on potential admin activity\n| where AppDisplayName =~ \"Azure Portal\"\n// Only get logons where the IP address is in an Azure range\n| evaluate ipv4_lookup(azure_ranges, IPAddress, values_properties_addressPrefixes)\n// Limit to where the user is external to the tenant\n| where HomeTenantId != ResourceTenantId\n// Further limit it to just access to the current tenant (you can drop this if you wanted to look elsewhere as well but it helps reduce FPs)\n| where ResourceTenantId == AADTenantId\n| summarize FirstSeen = min(TimeGenerated), LastSeen = max(TimeGenerated), make_set(ResourceDisplayName) by UserPrincipalName, IPAddress, UserAgent, Location, HomeTenantId, ResourceTenantId\n| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'This query looks for sign in attempts to the Azure Portal where the user who is signing in from another Azure tenant,\n and the IP address the login attempt is from is an Azure IP. A threat actor who compromises an Azure tenant may look\n to pivot to other tenants leveraging cross-tenant delegated access in this manner.'\n", "techniques": ["T1199"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/Brute%20Force%20Attack%20against%20GitHub%20Account.yaml", "query_name": "Brute Force Attack against GitHub Account", "query": "let LearningPeriod = 7d; \nlet BinTime = 1h; \nlet RunTime = 1h; \nlet StartTime = 1h; \nlet NumberOfStds = 3; \nlet MinThreshold = 10.0; \nlet EndRunTime = StartTime - RunTime; \nlet EndLearningTime = StartTime + LearningPeriod;\nlet aadFunc = (tableName:string){\nlet GitHubFailedSSOLogins = (table(tableName)  \n| where AppDisplayName == \"GitHub.com\" \n| where ResultType != 0); \nGitHubFailedSSOLogins \n| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime)) \n| summarize FailedLoginsCountInBinTime = count() by  UserPrincipalName, bin(TimeGenerated, BinTime), Type\n| summarize AvgOfFailedLoginsInLearning = avg(FailedLoginsCountInBinTime), StdOfFailedLoginsInLearning = stdev(FailedLoginsCountInBinTime) by UserPrincipalName, Type\n| extend LearningThreshold = max_of(AvgOfFailedLoginsInLearning + StdOfFailedLoginsInLearning * NumberOfStds, MinThreshold)  \n| join kind=innerunique ( \n  GitHubFailedSSOLogins \n  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime)) \n  | summarize FailedLoginsCountInRunTime = count() by User = Identity, UserPrincipalName, bin(TimeGenerated, BinTime), Type\n) on UserPrincipalName \n| where FailedLoginsCountInRunTime > LearningThreshold\n| extend AccountCustomEntity = UserPrincipalName , timestamp = TimeGenerated\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Attackers who are trying to guess your users' passwords or use brute-force methods to get in. If your organization is using SSO with Azure Active Directory, authentication logs to GitHub.com will be generated. Using the following query can help you identify a sudden increase in failed logon attempt of users.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/BruteForceCloudPC.yaml", "query_name": "Brute force attack against a Cloud PC", "query": "let failureCountThreshold = 5;\nlet successCountThreshold = 1;\nlet authenticationWindow = 20m;\nSigninLogs\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city)\n| where AppDisplayName =~ \"Windows Sign In\"\n// Split out failure versus non-failure types\n| extend FailureOrSuccess = iff(ResultType in (\"0\", \"50125\", \"50140\", \"70043\", \"70044\"), \"Success\", \"Failure\")\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), IPAddress = makeset(IPAddress), makeset(OS), makeset(Browser), makeset(City), \nmakeset(ResultType), FailureCount = countif(FailureOrSuccess==\"Failure\"), SuccessCount = countif(FailureOrSuccess==\"Success\") \nby bin(TimeGenerated, authenticationWindow), UserDisplayName, UserPrincipalName, AppDisplayName\n| where FailureCount >= failureCountThreshold and SuccessCount >= successCountThreshold\n| mvexpand IPAddress\n| extend IPAddress = tostring(IPAddress)\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Identifies evidence of brute force activity against a Windows 365 Cloud PC by highlighting multiple authentication failures and by a successful authentication within a given time window.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/BulkChangestoPrivilegedAccountPermissions.yaml", "query_name": "Bulk Changes to Privileged Account Permissions", "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-expand TargetResources\n| mv-expand TargetResources.modifiedProperties\n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n| where displayName_ =~ \"Role.DisplayName\"\n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n| where RoleName contains \"Admin\"\n| extend Target = tostring(TargetResources.userPrincipalName)\n| summarize dcount(Target) by bin(TimeGenerated, 1h)\n| where dcount_Target > 9\n| join kind=rightsemi  (AuditLogs\n| where Category =~ \"RoleManagement\"\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-expand TargetResources\n| mv-expand TargetResources.modifiedProperties\n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n| where displayName_ =~ \"Role.DisplayName\"\n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n| where RoleName contains \"Admin\"\n| extend Target = tostring(TargetResources.userPrincipalName)\n| extend TimeWindow = bin(TimeGenerated, 1h)) on $left.TimeGenerated == $right.TimeWindow\n| extend AccountCustomEntity = Target\n", "attributes": {"description": "'Identifies when changes to multiple users permissions are changed at once. Investigate immediately if not a planned change. This setting could enable an attacker access to Azure subscriptions in your environment.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-identity-management'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/BypassCondAccessRule.yaml", "query_name": "Attempt to bypass conditional access rule in Azure AD", "query": "\nlet threshold = 1;\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where ConditionalAccessStatus == 1 or ConditionalAccessStatus =~ \"failure\"\n| extend DeviceDetail = todynamic(DeviceDetail), Status = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city), Region = tostring(LocationDetails.countryOrRegion) \n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend ConditionalAccessPolicies = todynamic(ConditionalAccessPolicies)\n| extend ConditionalAccessPol0Name = tostring(ConditionalAccessPolicies[0].displayName)\n| extend ConditionalAccessPol1Name = tostring(ConditionalAccessPolicies[1].displayName)\n| extend ConditionalAccessPol2Name = tostring(ConditionalAccessPolicies[2].displayName)\n| extend Status = strcat(StatusCode, \": \", ResultDescription) \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), Status = make_list(Status), StatusDetails = make_list(StatusDetails), IPAddresses = make_list(IPAddress), IPAddressCount = dcount(IPAddress), CorrelationIds = make_list(CorrelationId) \nby UserPrincipalName, AppDisplayName, tostring(Browser), tostring(OS), City, State, Region, ConditionalAccessPol0Name, ConditionalAccessPol1Name, ConditionalAccessPol2Name, Type\n| where IPAddressCount > threshold and StatusDetails !has \"MFA successfully completed\"\n| mvexpand IPAddresses, Status, StatusDetails, CorrelationIds\n| extend Status = strcat(Status, \" \", StatusDetails)\n| summarize IPAddresses = make_set(IPAddresses), Status = make_set(Status), CorrelationIds = make_set(CorrelationIds) \nby StartTime, EndTime, UserPrincipalName, AppDisplayName, tostring(Browser), tostring(OS), City, State, Region, ConditionalAccessPol0Name, ConditionalAccessPol1Name, ConditionalAccessPol2Name, IPAddressCount, Type\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = tostring(IPAddresses)\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies an attempt to Bypass conditional access rule(s) in Azure Active Directory.\nThe ConditionalAccessStatus column value details if there was an attempt to bypass Conditional Access\nor if the Conditional access rule was not satisfied (ConditionalAccessStatus == 1).\nReferences: \nhttps://docs.microsoft.com/azure/active-directory/conditional-access/overview\nhttps://docs.microsoft.com/azure/active-directory/reports-monitoring/concept-sign-ins\nhttps://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\nConditionalAccessStatus == 0 // Success\nConditionalAccessStatus == 1 // Failure\nConditionalAccessStatus == 2 // Not Applied\nConditionalAccessStatus == 3 // unknown'\n", "techniques": ["T1078", "T1098"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/CredentialAddedAfterAdminConsent.yaml", "query_name": "Credential added after admin consented to Application", "query": "let auditLookbackStart = 2d;\nlet auditLookbackEnd = 1d;\nAuditLogs\n| where TimeGenerated >= ago(auditLookbackStart)\n| where OperationName =~ \"Consent to application\" \n| where Result =~ \"success\"\n| mv-expand target = TargetResources\n| extend targetResourceName = tostring(target.displayName)\n| extend targetResourceID = tostring(target.id)\n| extend targetResourceType = tostring(target.type)\n| extend targetModifiedProp = TargetResources[0].modifiedProperties\n| extend isAdminConsent = targetModifiedProp[0].newValue\n| extend Consent_ServicePrincipalNames = targetModifiedProp[5].newValue\n| extend Consent_Permissions = targetModifiedProp[4].newValue\n| extend Consent_InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend Consent_InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| join ( \nAuditLogs\n| where TimeGenerated  >= ago(auditLookbackEnd)\n| where OperationName =~ \"Add service principal credentials\"\n| where Result =~ \"success\"\n| mv-expand target = TargetResources\n| extend targetResourceName = tostring(target.displayName)\n| extend targetResourceID = tostring(target.id)\n| extend targetModifiedProp = TargetResources[0].modifiedProperties\n| extend Credential_KeyDescription = targetModifiedProp[0].newValue\n| extend UpdatedProperties = targetModifiedProp[1].newValue\n| extend Credential_ServicePrincipalNames = targetModifiedProp[2].newValue\n| extend Credential_InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend Credential_InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n) on targetResourceName, targetResourceID\n| extend TimeConsent = TimeGenerated, TimeCred = TimeGenerated1\n| where TimeConsent > TimeCred \n| project TimeConsent, TimeCred, Consent_InitiatingUserOrApp, Credential_InitiatingUserOrApp, targetResourceName, targetResourceType, isAdminConsent, Consent_ServicePrincipalNames, Credential_ServicePrincipalNames, Consent_Permissions, Credential_KeyDescription, Consent_InitiatingIpAddress, Credential_InitiatingIpAddress\n| extend timestamp = TimeConsent, AccountCustomEntity = Consent_InitiatingUserOrApp, IPCustomEntity = Consent_InitiatingIpAddress\n", "attributes": {"description": "'This query will identify instances where Service Principal credentials were added to an application by one user after the application was granted admin consent rights by another user.\n If a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\n Additional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow.\n For further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/DisabledAccountSigninsAcrossManyApplications.yaml", "query_name": "Attempts to sign in to disabled accounts", "query": "\nlet threshold = 3;\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where ResultType == \"50057\"\n| where ResultDescription =~ \"User account is disabled. The account has been disabled by an administrator.\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), applicationCount = dcount(AppDisplayName), \napplicationSet = make_set(AppDisplayName), count() by UserPrincipalName, IPAddress, Type\n| where applicationCount >= threshold\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies failed attempts to sign in to disabled accounts across multiple Azure Applications.\nDefault threshold for Azure Applications attempted to sign in to is 3.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n50057 - User account is disabled. The account has been disabled by an administrator.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/DistribPassCrackAttempt.yaml", "query_name": "Distributed Password cracking attempts in AzureAD", "query": "\nlet s_threshold = 30;\nlet l_threshold = 3;\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where OperationName =~ \"Sign-in activity\"\n// Error codes that we want to look at as they are related to the use of incorrect password.\n| where ResultType in (\"50126\", \"50053\" , \"50055\", \"50056\")\n| extend DeviceDetail = todynamic(DeviceDetail), Status = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n| extend OS = DeviceDetail.operatingSystem, Browser = DeviceDetail.browser\n| extend StatusCode = tostring(Status.errorCode), StatusDetails = tostring(Status.additionalDetails)\n| extend LocationString = strcat(tostring(LocationDetails.countryOrRegion), \"/\", tostring(LocationDetails.state), \"/\", tostring(LocationDetails.city))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), LocationCount=dcount(LocationString), Location = make_set(LocationString), \nIPAddress = make_set(IPAddress), IPAddressCount = dcount(IPAddress), AppDisplayName = make_set(AppDisplayName), ResultDescription = make_set(ResultDescription), \nBrowser = make_set(Browser), OS = make_set(OS), SigninCount = count() by UserPrincipalName, Type                              \n// Setting a generic threshold - Can be different for different environment\n| where SigninCount > s_threshold and LocationCount >= l_threshold\n| extend tostring(Location), tostring(IPAddress), tostring(AppDisplayName), tostring(ResultDescription), tostring(Browser), tostring(OS)\n| distinct *\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies distributed password cracking attempts from the Azure Active Directory SigninLogs.\nThe query looks for unusually high number of failed password attempts coming from multiple locations for a user account.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n50053   Account is locked because the user tried to sign in too many times with an incorrect user ID or password.\n50055   Invalid password, entered expired password.\n50056   Invalid or null password - Password does not exist in store for this user.\n50126   Invalid username or password, or invalid on-premises username or password.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/ExplicitMFADeny.yaml", "query_name": "Explicit MFA Deny", "query": "let aadFunc = (tableName:string){\ntable(tableName)\n| where ResultType == 500121\n| where Status has \"MFA Denied; user declined the authentication\" or Status has \"MFA denied; Phone App Reported Fraud\"\n| extend Type = Type\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress, URLCustomEntity = ClientAppUsed\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'User explicitly denies MFA push, indicating that login was not expected and the account's password may be compromised.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/FailedLogonToAzurePortal.yaml", "query_name": "Failed login attempts to Azure Portal", "query": "\nlet timeRange = 1d;\nlet lookBack = 7d;\nlet threshold_Failed = 5;\nlet threshold_FailedwithSingleIP = 20;\nlet threshold_IPAddressCount = 2;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet aadFunc = (tableName:string){\nlet azPortalSignins = materialize(table(tableName)\n| where TimeGenerated >= ago(lookBack)\n// Azure Portal only\n| where AppDisplayName =~ \"Azure Portal\")\n;\nlet successPortalSignins = azPortalSignins\n| where TimeGenerated >= ago(timeRange)\n// Azure Portal only and exclude non-failure Result Types\n| where ResultType in (\"0\", \"50125\", \"50140\")\n// Tagging identities not resolved to friendly names\n//| extend Unresolved = iff(Identity matches regex isGUID, true, false)\n| distinct TimeGenerated, UserPrincipalName\n;\nlet failPortalSignins = azPortalSignins\n| where TimeGenerated >= ago(timeRange)\n// Azure Portal only and exclude non-failure Result Types\n| where ResultType !in (\"0\", \"50125\", \"50140\", \"70044\", \"70043\")\n// Tagging identities not resolved to friendly names\n| extend Unresolved = iff(Identity matches regex isGUID, true, false)\n;\n// Verify there is no success for the same connection attempt after the fail\nlet failnoSuccess = failPortalSignins | join kind= leftouter (\n   successPortalSignins \n) on UserPrincipalName\n| where TimeGenerated > TimeGenerated1 or isempty(TimeGenerated1)\n| project-away TimeGenerated1, UserPrincipalName1\n;\n// Lookup up resolved identities from last 7 days\nlet identityLookup = azPortalSignins\n| where TimeGenerated >= ago(lookBack)\n| where not(Identity matches regex isGUID)\n| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName;\n// Join resolved names to unresolved list from portal signins\nlet unresolvedNames = failnoSuccess | where Unresolved == true | join kind= inner (\n   identityLookup \n) on UserId\n| extend UserDisplayName = lu_UserDisplayName, UserPrincipalName = lu_UserPrincipalName\n| project-away lu_UserDisplayName, lu_UserPrincipalName;\n// Join Signins that had resolved names with list of unresolved that now have a resolved name\nlet u_azPortalSignins = failnoSuccess | where Unresolved == false | union unresolvedNames;\nu_azPortalSignins\n| extend DeviceDetail = todynamic(DeviceDetail), Status = todynamic(DeviceDetail), LocationDetails = todynamic(LocationDetails)\n| extend Status = strcat(ResultType, \": \", ResultDescription), OS = tostring(DeviceDetail.operatingSystem), Browser = tostring(DeviceDetail.browser)\n| extend State = tostring(LocationDetails.state), City = tostring(LocationDetails.city), Region = tostring(LocationDetails.countryOrRegion)\n| extend FullLocation = strcat(Region,'|', State, '|', City)\n| summarize TimeGenerated = makelist(TimeGenerated), Status = makelist(Status), IPAddresses = makelist(IPAddress), IPAddressCount = dcount(IPAddress), FailedLogonCount = count()\nby UserPrincipalName, UserId, UserDisplayName, AppDisplayName, Browser, OS, FullLocation, Type\n| mvexpand TimeGenerated, IPAddresses, Status\n| extend TimeGenerated = todatetime(tostring(TimeGenerated)), IPAddress = tostring(IPAddresses), Status = tostring(Status)\n| project-away IPAddresses\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, UserId, UserDisplayName, Status, FailedLogonCount, IPAddress, IPAddressCount, AppDisplayName, Browser, OS, FullLocation, Type\n| where (IPAddressCount >= threshold_IPAddressCount and FailedLogonCount >= threshold_Failed) or FailedLogonCount >= threshold_FailedwithSingleIP\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies failed login attempts in the Azure Active Directory SigninLogs to the Azure Portal.  Many failed logon \nattempts or some failed logon attempts from multiple IPs could indicate a potential brute force attack.  \nThe following are excluded due to success and non-failure results:\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n0 - successful logon\n50125 - Sign-in was interrupted due to a password reset or password registration entry.\n50140 - This error occurred due to 'Keep me signed in' interrupt when the user was signing-in.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/FirstAppOrServicePrincipalCredential.yaml", "query_name": "First access credential added to Application or Service Principal where no credential was present", "query": "AuditLogs\n| where OperationName has_any (\"Add service principal\", \"Certificates and secrets management\") // captures \"Add service principal\", \"Add service principal credentials\", and \"Update application - Certificates and secrets management\" events\n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| extend targetDisplayName = tostring(TargetResources[0].displayName)\n| extend targetId = tostring(TargetResources[0].id)\n| extend targetType = tostring(TargetResources[0].type)\n| extend keyEvents = TargetResources[0].modifiedProperties\n| mv-expand keyEvents\n| where keyEvents.displayName =~ \"KeyDescription\"\n| extend new_value_set = parse_json(tostring(keyEvents.newValue))\n| extend old_value_set = parse_json(tostring(keyEvents.oldValue))\n| where old_value_set == \"[]\"\n| mv-expand new_value_set\n| parse new_value_set with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| where keyUsage == \"Verify\"  or keyUsage == \"\"\n| extend UserAgent = iff(AdditionalDetails[0].key == \"User-Agent\",tostring(AdditionalDetails[0].value),\"\")\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n// The below line is currently commented out but Microsoft Sentinel users can modify this query to show only Application or only Service Principal events in their environment\n//| where targetType =~ \"Application\" // or targetType =~ \"ServicePrincipal\"\n| project-away new_value_set, old_value_set\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUserOrApp, IPCustomEntity = InitiatingIpAddress\n", "attributes": {"description": "'This will alert when an admin or app owner account adds a new credential to an Application or Service Principal where there was no previous verify KeyCredential associated.\nIf a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": ["T1550.001"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/MailPermissionsAddedToApplication.yaml", "query_name": "Mail.Read Permissions Granted to Application", "query": "\nAuditLogs\n| where Category =~ \"ApplicationManagement\"\n| where ActivityDisplayName has_any (\"Add delegated permission grant\",\"Add app role assignment to service principal\")\n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| extend props = parse_json(tostring(TargetResources[0].modifiedProperties))\n| mv-expand props\n| extend UserAgent = tostring(AdditionalDetails[0].value)\n| extend InitiatingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend UserIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend DisplayName = tostring(props.displayName)\n| extend Permissions = tostring(parse_json(tostring(props.newValue)))\n| where Permissions has_any (\"Mail.Read\", \"Mail.ReadWrite\")\n| extend PermissionsAddedTo = tostring(TargetResources[0].displayName)\n| extend Type = tostring(TargetResources[0].type)\n| project-away props\n| join kind=leftouter(\n  AuditLogs\n  | where ActivityDisplayName has \"Consent to application\"\n  | extend AppName = tostring(TargetResources[0].displayName)\n  | extend AppId = tostring(TargetResources[0].id)\n  | project AppName, AppId, CorrelationId) on CorrelationId\n| project-reorder TimeGenerated, OperationName, InitiatingUser, UserIPAddress, UserAgent, PermissionsAddedTo, Permissions, AppName, AppId, CorrelationId\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUser, IPCustomEntity = UserIPAddress\n", "attributes": {"description": "'This query look for applications that have been granted (Delegated or App/Role) permissions to Read Mail (Permissions field has Mail.Read) and subsequently has been consented to. This can help identify applications that have been abused to gain access to mailboxes.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/MaliciousOAuthApp_O365AttackToolkit.yaml", "query_name": "Suspicious application consent similar to O365 Attack Toolkit", "query": "let detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated > ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"mailboxsettings\"\n| extend AppDisplayName = TargetResources.[0].displayName\n| extend AppClientId = tolower(TargetResources.[0].id)\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull contains \"contacts.read\" and ConsentFull contains \"user.read\" and ConsentFull contains \"mail.read\" and ConsentFull contains \"notes.read.all\" and ConsentFull contains \"mailboxsettings.readwrite\" and ConsentFull contains \"Files.ReadWrite.All\"\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ \"User-Agent\", tostring(AdditionalDetails[0].value), \"\")\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n| extend AppClientId = tolower(TargetResources[0].id)\n| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has \"AddressType\", TargetResources[0].modifiedProperties[1].newValue, \"\")\n| distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n| extend GrantAuthentication = tostring(TargetResources[0].displayName)\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n| extend timestamp = TimeGenerated, AccountCustomEntity = GrantInitiatedBy, IPCustomEntity = GrantIpAddress\n", "attributes": {"description": "'This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the MDSec O365 Attack Toolkit (https://github.com/mdsecactivebreach/o365-attack-toolkit).\nThe default permissions/scope for the MDSec O365 Attack toolkit are contacts.read, user.read, mail.read, notes.read.all, mailboxsettings.readwrite, and files.readwrite.all.\nConsent to applications with these permissions should be rare, especially as the knownApplications list is expanded, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": ["T1528", "T1550"], "tactics": ["CredentialAccess", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/MaliciousOAuthApp_PwnAuth.yaml", "query_name": "Suspicious application consent similar to PwnAuth", "query": "let detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated > ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"offline\"\n| extend AppDisplayName = TargetResources.[0].displayName\n| extend AppClientId = tolower(TargetResources.[0].id)\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull contains \"user.read\" and ConsentFull contains \"offline_access\" and ConsentFull contains \"mail.readwrite\" and ConsentFull contains \"mail.send\" and ConsentFull contains \"files.read.all\"\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend GrantUserAgent = iff(AdditionalDetails[0].key =~ \"User-Agent\", AdditionalDetails[0].value, \"\")\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n| extend AppClientId = tolower(TargetResources[0].id)\n| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has \"AddressType\", TargetResources[0].modifiedProperties[1].newValue, \"\")\n| distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n| extend GrantAuthentication = tostring(TargetResources[0].displayName)\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n| extend timestamp = TimeGenerated, AccountCustomEntity = GrantInitiatedBy, IPCustomEntity = GrantIpAddress\n", "attributes": {"description": "'This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the FireEye PwnAuth toolkit (https://github.com/fireeye/PwnAuth).\nThe default permissions/scope for the PwnAuth toolkit are user.read, offline_access, mail.readwrite, mail.send, and files.read.all.\nConsent to applications with these permissions should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": ["T1528", "T1550"], "tactics": ["CredentialAccess", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/MFARejectedbyUser.yaml", "query_name": "MFA Rejected by User", "query": "SigninLogs\n| where ResultType == 500121\n| extend additionalDetails_ = tostring(Status.additionalDetails)\n| where additionalDetails_ =~ \"MFA denied; user declined the authentication\"\n| extend AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Identifies accurances where a user has rejected an MFA prompt. This could be an indicator that a threat actor has compromised the username and password of this user account and is using it to try and log into the account.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/MultipleAdmin_membership_removals_from_NewAdmin.yaml", "query_name": "Multiple admin membership removals from newly created admin.", "query": "let lookback = 7d; \nlet timeframe = 1h; \nlet GlobalAdminsRemoved = AuditLogs \n| where TimeGenerated > ago(timeframe) \n| where Category =~ \"RoleManagement\" \n| where AADOperationType in (\"Unassign\", \"RemoveEligibleRole\") \n| where ActivityDisplayName has_any (\"Remove member from role\", \"Remove eligible member from role\") \n| mv-expand TargetResources \n| mv-expand TargetResources.modifiedProperties \n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName) \n| where displayName_ =~ \"Role.DisplayName\" \n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.oldValue))) \n| where RoleName == \"Global Administrator\" // Add other Privileged role if applicable \n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName) \n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) \n| where Initiator != \"MS-PIM\"  // Filtering PIM events \n| extend Target = tostring(TargetResources.userPrincipalName) \n| summarize RemovedGlobalAdminTime = max(TimeGenerated), TargetAdmins = make_set(Target) by OperationName,  RoleName, Initiator, Result; \nlet GlobalAdminsAdded = AuditLogs \n| where TimeGenerated > ago(lookback) \n| where Category =~ \"RoleManagement\" \n| where AADOperationType in (\"Assign\", \"AssignEligibleRole\") \n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\") and Result == \"success\" \n| mv-expand TargetResources \n| mv-expand TargetResources.modifiedProperties \n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName) \n| where displayName_ =~ \"Role.DisplayName\" \n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue))) \n| where RoleName == \"Global Administrator\" // Add other Privileged role if applicable \n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName) \n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) \n| where Initiator != \"MS-PIM\"  // Filtering PIM events \n| extend Target = tostring(TargetResources.userPrincipalName) \n| summarize AddedGlobalAdminTime = max(TimeGenerated) by OperationName,  RoleName, Target, Initiator, Result \n| extend AccountCustomEntity = Target; \nGlobalAdminsAdded \n| join kind= inner GlobalAdminsRemoved on $left.Target == $right.Initiator \n| where AddedGlobalAdminTime < RemovedGlobalAdminTime \n| extend NoofAdminsRemoved = array_length(TargetAdmins) \n| where NoofAdminsRemoved > 1\n| project AddedGlobalAdminTime, Initiator, Target, AccountCustomEntity, RemovedGlobalAdminTime, TargetAdmins, NoofAdminsRemoved\n", "attributes": {"description": "'This query detects when newly created Global admin removes multiple existing global admins which can be an attempt by adversaries to lock down organization and retain sole access. \n Investigate reasoning and intention of multiple membership removal by new Global admins and take necessary actions accordingly.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/NewAppOrServicePrincipalCredential.yaml", "query_name": "New access credential added to Application or Service Principal", "query": "AuditLogs\n| where OperationName has_any (\"Add service principal\", \"Certificates and secrets management\") // captures \"Add service principal\", \"Add service principal credentials\", and \"Update application - Certificates and secrets management\" events\n| where Result =~ \"success\"\n| mv-expand target = TargetResources\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| extend targetDisplayName = tostring(TargetResources[0].displayName)\n| extend targetId = tostring(TargetResources[0].id)\n| extend targetType = tostring(TargetResources[0].type)\n| extend keyEvents = TargetResources[0].modifiedProperties\n| mv-expand keyEvents\n| where keyEvents.displayName =~ \"KeyDescription\"\n| extend new_value_set = parse_json(tostring(keyEvents.newValue))\n| extend old_value_set = parse_json(tostring(keyEvents.oldValue))\n| where old_value_set != \"[]\"\n| extend diff = set_difference(new_value_set, old_value_set)\n| where isnotempty(diff)\n| parse diff with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| where keyUsage == \"Verify\"  or keyUsage == \"\"\n| extend UserAgent = iff(AdditionalDetails[0].key == \"User-Agent\",tostring(AdditionalDetails[0].value),\"\")\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n// The below line is currently commented out but Microsoft Sentinel users can modify this query to show only Application or only Service Principal events in their environment\n//| where targetType =~ \"Application\" // or targetType =~ \"ServicePrincipal\"\n| project-away diff, new_value_set, old_value_set\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatingUserOrApp, IPCustomEntity = InitiatingIpAddress\n", "attributes": {"description": "'This will alert when an admin or app owner account adds a new credential to an Application or Service Principal where a verify KeyCredential was already present for the app.\nIf a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": ["T1550.001"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/NRT_ADFSDomainTrustMods.yaml", "query_name": "NRT Modified domain federation trust settings", "query": "AuditLogs\n| where OperationName =~ \"Set federation settings on domain\" or OperationName =~ \"Set domain authentication\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-expand modifiedProperties\n| extend targetDisplayName = tostring(parse_json(modifiedProperties).displayName), NewDomainValue=tostring(parse_json(modifiedProperties).newValue)\n| extend Federated = iif(OperationName =~ \"Set domain authentication\", iif(NewDomainValue has \"Federated\", True, False), True)\n| where Federated == True\n| mv-expand AdditionalDetails\n| extend UserAgent = iff(AdditionalDetails.key == \"User-Agent\",tostring(AdditionalDetails.value),\"\")\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, AADOperationType, targetDisplayName, Result, InitiatingIpAddress, UserAgent, CorrelationId, TenantId, AADTenantId\n", "attributes": {"description": "'This will alert when a user or application modifies the federation settings on the domain or Update domain authentication from Managed to Federated.\nFor example, this alert will trigger when a new Active Directory Federated Service (ADFS) TrustedRealm object, such as a signing certificate, is added to the domain.\nModification to domain federation settings should be rare. Confirm the added or modified target domain/URL is legitimate administrator behavior.\nTo understand why an authorized user may update settings for a federated domain in Office 365, Azure, or Intune, see: https://docs.microsoft.com/office365/troubleshoot/active-directory/update-federated-domain-office-365.\nFor details on security realms that accept security tokens, see the ADFS Proxy Protocol (MS-ADFSPP) specification: https://docs.microsoft.com/openspecs/windows_protocols/ms-adfspp/e7b9ea73-1980-4318-96a6-da559486664b.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/NRT_MFARejectedbyUser.yaml", "query_name": "NRT MFA Rejected by User", "query": "SigninLogs\n| where ResultType == 500121\n| extend additionalDetails_ = tostring(Status.additionalDetails)\n| where additionalDetails_ =~ \"MFA denied; user declined the authentication\"\n", "attributes": {"description": "'Identifies occurrences where a user has rejected an MFA prompt. This could be an indicator that a threat actor has compromised the username and password of this user account and is using it to try and log into the account.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/NRT_NewAppOrServicePrincipalCredential.yaml", "query_name": "NRT New access credential added to Application or Service Principal", "query": "AuditLogs\n| where OperationName has_any (\"Add service principal\", \"Certificates and secrets management\")\n| where Result =~ \"success\"\n| mv-expand target = TargetResources\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| extend targetDisplayName = tostring(TargetResources[0].displayName)\n| extend targetId = tostring(TargetResources[0].id)\n| extend targetType = tostring(TargetResources[0].type)\n| extend keyEvents = TargetResources[0].modifiedProperties\n| mv-expand keyEvents\n| where keyEvents.displayName =~ \"KeyDescription\"\n| extend new_value_set = parse_json(tostring(keyEvents.newValue))\n| extend old_value_set = parse_json(tostring(keyEvents.oldValue))\n| where old_value_set != \"[]\"\n| extend diff = set_difference(new_value_set, old_value_set)\n| where isnotempty(diff)\n| parse diff with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| where keyUsage == \"Verify\"  or keyUsage == \"\"\n| extend UserAgent = iff(AdditionalDetails[0].key == \"User-Agent\",tostring(AdditionalDetails[0].value),\"\")\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n// The below line is currently commented out but Microsoft Sentinel users can modify this query to show only Application or only Service Principal events in their environment\n//| where targetType =~ \"Application\" // or targetType =~ \"ServicePrincipal\"\n| project-away diff, new_value_set, old_value_set\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId\n", "attributes": {"description": "'This will alert when an admin or app owner account adds a new credential to an Application or Service Principal where a verify KeyCredential was already present for the app.\nIf a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": ["T1550.001"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/NRT_PIMElevationRequestRejected.yaml", "query_name": "NRT PIM Elevation Request Rejected", "query": "AuditLogs\n| where ActivityDisplayName =~'Add member to role completed (PIM activation)'\n| where Result == \"failure\"\n| extend Role = tostring(TargetResources[3].displayName)\n| extend User = tostring(TargetResources[2].displayName)\n| project-reorder TimeGenerated, User, Role, OperationName, Result, ResultDescription\n| extend InitiatingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend IPCustomEntity = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n", "attributes": {"description": "'Identifies when a user is rejected for a privileged role elevation via PIM. Monitor rejections for indicators of attacker compromise of the requesting account.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-identity-management'\n", "techniques": ["T1078.004"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/NRT_PrivlegedRoleAssignedOutsidePIM.yaml", "query_name": "NRT Privileged Role Assigned Outside PIM", "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where OperationName has \"Add member to role outside of PIM\"\n        or (LoggedByService == \"Core Directory\" and OperationName == \"Add member to role\" and Identity != \"MS-PIM\")\n| extend AccountCustomEntity = tostring(TargetResources[0].userPrincipalName), IPCustomEntity = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n", "attributes": {"description": "'Identifies a privileged role being assigned to a user outside of PIM\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/NRT_UseraddedtoPrivilgedGroups.yaml", "query_name": "NRT User added to Azure Active Directory Privileged Groups", "query": "let OperationList = dynamic([\"Add member to role\",\"Add member to role in PIM requested (permanent)\"]);\nlet PrivilegedGroups = dynamic([\"UserAccountAdmins\",\"PrivilegedRoleAdmins\",\"TenantAdmins\"]);\nAuditLogs\n//| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"RoleManagement\"\n| where OperationName in~ (OperationList)\n| mv-expand TargetResources\n| extend modProps = parse_json(TargetResources).modifiedProperties\n| mv-expand bagexpansion=array modProps\n| evaluate bag_unpack(modProps)\n| extend displayName = column_ifexists(\"displayName\", \"NotAvailable\"), newValue = column_ifexists(\"newValue\", \"NotAvailable\")\n| where displayName =~ \"Role.WellKnownObjectName\"\n| extend DisplayName = displayName, GroupName = replace('\"','',newValue)\n| extend initByApp = parse_json(InitiatedBy).app, initByUser = parse_json(InitiatedBy).user\n| extend AppId = initByApp.appId,\nInitiatedByDisplayName = case(isnotempty(initByApp.displayName), initByApp.displayName, isnotempty(initByUser.displayName), initByUser.displayName, \"not available\"),\nServicePrincipalId = tostring(initByApp.servicePrincipalId),\nServicePrincipalName = tostring(initByApp.servicePrincipalName),\nUserId = initByUser.id,\nUserIPAddress = initByUser.ipAddress,\nUserRoles = initByUser.roles,\nUserPrincipalName = tostring(initByUser.userPrincipalName),\nTargetUserPrincipalName = tostring(TargetResources.userPrincipalName)\n| where GroupName in~ (PrivilegedGroups)\n// If you don't want to alert for operations from PIM, remove below filtering for MS-PIM.\n//| where InitiatedByDisplayName != \"MS-PIM\"\n| project TimeGenerated, AADOperationType, Category, OperationName, AADTenantId, AppId, InitiatedByDisplayName, ServicePrincipalId, ServicePrincipalName, DisplayName, GroupName, UserId, UserIPAddress, UserRoles, UserPrincipalName, TargetUserPrincipalName\n| extend AccountCustomEntity = case(isnotempty(ServicePrincipalName), ServicePrincipalName, isnotempty(ServicePrincipalId), ServicePrincipalId, isnotempty(UserPrincipalName), UserPrincipalName, \"not available\")\n", "attributes": {"description": "'This will alert when a user is added to any of the Privileged Groups.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\nFor Administrator role permissions in Azure Active Directory please see https://docs.microsoft.com/azure/active-directory/users-groups-roles/directory-assign-admin-roles'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/PIMElevationRequestRejected.yaml", "query_name": "PIM Elevation Request Rejected", "query": "AuditLogs\n| where ActivityDisplayName =~'Add member to role completed (PIM activation)'\n| where Result == \"failure\"\n| extend Role = tostring(TargetResources[3].displayName)\n| extend User = tostring(TargetResources[2].displayName)\n| project-reorder TimeGenerated, User, Role, OperationName, Result, ResultDescription\n| extend InitiatingUser = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend AccountCustomEntity = User, IPCustomEntity = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n", "attributes": {"description": "'Identifies when a user is rejected for a privileged role elevation via PIM. Monitor rejections for indicators of attacker compromise of the requesting account.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-identity-management'\n", "techniques": ["T1078.004"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/PrivilegedAccountsSigninFailureSpikes.yaml", "query_name": "Privileged Accounts - Sign in Failure Spikes", "query": "let starttime = 14d;\nlet timeframe = 1d;\nlet scorethreshold = 3;\nlet baselinethreshold = 5;\nlet aadFunc = (tableName:string){\n    IdentityInfo\n    | where TimeGenerated > ago(starttime)\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\n    | mv-expand AssignedRoles\n    | where AssignedRoles matches regex 'Admin'\n    | summarize Roles = make_list(AssignedRoles) by AccountUPN = tolower(AccountUPN)\n    | join kind=inner (\n        table(tableName)\n        | where TimeGenerated between (startofday(ago(starttime))..startofday(now()))\n        | where ResultType != 0\n        | extend UserPrincipalName = tolower(UserPrincipalName)\n    ) on $left.AccountUPN == $right.UserPrincipalName\n    | extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, Roles = tostring(Roles)\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nlet allSignins = union isfuzzy=true aadSignin, aadNonInt;\nlet TimeSeriesAlerts = \n    allSignins\n    | make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step 1h by UserPrincipalName, Roles\n    | extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')\n    | mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n    // Filtering low count events per baselinethreshold\n    | where anomalies > 0 and baseline > baselinethreshold\n    | extend AnomalyHour = TimeGenerated\n    | project UserPrincipalName, Roles, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;\n// Filter the alerts for specified timeframe\nTimeSeriesAlerts\n| where TimeGenerated > startofday(ago(timeframe))\n| join kind=inner ( \n    allSignins\n    | where TimeGenerated > startofday(ago(timeframe))\n    // create a new column and round to hour\n    | extend DateHour = bin(TimeGenerated, 1h)\n    | summarize PartialFailedSignins = count(), LatestAnomalyTime = arg_max(TimeGenerated, *) by bin(TimeGenerated, 1h), OperationName, Category, ResultType, ResultDescription, UserPrincipalName, Roles, UserDisplayName, AppDisplayName, ClientAppUsed, IPAddress, ResourceDisplayName\n) on UserPrincipalName, $left.AnomalyHour == $right.DateHour\n| project LatestAnomalyTime, OperationName, Category, UserPrincipalName, Roles = todynamic(Roles), UserDisplayName, ResultType, ResultDescription, AppDisplayName, ClientAppUsed, UserAgent, IPAddress, Location, AuthenticationRequirement, ConditionalAccessStatus, ResourceDisplayName, PartialFailedSignins, TotalFailedSignins = HourlyCount, baseline, anomalies, score\n| extend timestamp = LatestAnomalyTime, IPCustomEntity = IPAddress, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "' Identifies spike in failed sign-ins from Privileged accounts. Privileged accounts list can be based on IdentityInfo UEBA table or built-in watchlist.\nSpike is determined based on Time series anomaly which will look at historical baseline values.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/PrivlegedRoleAssignedOutsidePIM.yaml", "query_name": "Privileged Role Assigned Outside PIM", "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where OperationName has \"Add member to role outside of PIM\"\n        or (LoggedByService == \"Core Directory\" and OperationName == \"Add member to role\" and Identity != \"MS-PIM\")\n| extend AccountCustomEntity = tostring(TargetResources[0].userPrincipalName), IPCustomEntity = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n", "attributes": {"description": "'Identifies a privileged role being assigned to a user outside of PIM\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'\n", "techniques": ["T1078.004"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/RareApplicationConsent.yaml", "query_name": "Rare application consent", "query": "\nlet current = 1d;\nlet auditLookback = 7d;\n// Setting threshold to 3 as a default, change as needed.  \n// Any operation that has been initiated by a user or app more than 3 times in the past 7 days will be excluded\nlet threshold = 3;\n// Gather initial data from lookback period, excluding current, adjust current to more than a single day if no results\nlet AuditTrail = AuditLogs | where TimeGenerated >= ago(auditLookback) and TimeGenerated < ago(current)\n// 2 other operations that can be part of malicious activity in this situation are \n// \"Add OAuth2PermissionGrant\" and \"Add service principal\", extend the filter below to capture these too\n| where OperationName has \"Consent to application\"\n| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \ntostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| summarize max(TimeGenerated), OperationCount = count() by OperationName, InitiatedBy, TargetResourceName\n// only including operations by initiated by a user or app that is above the threshold so we produce only rare and has not occurred in last 7 days\n| where OperationCount > threshold\n;\n// Gather current period of audit data\nlet RecentConsent = AuditLogs | where TimeGenerated >= ago(current)\n| where OperationName has \"Consent to application\"\n| extend IpAddress = case(\nisnotempty(tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.user)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.user)).ipAddress), \nisnotempty(tostring(parse_json(tostring(InitiatedBy.app)).ipAddress)) and tostring(parse_json(tostring(InitiatedBy.app)).ipAddress) != 'null', tostring(parse_json(tostring(InitiatedBy.app)).ipAddress),\n'Not Available')\n| extend InitiatedBy = iff(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)), \ntostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), tostring(parse_json(tostring(InitiatedBy.app)).displayName))\n| extend TargetResourceName = tolower(tostring(TargetResources.[0].displayName))\n| parse TargetResources.[0].modifiedProperties with * \"ConsentType: \" ConsentType \"]\" *\n| mv-expand AdditionalDetails\n| extend UserAgent = iff(AdditionalDetails.key == \"User-Agent\",tostring(AdditionalDetails.value),\"\")\n| project TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType, UserAgent, CorrelationId, Type;\n// Exclude previously seen audit activity for \"Consent to application\" that was seen in the lookback period\n// First for rare InitiatedBy\nlet RareConsentBy = RecentConsent | join kind= leftanti AuditTrail on OperationName, InitiatedBy \n| extend Reason = \"Previously unseen user consenting\";\n// Second for rare TargetResourceName\nlet RareConsentApp = RecentConsent | join kind= leftanti AuditTrail on OperationName, TargetResourceName\n| extend Reason = \"Previously unseen app granted consent\";\nRareConsentBy | union RareConsentApp\n| summarize Reason = makeset(Reason) by TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType, UserAgent, CorrelationId, Type\n| extend timestamp = TimeGenerated, AccountCustomEntity = InitiatedBy, HostCustomEntity = TargetResourceName, IPCustomEntity = IpAddress\n", "attributes": {"description": "'This will alert when the \"Consent to application\" operation occurs by a user that has not done this operation before or rarely does this.\nThis could indicate that permissions to access the listed Azure App were provided to a malicious actor. \nConsent to application, Add service principal and Add OAuth2PermissionGrant should typically be rare events. \nThis may help detect the Oauth2 attack that can be initiated by this publicly available tool - https://github.com/fireeye/PwnAuth\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": ["T1136", "T1068"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/SeamlessSSOPasswordSpray.yaml", "query_name": "Password spray attack against Azure AD Seamless SSO", "query": "\nlet account_threshold = 5;\nAADNonInteractiveUserSignInLogs\n//| where ResultType == \"81016\"\n| where ResultType startswith \"81\"\n| summarize DistinctAccounts = dcount(UserPrincipalName), DistinctAddresses = make_set(IPAddress) by ResultType\n| where DistinctAccounts > account_threshold\n| mv-expand IPAddress = DistinctAddresses\n| extend IPAddress = tostring(IPAddress)\n| join kind=leftouter (union isfuzzy=true SigninLogs, AADNonInteractiveUserSignInLogs) on IPAddress\n| summarize\n    StartTime = min(TimeGenerated),\n    EndTime = max(TimeGenerated),\n    UserPrincipalName = make_set(UserPrincipalName),\n    UserAgent = make_set(UserAgent),\n    ResultDescription = take_any(ResultDescription),\n    ResultSignature = take_any(ResultSignature)\n    by IPAddress, Type, ResultType\n| project Type, StartTime, EndTime, IPAddress, ResultType, ResultDescription, ResultSignature, UserPrincipalName, UserAgent = iff(array_length(UserAgent) == 1, UserAgent[0], UserAgent)\n", "attributes": {"description": "'This query detects when there is a spike in Azure AD Seamless SSO errors. They may not be caused by a Password Spray attack, but the cause of the errors might need to be investigated.\nAzure AD only logs the requests that matched existing accounts, thus there might have been unlogged requests for non-existing accounts.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/Sign-in%20Burst%20from%20Multiple%20Locations.yaml", "query_name": "GitHub Signin Burst from Multiple Locations", "query": "let aadFunc = (tableName:string){\ntable(tableName)\n| where AppDisplayName == \"GitHub.com\"\n| where ResultType == 0\n| summarize CountOfLocations = dcount(Location), Locations = make_set(Location), BurstStartTime = min(TimeGenerated), BurstEndTime = max(TimeGenerated) by UserPrincipalName, Type\n| where CountOfLocations > 1\n| extend timestamp = BurstStartTime, AccountCustomEntity = UserPrincipalName\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'This alerts when there Signin burst from multiple locations in GitHub (AAD SSO).'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/SigninAttemptsByIPviaDisabledAccounts.yaml", "query_name": "Sign-ins from IPs that attempt sign-ins to disabled accounts", "query": "\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where ResultType == \"50057\" \n| where ResultDescription == \"User account is disabled. The account has been disabled by an administrator.\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), disabledAccountLoginAttempts = count(), \ndisabledAccountsTargeted = dcount(UserPrincipalName), applicationsTargeted = dcount(AppDisplayName), disabledAccountSet = make_set(UserPrincipalName), \napplicationSet = make_set(AppDisplayName) by IPAddress, Type\n| order by disabledAccountLoginAttempts desc\n| join kind= leftouter (\n    // Consider these IPs suspicious - and alert any related  successful sign-ins\n    table(tableName)\n    | where ResultType == 0\n    | summarize successfulAccountSigninCount = dcount(UserPrincipalName), successfulAccountSigninSet = make_set(UserPrincipalName, 15) by IPAddress, Type\n    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe\n    | where successfulAccountSigninCount < 100\n) on IPAddress  \n// IPs from which attempts to authenticate as disabled user accounts originated, and had a non-zero success rate for some other account\n| where isnotempty(successfulAccountSigninCount)\n| project StartTime, EndTime, IPAddress, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet, \nsuccessfulAccountSigninCount, successfulAccountSigninSet, Type\n| order by disabledAccountLoginAttempts\n| extend timestamp = StartTime, IPCustomEntity = IPAddress\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies IPs with failed attempts to sign in to one or more disabled accounts and where that same IP has had successful signins from other accounts.\nThis could indicate an attacker who obtained credentials for a list of accounts and is attempting to login with those accounts, some of which may have already been disabled.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n50057 - User account is disabled. The account has been disabled by an administrator.'\n", "techniques": ["T1078", "T1098"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/SigninBruteForce-AzurePortal.yaml", "query_name": "Brute force attack against Azure Portal", "query": "let timeRange = 24h;\nlet failureCountThreshold = 5;\nlet authenticationWindow = 20m;\nlet aadFunc = (tableName:string){\n table(tableName)\n| where AppDisplayName has \"Azure Portal\"\n| extend\n     DeviceDetail = todynamic(DeviceDetail),\n     //Status = todynamic(Status),\n     LocationDetails = todynamic(LocationDetails)\n| extend\n     OS = tostring(DeviceDetail.operatingSystem),\n     Browser = tostring(DeviceDetail.browser),\n     //StatusCode = tostring(Status.errorCode),\n     //StatusDetails = tostring(Status.additionalDetails),\n     State = tostring(LocationDetails.state),\n     City = tostring(LocationDetails.city),\n     Region = tostring(LocationDetails.countryOrRegion)\n// Split out failure versus non-failure types\n| extend FailureOrSuccess = iff(ResultType in (\"0\", \"50125\", \"50140\", \"70043\", \"70044\"), \"Success\", \"Failure\")  \n// bin outcomes based on authenticationWindow\n| summarize take_anyif(UserPrincipalName, not(UserPrincipalName matches regex @\"[a-f\\d]+\\-[a-f\\d]+\\-[a-f\\d]+\\-[a-f\\d]+\\-[a-f\\d]+\")),\n     take_anyif(UserDisplayName, isnotempty(UserDisplayName)),  FailureOrSuccessCount = count() by  FailureOrSuccess, UserId, UserDisplayName, AppDisplayName, IPAddress, Browser, OS, State, City, Region, Type, CorrelationId, bin(TimeGenerated, authenticationWindow), ResultType\n// sort for sessionizing - by UserPrincipalName and time of the authentication outcome\n| sort by UserPrincipalName asc, TimeGenerated asc\n| serialize \n// sessionize into failure groupings until either the account changes or there is a success\n| extend SessionStartedUtc = row_window_session(TimeGenerated, timeRange, authenticationWindow, UserPrincipalName != prev(UserPrincipalName) or prev(FailureOrSuccess) == \"Success\")\n// count the failures in each session\n| summarize FailureCountBeforeSuccess=sumif(FailureOrSuccessCount, FailureOrSuccess == \"Failure\"), StartTime=min(TimeGenerated), EndTime=max(TimeGenerated), makelist(FailureOrSuccess), IPAddress = make_set(IPAddress), make_set(Browser), make_set(City), make_set(State), make_set(Region), make_set(ResultType) by SessionStartedUtc, UserPrincipalName, CorrelationId, AppDisplayName, UserId, Type\n// the session must not start with a success, and must end with one\n| where array_index_of(list_FailureOrSuccess, \"Success\") != 0\n| where array_index_of(list_FailureOrSuccess, \"Success\") == array_length(list_FailureOrSuccess) - 1\n| project-away SessionStartedUtc, list_FailureOrSuccess\n// where the number of failures before the success is above the threshold \n| where FailureCountBeforeSuccess >= failureCountThreshold \n// expand out ip for entity assignment\n| mv-expand IPAddress\n| extend IPAddress = tostring(IPAddress)\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress \n};\n let aadSignin = aadFunc(\"SigninLogs\");\n let aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\n union isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies evidence of brute force activity against Azure Portal by highlighting multiple authentication failures \nand by a successful authentication within a given time window. \nDefault Failure count is 5 and default Time Window is 20 minutes.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/SigninPasswordSpray.yaml", "query_name": "Password spray attack against Azure AD application", "query": "\nlet timeRange = 3d;\nlet lookBack = 7d;\nlet authenticationWindow = 20m;\nlet authenticationThreshold = 5;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet failureCodes = dynamic([50053, 50126, 50055]); // invalid password, account is locked - too many sign ins, expired password\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\n// Lookup up resolved identities from last 7 days\nlet aadFunc = (tableName:string){\nlet identityLookup = table(tableName)\n| where TimeGenerated >= ago(lookBack)\n| where not(Identity matches regex isGUID)\n| where isnotempty(UserId)\n| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName, Type;\n// collect window threshold breaches\ntable(tableName)\n| where TimeGenerated > ago(timeRange)\n| where ResultType in(failureCodes)\n| summarize FailedPrincipalCount = dcount(UserPrincipalName) by bin(TimeGenerated, authenticationWindow), IPAddress, AppDisplayName, Type\n| where FailedPrincipalCount >= authenticationThreshold\n| summarize WindowThresholdBreaches = count() by IPAddress, Type\n| join kind= inner (\n// where we breached a threshold, join the details back on all failure data\ntable(tableName)\n| where TimeGenerated > ago(timeRange)\n| where ResultType in(failureCodes)\n| extend LocationDetails = todynamic(LocationDetails)\n| extend FullLocation = strcat(LocationDetails.countryOrRegion,'|', LocationDetails.state, '|', LocationDetails.city)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), make_set(ClientAppUsed), make_set(FullLocation), FailureCount = count() by IPAddress, AppDisplayName, UserPrincipalName, UserDisplayName, Identity, UserId, Type\n// lookup any unresolved identities\n| extend UnresolvedUserId = iff(Identity matches regex isGUID, UserId, \"\")\n| join kind= leftouter (\n identityLookup \n) on $left.UnresolvedUserId==$right.UserId\n| extend UserDisplayName=iff(isempty(lu_UserDisplayName), UserDisplayName, lu_UserDisplayName)\n| extend UserPrincipalName=iff(isempty(lu_UserPrincipalName), UserPrincipalName, lu_UserPrincipalName)\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), make_set(UserPrincipalName), make_set(UserDisplayName), make_set(set_ClientAppUsed), make_set(set_FullLocation), make_list(FailureCount) by IPAddress, AppDisplayName, Type\n| extend FailedPrincipalCount = arraylength(set_UserPrincipalName)\n) on IPAddress\n| project IPAddress, StartTime, EndTime, TargetedApplication=AppDisplayName, FailedPrincipalCount, UserPrincipalNames=set_UserPrincipalName, UserDisplayNames=set_UserDisplayName, ClientAppsUsed=set_set_ClientAppUsed, Locations=set_set_FullLocation, FailureCountByPrincipal=list_FailureCount, WindowThresholdBreaches, Type\n| join kind= inner (\ntable(tableName) // get data on success vs. failure history for each IP\n| where TimeGenerated > ago(timeRange)\n| where ResultType in(successCodes) or ResultType in(failureCodes) // success or failure types\n| summarize GlobalSuccessPrincipalCount = dcountif(UserPrincipalName, (ResultType in(successCodes))), ResultTypeSuccesses = make_set_if(ResultType, (ResultType in(successCodes))), GlobalFailPrincipalCount = dcountif(UserPrincipalName, (ResultType in(failureCodes))), ResultTypeFailures = make_set_if(ResultType, (ResultType in(failureCodes))) by IPAddress, Type\n| where GlobalFailPrincipalCount > GlobalSuccessPrincipalCount // where the number of failed principals is greater than success - eliminates FPs from IPs who authenticate successfully alot and as a side effect have alot of failures\n) on IPAddress\n| project-away IPAddress1\n| extend timestamp=StartTime, IPCustomEntity = IPAddress\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies evidence of password spray activity against Azure AD applications by looking for failures from multiple accounts from the same\nIP address within a time window. If the number of accounts breaches the threshold just once, all failures from the IP address within the time range\nare bought into the result. Details on whether there were successful authentications by the IP address within the time window are also included.\nThis can be an indicator that an attack was successful.\nThe default failure acccount threshold is 5, Default time window for failures is 20m and default look back window is 3 days\nNote: Due to the number of possible accounts involved in a password spray it is not possible to map identities to a custom entity.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/SuccessThenFail_DiffIP_SameUserandApp.yaml", "query_name": "Successful logon from IP and failure from a different IP", "query": "\nlet logonDiff = 10m;\nlet aadFunc = (tableName:string){\ntable(tableName) \n| where ResultType == \"0\" \n| where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\")\n| project SuccessLogonTime = TimeGenerated, UserPrincipalName, SuccessIPAddress = IPAddress, AppDisplayName, SuccessIPBlock = strcat(split(IPAddress, \".\")[0], \".\", split(IPAddress, \".\")[1]), Type\n| join kind= inner (\n    table(tableName)\n    | where ResultType !in (\"0\", \"50140\") \n    | where ResultDescription !~ \"Other\"  \n    | where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\")\n    | project FailedLogonTime = TimeGenerated, UserPrincipalName, FailedIPAddress = IPAddress, AppDisplayName, ResultType, ResultDescription, Type\n) on UserPrincipalName, AppDisplayName \n| where SuccessLogonTime < FailedLogonTime and FailedLogonTime - SuccessLogonTime <= logonDiff and FailedIPAddress !startswith SuccessIPBlock\n| summarize FailedLogonTime = max(FailedLogonTime), SuccessLogonTime = max(SuccessLogonTime) by UserPrincipalName, SuccessIPAddress, AppDisplayName, FailedIPAddress, ResultType, ResultDescription, Type\n| extend timestamp = SuccessLogonTime\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n", "attributes": {"description": "'Identifies when a user account successfully logs onto an Azure App from one IP and within 10 mins failed to logon to the same App via a different IP.\nThis may indicate a malicious attempt at password guessing based on knowledge of the users account.'\n", "techniques": ["T1110", "T1078"], "tactics": ["CredentialAccess", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/SuspiciousOAuthApp_OfflineAccess.yaml", "query_name": "Suspicious application consent for offline access", "query": "let detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated > ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"offline\"\n| extend AppDisplayName = TargetResources.[0].displayName\n| extend AppClientId = tolower(TargetResources.[0].id)\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| extend ConsentFull = TargetResources[0].modifiedProperties[4].newValue\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull contains \"offline_access\" and ConsentFull contains \"Files.Read\" or ConsentFull contains \"Mail.Read\" or ConsentFull contains \"Notes.Read\" or ConsentFull contains \"ChannelMessage.Read\" or ConsentFull contains \"Chat.Read\" or ConsentFull contains \"TeamsActivity.Read\" or ConsentFull contains \"Group.Read\" or ConsentFull contains \"EWS.AccessAsUser.All\" or ConsentFull contains \"EAS.AccessAsUser.All\"\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend GrantInitiatedBy = tostring(iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName))\n| extend GrantUserAgent = tostring(iff(AdditionalDetails[0].key =~ \"User-Agent\", AdditionalDetails[0].value, \"\"))\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n| extend AppClientId = tolower(TargetResources[0].id)\n| extend AppReplyURLs = iff(TargetResources[0].modifiedProperties[1].newValue has \"AddressType\", TargetResources[0].modifiedProperties[1].newValue, \"\")\n| distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n| extend GrantAuthentication = tostring(TargetResources[0].displayName)\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n| extend timestamp = TimeGenerated, AccountCustomEntity = GrantInitiatedBy, IPCustomEntity = GrantIpAddress\n", "attributes": {"description": "'This will alert when a user consents to provide a previously-unknown Azure application with offline access via OAuth.\nOffline access will provide the Azure App with access to the listed resources without requiring two-factor authentication.\nConsent to applications with offline access and read capabilities should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.'\n", "techniques": ["T1528"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/SuspiciousServicePrincipalcreationactivity.yaml", "query_name": "Suspicious Service Principal creation activity", "query": "let queryfrequency = 1h;\nlet wait_for_deletion = 10m;\nlet account_created =\n  AuditLogs \n  | where ActivityDisplayName == \"Add service principal\"\n  | where Result == \"success\"\n  | extend AppID = tostring(AdditionalDetails[1].value)\n  | extend creationTime = ActivityDateTime\n  | extend userPrincipalName_creator = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend ipAddress_creator = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress);\nlet account_activity =\n  AADServicePrincipalSignInLogs\n  | extend Activities = pack(\"ActivityTime\", TimeGenerated ,\"IpAddress\", IPAddress, \"ResourceDisplayName\", ResourceDisplayName)\n  | extend AppID = AppId\n  | summarize make_list(Activities) by AppID;\nlet account_deleted =\n  AuditLogs \n  | where OperationName == \"Remove service principal\"\n  | where Result == \"success\"\n  | extend AppID = tostring(AdditionalDetails[1].value)\n  | extend deletionTime = ActivityDateTime\n  | extend userPrincipalName_deleter = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n  | extend ipAddress_deleter = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress);\nlet account_credentials =\n  AuditLogs\n  | where OperationName has_all (\"Update application\", \"Certificates and secrets management\")\n  | where Result == \"success\"\n  | extend AppID = tostring(AdditionalDetails[1].value)\n  | extend credentialCreationTime = ActivityDateTime;\nlet roles_assigned =\n  AuditLogs\n  | where ActivityDisplayName == \"Add app role assignment to service principal\"\n  | extend AppID = tostring(TargetResources[1].displayName)\n  | extend AssignedRole =  iff(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].displayName)==\"AppRole.Value\", tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue))),\"\")\n  | extend AssignedRoles = pack(\"Role\", AssignedRole)\n  | summarize make_list(AssignedRoles) by AppID;\naccount_created\n| where TimeGenerated between (ago(wait_for_deletion+queryfrequency)..ago(wait_for_deletion))\n| join kind= inner (account_activity) on AppID\n| join kind= inner (account_deleted) on AppID\n| join kind= inner (account_credentials) on AppID\n| join kind= inner (roles_assigned) on AppID\n| where deletionTime - creationTime between (time(0s)..wait_for_deletion)\n| extend AliveTime = deletionTime - creationTime\n| project AADTenantId, AppID, creationTime, deletionTime, userPrincipalName_creator, userPrincipalName_deleter, ipAddress_creator, ipAddress_deleter, list_Activities, list_AssignedRoles, AliveTime\n", "attributes": {"description": "'This alert will detect creation of an SPN, permissions granted, credentials created, activity and deletion of the SPN in a time frame (default 10 minutes)'\n", "techniques": ["T1078", "T1528"], "tactics": ["CredentialAccess", "PrivilegeEscalation", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/UnusualGuestActivity.yaml", "query_name": "External guest invitation followed by Azure AD PowerShell signin", "query": "let queryfrequency = 1h;\nlet queryperiod = 1d;\nAuditLogs\n| where TimeGenerated > ago(queryperiod)\n| where OperationName in (\"Invite external user\", \"Bulk invite users - started (bulk)\", \"Invite external user with reset invitation status\")\n| extend InitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName), InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName)\n// Uncomment the following line to filter events where the inviting user was a guest user\n//| where InitiatedBy has_any (\"live.com#\", \"#EXT#\")\n| extend InvitedUser = TargetResources[0].userPrincipalName\n| mv-expand UserToCompare = pack_array(InitiatedBy, InvitedUser) to typeof(string)\n| where UserToCompare has_any (\"live.com#\", \"#EXT#\")\n| extend\n    parsedUser = replace_string(tolower(iff(UserToCompare startswith \"live.com#\", tostring(split(UserToCompare, \"#\")[1]), tostring(split(UserToCompare, \"#EXT#\")[0]))), \"@\", \"_\"),\n    InvitationTime = TimeGenerated\n| join (\n    (union isfuzzy=true SigninLogs, AADNonInteractiveUserSignInLogs)\n    | where TimeGenerated > ago(queryfrequency)\n    | where UserType != \"Member\"\n    | where AppId has_any                       // This web may contain a list of these apps: https://msshells.net/\n        (\"1b730954-1685-4b74-9bfd-dac224a7b894\",// Azure Active Directory PowerShell\n         \"04b07795-8ddb-461a-bbee-02f9e1bf7b46\",// Microsoft Azure CLI\n         \"1950a258-227b-4e31-a9cf-717495945fc2\",// Microsoft Azure PowerShell\n         \"a0c73c16-a7e3-4564-9a95-2bdf47383716\",// Microsoft Exchange Online Remote PowerShell\n         \"fb78d390-0c51-40cd-8e17-fdbfab77341b\",// Microsoft Exchange REST API Based Powershell\n         \"d1ddf0e4-d672-4dae-b554-9d5bdfd93547\",// Microsoft Intune PowerShell\n         \"9bc3ab49-b65d-410a-85ad-de819febfddc\",// Microsoft SharePoint Online Management Shell\n         \"12128f48-ec9e-42f0-b203-ea49fb6af367\",// MS Teams Powershell Cmdlets\n         \"23d8f6bd-1eb0-4cc2-a08c-7bf525c67bcd\",// Power BI PowerShell\n         \"31359c7f-bd7e-475c-86db-fdb8c937548e\",// PnP Management Shell\n         \"90f610bf-206d-4950-b61d-37fa6fd1b224\",// Aadrm Admin Powershell\n         \"14d82eec-204b-4c2f-b7e8-296a70dab67e\" // Microsoft Graph PowerShell\n        )\n    | summarize arg_min(TimeGenerated, *) by UserPrincipalName\n    | extend\n        parsedUser = replace_string(UserPrincipalName, \"@\", \"_\"),\n        SigninTime = TimeGenerated\n    )\n    on parsedUser\n| project InvitationTime, InitiatedBy, OperationName, InvitedUser, SigninTime, SigninCategory = Category1, SigninUserPrincipalName = UserPrincipalName, IPAddress, AppDisplayName, ResourceDisplayName, UserAgent, InvitationAdditionalDetails = AdditionalDetails, InvitationTargetResources = TargetResources\n", "attributes": {"description": "'By default guests have capability to invite more external guest users, guests also can do suspicious Azure AD enumeration. This detection look at guests\nusers, who have been invited or have invited recently, who also are logging via various PowerShell CLI.\nRef : 'https://danielchronlund.com/2021/11/18/scary-azure-ad-tenant-enumeration-using-regular-b2b-guest-accounts/'\n", "techniques": ["T1078.004", "T1136.003", "T1087.004"], "tactics": ["InitialAccess", "Persistence", "Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/UserAccounts-CABlockedSigninSpikes.yaml", "query_name": "User Accounts - Sign in Failure due to CA Spikes", "query": "let starttime = 14d;\nlet timeframe = 1d;\nlet scorethreshold = 3;\nlet baselinethreshold = 50;\nlet aadFunc = (tableName:string){\n  // Failed Signins attempts with reasoning related to conditional access policies.\n  table(tableName)\n  | where TimeGenerated between (startofday(ago(starttime))..startofday(now()))\n  | where ResultDescription has_any (\"conditional access\", \"CA\") or ResultType in (50005, 50131, 53000, 53001, 53002, 52003, 70044)\n  | extend UserPrincipalName = tolower(UserPrincipalName)\n  | extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nlet allSignins = union isfuzzy=true aadSignin, aadNonInt;\nlet TimeSeriesAlerts = \nallSignins\n| make-series DailyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step 1d by UserPrincipalName\n| extend (anomalies, score, baseline) = series_decompose_anomalies(DailyCount, scorethreshold, -1, 'linefit')\n| mv-expand DailyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n// Filtering low count events per baselinethreshold\n| where anomalies > 0 and baseline > baselinethreshold\n| extend AnomalyHour = TimeGenerated\n| project UserPrincipalName, AnomalyHour, TimeGenerated, DailyCount, baseline, anomalies, score;\n// Filter the alerts for specified timeframe\nTimeSeriesAlerts\n| where TimeGenerated > startofday(ago(timeframe))\n| join kind=inner ( \n  allSignins\n  | where TimeGenerated > startofday(ago(timeframe))\n  // create a new column and round to hour\n  | extend DateHour = bin(TimeGenerated, 1h)\n  | summarize PartialFailedSignins = count(), LatestAnomalyTime = arg_max(TimeGenerated, *) by bin(TimeGenerated, 1h), OperationName, Category, ResultType, ResultDescription, UserPrincipalName, UserDisplayName, AppDisplayName, ClientAppUsed, IPAddress, ResourceDisplayName\n) on UserPrincipalName, $left.AnomalyHour == $right.DateHour\n| project LatestAnomalyTime, OperationName, Category, UserPrincipalName, UserDisplayName, ResultType, ResultDescription, AppDisplayName, ClientAppUsed, UserAgent, IPAddress, Location, AuthenticationRequirement, ConditionalAccessStatus, ResourceDisplayName, PartialFailedSignins, TotalFailedSignins = DailyCount, baseline, anomalies, score\n| extend timestamp = LatestAnomalyTime, IPCustomEntity = IPAddress, AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "' Identifies spike in failed sign-ins from user accounts due to conditional access policied.\nSpike is determined based on Time series anomaly which will look at historical baseline values.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins'\n", "techniques": ["T1078.004"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/UseraddedtoPrivilgedGroups.yaml", "query_name": "User added to Azure Active Directory Privileged Groups", "query": "let OperationList = dynamic([\"Add member to role\",\"Add member to role in PIM requested (permanent)\"]);\nlet PrivilegedGroups = dynamic([\"UserAccountAdmins\",\"PrivilegedRoleAdmins\",\"TenantAdmins\"]);\nAuditLogs\n//| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"RoleManagement\"\n| where OperationName in~ (OperationList)\n| mv-expand TargetResources\n| extend modProps = parse_json(TargetResources).modifiedProperties\n| mv-expand bagexpansion=array modProps\n| evaluate bag_unpack(modProps)\n| extend displayName = column_ifexists(\"displayName\", \"NotAvailable\"), newValue = column_ifexists(\"newValue\", \"NotAvailable\")\n| where displayName =~ \"Role.WellKnownObjectName\"\n| extend DisplayName = displayName, GroupName = replace('\"','',newValue)\n| extend initByApp = parse_json(InitiatedBy).app, initByUser = parse_json(InitiatedBy).user\n| extend AppId = initByApp.appId, \nInitiatedByDisplayName = case(isnotempty(initByApp.displayName), initByApp.displayName, isnotempty(initByUser.displayName), initByUser.displayName, \"not available\"),\nServicePrincipalId = tostring(initByApp.servicePrincipalId),\nServicePrincipalName = tostring(initByApp.servicePrincipalName),\nUserId = initByUser.id,\nUserIPAddress = initByUser.ipAddress,\nUserRoles = initByUser.roles,\nUserPrincipalName = tostring(initByUser.userPrincipalName),\nTargetUserPrincipalName = tostring(TargetResources.userPrincipalName)\n| where GroupName in~ (PrivilegedGroups)\n// If you don't want to alert for operations from PIM, remove below filtering for MS-PIM.\n//| where InitiatedByDisplayName != \"MS-PIM\"\n| project TimeGenerated, AADOperationType, Category, OperationName, AADTenantId, AppId, InitiatedByDisplayName, ServicePrincipalId, ServicePrincipalName, DisplayName, GroupName, UserId, UserIPAddress, UserRoles, UserPrincipalName, TargetUserPrincipalName\n| extend timestamp = TimeGenerated, AccountCustomEntity = case(isnotempty(ServicePrincipalName), ServicePrincipalName, isnotempty(ServicePrincipalId), ServicePrincipalId, isnotempty(UserPrincipalName), UserPrincipalName, \"not available\")\n", "attributes": {"description": "'This will alert when a user is added to any of the Privileged Groups.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\nFor Administrator role permissions in Azure Active Directory please see https://docs.microsoft.com/azure/active-directory/users-groups-roles/directory-assign-admin-roles'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory/Analytic%20Rules/UserAssignedPrivilegedRole.yaml", "query_name": "User Assigned Privileged Role", "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where AADOperationType in (\"Assign\", \"AssignEligibleRole\")\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-expand TargetResources\n| mv-expand TargetResources.modifiedProperties\n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n| where displayName_ =~ \"Role.DisplayName\"\n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n| where RoleName contains \"Admin\"\n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n// Uncomment below to not alert for PIM activations\n//| where Initiator != \"MS-PIM\"\n| extend Target = tostring(TargetResources.userPrincipalName)\n| summarize by bin(TimeGenerated, 1h), OperationName,  RoleName, Target, Initiator, Result\n| extend AccountCustomEntity = Target\n", "attributes": {"description": "'Identifies when a new privileged role is assigned to a user.  Any account eligible for a role is now being given privileged access. If the assignment is unexpected or into a role that isn't the responsibility of the account holder, investigate.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'\n", "techniques": ["T1078.004"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Active%20Directory%20Identity%20Protection/Analytic%20Rules/CorrelateIPC_Unfamiliar-Atypical.yaml", "query_name": "Correlate Unfamiliar sign-in properties and atypical travel alerts", "query": "let Alert1 = \nSecurityAlert\n| where AlertName == \"Unfamiliar sign-in properties\"\n| extend UserPrincipalName = tostring(parse_json(ExtendedProperties).[\"User Account\"])\n| extend Alert1Time = TimeGenerated\n| extend Alert1 = AlertName\n| extend Alert1Severity = AlertSeverity\n;\nlet Alert2 = \nSecurityAlert\n| where AlertName == \"Atypical travel\"\n| extend UserPrincipalName = tostring(parse_json(ExtendedProperties).[\"User Account\"])\n| extend Alert2Time = TimeGenerated\n| extend Alert2 = AlertName\n| extend Alert2Severity = AlertSeverity\n| extend CurrentLocation = strcat(tostring(parse_json(tostring(parse_json(Entities)[2].Location)).CountryCode), \"|\", tostring(parse_json(tostring(parse_json(Entities)[2].Location)).State), \"|\", tostring(parse_json(tostring(parse_json(Entities)[2].Location)).City))\n| extend PreviousLocation = strcat(tostring(parse_json(tostring(parse_json(Entities)[3].Location)).CountryCode), \"|\", tostring(parse_json(tostring(parse_json(Entities)[3].Location)).State), \"|\", tostring(parse_json(tostring(parse_json(Entities)[3].Location)).City))\n| extend CurrentIPAddress = tostring(parse_json(Entities)[2].Address)\n| extend PreviousIPAddress = tostring(parse_json(Entities)[3].Address)\n;\nAlert1\n| join kind=inner Alert2 on UserPrincipalName\n| where abs(datetime_diff('minute', Alert1Time, Alert2Time)) <=10\n| extend TimeDelta = Alert1Time - Alert2Time\n| project UserPrincipalName, Alert1, Alert1Time, Alert1Severity, Alert2, Alert2Time, Alert2Severity, TimeDelta, CurrentLocation, PreviousLocation, CurrentIPAddress, PreviousIPAddress\n| extend AccountCustomEntity = UserPrincipalName\n| extend IPCustomEntity = CurrentIPAddress\n", "attributes": {"description": "'The combination of an Unfamiliar sign-in properties alert and an Atypical travel alert about the same user within a +10m or -10m window is considered a high severity incident.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20DDoS%20Protection/Analytic%20Rules/AttackSourcesPercentThreshold.yaml", "query_name": "DDoS Attack IP Addresses - Percent Threshold", "query": "let T1 = AzureDiagnostics\n  | where ResourceType == \"PUBLICIPADDRESSES\" and Category == \"DDoSMitigationFlowLogs\"\n  | summarize rows_count = count() by destPublicIpAddress_s, sourcePublicIpAddress_s;\nlet T2 = AzureDiagnostics\n  | where ResourceType == \"PUBLICIPADDRESSES\" and Category == \"DDoSMitigationFlowLogs\"\n  | summarize rows_total = count() by destPublicIpAddress_s;\nT2\n  | join kind=leftouter T1 on destPublicIpAddress_s\n  | project destPublicIpAddress_s, sourcePublicIpAddress_s, percent_of_traffic = 100*rows_count/rows_total\n  | order by percent_of_traffic desc\n  | where percent_of_traffic > 5\n", "attributes": {"description": "Identifies IP addresses that generate over 5% of traffic during DDoS attack mitigation", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20DDoS%20Protection/Analytic%20Rules/AttackSourcesPPSThreshold.yaml", "query_name": "DDoS Attack IP Addresses - PPS Threshold", "query": "AzureDiagnostics \n| where ResourceType == 'PUBLICIPADDRESSES' and Category == \"DDoSMitigationFlowLogs\"\n//sample rate of mitigation device 1:1000 so the PPS of the source is estimated to be x1000.\n| summarize PPS = 1000 * count() by destPublicIpAddress_s, sec = bin(TimeGenerated, 1s), sourcePublicIpAddress_s\n| summarize maxPPS = max(PPS) by destPublicIpAddress_s, sourcePublicIpAddress_s\n| order by destPublicIpAddress_s, maxPPS desc\n| where maxPPS > 10000\n", "attributes": {"description": "Identifies IP addresses that generates maximal traffic rate over 10k PPS during DDoS attack mitigation", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Firewall/Analytic%20Rules/SeveralDenyActionsRegistered.yaml", "query_name": "Several deny actions registered", "query": "\nlet threshold = 1;\nAzureDiagnostics\n    | where OperationName in (\"AzureFirewallApplicationRuleLog\",\"AzureFirewallNetworkRuleLog\")\n    | extend msg_s_replaced0 = replace(@\"\\s\\s\",@\" \",msg_s)\n    | extend msg_s_replaced1 = replace(@\"\\.\\s\",@\" \",msg_s_replaced0)\n    | extend msg_a = split(msg_s_replaced1,\" \")\n    | extend srcAddr_a = split(msg_a[3],\":\") , destAddr_a = split(msg_a[5],\":\")\n    | extend protocol = tostring(msg_a[0]), srcIp = tostring(srcAddr_a[0]), srcPort = tostring(srcAddr_a[1]), destIp = tostring(destAddr_a[0]), destPort = tostring(destAddr_a[1]), action = tostring(msg_a[7])\n    | where action == \"Deny\"\n    | extend url = iff(destIp matches regex \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\",\"\",destIp)\n    | summarize StartTime = min(TimeGenerated), count() by srcIp, destIp, url, action, protocol\n    | where count_ >= [\"threshold\"]\n    | extend timestamp = StartTime, URLCustomEntity = url, IPCustomEntity = srcIp\n", "attributes": {"description": "'Identifies attack pattern when attacker tries to move, or scan, from resource to resource on the network and creates an incident when a source has more than 1 registered deny action in Azure Firewall.'\n", "techniques": ["T1046", "T1071", "T1210"], "tactics": ["Discovery", "LateralMovement", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Key%20Vault/Analytic%20Rules/KeyvaultMassSecretRetrieval.yaml", "query_name": "Mass secret retrieval from Azure Key Vault", "query": "let EventCountThreshold = 25;\n// To avoid any False Positives, filtering using AppId is recommended.\n// The AppId 509e4652-da8d-478d-a730-e9d4a1996ca4 has been added in the query as it corresponds to Azure Resource Graph performing VaultGet operations for indexing and syncing all tracked resources across Azure.\n// The AppId 8cae6e77-e04e-42ce-b5cb-50d82bce26b1 has been added as it correspond to Microsoft Policy Insights Provider Data Plane performing VaultGet operations for policies checks.\nlet AllowedAppId = dynamic([\"509e4652-da8d-478d-a730-e9d4a1996ca4\",\"8cae6e77-e04e-42ce-b5cb-50d82bce26b1\"]);\nlet OperationList = dynamic([\"SecretGet\", \"KeyGet\", \"VaultGet\"]);\nAzureDiagnostics\n| where OperationName in (OperationList) and ResourceType =~ \"VAULTS\"\n| where not(identity_claim_appid_g in (AllowedAppId) and OperationName == 'VaultGet')\n| extend\n    ResultType = column_ifexists(\"ResultType\", \"\"),\n    identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = column_ifexists(\"identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\", \"\"),\n    identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_upn_s = column_ifexists(\"identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_upn_s\", \"\"),\n    identity_claim_oid_g = column_ifexists(\"identity_claim_oid_g\", \"\"),\n    identity_claim_upn_s = column_ifexists(\"identity_claim_upn_s\", \"\")\n| extend\n    CallerObjectId = iff(isempty(identity_claim_oid_g), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, identity_claim_oid_g),\n    CallerObjectUPN = iff(isempty(identity_claim_upn_s), identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_upn_s, identity_claim_upn_s)\n| as _Retrievals\n| where CallerObjectId in (toscalar(\n    _Retrievals\n    | where ResultType == \"Success\"\n    | summarize Count = count() by OperationName, CallerObjectId\n    | where Count > EventCountThreshold\n    | summarize make_set(CallerObjectId)\n))\n| extend\n    requestUri_s = column_ifexists(\"requestUri_s\", \"\"),\n    id_s = column_ifexists(\"id_s\", \"\"),\n    CallerIPAddress = column_ifexists(\"CallerIPAddress\", \"\"),\n    clientInfo_s = column_ifexists(\"clientInfo_s\", \"\")\n| summarize\n    EventCount = count(),\n    StartTime = min(TimeGenerated),\n    EndTime = max(TimeGenerated),\n    //TimeTriggered = make_list(TimeGenerated, 50),\n    OperationNameList = make_set(OperationName, 50),\n    RequestURLList = make_set(requestUri_s, 50),\n    CallerIPList = make_set(CallerIPAddress, 50),\n    clientInfo_sList = make_set(clientInfo_s, 50),\n    CallerIPMax = max(CallerIPAddress)\n    //CallerIPMax = arg_max(CallerIPAddress,*)\n    by ResourceType, ResultType, Resource, id_s, identity_claim_appid_g, CallerObjectId, CallerObjectUPN\n| project-reorder StartTime, EndTime, EventCount, ResourceType, Resource, id_s, identity_claim_appid_g, CallerObjectId, CallerObjectUPN, ResultType, OperationNameList, RequestURLList, CallerIPList, clientInfo_sList\n| extend timestamp = EndTime, IPCustomEntity = CallerIPMax, AccountCustomEntity = CallerObjectId\n", "attributes": {"description": "'Identifies mass secret retrieval from Azure Key Vault observed by a single user. \nMass secret retrival crossing a certain threshold is an indication of credential dump operations or mis-configured applications. \nYou can tweak the EventCountThreshold based on average count seen in your environment \nand also filter any known sources (IP/Account) and useragent combinations based on historical analysis to further reduce noise'\n", "techniques": ["T1003"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Key%20Vault/Analytic%20Rules/KeyVaultSensitiveOperations.yaml", "query_name": "Sensitive Azure Key Vault operations", "query": "\nlet SensitiveOperationList = dynamic(\n[\"VaultDelete\", \"KeyDelete\", \"SecretDelete\", \"SecretPurge\", \"KeyPurge\", \"SecretBackup\", \"KeyBackup\"]);\nAzureDiagnostics\n| extend ResultType = columnifexists(\"ResultType\", \"NoResultType\")\n| extend requestUri_s = columnifexists(\"requestUri_s\", \"None\"), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(\"identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\", \"None\")\n| extend id_s = columnifexists(\"id_s\", \"None\"), CallerIPAddress = columnifexists(\"CallerIPAddress\", \"None\"), clientInfo_s = columnifexists(\"clientInfo_s\", \"None\")\n| where ResultType !~ \"None\" and isnotempty(ResultType)\n| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ \"None\" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)\n| where id_s !~ \"None\" and isnotempty(id_s)\n| where CallerIPAddress !~ \"None\" and isnotempty(CallerIPAddress)\n| where clientInfo_s !~ \"None\" and isnotempty(clientInfo_s)\n| where requestUri_s !~ \"None\" and isnotempty(requestUri_s)\n| where ResourceType =~ \"VAULTS\" and ResultType =~ \"Success\" \n| where OperationName in~ (SensitiveOperationList)  \n| summarize EventCount=count(), StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated), TimeTriggered=makelist(TimeGenerated),OperationNameList=make_set(OperationName), RequestURLList=make_set(requestUri_s), CallerIPList = make_set(CallerIPAddress),  CallerIPMax= arg_max(CallerIPAddress,*) by ResourceType, ResultType, Resource, id_s, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, clientInfo_s\n| extend timestamp = StartTimeUtc, IPCustomEntity = CallerIPMax, AccountCustomEntity = identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\n", "attributes": {"description": "'Identifies when sensitive Azure Key Vault operations are used. This includes: VaultDelete, KeyDelete, SecretDelete, SecretPurge, KeyPurge, SecretBackup, KeyBackup. \nAny Backup operations should match with expected scheduled backup activity.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Key%20Vault/Analytic%20Rules/NRT_KeyVaultSensitiveOperations.yaml", "query_name": "NRT Sensitive Azure Key Vault operations", "query": "let SensitiveOperationList = dynamic(\n[\"VaultDelete\", \"KeyDelete\", \"SecretDelete\", \"SecretPurge\", \"KeyPurge\", \"SecretBackup\", \"KeyBackup\"]);\nAzureDiagnostics\n| extend ResultType = columnifexists(\"ResultType\", \"NoResultType\")\n| extend requestUri_s = columnifexists(\"requestUri_s\", \"None\"), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(\"identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\", \"None\")\n| extend id_s = columnifexists(\"id_s\", \"None\"), CallerIPAddress = columnifexists(\"CallerIPAddress\", \"None\"), clientInfo_s = columnifexists(\"clientInfo_s\", \"None\")\n| where ResultType !~ \"None\" and isnotempty(ResultType)\n| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ \"None\" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)\n| where id_s !~ \"None\" and isnotempty(id_s)\n| where CallerIPAddress !~ \"None\" and isnotempty(CallerIPAddress)\n| where clientInfo_s !~ \"None\" and isnotempty(clientInfo_s)\n| where requestUri_s !~ \"None\" and isnotempty(requestUri_s)\n| where ResourceType =~ \"VAULTS\" and ResultType =~ \"Success\"\n| where OperationName in~ (SensitiveOperationList)\n| summarize EventCount=count(), StartTimeUtc=min(TimeGenerated), EndTimeUtc=max(TimeGenerated), TimeTriggered=makelist(TimeGenerated),OperationNameList=make_set(OperationName), RequestURLList=make_set(requestUri_s), CallerIPList = make_set(CallerIPAddress),  CallerIPMax= arg_max(CallerIPAddress,*) by ResourceType, ResultType, Resource, id_s, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, clientInfo_s\n", "attributes": {"description": "'Identifies when sensitive Azure Key Vault operations are used. This includes: VaultDelete, KeyDelete, SecretDelete, SecretPurge, KeyPurge, SecretBackup, KeyBackup.\nAny Backup operations should match with expected scheduled backup activity.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Key%20Vault/Analytic%20Rules/TimeSeriesKeyvaultAccessAnomaly.yaml", "query_name": "Azure Key Vault access TimeSeries anomaly", "query": "\nlet starttime = 14d;\nlet timeframe = 1d;\nlet scorethreshold = 3;\nlet baselinethreshold = 5;\n// To avoid any False Positives, filtering using AppId is recommended. For example the AppId 509e4652-da8d-478d-a730-e9d4a1996ca4 has been added in the query as it corresponds \n// to Azure Resource Graph performing VaultGet operations for indexing and syncing all tracked resources across Azure.\nlet Allowedappid = dynamic([\"509e4652-da8d-478d-a730-e9d4a1996ca4\"]);\nlet OperationList = dynamic(\n[\"SecretGet\", \"KeyGet\", \"VaultGet\"]);\nlet TimeSeriesData = AzureDiagnostics\n| where TimeGenerated between (startofday(ago(starttime))..startofday(now()))\n| where not((identity_claim_appid_g in (Allowedappid)) and OperationName == 'VaultGet')\n| extend ResultType = columnifexists(\"ResultType\", \"None\"), CallerIPAddress = columnifexists(\"CallerIPAddress\", \"None\")\n| where ResultType !~ \"None\" and isnotempty(ResultType)\n| where CallerIPAddress !~ \"None\" and isnotempty(CallerIPAddress)\n| where ResourceType =~ \"VAULTS\" and ResultType =~ \"Success\"\n| where OperationName in (OperationList)\n| project TimeGenerated, OperationName, Resource, CallerIPAddress\n| make-series HourlyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by Resource;\n//Filter anomolies against TimeSeriesData\nlet TimeSeriesAlerts = TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(HourlyCount, scorethreshold, -1, 'linefit')\n| mv-expand HourlyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)\n| where anomalies > 0 | extend AnomalyHour = TimeGenerated\n| where baseline > baselinethreshold // Filtering low count events per baselinethreshold\n| project Resource, AnomalyHour, TimeGenerated, HourlyCount, baseline, anomalies, score;\nlet AnomalyHours = TimeSeriesAlerts | where TimeGenerated > ago(2d) | project TimeGenerated;\n// Filter the alerts since specified timeframe\nTimeSeriesAlerts\n| where TimeGenerated > ago(2d)\n// Join against base logs since specified timeframe to retrive records associated with the hour of anomoly\n| join (\nAzureDiagnostics\n| where TimeGenerated > ago(timeframe)\n| where not((identity_claim_appid_g in (Allowedappid)) and OperationName == 'VaultGet')\n| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour\n| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours\n| extend ResultType = columnifexists(\"ResultType\", \"NoResultType\")\n| extend requestUri_s = columnifexists(\"requestUri_s\", \"None\"), identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g = columnifexists(\"identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g\", \"None\")\n| extend id_s = columnifexists(\"id_s\", \"None\"), CallerIPAddress = columnifexists(\"CallerIPAddress\", \"None\"), clientInfo_s = columnifexists(\"clientInfo_s\", \"None\")\n| where ResultType !~ \"None\" and isnotempty(ResultType)\n| where identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g !~ \"None\" and isnotempty(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g)\n| where id_s !~ \"None\" and isnotempty(id_s)\n| where CallerIPAddress !~ \"None\" and isnotempty(CallerIPAddress)\n| where clientInfo_s !~ \"None\" and isnotempty(clientInfo_s)\n| where requestUri_s !~ \"None\" and isnotempty(requestUri_s)\n| where ResourceType =~ \"VAULTS\" and ResultType =~ \"Success\"\n| where OperationName in (OperationList)\n| summarize PerOperationCount=count(), LatestAnomalyTime = arg_max(TimeGenerated,*) by bin(TimeGenerated,1h), Resource, OperationName, id_s, CallerIPAddress, identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, requestUri_s, clientInfo_s\n) on Resource, TimeGenerated\n| summarize EventCount=count(), OperationNameList = make_set(OperationName), RequestURLList = make_set(requestUri_s, 100), AccountList = make_set(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g, 100), AccountMax = arg_max(identity_claim_http_schemas_microsoft_com_identity_claims_objectidentifier_g,*) by Resource, id_s, clientInfo_s, LatestAnomalyTime\n| extend timestamp = LatestAnomalyTime, IPCustomEntity = CallerIPAddress, AccountCustomEntity = AccountMax\n", "attributes": {"description": "'Indentifies a sudden increase in count of Azure Key Vault secret or vault access operations by CallerIPAddress. The query leverages a built-in KQL anomaly detection algorithm\nto find large deviations from baseline Azure Key Vault access patterns. Any sudden increase in the count of Azure Key Vault accesses can be an\nindication of adversary dumping credentials via automated methods. If you are seeing any noise, try filtering known source(IP/Account) and user-agent combinations.\nTimeSeries Reference Blog: https://techcommunity.microsoft.com/t5/azure-sentinel/looking-for-unknown-anomalies-what-is-normal-time-series/ba-p/555052'\n", "techniques": ["T1003"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Purview/Analytic%20Rules/AzurePurviewSensitiveDataDiscovered.yaml", "query_name": "Sensitive Data Discovered in the Last 24 Hours", "query": "PurviewDataSensitivityLogs\n| where Classification != \"[]\" \n| where TimeGenerated > ago(24h)\n", "attributes": {"description": "'Identifies all classifications that have been detected on assets during a scan by Azure Purview within the last 24 hours.'\n", "techniques": ["T1087"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Azure%20Purview/Analytic%20Rules/AzurePurviewSensitiveDataDiscoveredCustom.yaml", "query_name": "Sensitive Data Discovered in the Last 24 Hours - Customized", "query": "PurviewDataSensitivityLogs\n| where Classification contains \"Social Security Number\"\n//| where SourceRegion == \"westeurope\"\n//| where SourceType contains \"Amazon\"\n| where TimeGenerated > ago(24h)\n", "attributes": {"description": "'Customized query used to identify specific classifications and parameters that have been discovered on assets in the last 24 hours by Azure Purview. By default, the query identifies Social Security Numbers detected, but the specific classification monitored along with other data fields can be adjusted. A list of supported Azure Purview classifications can be found here: https://docs.microsoft.com/azure/purview/supported-classifications'\n", "techniques": ["T1087"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/AzureSecurityBenchmark/Analytic%20Rules/AzureSecurityBenchmarkPostureChanged.yaml", "query_name": "Azure Security Benchmark Posture Changed", "query": "let Last_Evaluated=SecurityRecommendation\n| join kind=fullouter(SecurityRegulatoryCompliance| where ComplianceStandard == \"Azure-Security-Benchmark\") on RecommendationName\n| summarize arg_max(TimeGenerated, *) by AssessedResourceId, RecommendationName\n| extend ComplianceDomain=iff(ComplianceControl contains \"NS.\", \"Network Security\", iff(ComplianceControl contains \"IM.\", \"Identity Management\", iff(ComplianceControl contains \"PA.\", \"Privileged Access\", iff(ComplianceControl contains \"DP.\", \"Data Protection\", iff(ComplianceControl contains \"AM.\", \"Asset Management\", iff(ComplianceControl contains \"LT.\", \"Logging & Threat Detection\", iff(ComplianceControl contains \"IR.\", \"Incident Response\", iff(ComplianceControl contains \"PV.\", \"Posture & Vulnerability Management\", iff(ComplianceControl contains \"ES.\", \"Endpoint Security\", iff(ComplianceControl contains \"BR.\", \"Backup & Recovery\", iff(ComplianceControl startswith \"DS.\", \"DevOps Security\", iff(ComplianceControl contains \"GS.\", \"Governance & Strategy\", \"Other\"))))))))))));\nSecurityRecommendation\n| join kind=fullouter(SecurityRegulatoryCompliance| where ComplianceStandard == \"Azure-Security-Benchmark\") on RecommendationName\n| extend ComplianceDomain=iff(ComplianceControl contains \"NS.\", \"Network Security\", iff(ComplianceControl contains \"IM.\", \"Identity Management\", iff(ComplianceControl contains \"PA.\", \"Privileged Access\", iff(ComplianceControl contains \"DP.\", \"Data Protection\", iff(ComplianceControl contains \"AM.\", \"Asset Management\", iff(ComplianceControl contains \"LT.\", \"Logging & Threat Detection\", iff(ComplianceControl contains \"IR.\", \"Incident Response\", iff(ComplianceControl contains \"PV.\", \"Posture & Vulnerability Management\", iff(ComplianceControl contains \"ES.\", \"Endpoint Security\", iff(ComplianceControl contains \"BR.\", \"Backup & Recovery\", iff(ComplianceControl startswith \"DS.\", \"DevOps Security\", iff(ComplianceControl contains \"GS.\", \"Governance & Strategy\", \"Other\"))))))))))))\n| summarize arg_max(TimeGenerated, *) by AssessedResourceId, RecommendationName\n| summarize Failed = countif(RecommendationState == \"Unhealthy\"), Passed = countif(RecommendationState == \"Healthy\"), Total = countif(RecommendationState == \"Healthy\" or RecommendationState == \"Unhealthy\") by ComplianceDomain\n| extend PassedControlsPercentage = (Passed/todouble(Total))*100\n| join (Last_Evaluated) on ComplianceDomain\n| project ComplianceDomain, Total, PassedControlsPercentage, Passed, Failed, LastEvaluated=TimeGenerated\n| summarize arg_max(LastEvaluated, *) by ComplianceDomain, Total, PassedControlsPercentage, Passed, Failed\n| where PassedControlsPercentage < 70 \n| sort by PassedControlsPercentage, Passed desc\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22')\n| extend URLCustomEntity = RemediationLink\n", "attributes": {"description": "'This alert is designed to monitor Azure policies aligned with the Azure Security Benchmark Regulatory Compliance initiative. The alert triggers when policy compliance falls below 70% within a 1 week time-frame.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassFilesSharedWithExternal.yaml", "query_name": "Bitglass - Multiple files shared with external entity", "query": "let threshold = 5;\nBitglass\n| where EventType =~ 'cloudaudit'\n| where Action =~ 'Action  DLPScan'\n| where EventMessage has_all ('External', 'Shared', 'DLP')\n| summarize f_cnt = makeset(SrcFileName) by User, bin(TimeGenerated, 10m)\n| where array_length(f_cnt) >= threshold\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Detects when multiple files shared with external entity.'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassImpossibleTravelDistance.yaml", "query_name": "Bitglass - Impossible travel distance", "query": "Bitglass\n| where EventType =~ 'access'\n| where EventResultDetails startswith 'Simultaneous logins from geographically distant locations'\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Detects logins from different geo locations.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassMultipleFailedLogins.yaml", "query_name": "Bitglass - Multiple failed logins", "query": "let threshold = 10;\nBitglass\n| where EventType =~ 'access'\n| where EventResultDetails =~ 'Failed login attempt.'\n| summarize count() by User, bin(TimeGenerated, 10m)\n| where count_ >= threshold\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Detects multiple failed logins.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassNewAdminUser.yaml", "query_name": "Bitglass - New admin user", "query": "Bitglass\n| where EventType =~ 'admin'\n| where EventResultDetails has_all ('User', 'Promoted to administrator')\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Detects new admin user.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassNewDevice.yaml", "query_name": "Bitglass - Login from new device", "query": "Bitglass\n| where EventType =~ 'access'\n| where EventMessage =~ 'Login'\n| summarize dev = makeset(Dvc) by User\n| join (Bitglass\n        | where EventType =~ 'access'\n        | where EventMessage =~ 'Login') on User\n| where dev !contains Dvc\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Detects when a user logins from new device.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassNewRiskyUser.yaml", "query_name": "Bitglass - New risky user", "query": "Bitglass\n| where EventType =~ 'access'\n| where EventResultDetails has_all ('Added', 'Risky Users')\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Detects new risky user.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassSmartEdgeAgentUninstall.yaml", "query_name": "Bitglass - The SmartEdge endpoint agent was uninstalled", "query": "Bitglass\n| where EventType =~ 'access'\n| where EventResultDetails startswith 'The SmartEdge endpoint agent was uninstalled'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when SmartEdge endpoint agent was uninstalled.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassSuspiciousFileUpload.yaml", "query_name": "Bitglass - Suspicious file uploads", "query": "Bitglass\n| where EventType =~ 'swgwebdlp'\n| where HttpRequestMethod =~ 'POST'\n| where isnotempty(DlpPattern)\n| summarize count() by User, bin(TimeGenerated, 15m)\n| where count_ > 1\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Detects suspicious file upload activity.'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassUserLoginNewGeoLocation.yaml", "query_name": "Bitglass - User login from new geo location", "query": "Bitglass\n| where EventType =~ 'access'\n| where EventMessage =~ 'Login'\n| summarize g_loc = makeset(SrcGeoLocation) by User\n| join (Bitglass\n        | where EventType =~ 'access'\n        | where EventMessage =~ 'Login') on User\n| where g_loc !contains SrcGeoLocation\n| extend AccountCustomEntity = User, FileCustomEntity = SrcFileName\n", "attributes": {"description": "'Detects user login from new geo location.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Analytic%20Rules/BitglassUserUAChanged.yaml", "query_name": "Bitglass - User Agent string has changed for user", "query": "Bitglass\n| where EventType =~ 'access'\n| where EventMessage =~ 'Login'\n| summarize ua = makeset(HttpUserAgent) by User\n| join (Bitglass\n        | where EventType =~ 'access'\n        | where EventMessage =~ 'Login') on User\n| where ua !contains HttpUserAgent\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Detects when User Agent string has changed for user.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassApplications.yaml", "query_name": "Bitglass - Applications used", "query": "Bitglass\n| where TimeGenerated > ago(24h)\n| where isnotempty(Application)\n| summarize count() by Application\n| extend AppCustomEntity = Application\n", "attributes": {"description": "'Query searches for applications used.'\n", "techniques": ["T1078"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassInsecureWebProtocol.yaml", "query_name": "Bitglass - Insecure web protocol", "query": "Bitglass\n| where TimeGenerated > ago(24h)\n| where EventType in~ ('swgweb', 'swgwebdlp')\n| where NetworkProtocol =~ 'http'\n| extend AccountCustomEntity = User, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for usage of http protocol.'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassLoginFailures.yaml", "query_name": "Bitglass - Login failures", "query": "Bitglass\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'access'\n| where EventResultDetails =~ 'Failed login attempt.'\n| order by TimeGenerated\n| extend AccountCustomEntity = User, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for login failures.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassNewApplications.yaml", "query_name": "Bitglass - New applications", "query": "Bitglass\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'admin'\n| where EventResultDetails has_all ('Application', 'added')\n| extend n_app = extract(@'Application\\s(.*?)\\sadded', 1, EventResultDetails)\n| extend AppCustomEntity = n_app\n", "attributes": {"description": "'Query searches for new applications configured.'\n", "techniques": ["T1078"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassNewUsers.yaml", "query_name": "Bitglass - New users", "query": "let u_list = Bitglass\n| where TimeGenerated between(ago(30d) .. ago(1d))\n| where EventType =~ 'access'\n| where EventMessage =~ 'Login'\n| summarize l_usr = makeset(User)\n| extend k = 1;\nBitglass\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'access'\n| where EventMessage =~ 'Login'\n| extend k = 1\n| join (u_list) on k\n| where l_usr !contains User\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Query searches for new users.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassPrivilegedLoginFailures.yaml", "query_name": "Bitglass - Privileged login failures", "query": "Bitglass\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'admin'\n| where EventResultDetails =~ 'Error attempting to login to Bitglass'\n| order by TimeGenerated\n| extend AccountCustomEntity = User, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for privileged login failures.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassRiskyUsers.yaml", "query_name": "Bitglass - Risky users", "query": "Bitglass\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'access'\n| where EventResultDetails has_all ('Added', 'Risky Users')\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Query searches for risky users.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassTopUsersWithBlocks.yaml", "query_name": "Bitglass - Risky users", "query": "Bitglass\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'swgweb'\n| where Action =~ 'block'\n| summarize count() by User\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Query searches for risky users.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassUncategorizedResources.yaml", "query_name": "Bitglass - Uncategorized resources", "query": "Bitglass\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'swgweb'\n| where WebCategories contains 'Uncategorized'\n| where Action =~ 'allow'\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Query searches for uncategorized resources.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Bitglass/Hunting%20Queries/BitglassUserDevices.yaml", "query_name": "Bitglass - User devices", "query": "Bitglass\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'access'\n| where isnotempty(Dvc)\n| summarize makeset(Dvc) by User\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Query searches for user devices.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxAbnormalUserActivity.yaml", "query_name": "Box - Abmormal user activity", "query": "let lbperiod_start = 14d;\nlet lbperiod_end = 24h;\nlet user_actions_1 = BoxEvents\n| where TimeGenerated between (ago(lbperiod_start) .. ago(lbperiod_end))\n| summarize TotalEvents = count() by SourceName\n| project TotalEvents, User = SourceName;\nlet user_actions_2 = BoxEvents\n| where TimeGenerated between (ago(lbperiod_start) .. ago(lbperiod_end))\n| summarize TotalEvents = count() by SrcUserName\n| project TotalEvents, User = SrcUserName;\nlet TotalActions = (union user_actions_1, user_actions_2)\n| summarize TotalEvents = count() by User\n| extend EventsPerDay = TotalEvents / 29\n| extend k = 1;\nlet actions1_last_h = BoxEvents\n| summarize TotalEventsH = count() by SourceName\n| project TotalEventsH, User = SourceName;\nlet actions2_last_h = BoxEvents\n| summarize TotalEventsH = count() by SourceName\n| project TotalEventsH, User = SourceName;\nlet TotalActionsLastHour = (union actions1_last_h, actions2_last_h)\n| summarize TotalEventsH = sum(TotalEventsH) by User\n| extend k = 1;\nTotalActions\n| join (TotalActionsLastHour) on k\n| where EventsPerDay > TotalEventsH\n| project User\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Detects spikes (deviations from avarage) in user activity.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxBinaryFile.yaml", "query_name": "Box - Executable file in folder", "query": "BoxEvents\n| where SourceFileName hassuffix '.exe' or SourceItemName hassuffix '.exe'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects executable files in folders.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxDownloadForbiddenFiles.yaml", "query_name": "Box - Forbidden file type downloaded", "query": "let forbidden_files = dynamic(['ps1', 'bat', 'scr', 'sh']);\nBoxEvents\n| where EventType =~ 'DOWNLOAD'\n| extend file_type = extract(@'\\.(\\w+)$', 1, SourceItemName)\n| where file_type in (forbidden_files)\n| extend AccountCustomEntity = SrcUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when new user downloads forbidden file types.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxInactiveUserLogin.yaml", "query_name": "Box - Inactive user login", "query": "let lbperiod_start = 14d;\nlet lbperiod_end = 7d;\nlet lbtime = 1h;\nlet active_users = BoxEvents\n| where TimeGenerated between (ago(lbperiod_end) .. ago(lbtime))\n| where EventType =~ 'LOGIN'\n| summarize makeset(SourceName);\nlet inactive_users = BoxEvents\n| where TimeGenerated between (ago(lbperiod_start) .. ago(lbperiod_end))\n| where EventType =~ 'LOGIN'\n| where SourceName !in (active_users)\n| summarize makeset(SourceName);\nBoxEvents\n| where EventType == 'LOGIN'\n| where SourceName in (inactive_users)\n| extend AccountCustomEntity = SourceName\n", "attributes": {"description": "'Detects user login after long inactivity period.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxItemSharedToExternalUser.yaml", "query_name": "Box - Item shared to external entity", "query": "BoxEvents\n| where EventType =~ 'COLLABORATION_INVITE'\n| extend corp_domain = tolower(extract(@'@(.*)', 1, SrcUserUpn))\n| extend accessibleby_domain = tolower(extract(@'@(.*)', 1, AccessibleByLogin))\n| where corp_domain != accessibleby_domain\n| extend AccountCustomEntity = SrcUserUpn\n", "attributes": {"description": "'Detects when an item was shared to external entity.'\n", "techniques": ["T1537"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxMultipleItemsDeletedByUser.yaml", "query_name": "Box - Many items deleted by user", "query": "let threshold = 100;\nBoxEvents\n| where EventType =~ 'DELETE'\n| summarize deleted_items = dcount(SourceItemName) by SrcUserName, bin(TimeGenerated, 5m)\n| where deleted_items > threshold\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects when a user deletes many items in short period of time.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxNewExternalUser.yaml", "query_name": "Box - New external user", "query": "BoxEvents\n| where EventType =~ 'NEW_USER'\n| extend corp_domain = extract(@'@(.*)', 1, SourceLogin)\n| extend new_domain = tolower(extract(@'@(.*)', 1, SourceLogin))\n| where corp_domain != new_domain\n| extend AccountCustomEntity = SourceLogin\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when new user created with SourceLogin containing non-corporate domain.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxSensitiveFile.yaml", "query_name": "Box - File containing sensitive data", "query": "BoxEvents\n| where SourceItemName =~ 'id_rsa' or SourceItemName contains 'password' or SourceItemName contains 'key' or SourceItemName contains '_key' or SourceItemName contains '.ssh' or SourceItemName endswith '.npmrc' or SourceItemName endswith '.muttrc' or SourceItemName contains 'config.json' or SourceItemName contains '.gitconfig' or SourceItemName endswith '.netrc' or SourceItemName endswith 'package.json' or SourceItemName endswith 'Gemfile' or SourceItemName endswith 'bower.json' or SourceItemName endswith 'config.gypi' or SourceItemName endswith 'travis.yml' or SourceFileName =~ 'id_rsa' or SourceFileName contains 'password' or SourceFileName contains 'key' or SourceFileName contains '_key' or SourceFileName contains '.ssh' or SourceFileName endswith '.npmrc' or SourceFileName endswith '.muttrc' or SourceFileName contains 'config.json' or SourceFileName contains '.gitconfig' or SourceFileName endswith '.netrc' or SourceFileName endswith 'package.json' or SourceFileName endswith 'Gemfile' or SourceFileName contains 'bower.json' or SourceFileName contains 'config.gypi' or SourceFileName contains 'travis.yml'\n| extend AccountCustomEntity = SrcUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects files which potentialy may contain sensitive data such as passwords, authentication tokens, secret keys.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxUserLoginAsAdmin.yaml", "query_name": "Box - User logged in as admin", "query": "let lbperiod_start = 14d;\nlet lbperiod_end = 1d;\nlet admins = BoxEvents\n| where TimeGenerated between (ago(lbperiod_start) .. ago(lbperiod_end))\n| where EventType =~ 'ADMIN_LOGIN'\n| summarize makeset(SourceLogin);\nBoxEvents\n| where EventType =~ 'ADMIN_LOGIN'\n| where SourceLogin !in (admins)\n| extend AccountCustomEntity = SourceLogin\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when user logged in as admin.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Analytic%20Rules/BoxUserRoleChangedToOwner.yaml", "query_name": "Box - User role changed to owner", "query": "let lbperiod = 14d;\nlet lbtime = 1h;\nBoxEvents\n| where TimeGenerated between (ago(lbperiod) .. ago(lbtime))\n| where EventType =~ 'COLLABORATION_INVITE'\n| where AdditionalDetailsRole !~ 'Owner'\n| summarize min(TimeGenerated) by AccessibleByName, FileDirectory, AdditionalDetailsRole\n| project AccessibleByName, FileDirectory, InitialRole = AdditionalDetailsRole\n|join (BoxEvents\n          | where EventType =~ 'COLLABORATION_ROLE_CHANGE'\n          | summarize max(TimeGenerated) by AccessibleByName, FileDirectory, AdditionalDetailsRole\n          | project AccessibleByName, FileDirectory, NewRole = AdditionalDetailsRole\n          ) on FileDirectory, AccessibleByName\n| where NewRole =~ 'Owner'\n| project AccessibleByName, FileDirectory\n| extend AccountCustomEntity = AccessibleByName\n", "attributes": {"description": "'Detects when user collaboration role is changed to owner.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxAdminIpAddress.yaml", "query_name": "Box - IP list for admin users", "query": "BoxEvents\n| where TimeGenerated > ago(30d)\n| where EventType =~ 'ADMIN_LOGIN'\n| summarize makeset(SrcIpAddr) by SourceLogin;\n| extend AccountCustomEntity = SourceLogin\n", "attributes": {"description": "'Query shows iplist for admin users. You can check for suspicious IPs or new IPs.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxDeletedUsers.yaml", "query_name": "Box - Deleted users", "query": "BoxEvents\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'DELETE_USER'\n| project TimeGenerated, SourceName, SourceLogin\n| extend AccountCustomEntity = SourceLogin\n", "attributes": {"description": "'Query shows deleted user accounts.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxInactiveAdmins.yaml", "query_name": "Box - Inactive admin users", "query": "let active_admins = BoxEvents\n| where TimeGenerated between (ago(7d) .. ago(1d))\n| where EventType =~ 'ADMIN_LOGIN'\n| summarize makeset(SourceLogin);\nlet inactive_admins = BoxEvents\n| where TimeGenerated between (ago(30d) .. ago(7d))\n| where EventType =~ 'ADMIN_LOGIN'\n| where SourceLogin !in (active_admins)\n| summarize makeset(SourceLogin);\nBoxEvents\n| where TimeGenerated > ago(7d)\n| where EventType =~ 'ADMIN_LOGIN'\n| where SourceLogin !in (active_admins)\n| where SourceLogin in (inactive_admins)\n| summarize LastLoginTime = max(TimeGenerated) by SourceLogin\n| project LastLoginTime, SourceLogin\n| extend AccountCustomEntity = SourceLogin\n", "attributes": {"description": "'Query shows inactive admin accounts (admin users which last login time is more than 30 days).'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxInactiveUsers.yaml", "query_name": "Box - Inactive users", "query": "let active_admins = BoxEvents\n| where TimeGenerated between (ago(7d) .. ago(1d))\n| where EventType =~ 'LOGIN'\n| summarize makeset(SourceLogin);\nlet inactive_admins = BoxEvents\n| where TimeGenerated between (ago(30d) .. ago(7d))\n| where EventType =~ 'LOGIN'\n| where SourceLogin !in (active_admins)\n| summarize makeset(SourceLogin);\nBoxEvents\n| where TimeGenerated > ago(7d)\n| where EventType =~ 'LOGIN'\n| where SourceLogin !in (active_admins)\n| where SourceLogin in (inactive_admins)\n| summarize LastLoginTime = max(TimeGenerated) by SourceLogin\n| project LastLoginTime, SourceLogin\n| extend AccountCustomEntity = SourceLogin\n", "attributes": {"description": "'Query shows inactive user accounts (users which last login time is more than 30 days).'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxNewUsers.yaml", "query_name": "Box - New users", "query": "BoxEvents\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'NEW_USER'\n| project TimeGenerated, SourceName, SourceLogin\n| extend AccountCustomEntity = SourceLogin\n", "attributes": {"description": "'Query shows new user accounts.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxSuspiciousFiles.yaml", "query_name": "Box - Suspicious or sensitive files", "query": "BoxEvents\n| where TimeGenerated > ago(24h)\n| where SourceItemName =~ 'id_rsa' or SourceItemName contains 'password' or SourceItemName contains 'key' or SourceItemName contains '_key' or SourceItemName contains '.ssh' or SourceItemName endswith '.npmrc' or SourceItemName endswith '.muttrc' or SourceItemName contains 'config.json' or SourceItemName contains '.gitconfig' or SourceItemName endswith '.netrc' or SourceItemName endswith 'package.json' or SourceItemName endswith 'Gemfile' or SourceItemName endswith 'bower.json' or SourceItemName endswith 'config.gypi' or SourceItemName endswith 'travis.yml' or SourceItemName endswith '.ps1' or SourceItemName endswith '.bat' or SourceItemName endswith '.scr' or SourceItemName endswith '.sh' or SourceItemName endswith '.exe' or SourceFileName =~ 'id_rsa' or SourceFileName contains 'password' or SourceFileName contains 'key' or SourceFileName contains '_key' or SourceFileName contains '.ssh' or SourceFileName endswith '.npmrc' or SourceFileName endswith '.muttrc' or SourceFileName contains 'config.json' or SourceFileName contains '.gitconfig' or SourceFileName endswith '.netrc' or SourceFileName endswith 'package.json' or SourceFileName endswith 'Gemfile' or SourceFileName contains 'bower.json' or SourceFileName contains 'config.gypi' or SourceFileName contains 'travis.yml' or SourceFileName endswith '.ps1' or SourceFileName endswith '.bat' or SourceFileName endswith '.scr' or SourceFileName endswith '.sh' or SourceFileName endswith '.exe'\n| project TimeGenerated, SourceName, SourceLogin\n| extend AccountCustomEntity = SourceLogin\n", "attributes": {"description": "'Query searches for potentially suspicious files or files which can contain sensitive information such as passwords, secrets.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxUserDownloadsByVolume.yaml", "query_name": "Box - Downloaded data volume per user", "query": "BoxEvents\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'DOWNLOAD'\n| summarize ['DataVolume(Bytes)'] = sum(FileSize) by SrcUserName\n| project SrcUserName, ['DataVolume(Bytes)']\n| order by ['DataVolume(Bytes)'] desc\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query shows downloaded data volume per user.'\n", "techniques": ["T1020", "T1119", "T1530"], "tactics": ["Exfiltration", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxUserGroupChanges.yaml", "query_name": "Box - New users", "query": "BoxEvents\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'GROUP_ADD_USER'\n| project TimeGenerated, SourceName, SourceLogin, AdditionalDetailsGroupName\n| extend AccountCustomEntity = SourceLogin\n", "attributes": {"description": "'Query shows user permissions(groups) changes.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxUsersWithOwnerPermissions.yaml", "query_name": "Box - Users with owner permissions", "query": "BoxEvents\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'COLLABORATION_ROLE_CHANGE'\n| where AdditionalDetailsRole =~ 'Owner'\n| project TimeGenerated, AccessibleByLogin, FileDirectory\n| extend AccountCustomEntity = AccessibleByLogin\n", "attributes": {"description": "'Query shows users with newly added owner permissions.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Box/Hunting%20Queries/BoxUserUploadsByVolume.yaml", "query_name": "Box - Uploaded data volume per user", "query": "BoxEvents\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'UPLOAD'\n| summarize ['DataVolume(Bytes)'] = sum(FileSize) by SrcUserName\n| project SrcUserName, ['DataVolume(Bytes)']\n| order by ['DataVolume(Bytes)'] desc\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query shows uploaded data volume per user.'\n", "techniques": ["T1530", "T1537"], "tactics": ["Exfiltration", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISEAdminPasswordReset.yaml", "query_name": "CiscoISE - ISE administrator password has been reset", "query": "let lbtime = 5m;\nCiscoISEEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId == '58019'\n| project TimeGenerated, SrcIpAddr, DstUserName\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when the ISE administrator password has been reset.'\n", "techniques": NaN, "tactics": ["InitialAccess", "Persistence", "PrivilegeEscalation", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISEAttempDeleteLocalStoreLogs.yaml", "query_name": "CiscoISE - Attempt to delete local store logs", "query": "let lbtime = 5m;\nCiscoISEEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId == '59103'\n| project TimeGenerated, DvcHostname, DvcIpAddr, DstUserName\n| extend HostCustomEntity = DvcHostname\n| extend IPCustomEntity = DvcIpAddr\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when attempt to delete local store logs failed.'\n", "techniques": NaN, "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISEBackupFailed.yaml", "query_name": "CiscoISE - Backup failed", "query": "let lbtime = 6h;\nCiscoISEEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('60095', '60098')\n| project TimeGenerated, DvcHostname, DvcIpAddr\n| extend HostCustomEntity = DvcHostname\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Detects when backup activity failed.'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISECertExpired.yaml", "query_name": "CiscoISE - Certificate has expired", "query": "let lbtime = 1h;\nCiscoISEEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId == '60167'\n| project SrcIpAddr, DvcIpAddr, DvcHostname, DstUserName\n| extend HostCustomEntity = DvcHostname\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects certificate expiration.'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISECmdExecutionWithHighestPrivilegesNewIP.yaml", "query_name": "CiscoISE -  Command executed with the highest privileges from new IP", "query": "let lbperiod = 60d;\nlet lbtime = 15m;\nlet knownAdminIpList =\nCiscoISEEvent\n| where TimeGenerated between (ago(lbperiod) .. ago(lbtime))\n| where PrivilegeLevel == '15'\n| summarize makelist(SrcIpAddr)\n;\nCiscoISEEvent\n| where TimeGenerated > ago(lbtime)\n| where PrivilegeLevel == '15'\n| where SrcIpAddr !in (knownAdminIpList)\n| project TimeGenerated, SrcIpAddr, DstIpAddr, DstUserName, CmdSet\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects command execution with PrivilegeLevel - 15 from new source.'\n", "techniques": NaN, "tactics": ["InitialAccess", "Persistence", "PrivilegeEscalation", "DefenseEvasion", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISECmdExecutionWithHighestPrivilegesNewUser.yaml", "query_name": "CiscoISE - Command executed with the highest privileges by new user", "query": "let lbperiod = 60d;\nlet lbtime = 15m;\nlet knownPrivUsers =\nCiscoISEEvent\n| where TimeGenerated between (ago(lbperiod) .. ago(lbtime))\n| where PrivilegeLevel == '15'\n| summarize makelist(DstUserName)\n;\nCiscoISEEvent\n| where TimeGenerated > ago(lbtime)\n| where PrivilegeLevel == '15'\n| where DstUserName !in (knownPrivUsers)\n| project TimeGenerated, SrcIpAddr, DstIpAddr, DstUserName, CmdSet\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects command execution with PrivilegeLevel - 15 by user for wich there was no such activity detected earlier.'\n", "techniques": NaN, "tactics": ["InitialAccess", "Persistence", "PrivilegeEscalation", "DefenseEvasion", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISEDeviceChangedIP.yaml", "query_name": "CiscoISE - Device changed IP in last 24 hours", "query": "let lbtime_48h = 48h;\nlet lbtime_24h = 24h;\nCiscoISEEvent\n| where TimeGenerated between (ago(lbtime_48h) .. ago(lbtime_24h))\n| where notempty(DvcIpAddr) and notempty(DvcHostname)\n| summarize knownIPs = make_set(DvcIpAddr) by DvcHostname\n| join (CiscoISEEvent\n      | where TimeGenerated > ago(lbtime_24h)\n      | where notempty(DvcIpAddr) and notempty(DvcHostname)\n      | summarize evts = count() by DvcHostname, DvcIpAddr\n      | project-away evts) on DvcHostname\n| project-away DvcHostname1\n| where knownIPs !contains DvcIpAddr\n| extend HostCustomEntity = DvcHostname\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Detects when device changes IP address in last 24 hours.'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISEDevicePostureStatusChanged.yaml", "query_name": "CiscoISE - Device PostureStatus changed to non-compliant", "query": "let lbtime_48h = 48h;\nlet lbtime_24h = 24h;\nlet lbtime_now = now();\nlet compliantIPs = CiscoISEEvent\n| where TimeGenerated between (ago(lbtime_48h) .. ago(lbtime_24h))\n| where PostureStatus == 'Compliant'\n| summarize makelist(DstIpAddr)\n;\nCiscoISEEvent\n| where TimeGenerated between (ago(lbtime_24h) .. lbtime_now)\n| where PostureStatus != 'Compliant'\n| where DstIpAddr in (compliantIPs)\n| project DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects when device changes PostureStatus from \"Compliant\".'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISELogCollectorSuspended.yaml", "query_name": "CiscoISE - Log collector was suspended", "query": "let lbtime = 10m;\nCiscoISEEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId == '59207'\n| project TimeGenerated, SrcIpAddr, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects when log collector was suspended.'\n", "techniques": NaN, "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Analytic%20Rules/CiscoISELogsDeleted.yaml", "query_name": "CiscoISE - Log files deleted", "query": "let lbtime = 5m;\nCiscoISEEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('58015', '59101', '59102')\n| project TimeGenerated, DvcHostname, DvcIpAddr, DstUserName\n| extend HostCustomEntity = DvcHostname\n| extend IPCustomEntity = DvcIpAddr\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects log file deleting activity.'\n", "techniques": NaN, "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISEAuthenticationToSuspendedAccount.yaml", "query_name": "CiscoISE - Authentication attempts to suspended user account", "query": "CiscoISEEvent\n| where TimeGenerated > ago(24h)\n| where EventId == '86014'\n| extend AccountCustomEntity = DstUserName", "attributes": {"description": "'Search authentication attempts to suspended user account.'\n", "techniques": NaN, "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISEDynamicAuthorizationFailed.yaml", "query_name": "CiscoISE - Dynamic authorization failed", "query": "let threshold = 10;\nCiscoISEEvent\n| where TimeGenerated > ago(24h)\n| where EventId == '5417'\n| summarize TotalEvents = count() by SrcIpAddr\n| where TotalEvents > threshold", "attributes": {"description": "'Search for dynamic authorization failed events.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISEExpiredCertInClientCertChain.yaml", "query_name": "CiscoISE - Expired certificate in the client certificates chain", "query": "CiscoISEEvent\n| where TimeGenerated > ago(24h)\n| where EventId == '12516'\n| extend IPCustomEntity = SrcIpAddr", "attributes": {"description": "'Search for expired certificates in the client certificates chain.'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISEFailedAuthentication.yaml", "query_name": "CiscoISE - Failed authentication events", "query": "CiscoISEEvent\n| where TimeGenerated > ago(24h)\n| where EventId in ('5400', '5401', '5412', '12508', '12514', '12516')\n| summarize count() by DstUserName\n| sort by count_", "attributes": {"description": "'Search for failed authentication events.'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISEFailedLoginsSSHCLI.yaml", "query_name": "CiscoISE - Failed login attempts via SSH CLI (users)", "query": "CiscoISEEvent\n| where TimeGenerated > ago(24h)\n| where EventId in ('60081', '60082')\n| summarize TotalEvents = count() by DstUserName\n| sort by TotalEvents", "attributes": {"description": "'Search for Failed login attempts via SSH CLI users.'\n", "techniques": NaN, "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISEGuestAuthenticationFailed.yaml", "query_name": "CiscoISE - Guest authentication failed", "query": "CiscoISEEvent\n| where TimeGenerated > ago(24h)\n| where EventId in ('86009', '86010', '86011', '86012', '86013', '86014', '86015', '86016', '86017', '86018', '86019', '86020')\n| project TimeGenerated, DstUserName, SrcIpAddr, DstIpAddr", "attributes": {"description": "'Search Guest authentication failed events.'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISEGuestAuthenticationSuccess.yaml", "query_name": "CiscoISE - Guest authentication succeeded", "query": "CiscoISEEvent\n| where TimeGenerated > ago(24h)\n| where EventId in ('5231', '5236')\n| project TimeGenerated, DstUserName, SrcIpAddr, DstIpAddr\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr", "attributes": {"description": "'Search for successful Guest authentication events.'\n", "techniques": NaN, "tactics": ["InitialAccess", "Persistence", "PrivilegeEscalation", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISERareUserAgent.yaml", "query_name": "CiscoISE - Rare or new useragent", "query": "let dt_lookBackPeriod = 30d;\nlet dt_lookBackTime = 24h;\nlet knownUserAgents =\nCiscoISEEvent \n| where TimeGenerated between (ago(dt_lookBackPeriod) .. ago(dt_lookBackTime))\n| where HttpUserAgentOriginal != ''\n| summarize makelist(HttpUserAgentOriginal)\n;\nCiscoISEEvent\n| where TimeGenerated > ago(dt_lookBackTime)\n| where HttpUserAgentOriginal !in (knownUserAgents)\n| summarize EventCount = count() by HttpUserAgentOriginal\n| project-away EventCount", "attributes": {"description": "'Search for rare useragent values.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISESourceHighNumberAuthenticationErrors.yaml", "query_name": "CiscoISE - Sources with high number of 'Failed Authentication' events", "query": "let threshold = 10;\nCiscoISEEvent\n| where TimeGenerated > ago(24h)\n| where EventId in ('5400', '5401')\n| summarize TotalEvents = count() by SrcIpAddr\n| where TotalEvents > threshold\n| project SrcIpAddr, TotalEvents", "attributes": {"description": "'Search sources with high number of Failed Authentication events.'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20ISE/Hunting%20Queries/CiscoISESuspendLogCollector.yaml", "query_name": "CiscoISE - Attempts to suspend the log collector", "query": "CiscoISEEvent\n| where TimeGenerated > ago(24h)\n| where EventId in ('59206', '59208')\n| extend IPCustomEntity = SrcIpAddr", "attributes": {"description": "'Search for attempts to suspend the log collector.'\n", "techniques": NaN, "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoEndpointHighAlert.yaml", "query_name": "Cisco SE High Events Last Hour", "query": "let endtime = 1h;\nCiscoSecureEndpoint_CL\n| where TimeGenerated >= ago(endtime)\n| where severity_s == \"High\"\n| project NetworkAddresses = parse_json(computer_network_addresses_s), computer_hostname_s, date_t, event_type_s, computer_links_trajectory_s\n| summarize CountInLastHour = count() by computer_hostname_s, date_t, event_type_s, tostring(NetworkAddresses.ip), computer_links_trajectory_s\n", "attributes": {"description": "'Find events from Cisco Secure Endpoint that are of High severity in the last hour.'\n", "techniques": NaN, "tactics": ["Execution", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSEC2Connection.yaml", "query_name": "Cisco SE - Connection to known C2 server", "query": "CiscoSecureEndpoint\n| where EventMessage has 'Suspected botnet connection'\n| extend HostCustomEntity = DstHostname, MalwareCustomEntity = ThreatName\n", "attributes": {"description": "'This rule is triggered when connection to known C2 is detected from host.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSEDropperActivity.yaml", "query_name": "Cisco SE - Dropper activity on host", "query": "CiscoSecureEndpoint\n| where EventMessage has 'Potential Dropper Infection'\n| extend HostCustomEntity = DstHostname, MalwareCustomEntity = ThreatName\n", "attributes": {"description": "'Detects possible dropper activity on host.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSEGenIoC.yaml", "query_name": "Cisco SE - Generic IOC", "query": "CiscoSecureEndpoint\n| where EventMessage has 'Generic IOC'\n| extend HostCustomEntity = DstHostname, MalwareCustomEntity = ThreatName\n", "attributes": {"description": "'This rule is triggered when generic IOC is observed on host.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSEMalwareExecution.yaml", "query_name": "Cisco SE - Malware execusion on host", "query": "CiscoSecureEndpoint\n| where EventMessage has 'Executed Malware'\n| extend HostCustomEntity = DstHostname, MalwareCustomEntity = ThreatName\n", "attributes": {"description": "'Detects malware execution on host.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSEMalwareOutbreak.yaml", "query_name": "Cisco SE - Malware outbreak", "query": "let threshold = 2;\nCiscoSecureEndpoint\n| where isnotempty(ThreatName)\n| summarize infected = makeset(DstHostname) by ThreatName, bin(TimeGenerated, 10m)\n| where array_length(infected) >= threshold\n| extend MalwareCustomEntity = ThreatName\n", "attributes": {"description": "'Detects possible malware outbreak.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSEMultipleMalwareOnHost.yaml", "query_name": "Cisco SE - Multiple malware on host", "query": "let threshold = 2;\nCiscoSecureEndpoint\n| where isnotempty(ThreatName)\n| summarize infected = makeset(ThreatName) by DstHostname, bin(TimeGenerated, 10m)\n| where array_length(infected) >= threshold\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'This rule triggers when multiple malware where detected on host.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSEPolicyUpdateFailure.yaml", "query_name": "Cisco SE - Policy update failure", "query": "CiscoSecureEndpoint\n| where EventMessage =~ 'Policy Update Failure'\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Detects policy updates failures.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSERansomwareActivityOnHost%20copy.yaml", "query_name": "Cisco SE - Ransomware Activity", "query": "CiscoSecureEndpoint\n| where EventMessage has 'Suspected ransomware'\n| extend HostCustomEntity = DstHostname, MalwareCustomEntity = ThreatName\n", "attributes": {"description": "'This rule is triggered when possible ransomware activity is detected on host.'\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSEUnexpectedBinary.yaml", "query_name": "Cisco SE - Unexpected binary file", "query": "CiscoSecureEndpoint\n| where isnotempty(SrcFileName)\n| where SrcFilePath contains @'AppData\\Local\\Temp' or SrcFilePath contains @'OUTLOOK_TEMP'\n| extend ext = extract(@\"(.*\\/)?(.*)\", 2, tostring(SrcFilePath))\n| where ext contains 'dll' or ext contains @'ps1' or ext contains @'exe'\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Detects binary files in uncommon locations.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Analytic%20Rules/CiscoSEWebshell.yaml", "query_name": "Cisco SE - Possible webshell", "query": "CiscoSecureEndpoint\n| where EventMessage has 'Possible webshell'\n| extend HostCustomEntity = DstHostname, MalwareCustomEntity = ThreatName\n", "attributes": {"description": "'Detects possible webshell on host.'\n", "techniques": ["T1102"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSEInfectedHosts.yaml", "query_name": "Cisco SE - Infected hosts", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where isnotempty(ThreatName)\n| order by TimeGenerated desc\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for infected hosts.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSEInfectedUsers.yaml", "query_name": "Cisco SE - Infected users", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where isnotempty(ThreatName)\n| order by TimeGenerated desc\n| extend AccountCustomEntity = User\n", "attributes": {"description": "'Query searches for infected users.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSELoginsToConsole.yaml", "query_name": "Cisco SE - User Logins", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where EventSubType =~ 'User'\n| where EventMessage =~ 'login'\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for user logins to management console.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSEMaliciousFiles.yaml", "query_name": "Cisco SE - Malicious files", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where IndicatorThreatType =~ 'Malicious'\n| order by TimeGenerated desc\n| extend FileCustomEntity = SrcFileName, HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for milicious files.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSEModifiedAgent.yaml", "query_name": "Cisco SE - Modified agents on hosts", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where EventSubType =~ 'Agent'\n| where EventMessage !~ 'create'\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for hosts with modified aggent settings.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSERareFilesScanned.yaml", "query_name": "Cisco SE - Rare scanned files", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'Scan Started'\n| summarize count() by SrcFileName\n| top 20 by count_ asc\n| extend FileCustomEntity = SrcFileName\n", "attributes": {"description": "'Query searches for rare scanned files.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSEScannedFiles.yaml", "query_name": "Cisco SE - Scanned files", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'Scan Started'\n| order by TimeGenerated desc\n| extend FileCustomEntity = SrcFileName\n", "attributes": {"description": "'Query searches for scanned files.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSESuspiciousPSDownloads.yaml", "query_name": "Cisco SE - Suspicious powershel downloads", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where ThreatName has 'PowerShell Download String'\n| order by TimeGenerated desc\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for suspicious powershell downloads.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSEUncommonApplicationBehavior.yaml", "query_name": "Cisco SE - Uncommon application behavior", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where ThreatName has 'launched a shell'\n| order by TimeGenerated desc\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for uncommon application behavior events.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cisco%20Secure%20Endpoint/Hunting%20Queries/CiscoSEVulnerableApplications.yaml", "query_name": "Cisco SE - Vulnerable applications", "query": "CiscoSecureEndpoint\n| where TimeGenerated > ago(24h)\n| where EventMessage =~ 'Vulnerable Application Detected'\n| summarize by DstHostname\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for volnerable applications on hosts.'\n", "techniques": ["T1204.002"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoASA/Analytic%20Rules/CiscoASA-AvgAttackDetectRateIncrease.yaml", "query_name": "Cisco ASA - average attack detection rate increase", "query": "\nlet timeframe = 1h;\nlet last1h = CommonSecurityLog \n| where TimeGenerated >= ago(timeframe)\n| where isempty(CommunicationDirection) \n| where DeviceEventClassID == \"733100\"\n| extend SourceOfDropRateCount = tostring(split(tostring(split(Message, \"]\")[0]),\"[ \")[1])\n| extend splitMessage = split(Message, \".\")\n| extend DropRate = tostring(split(tostring(splitMessage[0]),\"] \")[1])\n| extend CurrentBurstRate = split(tostring(split(tostring(splitMessage[1]),\"  \")[0]),\"is \")\n| extend CurrentBurstRatePerSec = toint(split(tostring(CurrentBurstRate[1]),\" \")[0])\n| extend MaxConfiguredBurstRate = toint(CurrentBurstRate[2])\n| extend CurrentAvgRate = split(tostring(split(tostring(splitMessage[1]),\"  \")[1]),\"is \")\n| extend CurrentAvgRatePerSec = toint(split(tostring(CurrentAvgRate[1]),\" \")[0])\n| extend MaxConfiguredAvgRate = toint(CurrentAvgRate[2])\n| extend CumulativeTotal = toint(split(tostring(split(tostring(splitMessage[1]),\"  \")[2]),\"is \")[1])\n| summarize last1hCumTotal = sum(CumulativeTotal), last1hAvgRatePerSec = avg(CurrentAvgRatePerSec), last1hAvgBurstRatePerSec = avg(CurrentBurstRatePerSec) by DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate;\nlet prev6h = CommonSecurityLog \n| where TimeGenerated between (ago(6h) .. ago(1h))\n| where isempty(CommunicationDirection) \n| where DeviceEventClassID == \"733100\"\n| extend SourceOfDropRateCount = tostring(split(tostring(split(Message, \"]\")[0]),\"[ \")[1])\n| extend splitMessage = split(Message, \".\")\n| extend DropRate = tostring(split(tostring(splitMessage[0]),\"] \")[1])\n| extend CurrentBurstRate = split(tostring(split(tostring(splitMessage[1]),\"  \")[0]),\"is \")\n| extend prevCurrentBurstRatePerSec = toint(split(tostring(CurrentBurstRate[1]),\" \")[0])\n| extend prevMaxConfiguredBurstRate = toint(CurrentBurstRate[2])\n| extend CurrentAvgRate = split(tostring(split(tostring(splitMessage[1]),\"  \")[1]),\"is \")\n| extend prevCurrentAvgRatePerSec = toint(split(tostring(CurrentAvgRate[1]),\" \")[0])\n| extend prevMaxConfiguredAvgRate = toint(CurrentAvgRate[2])\n| extend prevCumulativeTotal = toint(split(tostring(split(tostring(splitMessage[1]),\"  \")[2]),\"is \")[1])\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), prev6hCumTotal = sum(prevCumulativeTotal), prev6hAvgRatePerSec = avg(prevCurrentAvgRatePerSec), prev6hAvgBurstRatePerSec = avg(prevCurrentBurstRatePerSec) \nby DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate;\nlast1h | join (\n  prev6h \n) on DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate\n| project StartTimeUtc, EndTimeUtc, DeviceName, DeviceEventClassID, SourceIP, SourceOfDropRateCount, DropRate, last1hCumTotal, prev6hCumTotal, prev6hAvgCumTotal = prev6hCumTotal/6, last1hAvgRatePerSec, prev6hAvgRatePerSec, last1hAvgBurstRatePerSec, prev6hAvgBurstRatePerSec\n// Select only events that indicate a doubling of the expected rate in the last hour over the previous 6 hours\n| where last1hCumTotal > 2*prev6hAvgCumTotal or last1hAvgRatePerSec > 2*prev6hAvgRatePerSec or last1hAvgBurstRatePerSec > 2*prev6hAvgBurstRatePerSec\n| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName\n", "attributes": {"description": "'This will help you determine if Cisco ASA devices are under heavier attack than normal over the last hour versus the previous 6 hours based on DeviceEventClassID 733100\nReferences: https://www.cisco.com/c/en/us/td/docs/security/asa/syslog/b_syslog/syslogs9.html\nDetails on how to further troubleshoot/investigate: https://www.cisco.com/c/en/us/support/docs/security/asa-5500-x-series-next-generation-firewalls/113685-asa-threat-detection.html'\n", "techniques": ["T1046", "T1498"], "tactics": ["Discovery", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoASA/Analytic%20Rules/CiscoASA-ThreatDetectionMessage.yaml", "query_name": "Cisco ASA - threat detection message fired", "query": "\nCommonSecurityLog \n| where isempty(CommunicationDirection) \n| where DeviceEventClassID in (\"733101\",\"733102\",\"733103\",\"733104\",\"733105\")\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName\n", "attributes": {"description": "'Identifies when the Cisco ASA Threat Detection engine fired an alert based on malicious activity occurring on the network inicated by DeviceEventClassID 733101-733105\nResources: https://www.cisco.com/c/en/us/td/docs/security/asa/syslog/b_syslog/syslogs9.html\nDetails on how to further troubleshoot/investigate: https://www.cisco.com/c/en/us/support/docs/security/asa-5500-x-series-next-generation-firewalls/113685-asa-threat-detection.html'\n", "techniques": ["T1046", "T1498"], "tactics": ["Discovery", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoAdminDeleted.yaml", "query_name": "Cisco Duo - Admin user deleted", "query": "CiscoDuo\n| where DvcAction =~ \"admin_delete\"\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when admin user is deleted.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoAdminMFAFailures.yaml", "query_name": "Cisco Duo - Multiple admin 2FA failures", "query": "let threshold = 10;\nCiscoDuo\n| where DvcAction =~ \"admin_2fa_error\"\n| summarize count() by DstUserName, bin(TimeGenerated, 10m)\n| where count_ > threshold\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when multiple admin 2FA failures occurs.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoAdminPasswordReset.yaml", "query_name": "Cisco Duo - Admin password reset", "query": "CiscoDuo\n| where DvcAction =~ \"admin_reset_password\"\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when admin's password was reset.'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoADSyncFailed.yaml", "query_name": "Cisco Duo - AD sync failed", "query": "CiscoDuo\n| where DvcAction =~ \"ad_sync_failed\"\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when AD syncronization failed.'\n", "techniques": ["T1489"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoMultipleUserLoginFailures.yaml", "query_name": "Cisco Duo - Multiple user login failures", "query": "let threshold = 10;\nCiscoDuo\n| where EventType =~ 'authentication'\n| where EventResult in~ ('denied', 'failure')\n| summarize count() by DstUserName, bin(TimeGenerated, 10m)\n| where count_ > threshold\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when multiple user login failures occurs.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoMultipleUsersDeleted.yaml", "query_name": "Cisco Duo - Multiple users deleted", "query": "CiscoDuo\n| where DvcAction =~ \"user_delete\"\n| summarize count() by DstUserName, bin(TimeGenerated, 10m)\n| where count_ > 1\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when multiple users were deleted.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoNewAccessDevice.yaml", "query_name": "Cisco Duo - New access device", "query": "CiscoDuo\n| where EventType =~ 'authentication'\n| where EventResult =~ 'success'\n| where isnotempty(AccessDvcIpAddr)\n| summarize dvc_ip = makeset(AccessDvcIpAddr) by DstUserName\n| join (CiscoDuo\n        | where EventType =~ 'authentication'\n        | where EventResult =~ 'success') on DstUserName\n| where dvc_ip !has AccessDvcIpAddr\n| extend IPCustomEntity = AccessDvcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects new access device.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoNewAdmin.yaml", "query_name": "Cisco Duo - Admin user created", "query": "CiscoDuo\n| where DvcAction =~ \"admin_create\"\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when new admin user is created.'\n", "techniques": ["T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoNewAuthDeviceLocation.yaml", "query_name": "Cisco Duo - Authentication device new location", "query": "CiscoDuo\n| where EventType =~ 'authentication'\n| where EventResult =~ 'success'\n| where isnotempty(AuthDeviceCountry)\n| summarize src_c = makeset(AuthDeviceCountry) by SrcIpAddr\n| join (CiscoDuo\n        | where EventType =~ 'authentication'\n        | where EventResult =~ 'success') on SrcIpAddr\n| where src_c !has AuthDeviceCountry\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects new location of authentication device.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Analytic%20Rules/CiscoDuoUnexpectedAuthFactor.yaml", "query_name": "Cisco Duo - Unexpected authentication factor", "query": "let allowed_auth_f = dynamic(['duo_push', 'duo_mobile_passcode']);\nCiscoDuo\n| where EventType =~ 'authentication'\n| where EventResult =~ 'success'\n| where AuthFactor !in~ (allowed_auth_f)\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when unexpected authentication factor used.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoAdmin2FAFailure.yaml", "query_name": "Cisco Duo - Admin failure authentications", "query": "CiscoDuo\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ \"admin_2fa_error\"\n| project TimeGenerated, SrcIpAddr, DstUserName\n| extend AccountCustomEntity = DstUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for administrator issue completing secondary authentication.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoAdminDeleteActions.yaml", "query_name": "Cisco Duo - Delete actions", "query": "CiscoDuo\n| where TimeGenerated > ago(24h)\n| where DvcAction in~ ('activation_delete_link', 'admin_activation_delete', 'admin_delete', 'azure_directory_delete', 'bypass_delete', 'delete_child_customer', 'directory_delete', 'feature_delete', 'group_delete', 'hardtoken_delete', 'integration_delete', 'phone_delete', 'policy_delete', 'u2ftoken_delete', 'user_delete')\n| project TimeGenerated, SrcIpAddr, DstUserName, SrcUserName\n| extend AccountCustomEntity = SrcUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for delete actions performed by admin users.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoAdminFailure.yaml", "query_name": "Cisco Duo - Admin failure authentications", "query": "CiscoDuo\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ \"admin_login_error\"\n| project TimeGenerated, SrcIpAddr, DstUserName\n| extend AccountCustomEntity = DstUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches admin failure authentication events.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoAuthenticationErrorEvents.yaml", "query_name": "Cisco Duo - Authentication errors", "query": "CiscoDuo\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'authentication'\n| where EventResult =~ 'error'\n| project TimeGenerated, DstUserName, SrcIpAddr, EventResultDetails\n| extend AccountCustomEntity = DstUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for authentication errors.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoAuthenticationErrorReasons.yaml", "query_name": "Cisco Duo - Authentication error reasons", "query": "CiscoDuo\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'authentication'\n| where EventResult in~ ('denied', 'failure')\n| summarize count() by EventResultDetails, DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for authentication error reasons.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoDeletedUsers.yaml", "query_name": "Cisco Duo - Deleted users", "query": "CiscoDuo\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ \"user_delete\"\n| project TimeGenerated, SrcIpAddr, SrcUserName, DstUserName\n| extend AccountCustomEntity = SrcUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for deleted users.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoFraudAuthentication.yaml", "query_name": "Cisco Duo - Fraud authentications", "query": "CiscoDuo\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'authentication'\n| where EventResult =~ 'fraud'\n| project TimeGenerated, DstUserName, SrcIpAddr\n| extend AccountCustomEntity = DstUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for fraud authentication events.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoNewUsers.yaml", "query_name": "Cisco Duo - New users", "query": "CiscoDuo\n| where TimeGenerated > ago(24h)\n| where DvcAction == \"user_create\"\n| project TimeGenerated, SrcIpAddr, SrcUserName, DstUserName\n| extend AccountCustomEntity = SrcUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for new users created.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoUnpachedAccessDevices.yaml", "query_name": "Cisco Duo - Devices with vulnerable OS", "query": "let os_latest = 'x.x.xxx'; //put the latest version of OS here before running the query\nCiscoDuo\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'authentication'\n| where AccessDvcOsVersion != os_latest\n| project TimeGenerated, SrcIpAddr, DstUserName\n| extend AccountCustomEntity = DstUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for devices with vulnerable OS.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoDuoSecurity/Hunting%20Queries/CiscoDuoUnsecuredDevices.yaml", "query_name": "Cisco Duo - Devices with unsecure settings", "query": "CiscoDuo\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'authentication'\n| where  AccessDvcEncryptionEnabled == False or AccessDvcFirewallEnabled == False or AccessDvcPasswordSet == False\n| project TimeGenerated, SrcIpAddr, DstUserName\n| extend AccountCustomEntity = DstUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for devices with unsecure settings.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGDLPViolation.yaml", "query_name": "Cisco SEG - DLP policy violation", "query": "CiscoSEGEvent\n| where NetworkDirection =~ 'Outgoing'\n| where tostring(AdditionalFields) has 'ESADLPVerdict'\n| extend dlp_verdict = extract(@'ESADLPVerdict\":\"(NOT_EVALUATED|NO TRIGGER|VIOLATION|NO VIOLATION)\"', 1, tostring(AdditionalFields))\n| where dlp_verdict =~ 'VIOLATION'\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects DLP policy violation.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGMaliciousAttachmentNotBlocked.yaml", "query_name": "Cisco SEG - Malicious attachment not blocked", "query": "CiscoSEGEvent\n| where NetworkDirection =~ 'Incoming'\n| where SimplifiedDeviceAction =~ 'DELIVERED'\n| where tostring(AdditionalFields) has 'ESAAMPVerdict'\n| extend amp_verdict = extract(@'ESAAMPVerdict\":\"(NOT_EVALUATED|CLEAN|FA_PENDING|UNKNOWN|SKIPPED|UNSCANNABLE|LOW_RISK|MALICIOUS)\"', 1, tostring(AdditionalFields))\n| where amp_verdict =~ 'MALICIOUS'\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects mails with malicious attachments which were not blocked.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGMultipleLargeEmails.yaml", "query_name": "Cisco SEG - Multiple large emails sent to external recipient", "query": "let e_theshold = 3;\nlet s_threshold = 10000000;\nCiscoSEGEvent\n| where AdditionalFields[15]['ESAMsgSize'] > s_threshold\n| where NetworkDirection =~ 'Outgoing'\n| extend rec_domain = extract(@'@(.*)', 1, DstUserName)\n| extend s_domain = extract(@'@(.*)', 1, SrcUserName)\n| where s_domain != rec_domain\n| summarize count() by SrcUserName\n| where count_ >= e_theshold\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects possible data exfiltration.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGMultipleSuspiciousEmails.yaml", "query_name": "Cisco SEG - Multiple suspiciuos attachments received", "query": "let r_threshold = 5;\nCiscoSEGEvent\n| where NetworkDirection =~ 'Incoming'\n| where isnotempty(EventMessage)\n| where strlen(EventMessage) < 20\n| summarize rec=makeset(DstUserName) by EventMessage, bin(TimeGenerated, 10m)\n| where array_length(rec) > r_threshold\n| extend AccountCustomEntity = rec\n", "attributes": {"description": "'Detects possibly phishing emails.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGPossibleOutbreak.yaml", "query_name": "Cisco SEG - Possible outbreak", "query": "CiscoSEGEvent\n| where NetworkDirection =~ 'Incoming'\n| where tostring(AdditionalFields) has 'ESAOFVerdict'\n| extend of_verdict = extract(@'ESAOFVerdict\":\"(NOT_EVALUATED|POSITIVE|NEGATIVE)\"', 1, tostring(AdditionalFields))\n| where of_verdict =~ 'POSITIVE'\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects possible outbreak activity.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGPotentialLinkToMalwareDownload.yaml", "query_name": "Cisco SEG - Potential phishing link", "query": "let dl_cat = dynamic(['Illegal Downloads']);\nCiscoSEGEvent\n| where NetworkDirection =~ 'Incoming'\n| where tostring(AdditionalFields) has 'ESAURLDetails'\n| extend link_cat = extract(@\"'Category': '(.*?)'\", 1, tostring(AdditionalFields))\n| where link_cat in~ (dl_cat)\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects mails with suspicious links.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGSuspiciousLink.yaml", "query_name": "Cisco SEG - Suspicious link", "query": "let bl_cat = dynamic(['Adult', 'Hacking', 'Cheating and Plagiarism', 'Child Abuse Content', 'Dating', 'Illegal Activities', 'Pornography']);\nCiscoSEGEvent\n| where NetworkDirection =~ 'Incoming'\n| where tostring(AdditionalFields) has 'ESAURLDetails'\n| extend link_cat = extract(@\"'Category': '(.*?)'\", 1, tostring(AdditionalFields))\n| where link_cat in~ (bl_cat)\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects mails with suspicious links.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGSuspiciousSenderDomain.yaml", "query_name": "Cisco SEG - Suspicious sender domain", "query": "CiscoSEGEvent\n| where NetworkDirection =~ 'Incoming'\n| extend rec_domain = extract(@'@(.*)', 1, DstUserName)\n| extend s_domain = extract(@'@(.*)', 1, SrcUserName)\n| where s_domain != rec_domain\n| where tostring(AdditionalFields) has 'ESASDRDomainAge'\n| extend domain_age = extract(@'ESASDRDomainAge\":\"(.*days)\"', 1, tostring(AdditionalFields))\n| extend yy = toint(extract(@'(\\d+)\\syears', 1, domain_age))\n| extend mm = toint(extract(@'(\\d+)\\smonths', 1, domain_age))\n| extend dd = toint(extract(@'(\\d+)\\sdays', 1, domain_age))\n| where isempty(yy)\n| where isempty(mm) or mm <= 2\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects suspicious sender domain age.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGUnclassifiedLink.yaml", "query_name": "Cisco SEG - Unexpected link", "query": "let u_cat = dynamic(['Unclassified']);\nCiscoSEGEvent\n| where NetworkDirection =~ 'Incoming'\n| where tostring(AdditionalFields) has 'ESAURLDetails'\n| extend link_cat = extract(@\"'Category': '(.*?)'\", 1, tostring(AdditionalFields))\n| where link_cat in~ (u_cat)\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects mails with suspicious links.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGUnexpextedAttachment.yaml", "query_name": "Cisco SEG - Unexpected attachment", "query": "CiscoSEGEvent\n| where NetworkDirection =~ 'Incoming'\n| where tostring(AdditionalFields) has 'ESAAttachmentDetails'\n| extend attachment = replace_string(tostring(extract(@'\"ESAAttachmentDetails\":\"{(.*?):', 1, tostring(AdditionalFields))), \"'\", \"\")\n| where attachment endswith '.ps1' or attachment endswith '.lnk' or attachment endswith '.exe'\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects possibly malicious attachments.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Analytic%20Rules/CiscoSEGUnscannableAttachment.yaml", "query_name": "Cisco SEG - Unscannable attacment", "query": "CiscoSEGEvent\n| where NetworkDirection =~ 'Incoming'\n| where tostring(AdditionalFields) has 'ESAAMPVerdict'\n| extend amp_verdict = extract(@'ESAAMPVerdict\":\"(NOT_EVALUATED|CLEAN|FA_PENDING|UNKNOWN|SKIPPED|UNSCANNABLE|LOW_RISK|MALICIOUS)\"', 1, tostring(AdditionalFields))\n| where amp_verdict =~ 'UNSCANNABLE'\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects unscannable attachments in mails.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGDroppedInMails.yaml", "query_name": "Cisco SEG - Dropped incoming mails", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where NetworkDirection =~ 'Incoming'\n| where SimplifiedDeviceAction =~ 'DROPPED'\n| summarize count() by DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for dropped mails.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGDroppedOutMails.yaml", "query_name": "Cisco SEG - Dropped outgoing mails", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where NetworkDirection =~ 'Outgoing'\n| where SimplifiedDeviceAction =~ 'DROPPED'\n| summarize count() by SrcUserName\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for dropped outgoing mails.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGFailedDKIMFailure.yaml", "query_name": "Cisco SEG - DKIM failures", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where tostring(AdditionalFields) has 'ESADKIMVerdict'\n| extend dkim_status = extract(@'ESADKIMVerdict\":\"(Pass|Neutral|TempError|PermError|HardFail|None)\"', 1, tostring(AdditionalFields))\n| where dkim_status in~ ('PermError', 'HardFail', 'None')\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for mails with DKIM failure status.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGFailedDMARKFailure.yaml", "query_name": "Cisco SEG - DMARK failures", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where tostring(AdditionalFields) has 'ESADMARCVerdict'\n| extend dmark_status = extract(@'ESADMARCVerdict\":\"(PermFailure|TempFailure|Reject|Success)\"', 1, tostring(AdditionalFields))\n| where dmark_status in~ ('PermFailure', 'TempFailure', 'Reject')\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for mails with DMARK failure status.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGFailedSPFFailure.yaml", "query_name": "Cisco SEG - SPF failures", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where tostring(AdditionalFields) has 'ESASPFVerdict'\n| extend spf_status = extract(@'ESASPFVerdict\":\"(Pass|Neutral|SoftFail|Fail|TempError|PermError)\"', 1, tostring(AdditionalFields))\n| where spf_status in~ ('Fail', 'TempError', 'PermError')\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for mails with SPF failure status.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGFailedTLSIn.yaml", "query_name": "Cisco SEG - Failed incoming TLS connections", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where tostring(AdditionalFields) has 'ESATLSInConnStatus'\n| extend tls_status = extract(@'ESATLSInConnStatus\":\"(Success|Failure)\"', 1, tostring(AdditionalFields))\n| where tls_status =~ 'Failure'\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches failed TLS incoming connections.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGFailedTLSOut.yaml", "query_name": "Cisco SEG - Failed outgoing TLS connections", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where tostring(AdditionalFields) has 'ESATLSOutConnStatus'\n| extend tls_status = extract(@'ESATLSOutConnStatus\":\"(Success|Failure)\"', 1, tostring(AdditionalFields))\n| where tls_status =~ 'Failure'\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches failed TLS outgoing connections.'\n", "techniques": ["T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGInsecureProtocol.yaml", "query_name": "Cisco SEG - Insecure protocol", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where tostring(AdditionalFields) has 'ESATLSOutProtocol'\n| extend tls_status = extract(@'ESATLSOutProtocol\":\"(.*?)\"', 1, tostring(AdditionalFields))\n| where dlp_verdict != 'TLSv1.2'\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for connections with insecure protocol.'\n", "techniques": ["T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGSpamMails.yaml", "query_name": "Cisco SEG - Sources of spam mails", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where NetworkDirection =~ 'Incoming'\n| where SimplifiedDeviceAction =~ 'QUARANTINED'\n| extend act_det = extract(@'ESAFinalActionDetails\":\"(.*?)\"', 1, tostring(AdditionalFields))\n| where act_det has 'To SPAM'\n| summarize count by SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for sources of spam mails.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoSEG/Hunting%20Queries/CiscoSEGUsersReceivedSpam.yaml", "query_name": "Cisco SEG - Top users receiving spam mails", "query": "CiscoSEGEvent\n| where TimeGenerated > ago(24h)\n| where NetworkDirection =~ 'Incoming'\n| where SimplifiedDeviceAction =~ 'QUARANTINED'\n| extend act_det = extract(@'ESAFinalActionDetails\":\"(.*?)\"', 1, tostring(AdditionalFields))\n| where act_det has 'To SPAM'\n| summarize count by DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for top users receiving spam mails.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaConnectionNon-CorporatePrivateNetwork.yaml", "query_name": "Cisco Umbrella - Connection to non-corporate private network", "query": "let lbtime = 10m;\nCisco_Umbrella\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'proxylogs'\n| where DvcAction =~ 'Allowed'\n| where UrlCategory has_any ('Dynamic and Residential', 'Personal VPN')\n| project TimeGenerated, SrcIpAddr, Identities\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = Identities\n", "attributes": {"description": "'IP addresses of broadband links that usually indicates users attempting to access their home network, for example for a remote session to a home computer.'\n", "techniques": NaN, "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaConnectionToUnpopularWebsiteDetected.yaml", "query_name": "Cisco Umbrella - Connection to Unpopular Website Detected", "query": "let domain_lookBack= 14d;\nlet timeframe = 1d;\nlet top_million_list = Cisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(domain_lookBack) and TimeGenerated < ago(timeframe)\n| extend Hostname = parse_url(UrlOriginal)[\"Host\"]\n| summarize count() by tostring(Hostname)\n| top 1000000 by count_\n| summarize make_list(Hostname);\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| extend Hostname = parse_url(UrlOriginal)[\"Host\"]\n| where Hostname !in (top_million_list)\n| extend Message = \"Connect to unpopular website (possible malicious payload delivery)\"\n| project Message, SrcIpAddr, DstIpAddr,UrlOriginal, TimeGenerated\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects first connection to an unpopular website (possible malicious payload delivery).'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaCryptoMinerUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Crypto Miner User-Agent Detected", "query": "let timeframe = 15m;\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal contains \"XMRig\" or HttpUserAgentOriginal contains \"ccminer\"\n| extend Message = \"Crypto Miner User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated,HttpUserAgentOriginal\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects suspicious user agent strings used by crypto miners in proxy logs.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaEmptyUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Empty User Agent Detected", "query": "let timeframe = 15m;\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal == ''\n| extend Message = \"Empty User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Rule helps to detect empty and unusual user agent indicating web browsing activity by an unusual process other than a web browser.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaHackToolUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Hack Tool User-Agent Detected", "query": "let timeframe = 15m;\nlet user_agents=dynamic([\n                          '(hydra)',\n                          ' arachni/',\n                          ' BFAC ',\n                          ' brutus ',\n                          ' cgichk ',\n                          'core-project/1.0',\n                          ' crimscanner/',\n                          'datacha0s',\n                          'dirbuster',\n                          'domino hunter',\n                          'dotdotpwn',\n                          'FHScan Core',\n                          'floodgate',\n                          'get-minimal',\n                          'gootkit auto-rooter scanner',\n                          'grendel-scan',\n                          ' inspath ',\n                          'internet ninja',\n                          'jaascois',\n                          ' zmeu ',\n                          'masscan',\n                          ' metis ',\n                          'morfeus fucking scanner',\n                          'n-stealth',\n                          'nsauditor',\n                          'pmafind',\n                          'security scan',\n                          'springenwerk',\n                          'teh forest lobster',\n                          'toata dragostea',\n                          ' vega/',\n                          'voideye',\n                          'webshag',\n                          'webvulnscan',\n                          ' whcc/',\n                          ' Havij',\n                          'absinthe',\n                          'bsqlbf',\n                          'mysqloit',\n                          'pangolin',\n                          'sql power injector',\n                          'sqlmap',\n                          'sqlninja',\n                          'uil2pn',\n                          'ruler',\n                          'Mozilla/5.0 (Windows; U; Windows NT 5.1; pt-PT; rv:1.9.1.2) Gecko/20090729 Firefox/3.5.2 (.NET CLR 3.5.30729)'\n                          ]);\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal has_any (user_agents)\n| extend Message = \"Hack Tool User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated, HttpUserAgentOriginal\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects suspicious user agent strings used by known hack tools'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaPowershellUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Windows PowerShell User-Agent Detected", "query": "let timeframe = 15m;\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal contains \"WindowsPowerShell\"\n| extend Message = \"Windows PowerShell User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated,HttpUserAgentOriginal\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Rule helps to detect Powershell user-agent activity by an unusual process other than a web browser.'\n", "techniques": NaN, "tactics": ["CommandAndControl", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaRareUserAgentDetected.yaml", "query_name": "Cisco Umbrella - Rare User Agent Detected", "query": "let lookBack = 14d;\nlet timeframe = 1d;\nlet user_agents_list = Cisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(lookBack) and TimeGenerated < ago(timeframe)\n| summarize count() by HttpUserAgentOriginal\n| summarize make_list(HttpUserAgentOriginal);\nCisco_Umbrella\n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| where HttpUserAgentOriginal !in (user_agents_list)\n| extend Message = \"Rare User Agent\"\n| project Message, SrcIpAddr, DstIpAddr, UrlOriginal, TimeGenerated, HttpUserAgentOriginal\n| extend IpCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Rule helps to detect a rare user-agents indicating web browsing activity by an unusual process other than a web browser.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaRequestAllowedHarmfulMaliciousURICategory.yaml", "query_name": "Cisco Umbrella - Request Allowed to harmful/malicious URI category", "query": "let lbtime = 10m;\nCisco_Umbrella\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'proxylogs'\n| where DvcAction =~ 'Allowed'\n| where UrlCategory contains 'Adult Themes' or\n      UrlCategory contains 'Adware' or\n      UrlCategory contains 'Alcohol' or\n      UrlCategory contains 'Illegal Downloads' or\n      UrlCategory contains 'Drugs' or\n      UrlCategory contains 'Child Abuse Content' or\n      UrlCategory contains 'Hate/Discrimination' or\n      UrlCategory contains 'Nudity' or\n      UrlCategory contains 'Pornography' or\n      UrlCategory contains 'Proxy/Anonymizer' or\n      UrlCategory contains 'Sexuality' or\n      UrlCategory contains 'Tasteless' or\n      UrlCategory contains 'Terrorism' or\n      UrlCategory contains 'Web Spam' or\n      UrlCategory contains 'German Youth Protection' or\n      UrlCategory contains 'Illegal Activities' or\n      UrlCategory contains 'Lingerie/Bikini' or\n      UrlCategory contains 'Weapons'\n| project TimeGenerated, SrcIpAddr, Identities\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = Identities\n", "attributes": {"description": "'It is reccomended that these Categories shoud be blocked by policies because they provide harmful/malicious content..'\n", "techniques": NaN, "tactics": ["CommandAndControl", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaRequestBlocklistedFileType.yaml", "query_name": "Cisco Umbrella - Request to blocklisted file type", "query": "let file_ext_blocklist = dynamic(['.ps1', '.vbs', '.bat', '.scr']);\nlet lbtime = 10m;\nCisco_Umbrella\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'proxylogs'\n| where DvcAction =~ 'Allowed'\n| extend file_ext = extract(@'.*(\\.\\w+)$', 1, UrlOriginal)\n| extend Filename = extract(@'.*\\/*\\/(.*\\.\\w+)$', 1, UrlOriginal)\n| where file_ext in (file_ext_blocklist)\n| project TimeGenerated, SrcIpAddr, Identities, Filename\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = Identities\n", "attributes": {"description": "'Detects request to potentially harmful file types (.ps1, .bat, .vbs, etc.).'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Analytic%20Rules/CiscoUmbrellaURIContainsIPAddress.yaml", "query_name": "Cisco Umbrella - URI contains IP address", "query": "let lbtime = 10m;\nCisco_Umbrella\n| where TimeGenerated > ago(lbtime)\n| where EventType == 'proxylogs'\n| where DvcAction =~ 'Allowed'\n| where UrlOriginal matches regex @'\\Ahttp:\\/\\/\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}.*'\n| project TimeGenerated, SrcIpAddr, Identities\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = Identities\n", "attributes": {"description": "'Malware can use IP address to communicate with C2.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaAnomalousFQDNsforDomain.yaml", "query_name": "Cisco Umbrella - Anomalous FQDNs for domain", "query": "Cisco_Umbrella\n| where TimeGenerated > ago(24h)\n| where EventType == 'dnslogs'\n| extend replaced = replace(@'\\.$', @'', DnsQueryName)\n| extend Domain = extract(@'.*\\.(.*\\.[a-z]+)', 1, replaced)\n| extend fqdn = extract(@'(.*)\\..*\\.[a-z]+', 1, replaced)\n| summarize FQDNs = dcount(fqdn) by Domain\n| sort by FQDNs\n", "attributes": {"description": "'Large number of FQDNs for domain may be indicator of suspicious domain.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaBlockedUserAgents.yaml", "query_name": "Cisco Umbrella - 'Blocked' User-Agents.", "query": "Cisco_Umbrella\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'Blocked'\n| summarize count() by HttpUserAgentOriginal\n| sort by count_", "attributes": {"description": "'Shows User-Agent values which requests were blocked'\n", "techniques": ["T1020"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaDNSErrors.yaml", "query_name": "Cisco Umbrella - DNS Errors.", "query": "Cisco_Umbrella\n| where TimeGenerated > ago(24h)\n| where EventType == 'dnslogs'\n| where DnsResponseCodeName != 'NOERROR'\n| extend URLCustomEntity = UrlOriginal\n| extend AccountCustomEntity = Identities\n| extend IPCustomEntity = SrcIpAddr", "attributes": {"description": "'Shows error DNS requests.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaDNSRequestsUunreliableCategory.yaml", "query_name": "Cisco Umbrella - DNS requests to unreliable categories.", "query": "Cisco_Umbrella\n| where TimeGenerated > ago(24h)\n| where EventType == 'dnslogs'\n| where UrlCategory contains 'Dating' or UrlCategory contains 'Digital Postcards' or UrlCategory contains 'Freeware and Shareware' or UrlCategory contains 'Gambling' or UrlCategory contains  'Hacking' or UrlCategory contains 'Hunting' or UrlCategory contains 'Mobile Phones' or UrlCategory contains 'Software Updates' or UrlCategory contains 'URL Shortener' or UrlCategory contains  'Web Hosting'\n| where DvcAction == 'Allowed'\n| summarize TotalEvents = count() by DnsQueryName, SrcIpAddr\n| sort by TotalEvents\n| summarize listOfIps = make_set(SrcIpAddr) by DnsQueryName\n| extend URLCustomEntity = DnsQueryName", "attributes": {"description": "'Shows requests to URI categories which heavily are used in Initial Access stage by threat actiors and may contain malicious content.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaHighCountsOfTheSameBytesInSize.yaml", "query_name": "Cisco Umbrella - Higher values of count of the Same BytesIn size", "query": "let timeframe = 1d;\nCisco_Umbrella \n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| summarize count() by SrcIpAddr,DstIpAddr, SrcBytes\n| sort by count_ desc\n| extend Message = \"Possible communication with C2\"\n| project Message, SrcIpAddr, DstIpAddr\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Calculate the count of BytesIn per Source-Destination pair over 24 hours. Higher values may indicate beaconing.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaHighValuesOfUploadedData.yaml", "query_name": "Cisco Umbrella - High values of Uploaded Data", "query": "let timeframe = 1d;\nCisco_Umbrella \n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| summarize sum(DstBytes) by SrcIpAddr,DstIpAddr\n| sort by sum_DstBytes desc\n| project SrcIpAddr, DstIpAddr\n| extend IpCustomEntity = SrcIpAddr", "attributes": {"description": "'A normal user activity consists mostly of downloading data. Uploaded data is usually small unless there is a file/data upload to a website. Calculate the sum of BytesOut per Source-Destination pair over 12/24 hours.'\n", "techniques": ["T1020"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaPossibleConnectionC2.yaml", "query_name": "Cisco Umbrella - Possible connection to C2.", "query": "let timeframe = 1d;\nCisco_Umbrella \n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| summarize count() by SrcIpAddr, DstIpAddr, SrcBytes\n| sort by count_ desc\n| extend Message = \"Possible communication with C2\"\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Calculate the count of BytesIn per Source-Destination pair over 12/24 hours. Higher values may indicate beaconing. C2 servers reply with the same data, making BytesIn value the same.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaPossibleDataExfiltration.yaml", "query_name": "Cisco Umbrella - Possible data exfiltration", "query": "let timeframe = 1d;\nCisco_Umbrella \n| where EventType == \"proxylogs\"\n| where TimeGenerated > ago(timeframe)\n| summarize sum(DstBytes) by SrcIpAddr,DstIpAddr\n| sort by sum_DstBytes desc\n| extend Message = \"Possible data exfiltration\"\n| extend IPCustomEntity = SrcIpAddr", "attributes": {"description": "'A normal user activity consists mostly of downloading data. Uploaded data is usually small unless there is a file/data upload to a website. Calculate the sum of BytesOut per Source-Destination pair over 12/24 hours.'\n", "techniques": ["T1020"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaProxyAllowedUnreliableCategory.yaml", "query_name": "Cisco Umbrella - Proxy 'Allowed' to unreliable categories.", "query": "Cisco_Umbrella\n| where TimeGenerated > ago(24h)\n| where EventType == 'proxylogs'\n| where UrlCategory contains 'Dating' or UrlCategory contains 'Digital Postcards' or UrlCategory contains 'Freeware and Shareware' or UrlCategory contains 'Gambling' or UrlCategory contains  'Hacking' or UrlCategory contains 'Hunting' or UrlCategory contains 'Mobile Phones' or UrlCategory contains 'Software Updates' or UrlCategory contains 'URL Shortener' or UrlCategory contains  'Web Hosting'\n| where DvcAction == 'ALLOWED'\n| summarize TotalEvents = count() by UrlOriginal, SrcIpAddr\n| sort by TotalEvents\n| summarize listOfIps = make_set(SrcIpAddr) by UrlOriginal\n| extend URLCustomEntity = UrlOriginal", "attributes": {"description": "'Shows allowed requests to URI categories which heavily are used in Initial Access stage by threat actiors and may contain malicious content.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoUmbrella/Hunting%20Queries/CiscoUmbrellaRequestsUncategorizedURI.yaml", "query_name": "Cisco Umbrella - Requests to uncategorized resources", "query": "Cisco_Umbrella\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'Allowed'\n| where UrlCategory == ''\n| project UrlOriginal, Identities\n| extend URLCustomEntity = UrlOriginal\n| extend AccountCustomEntity = Identities", "attributes": {"description": "'Shows requests to URL where UrlCategory is not set.'\n", "techniques": ["T1071"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAAccessToUnwantedSite.yaml", "query_name": "Cisco WSA - Access to unwanted site", "query": "let risky_sites = dynamic(['IW_adlt', 'IW_hack', 'IW_porn']);\nCiscoWSAEvent\n| where UrlCategory in~ (risky_sites)\n| where DvcAction =~ 'DEFAULT_CASE'\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects when users attempting to access sites from high risk category.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSADataExfiltration.yaml", "query_name": "Cisco WSA - Unexpected uploads", "query": "let f_cnt_upload_threshold = 5;\nlet f_upload_size_threshold = 5000000;\nCiscoWSAEvent\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where isnotempty(AmpFileName)\n| where UrlCategory in~ ('IW_fts', 'IW_osb')\n| where DstBytes > f_upload_size_threshold\n| summarize count() by AmpFileName, SrcUserName, bin(TimeGenerated, 10m)\n| where count_ >= f_cnt_upload_threshold\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects unexpected file uploads.'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAMultipleErrorsToUnwantedCategory.yaml", "query_name": "Cisco WSA - Multiple errors to resource from risky category", "query": "let threshold = 10;\nlet risky_sites = dynamic(['IW_adlt', 'IW_hack', 'IW_porn']);\nCiscoWSAEvent\n| where DvcAction startswith 'BLOCK_'\n| where UrlCategory in~ (risky_sites)\n| summarize count() by SrcUserName, UrlOriginal, bin(TimeGenerated, 5m)\n| where count_ >= threshold\n| extend URLCustomEntity = UrlOriginal, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects multiple connection errors to resource from risky category.'\n", "techniques": ["T1189", "T1102"], "tactics": ["InitialAccess", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAMultipleErrorsToUrl.yaml", "query_name": "Cisco WSA - Multiple errors to URL", "query": "let threshold = 5;\nCiscoWSAEvent\n| where DvcAction =~ 'NONE'\n| summarize count() by SrcUserName, UrlOriginal, bin(TimeGenerated, 5m)\n| where count_ >= threshold\n| extend URLCustomEntity = UrlOriginal, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects multiple connection errors to URL.'\n", "techniques": ["T1102"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAMultipleInfectedFiles.yaml", "query_name": "Cisco WSA - Multiple infected files", "query": "CiscoWSAEvent\n| where isnotempty(AmpFileName)\n| where isnotempty(ThreatName)\n| summarize count() by SrcIpAddr, SrcUserName, bin(TimeGenerated, 15m)\n| where count_ > 1\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects multiple infected files on same source.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAMultipleUnwantedFileTypes.yaml", "query_name": "Cisco WSA - Multiple attempts to download unwanted file", "query": "let threshold = 2;\nCiscoWSAEvent\n| where DvcAction =~ 'BLOCK_ADMIN_FILE_TYPE'\n| summarize i_src = makeset(SrcIpAddr) by UrlOriginal, bin(TimeGenerated, 15m)\n| where array_length(i_src) >= threshold\n| extend IPCustomEntity = i_src, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects when multiple attempts to download unwanted file occur.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAProtocolAbuse.yaml", "query_name": "Cisco WSA - Suspected protocol abuse", "query": "CiscoWSAEvent\n| where DstPortNumber !in ('80', '443')\n| where NetworkApplicationProtocol in~ ('HTTP', 'HTTPs')\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects possible protocol abuse.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAPublicIPSource.yaml", "query_name": "Cisco WSA - Internet access from public IP", "query": "let ip_except = dynamic(['127.0.0.2']);    //Add exceptions to this list\nCiscoWSAEvent\n| where ipv4_is_private(SrcIpAddr) == false\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects internet access from public IP.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAUnexpectedFileType.yaml", "query_name": "Cisco WSA - Unexpected file type", "query": "CiscoWSAEvent\n| where isnotempty(AmpFileName)\n| where isempty(AmpThreatName)\n| where ResponseBodyMimeType =~ 'application/octet-stream'\n| where AmpFileName !endswith '.exe'\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects unexpected file type.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAUnexpectedUrl.yaml", "query_name": "Cisco WSA - Unexpected URL", "query": "let threshold = 5;\nCiscoWSAEvent\n| where UrlOriginal matches regex @'\\Ahttp(s)?[:][/][/]\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'\n| extend URLCustomEntity = UrlOriginal, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects unexpected URL.'\n", "techniques": ["T1102"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Analytic%20Rules/CiscoWSAUnscannableFile.yaml", "query_name": "Cisco WSA - Unscannable file or scan error", "query": "CiscoWSAEvent\n| where isnotempty(AmpFileName)\n| where AmpScanningVerdict in ('2', '3')\n| extend IPCustomEntity = SrcIpAddr, FileCustomEntity = AmpFileName, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects unscanned downloaded file.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSABlockedFiles.yaml", "query_name": "Cisco WSA - Blocked files", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'BLOCK_ADMIN_FILE_TYPE'\n| summarize count() by UrlOriginal\n| extend URLCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query searches for blocked files.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSARareApplications.yaml", "query_name": "Cisco WSA - Rare aplications", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| summarize count() by AvcApplicationName, SrcUserName\n| order by count_ asc\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for rare applications.'\n", "techniques": ["T1048", "T1567"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSATopApplications.yaml", "query_name": "Cisco WSA - Top aplications", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| summarize count() by AvcApplicationName, SrcUserName\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for top applications.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSATopResources.yaml", "query_name": "Cisco WSA - Top URLs", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| summarize count() by UrlOriginal, SrcUserName\n| extend URLCustomEntity = UrlOriginal, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for top URLs.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSAUncategorizedResources.yaml", "query_name": "Cisco WSA - Uncategorized URLs", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| where UrlCategory in~ ('IW_nc', 'IW_nact')\n| project UrlOriginal, SrcUserName, SrcIpAddr\n| extend URLCustomEntity = UrlOriginal, AccountCustomEntity = SrcUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for uncategorized URLs.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSAUploadedFiles.yaml", "query_name": "Cisco WSA - Uploaded files", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where isnotempty(AmpFileName)\n| project AmpFileName, SrcUserName\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for uploaded files.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSAUrlRareErrorUrl.yaml", "query_name": "Cisco WSA - Rare URL with error", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'OTHER'\n| summarize count() by UrlOriginal\n| order by count_ asc\n| extend URLCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query searches for rare URLs with errors.'\n", "techniques": ["T1189", "T1048"], "tactics": ["InitialAccess", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSAUrlShortenerLinks.yaml", "query_name": "Cisco WSA - URL shorteners", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| where UrlCategory =~ 'IW_shrt'\n| project UrlOriginal, SrcUserName, SrcIpAddr\n| extend URLCustomEntity = UrlOriginal, AccountCustomEntity = SrcUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches connections to Url shorteners resources.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSAUrlSuspiciousResources.yaml", "query_name": "Cisco WSA - Potentially risky resources", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'BLOCK_CONTINUE_WEBCAT'\n| project UrlOriginal, SrcUserName, SrcIpAddr\n| extend URLCustomEntity = UrlOriginal, AccountCustomEntity = SrcUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for potentially risky resources.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CiscoWSA/Hunting%20Queries/CiscoWSAUrlUsersWithErrors.yaml", "query_name": "Cisco WSA - User errors", "query": "CiscoWSAEvent\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'OTHER'\n| summarize count() by UrlOriginal, SrcUserName\n| extend URLCustomEntity = UrlOriginal, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for user errors during accessing resource.'\n", "techniques": ["T1189", "T1048"], "tactics": ["InitialAccess", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotyAssetDown.yaml", "query_name": "Claroty - Asset Down", "query": "ClarotyEvent\n| where EventOriginalType has 'Asset Down' or EventType has 'Asset Down'\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Triggers asset is down.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotyCriticalBaselineDeviation.yaml", "query_name": "Claroty - Critical baseline deviation", "query": "ClarotyEvent\n| where EventOriginalType has 'Baseline Deviation' or EventType has 'Baseline Deviation'\n| where EventSeverity == '5'\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects when critical deviation from baseline occurs.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotyLoginToUncommonSite.yaml", "query_name": "Claroty - Login to uncommon location", "query": "let usr_sites = ClarotyEvent\n| where TimeGenerated > ago(14d)\n| where EventType has 'Login to SRA succeeded'\n| extend Site = column_ifexists(\"site_name\",\"\")\n| where isnotempty(Site)\n| extend SrcUsername = extract(@'User\\s(.*?)\\slogged', 1, EventMessage)\n| summarize all_loc = makeset(tostring(Site)) by SrcUsername\n| extend k = 1;\nClarotyEvent\n| where EventType has 'Login to SRA succeeded'\n| extend Site = column_ifexists(\"site_name\",\"\")\n| where isnotempty(Site)\n| extend SrcUsername = extract(@'User\\s(.*?)\\slogged', 1, EventMessage)\n| extend k = 1\n| join kind=innerunique (usr_sites) on k\n| where all_loc !contains Site\n| extend SrcIpAddr\n", "attributes": {"description": "'Detects user login to uncommon location.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotyMultipleFailedLogin.yaml", "query_name": "Claroty - Multiple failed logins by user", "query": "let threshold = 5;\nClarotyEvent\n| where EventType has 'Login to SRA'\n| where EventType !has 'succeeded'\n| extend SrcUsername = extract(@'User\\s(.*?)\\sfailed', 1, EventMessage)\n| summarize count() by SrcUsername, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend AccountCustomEntity = SrcUsername\n", "attributes": {"description": "'Detects multiple failed logins by same user.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotyMultipleFailedLoginsSameDst.yaml", "query_name": "Claroty - Multiple failed logins to same destinations", "query": "let threshold = 10;\nClarotyEvent\n| where EventType has 'Login to SRA'\n| where EventType !has 'succeeded'\n| extend Site = column_ifexists(\"site_name\",\"\")\n| where isnotempty(Site)\n| extend SrcUsername = extract(@'User\\s(.*?)\\sfailed', 1, EventMessage)\n| summarize count() by Site, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend SGCustomEntity = Site\n", "attributes": {"description": "'Detects multiple failed logins to same destinations.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotyNewAsset.yaml", "query_name": "Claroty - New Asset", "query": "ClarotyEvent\n| where EventOriginalType has 'New Asset' or EventType has 'New Asset'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Triggers when a new asset has been added into the environment.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotyPolicyViolation.yaml", "query_name": "Claroty - Policy violation", "query": "ClarotyEvent\n| where EventOriginalType has 'Policy Violation' or EventType has 'Policy Violation'\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects policy violations.'\n", "techniques": ["T1018"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotySuspiciousActivity.yaml", "query_name": "Claroty - Suspicious activity", "query": "ClarotyEvent\n| where EventOriginalType has 'Suspicious Activity' or EventType has 'Suspicious Activity'\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects suspicious behavior that is generally indicative of malware.'\n", "techniques": ["T1018"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotySuspiciousFileTransfer.yaml", "query_name": "Claroty - Suspicious file transfer", "query": "ClarotyEvent\n| where EventOriginalType has 'Suspicious File Transfer' or EventType has 'Suspicious File Transfer'\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects suspicious file transfer activity.'\n", "techniques": ["T1018"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Analytic%20Rules/ClarotyTreat.yaml", "query_name": "Claroty - Treat detected", "query": "ClarotyEvent\n| where EventOriginalType has 'Treat' or EventType has 'Treat'\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects Collection of known malware commands and control servers.'\n", "techniques": ["T1018"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotyBaselineDeviation.yaml", "query_name": "Claroty - Baseline deviation", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where EventOriginalType has 'Baseline Deviation' or EventType has 'Baseline Deviation'\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for baseline deviation events.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotyConflictAssets.yaml", "query_name": "Claroty - Conflict assets", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where EventOriginalType has 'New Conflict Asset' or EventType has 'New Conflict Asset'\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for conflicting assets.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotyCriticalEvents.yaml", "query_name": "Claroty - Critical Events", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where EventSeverity == '5'\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for critical severity events.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotyPLCLogins.yaml", "query_name": "Claroty - PLC logins", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where EventOriginalType =~ 'Alert'\n| where EventType has 'Login'\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for PLC login security alerts.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotyScanSources.yaml", "query_name": "Claroty - Network scan sources", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where EventOriginalType has_any ('Network Scan', 'TCP Scan', 'UDP Scan') or EventType has_any ('Network Scan', 'TCP Scan', 'UDP Scan')\n| project TimeGenerated, SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for sources of network scans.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotyScantargets.yaml", "query_name": "Claroty - Network scan targets", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where EventOriginalType has_any ('Network Scan', 'TCP Scan', 'UDP Scan') or EventType has_any ('Network Scan', 'TCP Scan', 'UDP Scan')\n| project TimeGenerated, DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for targets of network scans.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotySRAFailedLogins.yaml", "query_name": "Claroty - User failed logins", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where EventType has 'Login to SRA'\n| where EventType !has 'succeeded'\n| extend SrcUsername = extract(@'User\\s(.*?)\\sfailed', 1, EventMessage)\n| summarize count() by SrcUsername\n| extend AccountCustomEntity = SrcUsername\n", "attributes": {"description": "'Query searches for login failure events.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotyUnapprovedAccess.yaml", "query_name": "Claroty - Unapproved access", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where EventSeverity =~ 'Unapproved'\n| where isnotempty(CategoryAccess)\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for unapproved access events.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotyUnresolvedAlerts.yaml", "query_name": "Claroty - Unresolved alerts", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where EventOriginalType =~ 'Alert'\n| where ResolvedAs =~ 'Unresolved'\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for alerts with unresolved status.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Claroty/Hunting%20Queries/ClarotyWriteExecuteOperations.yaml", "query_name": "Claroty - Write and Execute operations", "query": "ClarotyEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(CategoryAccess)\n| where CategoryAccess != 'Read'\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for operations with Write and Execute accesses.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareBadClientIp.yaml", "query_name": "Cloudflare - Bad client IP", "query": "let ip_reputation = dynamic(['unknown', 'badHost', 'greylist', 'securityScanner', 'scan', 'tor']);\nCloudflare\n| where ClientIPClass in~ (ip_reputation)\n| extend IPCustomEntity = SrcIpAddr\n| extend UrlCustomEntity = ClientRequestURI\n", "attributes": {"description": "'Detects requests from IP with bad reputation index.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareEmptyUA.yaml", "query_name": "Cloudflare - Empty user agent", "query": "Cloudflare\n| where isempty(HttpUserAgentOriginal)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests where user agent is empty.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareMultipleErrorsSource.yaml", "query_name": "Cloudflare - Multiple error requests from single source", "query": "let threshold = 100;\nCloudflare\n| where HttpRequestMethod =~ 'GET'\n| summarize err_cnt = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where err_cnt > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple failure requests from single source in short timeframe.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareMultipleUAs.yaml", "query_name": "Cloudflare - Multiple user agents for single source", "query": "let threshold = 10;\nCloudflare\n| where isnotempty(HttpUserAgentOriginal)\n| summarize d_ua = dcount(HttpUserAgentOriginal) by SrcIpAddr, bin(TimeGenerated, 3m)\n| where d_ua > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests with different user agents from one source in short timeframe.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareUnexpectedCountry.yaml", "query_name": "Cloudflare - Client request from country in blocklist", "query": "let bl_countries = dynamic(['cn', 'hk']);\nCloudflare\n| where SrcGeoCountry in~ (bl_countries)\n| extend IPCustomEntity = SrcIpAddr\n| extend UrlCustomEntity = ClientRequestURI\n", "attributes": {"description": "'Detects requests from countries which are in blocklist.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareUnexpectedPost.yaml", "query_name": "Cloudflare - Unexpected POST requests", "query": "Cloudflare\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where tostring(HttpStatusCode) startswith '2'\n| where DstBytes != 0 or SrcBytes != 0\n| extend fe = extract(@'.*(\\.\\w+)$', 1, ClientRequestURI)\n| where fe in~ ('.jpg', '.jpeg', '.gif', '.png', '.icon', '.ico', '.xml', '.swf', '.svg', '.ppt', '.pttx', '.doc', '.docx', '.rtf', '.pdf', '.tif', '.zip', '.mov')\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects post requests to unusual extensions.'\n", "techniques": ["T1505", "T1071"], "tactics": ["Persistence", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareUnexpectedRequest.yaml", "query_name": "Cloudflare - Unexpected client request", "query": "Cloudflare\n| where HttpRequestMethod =~ 'GET'\n| where DstBytes != 0 or SrcBytes != 0\n| where ClientRequestURI has_any ('/admin', '/admin.php', 'wp-admin', '.htaccess', '/etc/shadow', '/etc/passwd', '/etc/hosts', '/etc/ssh/') \n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects client requests to unusual URI.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareUnexpectedUrl.yaml", "query_name": "Cloudflare - Unexpected URI", "query": "Cloudflare\n| where HttpRequestMethod =~ 'GET'\n| where DstBytes != 0 or SrcBytes != 0\n| where ClientRequestURI matches regex @'(127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})|(10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})|(172\\.1[6-9]\\.\\d{1,3}\\.\\d{1,3})|(172\\.2[0-9]\\.\\d{1,3}\\.\\d{1,3})|(172\\.3[0-1]\\.\\d{1,3}\\.\\d{1,3})|(192\\.168\\.\\d{1,3}\\.\\d{1,3})'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects client requests to unusual URI.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareWafThreatAllowed.yaml", "query_name": "Cloudflare - WAF Allowed threat", "query": "Cloudflare\n| where isnotempty(WAFRuleID) or isnotempty(WAFRuleMessage)\n| where WAFAction =~ 'Allow'\n| extend IPCustomEntity = SrcIpAddr\n| extend UrlCustomEntity = ClientRequestURI\n", "attributes": {"description": "'Detects WAF \"Allowed\" action on threat events.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Analytic%20Rules/CloudflareXSSProbingPattern.yaml", "query_name": "Cloudflare - XSS probing pattern in request", "query": "let s_threshold = 3;\nCloudflare\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| extend susp_ch = countof(ClientRequestURI, '%00')\n| where ClientRequestURI matches regex @'(alert\\()|(alert\\%28)|(String\\.fromCharCode\\()|(expression\\(alert)' or susp_ch > s_threshold\n| extend IPCustomEntity = SrcIpAddr\n| extend UrlCustomEntity = ClientRequestURI\n", "attributes": {"description": "'Detects XSS probing patterns.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareClientErrors.yaml", "query_name": "Cloudflare - Client errors", "query": "Cloudflare\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode startswith '4'\n| extend IPCustomEntity = SrcIpAddr\n| extend UrlCustomEntity = ClientRequestURI\n", "attributes": {"description": "'Query searches for client related errors.'\n", "techniques": ["T1190", "T1133", "T1498"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareClientTlsErrors.yaml", "query_name": "Cloudflare - Client TLS errors", "query": "let err_tls = dynamic(['UNKNOWN', 'INTERNAL_ERROR', 'INVALID_CONFIG', 'INVALID_SNI', 'HANDSHAKE_FAILED']);\nCloudflare\n| where TimeGenerated > ago(24h)\n| where ClientTlsStatus in~ (err_tls)\n| extend IPCustomEntity = SrcIpAddr\n| extend UrlCustomEntity = ClientRequestURI\n", "attributes": {"description": "'Query searches for client TLS errors.'\n", "techniques": ["T1190", "T1133", "T1498"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareFilesRequested.yaml", "query_name": "Cloudflare - Files requested", "query": "Cloudflare\n| where TimeGenerated > ago(24h)\n| extend File = extract(@'\\/(\\w+\\.\\w+)', 1, ClientRequestURI)\n| summarize count() by File, SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query searches for files requested.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareRareUAs.yaml", "query_name": "Cloudflare - Rare user agents", "query": "Cloudflare\n| where TimeGenerated > ago(24h)\n| where isnotempty(HttpUserAgentOriginal)\n| summarize count() by HttpUserAgentOriginal, SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches rare user agent strings.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareServerErrors.yaml", "query_name": "Cloudflare - Server errors", "query": "Cloudflare\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode startswith '5'\n| extend IPCustomEntity = SrcIpAddr\n| extend UrlCustomEntity = ClientRequestURI\n", "attributes": {"description": "'Query searches for server related errors.'\n", "techniques": ["T1190", "T1133", "T1498"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareServerTlsErrors.yaml", "query_name": "Cloudflare - Server TLS errors", "query": "let err_tls = dynamic(['UNKNOWN', 'INTERNAL_ERROR', 'INVALID_CONFIG', 'INVALID_SNI', 'HANDSHAKE_FAILED']);\nCloudflare\n| where TimeGenerated > ago(24h)\n| where OriginTlsStatus in~ (err_tls)\n| extend IPCustomEntity = SrcIpAddr\n| extend UrlCustomEntity = ClientRequestURI\n", "attributes": {"description": "'Query searches for server TLS errors.'\n", "techniques": ["T1190", "T1133", "T1498"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareTopNetworkRules.yaml", "query_name": "Cloudflare - Top Network rules", "query": "Cloudflare\n| where TimeGenerated > ago(24h)\n| where isnotempty(NetworkRuleName)\n| summarize count() by NetworkRuleName, EdgeRequestHost\n| order by count_\n| extend CloudAppCustomEntity = EdgeRequestHost\n", "attributes": {"description": "'Query searches top network rules triggered.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareTopWafRules.yaml", "query_name": "Cloudflare - Top WAF rules", "query": "Cloudflare\n| where TimeGenerated > ago(24h)\n| where isnotempty(WAFRuleID)\n| summarize count() by WAFRuleID, WAFRuleMessage, EdgeRequestHost\n| order by count_\n| extend CloudAppCustomEntity = EdgeRequestHost\n", "attributes": {"description": "'Query searches top WAF rules triggered.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareUnexpectedCountries.yaml", "query_name": "Cloudflare - Unexpected countries", "query": "Cloudflare\n| where TimeGenerated > ago(24h)\n| summarize count() by SrcGeoCountry, SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches requests by country and helps to identify requests coming from unexpected countries.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cloudflare/Hunting%20Queries/CloudflareUnexpectedEdgeResponse.yaml", "query_name": "Cloudflare - Unexpected edge response", "query": "Cloudflare\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode != EdgeResponseStatus\n| extend IPCustomEntity = SrcIpAddr\n| extend UrlCustomEntity = ClientRequestURI\n", "attributes": {"description": "'Query searches for unexpected EdgeResponseStatus values.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniHighRiskBusinessIncidents.yaml", "query_name": "Cognni Incidents for Highly Sensitive Business Information", "query": "let highRisk = 3;\nlet business = 'Business Information';\nCognniIncidents_CL \n| where Severity == highRisk\n| where informationType_s == business\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which highly sensitive business information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniHighRiskFinancialIncidents.yaml", "query_name": "Cognni Incidents for Highly Sensitive Financial Information", "query": "let highRisk = 3;\nlet financial = 'Financial Information';\nCognniIncidents_CL \n| where Severity == highRisk\n| where informationType_s == financial\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which highly sensitive financial information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniHighRiskGovernanceIncidents.yaml", "query_name": "Cognni Incidents for Highly Sensitive Governance Information", "query": "let highRisk = 3;\nlet governance = 'Governance Information';\nCognniIncidents_CL \n| where Severity == highRisk\n| where informationType_s == governance\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which highly sensitive governance information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniHighRiskHRIncidents.yaml", "query_name": "Cognni Incidents for Highly Sensitive HR Information", "query": "let highRisk = 3;\nlet hr = 'HR Information';\nCognniIncidents_CL \n| where Severity == highRisk\n| where informationType_s == hr\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which highly sensitive HR information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniHighRiskLegalIncidents.yaml", "query_name": "Cognni Incidents for Highly Sensitive Legal Information", "query": "let highRisk = 3;\nlet legal = 'Legal Information';\nCognniIncidents_CL \n| where Severity == highRisk\n| where informationType_s == legal\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which highly sensitive legal information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniLowRiskBusinessIncidents.yaml", "query_name": "Cognni Incidents for Low Sensitivity Business Information", "query": "let lowRisk = 1;\nlet business = 'Business Information';\nCognniIncidents_CL \n| where Severity == lowRisk\n| where informationType_s == business\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which low sensitivity business information] was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniLowRiskFinancialIncidents.yaml", "query_name": "Cognni Incidents for Low Sensitivity Financial Information", "query": "let lowRisk = 1;\nlet financial = 'Financial Information';\nCognniIncidents_CL \n| where Severity == lowRisk\n| where informationType_s == financial\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which low sensitivity financial information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniLowRiskGovernanceIncidents.yaml", "query_name": "Cognni Incidents for Low Sensitivity Governance Information", "query": "let lowRisk = 1;\nlet governance = 'Governance Information';\nCognniIncidents_CL \n| where Severity == lowRisk\n| where informationType_s == governance\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which low sensitivity governance information] was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniLowRiskHRIncidents.yaml", "query_name": "Cognni Incidents for Low Sensitivity HR Information", "query": "let lowRisk = 1;\nlet hr = 'HR Information';\nCognniIncidents_CL \n| where Severity == lowRisk\n| where informationType_s == hr\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which low sensitive HR information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniLowRiskLegalIncidents.yaml", "query_name": "Cognni Incidents for Low Sensitivity Legal Information", "query": "let lowRisk = 1;\nlet legal = 'Legal Information';\nCognniIncidents_CL \n| where Severity == lowRisk\n| where informationType_s == legal\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which low sensitivity legal information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniMediumRiskBusinessIncidents.yaml", "query_name": "Cognni Incidents for Medium Sensitivity Business Information", "query": "let mediumRisk = 2;\nlet business = 'Business Information';\nCognniIncidents_CL \n| where Severity == mediumRisk\n| where informationType_s == business\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which medium sensitivity business information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniMediumRiskFinancialIncidents.yaml", "query_name": "Cognni Incidents for Medium Sensitivity Financial Information", "query": "let mediumRisk = 2;\nlet financial = 'Financial Information';\nCognniIncidents_CL \n| where Severity == mediumRisk\n| where informationType_s == financial\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which medium sensitive financial information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniMediumRiskGovernanceIncidents.yaml", "query_name": "Cognni Incidents for Medium Sensitivity Governance Information", "query": "let mediumRisk = 2;\nlet goverence = 'Goverence Information';\nCognniIncidents_CL \n| where Severity == mediumRisk\n| where informationType_s == goverence\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which medium sensitivity governance information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniMediumRiskHRIncidents.yaml", "query_name": "Cognni Incidents for Medium Sensitivity HR Information", "query": "let mediumRisk = 2;\nlet hr = 'HR Information';\nCognniIncidents_CL \n| where Severity == mediumRisk\n| where informationType_s == hr\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which medium sensitivity HR information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cognni/Analytic%20Rules/CognniMediumRiskLegalIncidents.yaml", "query_name": "Cognni Incidents for Medium Sensitivity Legal Information", "query": "let mediumRisk = 2;\nlet legal = 'Legal Information';\nCognniIncidents_CL \n| where Severity == mediumRisk\n| where informationType_s == legal\n| where TimeGenerated >= ago(5h)\n| extend AccountCustomEntity = userId_s\n", "attributes": {"description": "'Display incidents in which medium sensitivity legal information was placed at risk by user sharing.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ContinuousDiagnostics%26Mitigation/Analytic%20Rules/ContinuousDiagnostics%26MitigationPostureChanged.yaml", "query_name": "CDM_ContinuousDiagnostics&Mitigation_PostureChanged", "query": "SecurityRecommendation\n| where RecommendationDisplayName <> \"\"\n| extend MaturityLevel=iff(RecommendationDisplayName has_any(\"log\", \"defender\", \"asset\", \"arc\"), \"Hardware Asset Management (HWAM)\",\n    iff(RecommendationDisplayName has_any(\"allow\", \"software\", \"application\"), \"Software Asset Management (SWAM)\",\n    iff(RecommendationDisplayName has_any(\"account\", \"user\", \"identity\", \"trust\"), \"User Trust (TRUST)\",\n    iff(RecommendationDisplayName has_any(\"access\", \"auth\", \"key\", \"cert\", \"token\"), \"Credentials & Authenticators (CRED)\",\n    iff(RecommendationDisplayName has_any(\"priv\", \"admin\", \"root\"), \"Privileges (PRIV)\",\n    iff(RecommendationDisplayName has_any(\"network\", \"internet\", \"traffic\", \"firewall\", \"intrusion\", \"bound\", \"tls\", \"gateway\", \"subnet\", \"web\", \"url\", \"proxy\", \"just\", \"port\", \"JIT\", \"http\"), \"Boundary Protection (BOUND)\",\n    iff(RecommendationDisplayName has_any(\"event\", \"agent\", \"incident\", \"back\", \"privacy\", \"audit\", \"collect\"), \"Manage Events (MNGEVT)\",\n    iff(RecommendationDisplayName has_any(\"edr\", \"malware\", \"endpoint protection\", \"detect\", \"respon\"), \"Endpoint Detection & Response (EDR)\",\n    iff(RecommendationDisplayName has_any(\"aks\", \"contain\", \"kube\", \"supply\"), \"Design & Build in Security (DBS)\",\n    iff(RecommendationDisplayName has_any(\"data\", \"storage\", \"sql\", \"cmk\", \"key\"), \"Data Protection Management (DPM)\", \"Other\"))))))))))\n| where MaturityLevel in ('Hardware Asset Management (HWAM)', 'Software Asset Management (SWAM)', 'User Trust (TRUST)', 'Credentials & Authenticators (CRED)', 'Privileges (PRIV)', 'Boundary Protection (BOUND)', 'Manage Events (MNGEVT)', 'Endpoint Detection & Response (EDR)', 'Design & Build in Security (DBS)', 'Data Protection Management (DPM)')\n| summarize arg_max(TimeGenerated, *) by AssessedResourceId, RecommendationDisplayName\n| summarize\n    Failed = countif(RecommendationState == \"Unhealthy\"),\n    Passed = countif(RecommendationState == \"Healthy\"),\n    NotApplicable = countif(RecommendationState == \"NotApplicable\" or RecommendationState == \"Removed\"),\n    Applicable = countif(RecommendationState == \"Unhealthy\" or RecommendationState == \"Healthy\"),\n    Total = countif(RecommendationState == \"Unhealthy\" or RecommendationState == \"Healthy\" or RecommendationState == \"NotApplicable\" or RecommendationState == \"Removed\")\n    by MaturityLevel\n| extend PassedControls = (Passed / todouble(Applicable)) * 100\n| project MaturityLevel, Total, PassedControls, Passed, Failed, Applicable, NotApplicable\n| sort by Total, Passed desc\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22')\n| project CapabilityArea=MaturityLevel, Total, PassedControls, Passed, Failed, RemediationLink, LastObserved=now()\n| where CapabilityArea <> ''\n| where PassedControls < 70 \n//Adjust Either FailedRatePercentage or PassedRatePercentage Thresholds within organizational requirements\n| sort by PassedControls desc\n| extend URLCustomEntity = RemediationLink\n", "attributes": {"description": "'This alert is designed to monitor Azure policies aligned with the Continuous Diagnostics & Mitigation (CDM) Program. The alert triggers when policy compliance falls below 70% within a 1 week timeframe.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ContinuousDiagnostics%26Mitigation/Hunting%20Queries/ContinuousDiagnostics%26MitigationPosture.yaml", "query_name": "CDM_ContinuousDiagnostics&Mitigation_Posture", "query": "SecurityRecommendation\n| where RecommendationDisplayName <> \"\"\n| extend MaturityLevel=iff(RecommendationDisplayName has_any(\"log\", \"defender\", \"asset\", \"arc\"), \"Hardware Asset Management (HWAM)\",\n    iff(RecommendationDisplayName has_any(\"allow\", \"software\", \"application\"), \"Software Asset Management (SWAM)\",\n    iff(RecommendationDisplayName has_any(\"account\", \"user\", \"identity\", \"trust\"), \"User Trust (TRUST)\",\n    iff(RecommendationDisplayName has_any(\"access\", \"auth\", \"key\", \"cert\", \"token\"), \"Credentials & Authenticators (CRED)\",\n    iff(RecommendationDisplayName has_any(\"priv\", \"admin\", \"root\"), \"Privileges (PRIV)\",\n    iff(RecommendationDisplayName has_any(\"network\", \"internet\", \"traffic\", \"firewall\", \"intrusion\", \"bound\", \"tls\", \"gateway\", \"subnet\", \"web\", \"url\", \"proxy\", \"just\", \"port\", \"JIT\", \"http\"), \"Boundary Protection (BOUND)\",\n    iff(RecommendationDisplayName has_any(\"event\", \"agent\", \"incident\", \"back\", \"privacy\", \"audit\", \"collect\"), \"Manage Events (MNGEVT)\",\n    iff(RecommendationDisplayName has_any(\"edr\", \"malware\", \"endpoint protection\", \"detect\", \"respon\"), \"Endpoint Detection & Response (EDR)\",\n    iff(RecommendationDisplayName has_any(\"aks\", \"contain\", \"kube\", \"supply\"), \"Design & Build in Security (DBS)\",\n    iff(RecommendationDisplayName has_any(\"data\", \"storage\", \"sql\", \"cmk\", \"key\"), \"Data Protection Management (DPM)\", \"Other\"))))))))))\n| where MaturityLevel in ('Hardware Asset Management (HWAM)', 'Software Asset Management (SWAM)', 'User Trust (TRUST)', 'Credentials & Authenticators (CRED)', 'Privileges (PRIV)', 'Boundary Protection (BOUND)', 'Manage Events (MNGEVT)', 'Endpoint Detection & Response (EDR)', 'Design & Build in Security (DBS)', 'Data Protection Management (DPM)')\n| summarize arg_max(TimeGenerated, *) by AssessedResourceId, RecommendationDisplayName\n| summarize\n    Failed = countif(RecommendationState == \"Unhealthy\"),\n    Passed = countif(RecommendationState == \"Healthy\"),\n    NotApplicable = countif(RecommendationState == \"NotApplicable\" or RecommendationState == \"Removed\"),\n    Applicable = countif(RecommendationState == \"Unhealthy\" or RecommendationState == \"Healthy\"),\n    Total = countif(RecommendationState == \"Unhealthy\" or RecommendationState == \"Healthy\" or RecommendationState == \"NotApplicable\" or RecommendationState == \"Removed\")\n    by MaturityLevel\n| extend PassedControls = (Passed / todouble(Applicable)) * 100\n| project MaturityLevel, Total, PassedControls, Passed, Failed, Applicable, NotApplicable\n| sort by Total, Passed desc\n| project CapabilityArea=MaturityLevel, Total, PassedControls, Passed, Failed, LastObserved=now()\n", "attributes": {"description": "'This hunting query is designed to monitor Azure policies aligned with the Continuous Diagnostics & Mitigation (CDM) Program. It provides a policy check assessment of current CDM policy status across capability areas.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Contrast%20Protect/Analytic%20Rules/ContrastBlocks.yaml", "query_name": "Contrast Blocks", "query": "let extract_data=(a:string, k:string) {\n  parse_urlquery(replace(@';', @'&', a))[\"Query Parameters\"][k]\n};\n\nCommonSecurityLog \n| where DeviceVendor == \"Contrast Security\"\n| where AdditionalExtensions contains \"BLOCKED\"\n| extend DeviceProduct\n| extend SourceIP\n| extend DeviceVersion\n| extend Activity\n| extend ApplicationProtocol\n| extend RequestURL\n| extend RequestMethod\n| extend Rule = extract_data(AdditionalExtensions, 'pri')\n", "attributes": {"description": "'Creates Incidents for Blocked events sourced from the Contrast Protect agent.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Contrast%20Protect/Analytic%20Rules/ContrastExploits.yaml", "query_name": "Contrast Exploits", "query": "let extract_data=(a:string, k:string) {\n  parse_urlquery(replace(@';', @'&', a))[\"Query Parameters\"][k]\n};\n\nCommonSecurityLog \n| where DeviceVendor == \"Contrast Security\"\n| where AdditionalExtensions contains \"EXPLOITED\"\n| extend DeviceProduct\n| extend SourceIP\n| extend DeviceVersion\n| extend Activity\n| extend ApplicationProtocol\n| extend RequestURL\n| extend RequestMethod\n| extend Rule = extract_data(AdditionalExtensions, 'pri')\n", "attributes": {"description": "'Creates Incidents for Exploit events sourced from the Contrast Protect agent.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Contrast%20Protect/Analytic%20Rules/ContrastProbes.yaml", "query_name": "Contrast Probes", "query": "let extract_data=(a:string, k:string) {\n  parse_urlquery(replace(@';', @'&', a))[\"Query Parameters\"][k]\n};\n\nCommonSecurityLog \n| where DeviceVendor == \"Contrast Security\"\n| where AdditionalExtensions contains \"PROBED\" or AdditionalExtensions contains \"INEFFECTIVE\"\n| extend DeviceProduct\n| extend SourceIP\n| extend DeviceVersion\n| extend Activity\n| extend ApplicationProtocol\n| extend RequestURL\n| extend RequestMethod\n| extend Rule = extract_data(AdditionalExtensions, 'pri')\n", "attributes": {"description": "'Creates Incidents for Probed events sourced from the Contrast Protect agent.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Contrast%20Protect/Analytic%20Rules/ContrastSuspicious.yaml", "query_name": "Contrast Suspicious", "query": "let extract_data=(a:string, k:string) {\n  parse_urlquery(replace(@';', @'&', a))[\"Query Parameters\"][k]\n};\n\nCommonSecurityLog \n| where DeviceVendor == \"Contrast Security\"\n| where AdditionalExtensions contains \"SUSPICIOUS\"\n| extend DeviceProduct\n| extend SourceIP\n| extend DeviceVersion\n| extend Activity\n| extend ApplicationProtocol\n| extend RequestURL\n| extend RequestMethod\n| extend Rule = extract_data(AdditionalExtensions, 'pri')\n", "attributes": {"description": "'Creates Incidents for Suspicious events sourced from the Contrast Protect agent.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightC2RepetitiveFailures.yaml", "query_name": "Corelight - C2 DGA Detected Via Repetitive Failures", "query": "let threshold = 25;\nCorelight\n| where EventType =~ 'dns'\n| where DnsResponseCodeName in~ ('NXDOMAIN', 'SERVFAIL')\n| summarize count() by DnsQueryName, SrcIpAddr, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects large amounts of DNS resolution failures.'\n", "techniques": NaN, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightExternalProxyDetected.yaml", "query_name": "Corelight - External Proxy Detected", "query": "Corelight\n| where EventType =~ 'http'\n| where isnotempty(HttpProxiedHeaders)\n| where ipv4_is_private(SrcIpAddr) == 'False'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects external proxy usage.'\n", "techniques": ["T1090"], "tactics": ["DefenseEvasion", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightForcedExternalOutboundSMB.yaml", "query_name": "Corelight - Forced External Outbound SMB", "query": "Corelight\n| where EventType =~ 'conn'\n| where ZeekConnLocalSrc == 'True'\n| where ZeekConnLocalDst == 'False'\n| where NetworkConnectionHistory hasprefix 'Sh' and NetworkApplication hasprefix 'smb'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects SMB requests that originate internally and communicate with an external IP address.'\n", "techniques": ["T1187"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightMultipleCompressedFilesTransferredOverHTTP.yaml", "query_name": "Corelight - Multiple Compressed Files Transferred over HTTP", "query": "let threshold = 25;\nCorelight\n| where EventType =~ 'http'\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where isempty(HttpReferrerOriginal)\n| where SrcMimeType in~ ('application/vnd.ms-cab-compressed', 'application/warc', 'application/x-7z-compressed', 'application/x-ace', 'application/x-arc', 'application/x-archive', 'application/x-arj', 'application/x-compress', 'application/x-cpio', 'application/x-dmg', 'application/x-eet', 'application/x-gzip', 'application/x-lha', 'application/x-lrzip', 'application/x-lz4', 'application/x-lzma', 'application/x-lzh', 'application/x-lzip', 'application/x-rar', 'application/x-rpm', 'application/x-stuffit', 'application/x-tar', 'application/x-xz', 'application/x-zoo', 'application/zip')\n| summarize count() by UrlOriginal, SrcIpAddr, bin(TimeGenerated, 15m)\n| where count_ > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects compressed archives transferre over HTTP.'\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightMultipleFilesSentOverHTTPAbnormalRequests.yaml", "query_name": "Corelight - Multiple files sent over HTTP with abnormal requests", "query": "let threshold = 25;\nlet fl_size_threshold = 10000000;\nCorelight\n| where EventType =~ 'http'\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where isempty(HttpReferrerOriginal)\n| where tolong(HttpRequestBodyBytes) > fl_size_threshold\n| summarize count() by UrlOriginal, SrcIpAddr, bin(TimeGenerated, 15m)\n| where count_ > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects sources sending multiple compressed files greater than 10MBs sent over HTTP in a short amount of time.'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightNetworkServiceScanning.yaml", "query_name": "Corelight - Network Service Scanning Multiple IP Addresses", "query": "let threshold = 25;\nCorelight\n| where EventType =~ 'conn'\n| where ZeekConnLocalSrc == 'True'\n| where ZeekConnLocalDst == 'True'\n| where NetworkConnectionState in~ ('S0', 'REJ')\n| where NetworkConnectionHistory !contains 'D'\n| summarize count() by SrcIpAddr, DstPort, bin(TimeGenerated, 1m)\n| where count_ > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Identify scanning of services that may be available on the internal network.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightPossibleWebshell.yaml", "query_name": "Corelight - Possible Webshell", "query": "Corelight\n| where EventType =~ 'http'\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where toint(HttpStatusCode) between (200 .. 299)\n| where HttpRequestBodyBytes != 0 or HttpResponseBodyBytes != 0\n| extend fe = extract(@'.*(\\.\\w+)$', 1, UrlOriginal)\n| where fe in~ ('.jpg', '.jpeg', '.gif', '.png', '.icon', '.ico', '.xml', '.swf', '.svg', '.ppt', '.pttx', '.doc', '.docx', '.rtf', '.pdf', '.tif', '.zip', '.mov')\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects post requests to unusual extensions.'\n", "techniques": ["T1505"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightPossibleWebshellRarePOST.yaml", "query_name": "Corelight - Possible Webshell (Rare PUT or POST)", "query": "let threshold = 3;\nCorelight\n| where EventType =~ 'http'\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where toint(HttpStatusCode) !between (400 .. 499)\n| where HttpRequestBodyBytes != 0 or HttpResponseBodyBytes != 0\n| extend fe = extract(@'.*(\\.\\w+)$', 1, UrlOriginal)\n| where fe in~ ('.aspx', '.asp', '.php', '.jsp', '.jspx', '.war', '.ashx', '.asmx', '.ascx', '.asx', '.cshtml', '.cfm', '.cfc', '.cfml', '.wss', '.do', '.action', '.pl', '.plx', '.pm', '.xs', '.t', '.pod', '.php-s', '.pht', '.phar', '.phps', '.php7', '.php5', '.php4', '.php3', '.phtml', '.py', '.rb', '.rhtml', '.cgi', '.dll', '.ayws', '.cgi', '.erb', '.rjs', '.hta', '.htc', '.cs', '.kt', '.lua', '.vbhtml')\n| summarize count() by UrlOriginal, SrcIpAddr\n| where count_ < threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects rare post requests to a single webserver location.'\n", "techniques": ["T1505"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightSMTPEmailSubjectNonAsciiCharacters.yaml", "query_name": "Corelight - SMTP Email containing NON Ascii Characters within the Subject", "query": "Corelight\n| where EventType =~ 'smtp'\n| where Subject hasprefix  @'\\=?utf-16'\n| summarize recipients = dcount(To)\n| extend k = 1\n| join (Corelight\n        | where Subject hasprefix  @'\\=?utf-16'\n        | summarize by To\n        | extend k = 1) on k\n| where recipients > 1\n| extend MailCustomEntity = To\n", "attributes": {"description": "'Detects where an emails contain non ascii characters within the Subject.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Analytic%20Rules/CorelightTypoSquattingOrPunycodePhishingHTTPRequest.yaml", "query_name": "Corelight - Possible Typo Squatting or Punycode Phishing HTTP Request", "query": "Corelight\n| where EventType =~ 'http'\n| where HttpRequestMethod =~ 'GET'\n| where isempty(HttpReferrerOriginal)\n| where HttpRequestHeaderHost has 'xn--'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when an HTTP request was made to a domain that was using unicode/punycode.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightAbnormalEmailSubject.yaml", "query_name": "Corelight - Abnormal Email Subject", "query": "Corelight\n| where EventType =~ 'smtp'\n| where Subject hasprefix @'\\=?utf-16'\n| extend MailCustomEntity = To\n", "attributes": {"description": "'Query searches for emails with NON-Ascii characters within the Subject .'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightCompressedFilesTransferredOverHTTP.yaml", "query_name": "Corelight - Compressed Files Transferred over HTTP", "query": "Corelight\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'http'\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where SrcMimeType in~ ('application/vnd.ms-cab-compressed', 'application/warc', 'application/x-7z-compressed', 'application/x-ace', 'application/x-arc', 'application/x-archive', 'application/x-arj', 'application/x-compress', 'application/x-cpio', 'application/x-dmg', 'application/x-eet', 'application/x-gzip', 'application/x-lha', 'application/x-lrzip', 'application/x-lz4', 'application/x-lzma', 'application/x-lzh', 'application/x-lzip', 'application/x-rar', 'application/x-rpm', 'application/x-stuffit', 'application/x-tar', 'application/x-xz', 'application/x-zoo', 'application/zip')\n| summarize count() by SrcIpAddr\n| top 10 by count_\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for top sources which transferred compressed archives over HTTP.'\n", "techniques": ["T1560"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightDataTransferedByIp.yaml", "query_name": "Corelight - Top sources of data transferred", "query": "Corelight\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'http'\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| summarize data_sent = sum(tolong(HttpRequestBodyBytes)) by SrcIpAddr\n| top 10 by data_sent\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for top sources by transferred data over period of time.'\n", "techniques": ["T1560"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightExternalServices.yaml", "query_name": "Corelight - External Facing Services", "query": "Corelight\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'conn'\n| where ipv4_is_private(SrcIpAddr) == 'False'\n| where isnotempty(DstPort)\n| where NetworkConnectionHistory startswith 'Sh'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for external facing services.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightFilesSeen.yaml", "query_name": "Corelight - Files in logs", "query": "Corelight\n| where isnotempty(FileName)\n| summarize makeset(FileName) by SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for files which where seen in logs over period of time.'\n", "techniques": ["T1566", "T1560"], "tactics": ["InitialAccess", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightFilesTransferedByIp.yaml", "query_name": "Corelight - File transferred by source", "query": "Corelight\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'http'\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where isnotempty(FilePath)\n| summarize f_list = makeset(FilePath) by SrcIpAddr\n| extend f_cnt = array_length(f_list)\n| order by f_cnt\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for files transferred over period of time by each source.'\n", "techniques": ["T1560"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightMultipleRemoteSMBConnectionsFromSingleIP.yaml", "query_name": "Corelight - Multiple Remote SMB Connections from single client", "query": "let threshold = 50;\nCorelight\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'smb_mapping'\n| where isnotempty(ShareName)\n| summarize sh_cnt = dcount(ShareName) by SrcIpAddr, bin(TimeGenerated, 1m)\n| where sh_cnt > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when a single source is connecting to many different SMB or file shares.'\n", "techniques": ["T1135"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightObfuscatedBinary.yaml", "query_name": "Corelight - Obfuscated binary filenames", "query": "Corelight\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'http'\n| where FileMimeType in~ ('application/java-archive', 'application/mshelp', 'application/chrome-ext', 'application/x-object', 'application/x-executable', 'application/x-dosexec', 'application/x-msdownload', 'application/vnd.microsoft.portable-executable ')\n| where UrlOriginal !hassuffix '.exe' or UrlOriginal !hassuffix '.dll' or UrlOriginal !hassuffix '.msi'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for downloaded obfuscated binary file names.'\n", "techniques": ["T1189", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightRarePOST.yaml", "query_name": "Corelight - Rare PUT or POST", "query": "Corelight\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'http'\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| where HttpStatusCode !startswith '4'\n| where HttpRequestBodyBytes != 0 or HttpResponseBodyBytes != 0\n| extend fe = extract(@'.*(\\.\\w+)$', 1, UrlOriginal)\n| where fe in~ ('.aspx', '.asp', '.php', '.jsp', '.jspx', '.war', '.ashx', '.asmx', '.ascx', '.asx', '.cshtml', '.cfm', '.cfc', '.cfml', '.wss', '.do', '.action', '.pl', '.plx', '.pm', '.xs', '.t', '.pod', '.php-s', '.pht', '.phar', '.phps', '.php7', '.php5', '.php4', '.php3', '.phtml', '.py', '.rb', '.rhtml', '.cgi', '.dll', '.ayws', '.cgi', '.erb', '.rjs', '.hta', '.htc', '.cs', '.kt', '.lua', '.vbhtml')\n| summarize count() by SrcIpAddr\n| where count_ < 10\n| order by count_ asc\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for rare post requests to a single location.'\n", "techniques": ["T1100", "T1505"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Corelight/Hunting%20Queries/CorelightRepetitiveDnsFailures.yaml", "query_name": "Corelight - Repetitive DNS Failures", "query": "let threshold = 100;\nCorelight\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'dns'\n| where DnsResponseCodeName in~ ('NXDOMAIN', 'SERVFAIL')\n| summarize count() by SrcIpAddr, bin(TimeGenerated, 1h)\n| where count_ > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for repetitive DNS resolution failures from single host.'\n", "techniques": ["T1094", "T1043"], "tactics": ["CommanAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CrowdStrike%20Falcon%20Endpoint%20Protection/Analytic%20Rules/CriticalOrHighSeverityDetectionsByUser.yaml", "query_name": "Critical or High Severity Detections by User", "query": "let timeframe = 1h;\nlet threshold = 15; // update threshold value based on organization's preference\nlet NoteableEvents = CrowdStrikeFalconEventStream\n| where TimeGenerated > ago(timeframe)\n| where EventType == \"DetectionSummaryEvent\"\n| where Severity in (\"Critical\", \"High\")\n| summarize Total = count() by DstUserName\n| where Total > threshold;\nCrowdStrikeFalconEventStream\n| where TimeGenerated > ago(timeframe)\n| where EventType == \"DetectionSummaryEvent\"\n| where Severity in (\"Critical\", \"High\")\n| join kind=inner (NoteableEvents) on DstUserName\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Total = count() by DstHostName, SrcIpAddr, DstUserName, FileName, FileHash, Message\n| extend timestamp = StartTimeUtc, AccountCustomEntity = DstUserName, HostCustomEntity = DstHostName, IPCustomEntity = SrcIpAddr, FileHashCustomEntity = FileHash\n", "attributes": {"description": "'Creates an incident when a large number of Critical/High severity CrowdStrike Falcon sensor detections is triggered by a single user'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CrowdStrike%20Falcon%20Endpoint%20Protection/Analytic%20Rules/CriticalSeverityDetection.yaml", "query_name": "Critical Severity Detection", "query": "let timeframe = 1h;\nCrowdStrikeFalconEventStream\n| where TimeGenerated > ago(timeframe)\n| where EventType == \"DetectionSummaryEvent\"\n| where Severity == \"Critical\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Total = count() by DstHostName, SrcIpAddr, DstUserName, Activity, Technique, FileName, FilePath, FileHash, Message\n| extend timestamp = StartTimeUtc, AccountCustomEntity = DstUserName, HostCustomEntity = DstHostName, IPCustomEntity = SrcIpAddr, FileHashCustomEntity = FileHash\n", "attributes": {"description": "'Creates an incident when a CrowdStrike Falcon sensor detection is triggered with a Critical Severity'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMAttackAttemptNotBlocked.yaml", "query_name": "CyberArkEPM - Attack attempt not blocked", "query": "CyberArkEPM\n| where EventSubType =~ 'AttackAttempt'\n| where ThreatProtectionAction =~ 'Detect'\n| project EventEndTime, EventMessage, ActorUsername, ActingProcessFileInternalName, Evidences\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'This rule triggers on attack attempt which was not blocked by CyberArkEPM.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMMSBuildLOLBin.yaml", "query_name": "CyberArkEPM - MSBuild usage as LOLBin", "query": "CyberArkEPM\n| where EventSubType != 'AttackAttempt'\n| where ActingProcessName endswith @'msbuild.exe'\n| where ActingProcessCommandLine has_any ('xml', 'csproj', 'vcxproj', 'vbproj', 'fsproj')\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Detects usage of msbuild tool as LOLBin.'\n", "techniques": ["T1127"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMMultipleAttackAttempts.yaml", "query_name": "CyberArkEPM - Multiple attack types", "query": "CyberArkEPM\n| where EventSubType =~ 'AttackAttempt'\n| summarize LatestAttackTime=max(EventEndTime), att=makeset(EventMessage) by ActorUsername\n| where array_length(att) > 1\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'This rule triggers on multiple attack attemts triggered by same user.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMNewProcessStartetFromSystem.yaml", "query_name": "CyberArkEPM - Uncommon Windows process started from System folder", "query": "let lb_period = 14d;\nlet q_time = 1h;\nlet sys_proc = CyberArkEPM\n| where TimeGenerated between (ago(lb_period) .. ago(q_time))\n| where EventSubType != 'AttackAttempt'\n| where ActingProcessName has @'\\'\n| where ActingProcessName has_any ('System32', 'SysWOW64')\n| summarize makeset(ActingProcessFileInternalName);\nCyberArkEPM\n| where TimeGenerated > ago(q_time)\n| where EventSubType != 'AttackAttempt'\n| where ActingProcessName has @'\\'\n| where ActingProcessName has_any ('System32', 'SysWOW64')\n| where ActingProcessFileInternalName !in (sys_proc)\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Detects when uncommon windows proccess is started from System folder.'\n", "techniques": ["T1204", "T1036"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMPossibleExecutionOfPowershellEmpire.yaml", "query_name": "CyberArkEPM - Possible execution of Powershell Empire", "query": "CyberArkEPM\n| where EventSubType != 'AttackAttempt'\n| where ActingProcessCommandLine has_any ('-NoP -sta -NonI -W Hidden -Enc', '-noP -sta -w 1 -enc', '-NoP -NonI -W Hidden -enc')\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Detects possible execution of Powershell Empire.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMProcessChangedStartLocation.yaml", "query_name": "CyberArkEPM - Process started from different locations", "query": "CyberArkEPM\n| where EventSubType != 'AttackAttempt'\n| extend bin_path = tolower(extract(@'\\A(.*)(\\\\|/)', 1, ActingProcessName))\n| summarize p = makeset(bin_path) by ActingProcessFileInternalName, DvcId\n| where array_length(p) > 1\n| extend FileCustomEntity = ActingProcessFileInternalName\n", "attributes": {"description": "'Detects when process started from different locations on a host.'\n", "techniques": ["T1204", "T1036"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMRareProcInternetAccess.yaml", "query_name": "CyberArkEPM - Uncommon process Internet access", "query": "let lb_period = 14d;\nlet q_time = 1h;\nlet inet_access_proc = CyberArkEPM\n| where TimeGenerated between (ago(lb_period) .. ago(q_time))\n| where EventSubType =~ 'DetectAccessInternet'\n| where isnotempty(ActingProcessFileInternalName)\n| summarize makeset(ActingProcessFileInternalName);\nCyberArkEPM\n| where TimeGenerated > ago(q_time)\n| where EventSubType =~ 'DetectAccessInternet'\n| where ActingProcessFileInternalName !in (inet_access_proc)\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Detects access to the Internet by uncommon processes.'\n", "techniques": ["T1204", "T1036", "T1095"], "tactics": ["Execution", "DefenseEvasion", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMRenamedWindowsBinary.yaml", "query_name": "CyberArkEPM - Renamed Windows binary", "query": "CyberArkEPM\n| where EventSubType != 'AttackAttempt'\n| where ActingProcessName has @'\\'\n| where ActingProcessName !has ActingProcessFileInternalName\n| project EventEndTime, EventMessage, ActorUsername, ActingProcessFileInternalName\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Detects renamed windows binaries.'\n", "techniques": ["T1204", "T1036"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMUnexpectedExecutableExtension.yaml", "query_name": "CyberArkEPM - Unexpected executable extension", "query": "CyberArkEPM\n| where EventSubType != 'AttackAttempt'\n| where ActingProcessName has @'\\'\n| where ActingProcessName !endswith '.exe'\n| project EventEndTime, EventMessage, ActorUsername, ActingProcessFileInternalName\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Detects Windows executable with unexpected extension.'\n", "techniques": ["T1204", "T1036"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Analytic%20Rules/CyberArkEPMUnexpectedExecutableLocation.yaml", "query_name": "CyberArkEPM - Unexpected executable location", "query": "let susp_exe_folders = dynamic([@'\\tmp\\', @'\\TEMP\\', @'/tmp/', @'\\Users\\Public\\', @'\\$Recycle.bin', @'\\Windows\\Fonts\\', @'$']);\nCyberArkEPM\n| where EventSubType != 'AttackAttempt'\n| where ActingProcessName has_any (susp_exe_folders)\n| project EventEndTime, EventMessage, ActorUsername, ActingProcessFileInternalName\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Detects program run from unexpected location.'\n", "techniques": ["T1204", "T1036"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMElevationRequests.yaml", "query_name": "CyberArkEPM - Elevation requests", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where EventSubType =~ 'ElevationRequest'\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Query shows elevation requests.'\n", "techniques": ["T1204", "T1078"], "tactics": ["Execution", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMPowershellDownloads.yaml", "query_name": "CyberArkEPM - Powershell downloads", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where ActingProcessFileInternalName =~ 'powershell.exe'\n| where ActingProcessCommandLine has_any ('WebClient', 'DownloadString', 'DownloadFile')\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Query shows powershell downloads.'\n", "techniques": ["T1204", "T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMPowershellExecutionParameters.yaml", "query_name": "CyberArkEPM - Powershell scripts execution parameters", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where ActingProcessFileInternalName =~ 'powershell.exe'\n| summarize count() by ActorUsername, ActingProcessCommandLine\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Query shows powershell scripts execution parameters.'\n", "techniques": ["T1204", "T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMProcessesAccessedInternet.yaml", "query_name": "CyberArkEPM - Processes with Internet access attempts", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where EventSubType in~ ('DetectAccessInternet', 'Internet')\n| summarize count() by ActingProcessFileInternalName, ActorUsername\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Query shows processes which attempted to access Internet.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMProcessesRunAsAdmin.yaml", "query_name": "CyberArkEPM - Processes run as admin", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where UserIsAdmin == true\n| summarize count() by ActingProcessName, ActingProcessCommandLine, ActorUsername\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Query shows processes run as admin.'\n", "techniques": ["T1204", "T1078"], "tactics": ["Execution", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMProcessNewHash.yaml", "query_name": "CyberArkEPM - Process hash changed", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where isnotempty(Hash)\n| summarize hashes = makeset(Hash) by ActingProcessFileInternalName\n| where array_length(hashes) > 1\n| extend FileCustomEntity = ActingProcessFileInternalName\n", "attributes": {"description": "'Query shows processes which hash has been changed recently.'\n", "techniques": ["T1036"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMRareProcessesRunByUsers.yaml", "query_name": "CyberArkEPM - Rare process run by users", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where isnotempty(ActingProcessFileInternalName)\n| summarize count() by ActingProcessFileInternalName, ActorUsername\n| top 25 by count_ asc\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Query shows rare process run by users.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMRareProcVendors.yaml", "query_name": "CyberArkEPM - Rare process vendors", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where isnotempty(ActingProcessFileCompany)\n| summarize count() by ActingProcessFileCompany, ActingProcessFileInternalName\n| top 25 by count_ asc\n| extend ProcCustomEntity = ActingProcessFileCompany\n", "attributes": {"description": "'Query shows rare process vendors.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMScriptsExecuted.yaml", "query_name": "CyberArkEPM - Scripts executed on hosts", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where AppType =~ 'Script'\n| project EventStartTime, EventEndTime, EventMessage, ActingProcessFileInternalName, Hash, ActorUsername, EventSourceName\n| extend FileCustomEntity = ActingProcessFileInternalName, AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Query shows scripts which where executed on hosts.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CyberArkEPM/Hunting%20Queries/CyberArkEPMSuspiciousActivityAttempts.yaml", "query_name": "CyberArkEPM - Suspicious activity attempts", "query": "CyberArkEPM\n| where TimeGenerated > ago(24h)\n| where EventSubType =~ 'SuspiciousActivityAttempt'\n| extend AccountCustomEntity = ActorUsername\n", "attributes": {"description": "'Query shows suspicious activity attempts.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Cyberpion/Analytic%20Rules/HighUrgencyActionItems.yaml", "query_name": "High Urgency Cyberpion Action Items", "query": "let timeframe = 14d;\nlet time_generated_bucket = 1h;\nlet min_urgency = 9;\nlet maxTimeGeneratedBucket = toscalar(\n   CyberpionActionItems_CL\n   | where TimeGenerated > ago(timeframe)\n   | summarize max(bin(TimeGenerated, time_generated_bucket))\n   );\nCyberpionActionItems_CL\n | where TimeGenerated > ago(timeframe) and is_open_b == true\n | where bin(TimeGenerated, time_generated_bucket) == maxTimeGeneratedBucket\n | where urgency_d >= min_urgency\n | extend timestamp = opening_datetime_t\n | extend DNSCustomEntity = host_s\n", "attributes": {"description": "'This query creates an alert for active Cyberpion Action Items with high urgency (9-10).\n Urgency can be altered using the \"min_urgency\" variable in the query.'\n", "techniques": ["T1190", "T1195"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CybersecurityMaturityModelCertification%28CMMC%292.0/Analytic%20Rules/CMMC2.0Level1FoundationalPosture.yaml", "query_name": "CMMC 2.0 Level 1 (Foundational) Readiness Posture", "query": "SecurityRegulatoryCompliance\n| where ComplianceStandard == \"NIST-SP-800-171-R2\"\n| extend Level=iff(ComplianceControl in (\"3.1.1\",\"3.1.2\",\"3.1.20\",\"3.1.22\",\"3.4.1\",\"3.5.2\",\"3.5.2\",\"3.8.3\",\"3.13.1\",\"3.13.5\",\"3.14.1\",\"3.14.2\",\"3.14.4\",\"3.14.5\"), \"Level 1: Foundational\",\"Level 2: Advanced\")\n| where Level == \"Level 1: Foundational\"\n| summarize arg_max(TimeGenerated, *) by RecommendationName, AssessedResourceId, Level\n| summarize Failed=countif(State==\"Failed\"),Passed=countif(State==\"Passed\"),Total=countif(State==\"Passed\" or State == \"Failed\") by Level\n|extend PassedControlsPercentage = (Passed/todouble(Total))*100\n| where PassedControlsPercentage < 70 \n//Adjust Either Passed Thresholds within Organizational Needs\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22')\n| project Level, Total, PassedControlsPercentage, Passed, Failed, RemediationLink, LastObserved=now()\n| extend URLCustomEntity = RemediationLink\n", "attributes": {"description": "'CMMC 2.0 Level 1 (Foundational) assessments have deviated from configured threshold baselines. This alert is triggered when CMMC2.0 policy compliance is assessed below 70% compliance in 7 days.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/CybersecurityMaturityModelCertification%28CMMC%292.0/Analytic%20Rules/CMMC2.0Level2AdvancedPosture.yaml", "query_name": "CMMC 2.0 Level 2 (Advanced) Readiness Posture", "query": "SecurityRegulatoryCompliance\n| where ComplianceStandard == \"NIST-SP-800-171-R2\"\n| extend Level=iff(ComplianceControl in (\"3.1.1\",\"3.1.2\",\"3.1.20\",\"3.1.22\",\"3.4.1\",\"3.5.2\",\"3.5.2\",\"3.8.3\",\"3.13.1\",\"3.13.5\",\"3.14.1\",\"3.14.2\",\"3.14.4\",\"3.14.5\"), \"Level 1: Foundational\",\"Level 2: Advanced\")\n| where Level == \"Level 2: Advanced\"\n| summarize arg_max(TimeGenerated, *) by RecommendationName, AssessedResourceId, Level\n|summarize Failed=countif(State==\"Failed\"),Passed=countif(State==\"Passed\"),Total=countif(State==\"Passed\" or State == \"Failed\") by Level\n|extend PassedControlsPercentage = (Passed/todouble(Total))*100\n| where PassedControlsPercentage < 70 \n//Adjust Either Passed Thresholds within Organizational Needs\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22')\n| project Level, Total, PassedControlsPercentage, Passed, Failed, RemediationLink, LastObserved=now()\n| extend URLCustomEntity = RemediationLink\n", "attributes": {"description": "'CMMC 2.0 Level 2 (Advanced) assessments have deviated from configured threshold baselines. This alert is triggered when CMMC2.0 policy compliance is assessed below 70% compliance in 7 days.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Darktrace/Analytic%20Rules/CreateAlertFromModelBreach.yaml", "query_name": "Darktrace Model Breach", "query": "darktrace_model_alerts_CL\n| where dtProduct_s ==\"Policy Breach\"\n| extend EventCount = 1\n| extend EventType = \"NetworkSession\"\n| extend EventSchema = \"NetworkSession\"\n| extend EventSchemaVersion = \"0.2.2\"\n| extend EventResult = \"Success\"\n| extend DvcAction = \"Allow\"\n| project-rename EventSeverity=score_d\n| extend EventVendor = \"Darktrace\"\n| extend EventProduct = \"Enterprise Immune System\"\n| project-rename  EventStartTime = breachTime_s\n| extend EventEndTime = EventStartTime\n| project-rename NetworkRuleName=modelName_s\n| project-rename NetworkRuleNumber=pid_d\n| extend Rule = \"NetworkRuleNumber\"\n| project-rename ThreatId=threatID_d\n| extend ThreatName = NetworkRuleName\n| project-rename ThreatCategory=dtProduct_s\n| extend ThreatRiskLevel=EventSeverity\n| project-rename SrcIPAddr=SourceIP\n| project-rename SrcHostname=sourceHost_s\n| project-rename SrcMacAddr=sourceMac_s\n| project-rename SrcPortNumber=sourcePort_s\n| project-rename DstIpAddr=destIP_s\n| project-rename DstPortNumber=destPort_s\n| project-rename DstHostname=destHost_s\n| project-rename DstMacAddr=destMac_s\n", "attributes": {"description": "'This rule creates Microsoft Sentinel Alerts based on Darktrace Model Breaches, fetched every 5 minutes.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Darktrace/Analytic%20Rules/CreateAlertFromSystemStatus.yaml", "query_name": "Darktrace System Status", "query": "darktrace_model_alerts_CL\n| where dtProduct_s ==\"System Alert\"\n| extend EventVendor = \"Darktrace\"\n| extend EventProduct = \"Enterprise Immune System\"\n", "attributes": {"description": "'This rule creates Microsoft Sentinel Alerts based on Darktrace system status alerts for health monitoring, fetched every 5 minutes.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Darktrace/Analytic%20Rules/CreateIncidentFromAIAnalystIncident.yaml", "query_name": "Darktrace AI Analyst", "query": "darktrace_model_alerts_CL\n| where dtProduct_s == \"AI Analyst\"\n| project-rename  EventStartTime=startTime_s\n| project-rename EventEndTime = endTime_s\n| project-rename NetworkRuleName=title_s\n| project-rename CurrentGroup=externalId_g //externalId is the Current Group ID from Darktrace \n| project-rename ThreatCategory=dtProduct_s\n| extend ThreatRiskLevel=score_d //This is the event score, which is different from the GroupScore\n| project-rename SrcHostname=hostname_s\n| project-rename DarktraceLink=url_s\n| project-rename Summary=summary_s\n| project-rename GroupScore=groupScore_d\n| project-rename GroupCategory=groupCategory_s\n| project-rename SrcDeviceName=bestDeviceName_s\n", "attributes": {"description": "'This rule creates Microsoft Sentinel Incidents based on Darktrace AI Analyst Incidents, fetched every 5 minutes.'\n", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DEV-0537DetectionandHunting/Hunting%20Queries/Empty.yaml", "query_name": "test", "query": "test\n", "attributes": {"description": "'test'\n", "techniques": ["T1190", "T1133"], "tactics": ["Test"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Digital%20Shadows/Analytic%20Rules/Digital_Shadows_incident_creation_exclude.yaml", "query_name": "Digital Shadows Incident Creation for exclude-app", "query": "let DSSearchLight_view  = view () { DigitalShadows_CL | where app_s == \"exclude\" | extend EventVendor=\"Digital Shadows\", EventProduct=\"SearchLight\",Type=\"DigitalShadows_CL\",EventStartTime=raised_t,EventMessage=title_s,EventOriginalUid=triage_id_g,EventOriginalType=classification_s | extend EventOriginalSeverity=iif(isempty(risk_level_s), risk_assessment_risk_level_s, risk_level_s) | extend EventSeverity = case(EventOriginalSeverity == 'none', 'Informational', EventOriginalSeverity == 'very-low', 'Low',EventOriginalSeverity == 'low', 'Low',EventOriginalSeverity == 'medium', 'Medium',EventOriginalSeverity == 'high', 'High',EventOriginalSeverity == 'very-high', 'High','Informational') | extend EventReportUrl=iif(isempty(id_d), strcat('https://portal-digitalshadows.com/triage/alerts/',portal_id_s),strcat('https://portal-digitalshadows.com/triage/alert-incidents/',id_d)) | extend AdditionalFields = pack(\"assets\", assets_s, \"comments\", comments_s, \"description\", description_s, \"incident_id\", id_d, \"alert_id\", id_g, \"short_code\", portal_id_s, \"impact\", impact_description_s, \"mitigation\", mitigation_s, \"risk_factors\", risk_factors_s, \"triage_status\", status_s, \"triage_id\", triage_id_g, \"triage_raised\", triage_raised_time_t,\"triage_updated\", triage_updated_time_t, \"updated\", updated_t) | project TimeGenerated, EventVendor,EventProduct, Type, EventStartTime,EventMessage, EventOriginalUid, EventOriginalType,EventOriginalSeverity, EventSeverity, EventReportUrl,AdditionalFields};DSSearchLight_view | summarize arg_max(TimeGenerated, *) by EventOriginalUid | extend description = AdditionalFields.description | extend impact = AdditionalFields.impact | extend mitigation = AdditionalFields.mitigation | extend status = AdditionalFields.triage_status | extend comments = AdditionalFields.comments", "attributes": {"description": "Digital Shadows Analytic rule for generating Sentinel incidents for the data ingested by app polling for excluded classifications", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Digital%20Shadows/Analytic%20Rules/Digital_Shadows_incident_creation_include.yaml", "query_name": "Digital Shadows Incident Creation for include-app", "query": "let DSSearchLight_view  = view () { DigitalShadows_CL | where app_s == \"include\" | extend EventVendor=\"Digital Shadows\", EventProduct=\"SearchLight\",Type=\"DigitalShadows_CL\",EventStartTime=raised_t,EventMessage=title_s,EventOriginalUid=triage_id_g,EventOriginalType=classification_s | extend EventOriginalSeverity=iif(isempty(risk_level_s), risk_assessment_risk_level_s, risk_level_s) | extend EventSeverity = case(EventOriginalSeverity == 'none', 'Informational', EventOriginalSeverity == 'very-low', 'Low',EventOriginalSeverity == 'low', 'Low',EventOriginalSeverity == 'medium', 'Medium',EventOriginalSeverity == 'high', 'High',EventOriginalSeverity == 'very-high', 'High','Informational') | extend EventReportUrl=iif(isempty(id_d), strcat('https://portal-digitalshadows.com/triage/alerts/',portal_id_s),strcat('https://portal-digitalshadows.com/triage/alert-incidents/',id_d)) | extend AdditionalFields = pack(\"assets\", assets_s, \"comments\", comments_s, \"description\", description_s, \"incident_id\", id_d, \"alert_id\", id_g, \"short_code\", portal_id_s, \"impact\", impact_description_s, \"mitigation\", mitigation_s, \"risk_factors\", risk_factors_s, \"triage_status\", status_s, \"triage_id\", triage_id_g, \"triage_raised\", triage_raised_time_t,\"triage_updated\", triage_updated_time_t, \"updated\", updated_t) | project TimeGenerated, EventVendor,EventProduct, Type, EventStartTime,EventMessage, EventOriginalUid, EventOriginalType,EventOriginalSeverity, EventSeverity, EventReportUrl,AdditionalFields};DSSearchLight_view | summarize arg_max(TimeGenerated, *) by EventOriginalUid | extend description = AdditionalFields.description | extend impact = AdditionalFields.impact | extend mitigation = AdditionalFields.mitigation | extend status = AdditionalFields.triage_status | extend comments = AdditionalFields.comments", "attributes": {"description": "Digital Shadows Analytic rule for generating Sentinel incidents for the data ingested by app polling for included classifications", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianClassifiedDataInsecureTransfer.yaml", "query_name": "Digital Guardian - Sensitive data transfer over insecure channel", "query": "DigitalGuardianDLPEvent\n| where isnotempty(MatchedPolicies)\n| where isnotempty(inspected_document)\n| where NetworkApplicationProtocol =~ 'HTTP'\n| extend AccountCustomEntity = SrcUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects sensitive data transfer over insecure channel.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianExfiltrationOverDNS.yaml", "query_name": "Digital Guardian - Exfiltration using DNS protocol", "query": "DigitalGuardianDLPEvent\n| where DstPortNumber == 53\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects exfiltration using DNS protocol.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianExfiltrationToFileShareServices.yaml", "query_name": "Digital Guardian - Exfiltration to online fileshare", "query": "let threshold = 10;\nDigitalGuardianDLPEvent\n| where isnotempty(inspected_document)\n| where http_url contains 'dropbox' or http_url contains 'mega.nz'\n| summarize f = dcount(inspected_document) by SrcUserName, bin(TimeGenerated, 30m)\n| where f >= threshold\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects exfiltration to online fileshare.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianFileSentToExternal.yaml", "query_name": "Digital Guardian - Exfiltration to private email", "query": "DigitalGuardianDLPEvent\n| where NetworkApplicationProtocol =~ 'SMTP'\n| where isnotempty(inspected_document)\n| extend s_user = substring(SrcUserName, 0, indexof(SrcUserName, '@'))\n| extend d_user = substring(DstUserName, 0, indexof(DstUserName, '@'))\n| extend s_domain = extract(@'@(.*)', 1, SrcUserName)\n| extend d_domain = extract(@'@(.*)', 1, DstUserName)\n| where s_domain != d_domain\n| where s_user == d_user\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects exfiltration to private email.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianFileSentToExternalDomain.yaml", "query_name": "Digital Guardian - Exfiltration to external domain", "query": "let corp_domain = dynamic(['example.com']);     //add all corporate domains to this list\nDigitalGuardianDLPEvent\n| where NetworkApplicationProtocol =~ 'SMTP'\n| where isnotempty(inspected_document)\n| extend s_domain = extract(@'@(.*)', 1, SrcUserName)\n| extend d_domain = extract(@'@(.*)', 1, DstUserName)\n| where s_domain in~ (corp_domain)\n| where d_domain !in (corp_domain)\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects exfiltration to external domain.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianFilesSentToExternalDomain.yaml", "query_name": "Digital Guardian - Bulk exfiltration to external domain", "query": "let threshold = 10;\nlet corp_domain = dynamic(['example.com']);\nDigitalGuardianDLPEvent\n| where NetworkApplicationProtocol =~ 'SMTP'\n| where isnotempty(inspected_document)\n| extend s_domain = extract(@'@(.*)', 1, SrcUserName)\n| extend d_domain = extract(@'@(.*)', 1, DstUserName)\n| where s_domain in~ (corp_domain)\n| where d_domain !in (corp_domain)\n| summarize f = dcount(inspected_document) by SrcUserName, DstUserName, bin(TimeGenerated, 30m)\n| where  f >= threshold\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects bulk exfiltration to external domain.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianMultipleIncidentsFromUser.yaml", "query_name": "Digital Guardian - Multiple incidents from user", "query": "let threshold = 2;\nDigitalGuardianDLPEvent\n| where isnotempty(MatchedPolicies)\n| summarize count() by SrcUserName, bin(TimeGenerated, 30m)\n| where count_ >= threshold\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects multiple incidents from user.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianPossibleProtocolAbuse.yaml", "query_name": "Digital Guardian - Possible SMTP protocol abuse", "query": "DigitalGuardianDLPEvent\n| where NetworkApplicationProtocol =~ 'SMTP'\n| where DstPortNumber != 25\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects possible SMTP protocol abuse.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianUnexpectedProtocol.yaml", "query_name": "Digital Guardian - Unexpected protocol", "query": "DigitalGuardianDLPEvent\n| where DstPortNumber == 3389\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects RDP protocol usage for data transfer which is not common.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Analytic%20Rules/DigitalGuardianViolationNotBlocked.yaml", "query_name": "Digital Guardian - Incident with not blocked action", "query": "DigitalGuardianDLPEvent\n| where isnotempty(IncidentStatus)\n| extend inc_act = split(IncidentStatus, ',')\n| where inc_act has 'New'\n| where inc_act !contains 'Block'\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects when incident has not block action.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianDomains.yaml", "query_name": "Digital Guardian - Incident domains", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(http_url)\n| extend u = parse_url(http_url)\n| extend domain=u.Host\n| summarize count() by tostring(domain), SrcUserName\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for incident domains.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianFilesSentByUsers.yaml", "query_name": "Digital Guardian - Files sent by users", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(inspected_document)\n| summarize Files = makeset(inspected_document) by SrcUserName\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for files sent by users.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianIncidentsByUser.yaml", "query_name": "Digital Guardian - Users' incidents", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(IncidentStatus)\n| where inc_act has 'New'\n| summarize makeset(IncidentsUrl) by SrcUserName\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for users' incidents.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianInsecureProtocolSources.yaml", "query_name": "Digital Guardian - Insecure file transfer sources", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| where NetworkApplicationProtocol in~ ('HTTP', 'FTP')\n| project SrcUserName, SrcIpAddr, DstIpAddr, DstPortNumber, File=inspected_document\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for insecure file transfer sources.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianInspectedFiles.yaml", "query_name": "Digital Guardian - Inspected files", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(inspected_document)\n| project SrcUserName, DstUserName, File=inspected_document, MatchedPolicies\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for inspected files.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianNewIncidents.yaml", "query_name": "Digital Guardian - New incidents", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(IncidentStatus)\n| extend inc_act = split(IncidentStatus, ',')\n| where inc_act has 'New'\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for new incidents.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianRareDestinationPorts.yaml", "query_name": "Digital Guardian - Rare destination ports", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| summarize count() by DstIpAddr, DstPortNumber\n| order by count_ asc\n| top 10 by count_\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for rare destination ports.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianRareNetworkProtocols.yaml", "query_name": "Digital Guardian - Rare network protocols", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(NetworkApplicationProtocol)\n| summarize count() by SrcIpAddr, SrcUserName\n| order by count_ asc\n| top 10 by count_\n| extend AccountCustomEntity = SrcUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches rare network protocols.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianRareUrls.yaml", "query_name": "Digital Guardian - Rare Urls", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(http_url)\n| summarize count() by SrcUserName, http_url\n| order by count_ asc\n| top 10 by count_\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for rare Urls.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/DigitalGuardianDLP/Hunting%20Queries/DigitalGuardianUrlByUser.yaml", "query_name": "Digital Guardian - Urls used", "query": "DigitalGuardianDLPEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(http_url)\n| project SrcUserName, DstUserName, URL=http_url, MatchedPolicies\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for URLs used.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Dynamics%20365/Analytic%20Rules/DynamicsEncryptionSettingsChanged.yaml", "query_name": "Dynamics Encryption Settings Changed", "query": "Dynamics365Activity\n| extend Message = tostring(split(OriginalObjectId, ' ')[0])\n| where Message =~ 'IsDataEncryptionActive'\n| project-reorder TimeGenerated, Message, UserId, ClientIP, InstanceUrl, UserAgent\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP\n", "attributes": {"description": "'This query looks for changes to the Data Encryption settings for Dynamics 365.\nReference: https://docs.microsoft.com/microsoft-365/compliance/office-365-encryption-in-microsoft-dynamics-365'\n", "techniques": ["T1600"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Dynamics%20365/Analytic%20Rules/MassExportOfDynamicstoExcel.yaml", "query_name": "Mass Export of Dynamics 365 Records to Excel", "query": "let baseline_time = 7d;\nlet detection_time = 1d;\nDynamics365Activity\n| where TimeGenerated between(ago(baseline_time)..ago(detection_time-1d))\n| where OriginalObjectId contains 'ExportToExcel'\n| extend numQueryCount = todouble(QueryResults)\n| extend QueryCount = iif(QueryResults contains \",\", todouble(countof(tostring(QueryResults), ',') + 1), numQueryCount)\n| extend QueryCount = iif(isnotempty(QueryCount), QueryCount, double(1))\n| summarize sum(QueryCount) by UserId\n| extend HistoricalBaseline = sum_QueryCount\n| join (Dynamics365Activity\n| where TimeGenerated > ago(detection_time)\n| where OriginalObjectId contains 'ExportToExcel'\n| extend numQueryCount = todouble(QueryResults)\n| extend QueryCount = iif(QueryResults contains \",\", todouble(countof(tostring(QueryResults), ',') + 1), numQueryCount)\n| extend QueryCount = iif(isnotempty(QueryCount), QueryCount, double(1))\n| summarize sum(QueryCount) by UserId\n| extend CurrentExportRate = sum_QueryCount) on UserId\n| where CurrentExportRate > HistoricalBaseline\n| project UserId, HistoricalBaseline, CurrentExportRate\n| join kind=inner(Dynamics365Activity\n| where TimeGenerated > ago(detection_time)\n| where OriginalObjectId contains 'ExportToExcel'\n| extend numQueryCount = todouble(QueryResults)\n| extend QueryCount = iif(QueryResults contains \",\", todouble(countof(tostring(QueryResults), ',') + 1), numQueryCount)\n| extend QueryCount = iif(isnotempty(QueryCount), QueryCount, double(1))) on UserId\n| project TimeGenerated, UserId, QueryCount, UserAgent, OriginalObjectId, ClientIP, HistoricalBaseline, CurrentExportRate, CorrelationId, CrmOrganizationUniqueName\n| summarize QuerySizes = make_set(QueryCount), MostRecentQuery = max(TimeGenerated), IPs = make_set(ClientIP), UserAgents = make_set(UserAgent) by UserId, CrmOrganizationUniqueName, HistoricalBaseline, CurrentExportRate\n| extend timestamp = MostRecentQuery, AccountCustomEntity = UserId\n", "attributes": {"description": "'The query detects user exporting a large amount of records from Dynamics 365 to Excel, significantly more records exported than any other recent activity by that user.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Dynamics%20365/Analytic%20Rules/NewDynamicsAdminActivity.yaml", "query_name": "New Dynamics 365 Admin Activity", "query": "let baseline_time = 14d;\nlet detection_time = 1h;\nDynamics365Activity\n| where TimeGenerated between(ago(baseline_time)..ago(detection_time))\n| where UserType =~ 'admin'\n| extend Message = tostring(split(OriginalObjectId, ' ')[0])\n| summarize by UserId\n| join kind=rightanti\n(Dynamics365Activity\n| where TimeGenerated > ago(detection_time)\n| where UserType =~ 'admin')\non UserId\n| summarize Actions = make_set(Message), MostRecentAction = max(TimeGenerated), IPs=make_set(ClientIP), UserAgents = make_set(UserAgent) by UserId\n| extend timestamp = MostRecentAction, AccountCustomEntity = UserId\n", "attributes": {"description": "'Detects users conducting administrative activity in Dynamics 365 where they have not had admin rights before.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Dynamics%20365/Analytic%20Rules/NewDynamicsUserAgent.yaml", "query_name": "New Dynamics 365 User Agent", "query": "let lookback = 14d;\nlet timeframe = 1d;\nlet user_accounts = \"(([a-zA-Z]{1,})\\\\.([a-zA-Z]{1,}))@.*\";\nlet known_useragents = dynamic([]);\nDynamics365Activity\n| where TimeGenerated between(ago(lookback)..ago(timeframe))\n| where isnotempty(UserAgent)\n| summarize by UserAgent, UserId\n| join kind = rightanti (Dynamics365Activity\n| where TimeGenerated > ago(timeframe)\n| where isnotempty(UserAgent)\n| where UserAgent !in~ (known_useragents)\n| where UserAgent !hasprefix \"azure-logic-apps\" and UserAgent !hasprefix \"PowerApps\"\n| where UserId matches regex user_accounts)\non UserAgent, UserId\n// Uncomment this section to exclude user agents with a rendering engine, indicating browsers.\n//| join kind = leftanti(\n//Dynamics365Activity\n//| where TimeGenerated between(ago(lookback)..ago(timeframe))\n//| where UserAgent has_any (\"Gecko\", \"WebKit\", \"Presto\", \"Trident\", \"EdgeHTML\", \"Blink\")) on UserAgent\n| summarize FirstSeen = min(TimeGenerated), IPs = make_set(ClientIP) by UserAgent, UserId\n| extend timestamp = FirstSeen, AccountCustomEntity = UserId\n", "attributes": {"description": "'Detects users accessing Dynamics from a User Agent that has not been seen the 14 days. Has configurable filter for known good user agents such as PowerApps. Also includes optional section to exclude User Agents to indicate a browser being used.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Dynamics%20365/Analytic%20Rules/NewOfficeUserAgentinDynamics.yaml", "query_name": "New Office User Agent in Dynamics 365", "query": "let timeframe = 1h;\nlet lookback = 7d;\nlet known_useragents = dynamic([]);\nDynamics365Activity\n| where TimeGenerated > ago(timeframe)\n| extend Message = tostring(split(OriginalObjectId, ' ')[0])\n| where Message =~ \"UserSignIn\"\n| extend IPAddress = tostring(split(ClientIP, \":\")[0])\n| where isnotempty(UserAgent)\n// Exclude user agents with a render agent to reduce noise\n| where UserAgent has_any (\"Gecko\", \"WebKit\", \"Presto\", \"Trident\", \"EdgeHTML\", \"Blink\")\n| join kind=leftanti(\nOfficeActivity\n| where TimeGenerated > ago(lookback)\n| where UserAgent !in~ (known_useragents))\non UserAgent\n| summarize MostRecentActivity=max(TimeGenerated), IPs=make_set(IPAddress), Users=make_set(UserId), Actions=make_set(OriginalObjectId) by UserAgent\n| extend timestamp = MostRecentActivity\n", "attributes": {"description": "'Detects users accessing Dynamics from a User Agent that has not been seen in any Office 365 workloads in the last 7 days. Has configurable filter for known good user agents such as PowerApps.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Dynamics%20365/Analytic%20Rules/UserBulkRetreivalOutsideNormalActivity.yaml", "query_name": "Dynamics 365 - User Bulk Retrieval Outside Normal Activity", "query": "let baseline_time = 14d;\nlet detection_time = 1d;\nDynamics365Activity\n| where TimeGenerated between(ago(baseline_time)..ago(detection_time-1d))\n| extend Message = tostring(split(OriginalObjectId, ' ')[0])\n| where Message =~ \"RetrieveMultiple\"\n| extend numQueryCount = todouble(QueryResults)\n| extend QueryCount = iif(QueryResults contains \",\", todouble(countof(tostring(QueryResults), ',') + 1), numQueryCount)\n| extend QueryCount = iif(isnotempty(QueryCount), QueryCount, double(1))\n| summarize sum(QueryCount) by UserId\n| extend HistoricalBaseline = sum_QueryCount\n| join (Dynamics365Activity\n| where TimeGenerated > ago(detection_time)\n| extend Message = tostring(split(OriginalObjectId, ' ')[0])\n| where Message =~ \"RetrieveMultiple\"\n| extend numQueryCount = todouble(QueryResults)\n| extend QueryCount = iif(QueryResults contains \",\", todouble(countof(tostring(QueryResults), ',') + 1), numQueryCount)\n| extend QueryCount = iif(isnotempty(QueryCount), QueryCount, double(1))\n| summarize sum(QueryCount) by UserId\n| extend CurrentExportRate = sum_QueryCount) on UserId\n| where CurrentExportRate > HistoricalBaseline\n| project UserId, HistoricalBaseline, CurrentExportRate\n| join kind=inner(Dynamics365Activity\n| where TimeGenerated > ago(detection_time)\n| extend Message = tostring(split(OriginalObjectId, ' ')[0])\n| where Message =~ \"RetrieveMultiple\"\n| extend numQueryCount = todouble(QueryResults)\n| extend QueryCount = iif(QueryResults contains \",\", todouble(countof(tostring(QueryResults), ',') + 1), numQueryCount)\n| extend QueryCount = iif(isnotempty(QueryCount), QueryCount, double(1))) on UserId\n| project TimeGenerated, UserId, QueryCount, UserAgent, Message, ClientIP, HistoricalBaseline, CurrentExportRate, CorrelationId, CrmOrganizationUniqueName, Query\n| summarize QuerySizes = make_set(QueryCount), MostRecentQuery = max(TimeGenerated), IPs = make_set(ClientIP), UserAgents = make_set(UserAgent), make_set(Query) by UserId, CrmOrganizationUniqueName, HistoricalBaseline, CurrentExportRate\n| extend timestamp = MostRecentQuery, AccountCustomEntity = UserId\n", "attributes": {"description": "'This query detects users retrieving significantly more records from Dynamics 365 than they have in the past 2 weeks. This could indicate potentially unauthorized access to data within Dynamics 365.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Dynamics%20365/Hunting%20Queries/DynamicsActivityAfterAADAlert.yaml", "query_name": "Dynamics 365 Activity After Azure AD Alerts", "query": "let match_window = 1h;\nlet analysis_window = 1d;\nlet lookback_window = 7d;\nSecurityAlert\n| where TimeGenerated > ago(analysis_window)\n| where ProviderName == 'IPC'\n| extend UserName = tostring(parse_json(ExtendedProperties).[\"User Account\"])\n| extend UserName = tolower(UserName)\n| extend TimeKey = bin(TimeGenerated, match_window)\n| join kind=inner(Dynamics365Activity\n| where TimeGenerated > ago(analysis_window)\n| extend UserName = tolower(UserId)\n| extend TimeKey = bin(TimeGenerated, match_window))\non UserName, TimeKey\n| join kind=leftanti(Dynamics365Activity\n| where TimeGenerated between(ago(lookback_window)..ago(analysis_window))\n| extend UserName = tolower(UserId))\non UserName, OriginalObjectId\n| summarize Actions = make_set(OriginalObjectId), MostRecentAction = max(TimeGenerated1), IPs = make_set(split(tostring(ClientIP), ':')[0]), AADAlerts=make_set(Description), MostRecentAlert = max(TimeGenerated) by UserName\n| extend timestamp = MostRecentAction, AccountCustomEntity = UserName\n", "attributes": {"description": "'This hunting query looks for users conducting Dynamics 365 activity shortly after Azn Azure AD Identity Protection alert for that user. The query only looks for users not seen before or conducting Dynamics activity not previously seen.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Dynamics%20365/Hunting%20Queries/DynamicsActivityAfterFailedLogons.yaml", "query_name": "Dynamics 365 Activity After Failed Logons", "query": "let threshold = 10;\nSigninLogs\n| where ResultType in (\"50125\", \"50140\", \"70043\", \"70044\")\n| summarize count() by IPAddress\n| where count_ >= threshold\n| join (Dynamics365Activity\n| extend IPAddress = tostring(split(ClientIP, \":\")[0]))\non IPAddress\n| project-rename FailedLogonCount = count_\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = IPAddress\n", "attributes": {"description": "'This hunting query looks for users conducting Dynamics 365 activity shortly after a number of failed logons. Use this to look for potential post brute force activity. Adjust the threshold figure based on false positive rate.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/EatonForeseer/Analytic%20Rules/EatonUnautorizedLogins.yaml", "query_name": "EatonForeseer - Unauthorized Logins", "query": "SecurityEvent\n// Look for all events relating to user logins\n| where EventID in (4624,4625,4648,4675,4634,4647)\n| where AccountType == \"User\"\n// Filter for data present\n| where isnotempty(TargetUserName)\n// Look for all events that relate to the Eaton Foreseer application\n| where ProcessName has \"Foreseer\"\n// Ignore known user accounts (please edit based on your allowed users)\n| where TargetUserName !in (\"janedoe\", \"johndoe\")\n// De-duplicate multiple entries for the same user accessing a particular device\n| summarize TimeGenerated=arg_min(TimeGenerated, *) by TargetUserName, Computer\n| project\n    TimeGenerated,\n    IPCustomEntity = IpAddress,\n    HostCustomEntity = Computer,\n    UserEntity = TargetUserName,\n    Process,\n    ProcessName\n", "attributes": {"description": "'Detects Unauthorized Logins into Eaton Foreseer'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Eset%20Security%20Management%20Center/Analytic%20Rules/eset-sites-blocked.yaml", "query_name": "Web sites blocked by Eset", "query": "eset_CL\n| where event_type_s == 'FilteredWebsites_Event'\n| extend AccountCustomEntity = username_s, URLCustomEntity = object_uri_s, HostCustomEntity = hostname_s, IPCustomEntity = ipv4_s\n", "attributes": {"description": "'Create alert on web sites blocked by Eset.'\n", "techniques": NaN, "tactics": ["Exfiltration", "CommandAndControl", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Eset%20Security%20Management%20Center/Analytic%20Rules/eset-threats.yaml", "query_name": "Threats detected by Eset", "query": "eset_CL\n| where event_type_s == \"Threat_Event\"\n| extend HostCustomEntity = hostname_s, AccountCustomEntity = username_s, IPCustomEntity = ipv4_s\n", "attributes": {"description": "'Escalates threats detected by Eset.'\n", "techniques": NaN, "tactics": ["Execution", "CredentialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ESETPROTECT/Analytic%20Rules/ESETThreatDetected.yaml", "query_name": "Threats detected by ESET", "query": "ESETPROTECT\n| where EventType == \"Threat_Event\"\n| extend HostCustomEntity = DvcHostname, AccountCustomEntity = SrcUserName, IPCustomEntity = DvcIpAddr, FileHashCustomEntity = FileHashSha1, FileHashAlgo = \"SHA1\"\n", "attributes": {"description": "'Escalates threats detected by ESET.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ESETPROTECT/Analytic%20Rules/ESETWebsiteBlocked.yaml", "query_name": "Website blocked by ESET", "query": "ESETPROTECT\n| where EventType == 'FilteredWebsites_Event'\n| extend AccountCustomEntity = SrcUserName, URLCustomEntity = FilePath, HostCustomEntity = DvcHostname, IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Create alert on websites blocked by ESET.'\n", "techniques": ["T1041", "T1071", "T1189", "T1566"], "tactics": ["Exfiltration", "CommandAndControl", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/ASRBypassingWritingExecutableContent.yaml", "query_name": "ASR Bypassing Writing Executable Content", "query": "let timeframe = 1d;\nlet executableExtensions = dynamic([\".js\", \".hta\", \".lnk\", \".application\", \".vb\", \".vba\", \".vbs\", \".ps\", \".ps1\", \".bat\", \".cmd\"]);\nDeviceFileEvents\n| where Timestamp >= ago(timeframe)\n| where InitiatingProcessFileName in~ (\"winword.exe\", \"excel.exe\", \"outlook.exe\", \"powerpnt.exe\")\n| where ActionType == \"FileRenamed\"\n// The mv-apply is less performance compared to doing a full written out !endswith. We kept the mv-apply since We don't hit any limits and get more readable/maintainable code.\n| mv-apply ext=executableExtensions to typeof(string) on\n(\n    where PreviousFileName !endswith ext and FileName endswith ext\n)\n| project-reorder PreviousFileName, FileName\n// Begin allow-list.\n// End allow-list.\n", "attributes": {"description": "The query checks for any file which has been created/written by an Office application and shortly after renamed to one of the deny-listed \"executable extensions\" which are text files. (e.g. ps1, .js, .vbs).\n", "techniques": ["T1211"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/AzureADRareUserAgentAppSignin.yaml", "query_name": "Azure AD Rare UserAgent App Sign-in", "query": "let minimumAppThreshold = 100;\nlet timeframe = 1d;\nlet lookback_timeframe= 7d;\nlet ExtractBrowserTypeFromUA=(ua:string) {\n    // Note: these are in a specific order since, for example, Edge contains \"Chrome/\" and \"Edge/\" strings.\n    case(\n        ua has \"Edge/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Edge\"}),\n        ua has \"Edg/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Edge\"}),\n        ua has \"Trident/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Internet Explorer\"}),\n        ua has \"Chrome/\" and ua has \"Safari/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Chrome\"}),\n        ua has \"Gecko/\" and ua has \"Firefox/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Firefox\"}),\n        not(ua has \"Mobile/\") and ua has \"Safari/\" and ua has \"Version/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Safari\"}),\n        ua startswith \"Dalvik/\" and ua has \"Android\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Android Browser\"}),\n        ua startswith \"MobileSafari//\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Mobile Safari\"}),\n        ua has \"Mobile/\" and ua has \"Safari/\" and ua has \"Version/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Mobile Safari\"}),\n        ua has \"Mobile/\" and ua has \"FxiOS/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"IOS Firefox\"}),\n        ua has \"Mobile/\" and ua has \"CriOS/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"IOS Chrome\"}),\n        ua has \"Mobile/\" and ua has \"WebKit/\", dynamic({\"AgentType\": \"Browser\", \"AgentName\": \"Mobile Webkit\"}),\n        //\n        ua startswith \"Excel/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Excel\"}),\n        ua startswith \"Outlook/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Outlook\"}),\n        ua startswith \"OneDrive/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"OneDrive\"}),\n        ua startswith \"OneNote/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"OneNote\"}),\n        ua startswith \"Office/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Office\"}),\n        ua startswith \"PowerPoint/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"PowerPoint\"}),\n        ua startswith \"PowerApps/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"PowerApps\"}),\n        ua startswith \"SharePoint/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"SharePoint\"}),\n        ua startswith \"Word/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Word\"}),\n        ua startswith \"Visio/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Visio\"}),\n        ua startswith \"Whiteboard/\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Whiteboard\"}),\n        ua =~ \"Mozilla/5.0 (compatible; MSAL 1.0)\", dynamic({\"AgentType\": \"OfficeApp\", \"AgentName\": \"Office Telemetry\"}),\n        //\n        ua has \".NET CLR\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"Dotnet\"}),\n        ua startswith \"Java/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"Java\"}),\n        ua startswith \"okhttp/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"okhttp\"}),\n        ua has \"Drupal/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"Drupal\"}),\n        ua has \"PHP/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"PHP\"}),\n        ua startswith \"curl/\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"curl\"}),\n        ua has \"python-requests\", dynamic({\"AgentType\": \"Custom\", \"AgentName\": \"Python\"}),\n        pack(\"AgentType\",\"Other\",\"AgentName\", extract(@\"^([^/]*)/\",1,ua))\n    )\n};\n// Query to obtain 'simplified' user agents in a given timespan.\nlet QueryUserAgents = (start_time:timespan, end_time:timespan) {\n    union withsource=tbl_name AADNonInteractiveUserSignInLogs, SigninLogs\n    | where TimeGenerated >= ago(start_time)\n    | where TimeGenerated < ago(end_time)\n    | where ResultType == 0  // Only look at succesful logins\n    | extend ParsedUserAgent=ExtractBrowserTypeFromUA(UserAgent)\n    | extend UserAgentType=tostring(ParsedUserAgent.AgentType)\n    | extend UserAgentName=tostring(ParsedUserAgent.AgentName)\n    //| extend SimpleUserAgent=strcat(UserAgentType,\"_\",UserAgentName)\n    | extend SimpleUserAgent=UserAgentType\n    | where not(isempty(UserAgent))\n    | where not(isempty(AppId))\n};\n// Get baseline usage per application.\nlet BaselineUserAgents=materialize(\n    QueryUserAgents(lookback_timeframe+timeframe, timeframe)\n    | summarize RequestCount=count() by AppId, AppDisplayName, SimpleUserAgent\n);\nlet BaselineSummarizedAgents=(\n    BaselineUserAgents\n    | summarize BaselineUAs=make_set(SimpleUserAgent),BaselineRequestCount=sum(RequestCount) by AppId, AppDisplayName\n);\nQueryUserAgents(timeframe, 0d)\n| summarize count() by AppId, AppDisplayName, UserAgent, SimpleUserAgent\n| join kind=leftanti BaselineUserAgents on AppId, AppDisplayName, SimpleUserAgent\n| join BaselineSummarizedAgents on AppId, AppDisplayName\n| where BaselineRequestCount > minimumAppThreshold // Search only for actively used applications.\n// Get back full original requests.\n| join QueryUserAgents(timeframe, 0d) on AppId, UserAgent\n| project-away ParsedUserAgent, UserAgentName\n| project-reorder TimeGenerated, AppDisplayName, UserPrincipalName, UserAgent, BaselineUAs\n// Begin allow-list.\n// End allow-list.\n| summarize count() by UserPrincipalName, AppDisplayName, AppId, UserAgentType, SimpleUserAgent, UserAgent\n", "attributes": {"description": "This query establishes a baseline of the type of UserAgent (i.e. browser, office application, etc) that is typically used for a particular application by looking back for a number of days. \nIt then searches the current day for any deviations from this pattern, i.e. types of UserAgents not seen before in combination with this application.\n", "techniques": ["T1036"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/AzureADUserAgentOSmissmatch.yaml", "query_name": "Azure AD UserAgent OS Missmatch", "query": "let timeframe = 1d;\nlet ExtractOSFromUA=(ua:string) {\n    case(\n        ua has \"Windows NT 6.0\", \"Windows Vista/Windows Server 2008\",\n        ua has \"Windows NT 6.1\", \"Windows 7/Windows Server 2008R2\",\n        ua has \"Windows NT 6.1\", \"Windows 7/Windows Server 2008\",\n        ua has \"Windows NT 6.2\", \"Windows 8/Windows Server 2012\",\n        ua has \"Windows NT 6.3\", \"Windows 8.1/Windows Server 2012R2\",\n        ua has \"Windows NT 10.0\", \"Windows 10\",\n        ua has \"Windows Phone\", \"WindowsPhone\",\n        ua has \"Android\", \"Android\",\n        ua has \"iPhone;\", \"IOS\",\n        ua has \"iPad;\", \"IOS\",\n        ua has \"Polycom/\", \"Polycom\",\n        ua has \"Darwin/\", \"MacOS\",\n        ua has \"Mac OS X\", \"MacOS\",\n        ua has \"macOS\", \"MacOS\",\n        ua has \"ubuntu\", \"Linux\",\n        ua has \"Linux\", \"Linux\",\n        ua has \"curl\", \"CLI\",\n        ua has \"python\", \"CLI\",\n        \"Unknown\"\n    )\n};\n// Query to obtain 'simplified' user agents in a given timespan.\nunion withsource=tbl_name AADNonInteractiveUserSignInLogs, SigninLogs\n| where TimeGenerated >= ago(timeframe)\n| extend UserAgentOS=tolower(ExtractOSFromUA(UserAgent))\n| where not(isempty(UserAgent))\n| where not(isempty(AppId))\n| where ResultType == 0\n| extend DeviceOS=tolower(DeviceDetail_dynamic.operatingSystem)\n| where not(isempty(DeviceOS))\n| where not(UserAgentOS == \"unknown\")\n// Look for matches both ways, since sometimes the browser OS is more specific and sometimes the DeviceOS is more specific.\n| where not(UserAgentOS contains DeviceOS) and not(DeviceOS contains UserAgentOS)\n| where not(DeviceOS == \"ios\" and UserAgentOS == \"macos\") // This can happen for 'request desktop site'\n| where not(DeviceOS == \"android\" and UserAgentOS == \"linux\") // Android and Linux sometimes confused\n| summarize count(), arg_min(TimeGenerated,*) by DeviceOS, UserAgentOS, UserPrincipalName\n// Begin allow-list.\n// End allow-list.\n", "attributes": {"description": "This query extracts the operating system from the UserAgent header and compares this to the DeviceDetail information present in Azure Active Directory.\n", "techniques": ["T1036"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/CertifiedPreOwned-backup-key-1.yaml", "query_name": "Certified Pre-Owned - backup of CA private key - rule 1", "query": "SecurityEvent\n// Fill in the machine name of your CA.\n| where EventID == 5058 and Computer contains \"<YOUR CA MACHINE NAME>\"\n| where EventData contains \"%%2499\" // Machine key.\n| extend EventData=parse_xml(EventData)\n| mv-apply d=EventData.EventData.Data on\n(\n    where d[\"@Name\"]==\"KeyName\"\n    | project KeyName=tostring(d[\"#text\"])\n)\n| mv-apply d=EventData.EventData.Data on\n(\n    where d[\"@Name\"]==\"SubjectUserName\"\n    | project SubjectUserName=tostring(d[\"#text\"])\n)\n| mv-apply d=EventData.EventData.Data on\n(\n    where d[\"@Name\"]==\"Operation\"\n    | project Operation=tostring(d[\"#text\"])\n)\n| extend Operation=iff(Operation == \"%%2458\", \"Read persisted key from file\", Operation)\n// This one is a guess and very poorly documented :(\n| extend Operation=iff(Operation == \"%%2459\", \"Write persisted key to file\", Operation)\n// Fill in the keyname of the CA key.\n| where KeyName == \"<INSERT ISSUING CA KEY HERE>\" // Or any other key you want to monitor.\n", "attributes": {"description": "This query identifies someone that performs a read operation of they CA key from the file.\n", "techniques": ["T1036"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/CertifiedPreOwned-backup-key-2.yaml", "query_name": "Certified Pre-Owned - backup of CA private key - rule 2", "query": "SecurityEvent\n// Fill in the machine name of your CA.\n| where EventID == 5059 and Computer contains \"<YOUR CA MACHINE NAME>\"\n| where EventData contains \"%%2499\" and EventData contains \"%%2464\"\n| extend EventData=parse_xml(EventData)\n| mv-apply d=EventData.EventData.Data on\n(\n    where d[\"@Name\"]==\"KeyName\"\n    | project KeyName=tostring(d[\"#text\"])\n)\n| mv-apply d=EventData.EventData.Data on\n(\n    where d[\"@Name\"]==\"SubjectUserName\"\n    | project SubjectUserName=tostring(d[\"#text\"])\n)\n| parse Account with \"<YOUR DOMAIN NAME>\\\\\" CleanAccount \"$\"\n| where not(Computer startswith CleanAccount)\n", "attributes": {"description": "This query identifies someone that performs a backup of they CA key.\n", "techniques": ["T1036"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/CertifiedPreOwned-TGTs-requested.yaml", "query_name": "Certified Pre-Owned - TGTs requested with certificate authentication", "query": "let timeframe=1h;\nSecurityEvent\n| where TimeGenerated >= ago(timeframe)\n| where EventID == 4768\n| project TimeGenerated, Computer, TargetAccount, EventData=parse_xml(EventData)\n| mv-apply d=EventData.EventData.Data on\n(\n  where d[\"@Name\"]==\"CertIssuerName\"\n  | project CIN=tostring(d[\"#text\"])\n)\n| where not(isempty(CIN))\n// <DECISION - 1>\n// In some environments, we see a lot of certs starting with a sid and containing live.com. Comment out the next line if you have that as well.\n//| where not(CIN startswith \"S-1-\")\n// <DECISION - 2>\n// If you're seeing a significant number of machine accounts, it might be due to 802.1X or SCCM. https://twitter.com/MagnusMOD/status/1407800853088591872?s=20.\n// The following line allows you to filter out all endpoints. This does introduce a blindspot, and you need a custom function which provides data about (on-prem) AD machines.\n// Alternatively, you can use DeviceInfo, if you're ingesting that data from MDE.\n| parse CIN with \"CN=\" MachineName\n//| join kind=leftouter  MyCustomLookupFunction on $left.MachineName == $right.CN\n//| where not(OperatingSystem startswith \"Windows 10\")\n", "attributes": {"description": "This query identifies someone using machine certificates to request Kerberos Ticket Granting Tickets (TGTs).\n", "techniques": ["T1036"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/CertutilIngressToolTransfer.yaml", "query_name": "Ingress Tool Transfer - Certutil", "query": "// Set the time span for the query.\nlet Timeframe = 1h;\n// Set the HashTimeframe for the hash lookup; longer makes it more accurate, but obviously also more resource-intensive.\nlet HashTimeframe = 14d;\n// Get all known SHA1 hashes for certutil executions or renamed files formerly named certutil.\nlet CertUtilPESha1=materialize(DeviceProcessEvents | where Timestamp > ago(HashTimeframe)| where FileName has \"certutil\"  | where isnotempty(SHA1) | summarize sha1=make_set(SHA1));\nlet CertUtilFESha1=materialize(DeviceFileEvents | where Timestamp > ago(HashTimeframe)| where PreviousFileName contains \"certutil\" or FileName contains \"certutil\"  | where isnotempty(SHA1) | summarize sha1=make_set(SHA1));\nDeviceProcessEvents\n| where Timestamp >= ago(Timeframe)\n// Get all executions by processes with a SHA1 hash that is or was named certutil.\n| where SHA1 in (CertUtilPESha1) or SHA1 in (CertUtilFESha1) or FileName =~ \"certutil.exe\" or ProcessCommandLine has \"certutil\"\n// Create a new field called CleanProcessCommandLine which gets populated with the value of ProcessCommandLine as Windows parses it for execution, \n// removing any potential command line obfuscation. \n| extend CleanProcessCommandLine=parse_command_line(ProcessCommandLine, \"windows\")\n// Search for de-obfuscated commands used. \n// Urlcache is the documented attribute. However, url is also accepted.\n// Verifyctl is the documented attribute. However, verify is also accepted.\n| where CleanProcessCommandLine has_any (\"decode\", \"encode\", \"verify\",\"url\") \n| order by Timestamp\n", "attributes": {"description": "This detection addresses most of the known ways to utilize this binary for malicious/unintended purposes. \nIt attempts to accommodate for most detection evasion techniques, like commandline obfuscation and binary renaming.\n", "techniques": ["T1105", "T1564.004", "T1027", "T1140"], "tactics": ["CommandAndControl", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/COMHijacking.yaml", "query_name": "Component Object Model Hijacking - Vault7 trick", "query": "DeviceRegistryEvents\n| where RegistryKey has \"ShellFolder\"  and ActionType =~ \"RegistryValueSet\" and RegistryValueName =~ \"Attributes\" \n// toint automatically converts base10 and base16 strings to int toint(\"0xFF\") == toint(\"255\") == int(0xFF) ==  int(255).\n// We are using >= to make sure that if someone adds an additional flag to this field, it doesn't bypass this hunt.\n// Removing any flag will bypass this hunt, but more research is needed to understand which of the flag values are relevant.\n| where toint(RegistryValueData) >= int(0xf090013d) \n//UPDATE: Flag details are here: https://medium.com/falconforce/introducing-falcon-friday-1f972d65ce1b?source=friends_link&sk=e48d9cb974e216cc4b9b61945a3b177d\n", "attributes": {"description": "This detection looks for the very specific value of \"Attribute\" in the \"ShellFolder\" CLSID of a COM object. This value (0xf090013d) seems to only link back to this specific persistence method. \nThe blog post linked here (https://www.ired.team/offensive-security/code-execution/forcing-iexplore.exe-to-load-a-malicious-dll-via-com-abuse) provides more background on the meaning of this value. \n", "techniques": ["T1546.015"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/CreateProcessWithToken.yaml", "query_name": "Access Token Manipulation - Create Process with Token", "query": "let RunAsProcess=DeviceProcessEvents\n    | where FileName =~ \"runas.exe\" \n    // You can choose to filter out the local admin account. This is based on convention. Here, we assume that localadmin accounts\n    // end with _ladmin (RID 500 / LAPS).\n    | where not(AccountName has_any(\"_ladmin\"))\n    // De-obfuscate the commandline used. \n    | extend CleanProcessCommandLine=parse_command_line(tostring(ProcessCommandLine), \"windows\")\n    // Exclude a user running something on their system through their admin account.\n    | where CleanProcessCommandLine !contains strcat(AccountName, \"_adm\") // Replace this with your admin account naming convention.\n    // Exclude local admin account activities by, for instance, the servicedesk that uses the LAPS provisioned account. This is optional. \n    // Disable the line below if the number of false positives is acceptable. \n    | where not(CleanProcessCommandLine has_any (\":_ladmin\")) // Replace this with your local RID500/LAPS account.\n    // Extract the username for the elevation action.\n    | extend ElevatedAccountName=extract(\"user:([a-zA-Z0-9\\\\\\\\]+)\",1,tostring(CleanProcessCommandLine))\n    // Strip the domain suffix.\n    | extend CleanElevatedAccountName= trim(\"(.*\\\\\\\\)\",ElevatedAccountName);\nRunAsProcess\n| join kind=leftouter ( \n    DeviceLogonEvents\n    | project-rename CleanElevatedAccountName = AccountName\n    ) on CleanElevatedAccountName,DeviceId\n| project-rename ElevatedActionType=ActionType1,ElevatedAccountSid=AccountSid1\n| project TimeGenerated,DeviceId,DeviceName,FileName,FolderPath,ProcessCommandLine,SHA256,ProcessIntegrityLevel,AccountDomain,AccountName,AccountSid, LogonId, InitiatingProcessFileName,InitiatingProcessFolderPath,InitiatingProcessCommandLine,CleanProcessCommandLine,ElevatedAccountName,CleanElevatedAccountName,ElevatedActionType,LogonType,ElevatedAccountSid\n", "attributes": {"description": "This query detects the use of the 'runas' command and checks whether the account used to elevate privileges isn't the user's own admin account. \nAdditionally, it will match this event to the logon events - to check whether it has been successful as well as augment the event with the new SID.\n", "techniques": ["T1134.002"], "tactics": ["PrivilegeEscalation", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/DCOMLateralMovement.yaml", "query_name": "DCOM Lateral Movement", "query": "let allowListedExecs = dynamic([\"TiWorker.exe\", \"dllhost.exe\", \"backgroundTaskHost.exe\", \"mobsync.exe\", \"WmiPrvSE.exe\", \"RuntimeBroker.exe\", \"smartscreen.exe\", \"SppExtComObj.Exe\", \"usocoreworker.exe\", \"browser_broker.exe\", \"ssoncom.exe\"]);\nlet rpcNetwEvents = materialize(DeviceNetworkEvents\n| where InitiatingProcessFileName =~ \"svchost.exe\" and InitiatingProcessCommandLine has \"rpcss\" and LocalPort == 135\n| where LocalIP !~ RemoteIP and ActionType != \"ListeningConnectionCreated\"\n| project TimestampNetwEvent=bin(Timestamp, 5s),TimestampNetwEventExact=Timestamp, DeviceId, DeviceName, RPCHostID=InitiatingProcessId, RPCHostFileName=InitiatingProcessFileName, LocalIP, RemoteIP);\nlet dcomProcEvents = materialize (DeviceProcessEvents\n| where InitiatingProcessFileName =~ \"svchost.exe\" and InitiatingProcessCommandLine has \"dcomlaunch\"\n| project TimestampProcEvent=bin(Timestamp, 5s),TimestampProcEventExact=Timestamp, DeviceId, DeviceName, DCOMHostPID=InitiatingProcessId, DCOMHostFileName=InitiatingProcessFileName, DCOMPID=ProcessId, DCOMFileName=FileName, DCOMCmdLine=ProcessCommandLine);\nlet lastBootTime = materialize(DeviceProcessEvents\n| where FileName =~ \"services.exe\"\n| summarize LastBootTime=max(Timestamp) by DeviceId);\nlet RemoteDcomProcs = materialize(rpcNetwEvents\n| join kind=inner dcomProcEvents on DeviceId \n| join kind=leftouter lastBootTime on DeviceId\n| where TimestampProcEvent > LastBootTime+5m // Ignore first 5 min after boot.\n// Avoiding < 2 since if the time between netw and proc creation is negative, they can't be related. Network event must come first. \n| where datetime_diff(\"second\", TimestampProcEventExact, TimestampNetwEventExact) between (0 .. 2) \n// Allow-listing some usual suspects which create lot of noise. This is dangerous though...huge gap for bypass. \n| where DCOMFileName  !in~ (allowListedExecs));\nRemoteDcomProcs\n| join kind=inner hint.strategy=broadcast (\n    DeviceProcessEvents \n    | where InitiatingProcessParentFileName =~ \"svchost.exe\" and InitiatingProcessFileName in ((RemoteDcomProcs | project DCOMFileName))) \non $left.DCOMHostPID == $right.InitiatingProcessParentId, DeviceId, $left.DCOMPID == $right.InitiatingProcessId\n| where InitiatingProcessParentFileName =~ \"svchost.exe\" and InitiatingProcessFileName =~ DCOMFileName \n// Allow-listing the magic of Defender.\n| where FileName !in~ (\"csc.exe\") \n| summarize make_set(ProcessCommandLine) by TimestampNetwEventExact, TimestampProcEventExact, DeviceId, DeviceName, InitiatingProcessId, LocalIP, RemoteIP, LastBootTime, DCOMCmdLine\n", "attributes": {"description": "This detection looks for cases of close-time proximity between incoming network traffic on RPC/TCP, followed by the creation of a DCOM object, followed by the creation of a child process of the DCOM object. \nThe query first identifies incoming network traffic over RPC/TCP, followed by the creation of a DCOM object (process) within 2 seconds, followed by the creation of a child process of this DCOM object. \n", "techniques": ["T1021.003"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/DisableOrModifyWindowsDefender.yaml", "query_name": "Disable or Modify Windows Defender", "query": "let defendertampering=dynamic([\"Set-MpPreference -DisableRealtimeMonitoring $true\",\"sc stop WinDefend\",\"sc delete WinDefend\",\"Set-MpPreference -DisableBehaviorMonitoring $true\",\"Set-MpPreference -ExclusionProcess\", \"Set-MpPreference -ExclusionExtension dll\",\"net stop security center\"]);\nDeviceProcessEvents\n| where ProcessCommandLine has_any (defendertampering)\n// If you have a lot of false positives coming from JetBrains, you can use the line below. \n//| where InitiatingProcessFolderPath !startswith @\"c:\\program files\\jetbrains\\\" and InitiatingProcessVersionInfoProductName !~ (\"Android Studio\")\n", "attributes": {"description": "This detection watches the commandline logs for known commands that are used to disable the Defender AV. This is based on research performed by @olafhartong on a large sample of malware for varying purposes. \nNote that this detection is imperfect and is only meant to serve as basis for building a more resilient detection rule. \nMake the detection more resilient, currently the order of parameters matters. You don't want that for a production rule. \nSee blogpost (https://medium.com/falconforce/falconfriday-av-manipulation-0xff0e-67ed4387f9ab?source=friends_link&sk=3c7c499797bbb4d74879e102ef3ecf8f) \nfor more resilience considerations. The current approach can easily be bypassed by not using the powershell.exe executable. \nConsider adding more ways to detect this behavior.\n", "techniques": ["T1562.001"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/DLLSideLoading.yaml", "query_name": "Hijack Execution Flow - DLL Side-Loading", "query": "let imls = materialize(\n    DeviceImageLoadEvents\n    | where InitiatingProcessIntegrityLevel in (\"High\", \"System\") and FileName !endswith \".exe\"\n    | project FolderPath=tolower(FolderPath), InitiatingProcessFileName, InitiatingProcessIntegrityLevel, DeviceId, DeviceName\n    | distinct FolderPath, InitiatingProcessFileName, InitiatingProcessIntegrityLevel, DeviceId, DeviceName\n);\nimls \n| join (\n    DeviceFileEvents \n    | where FolderPath in~ ((imls | project FolderPath)) and ActionType in (\"FileCreated\", \"FileModified\") and \n    InitiatingProcessIntegrityLevel !in (\"High\", \"System\", \"\") and InitiatingProcessAccountSid != \"S-1-5-18\" and \n    InitiatingProcessTokenElevation in (\"TokenElevationTypeDefault\", \"TokenElevationTypeLimited\") and InitiatingProcessAccountSid !endswith \"-500\"\n    | extend FolderPath=tolower(FolderPath)\n) on FolderPath, DeviceId, DeviceName\n| project-away FolderPath1\n", "attributes": {"description": "This detection tries to identify all DLLs loaded by \"high integrity\" processes and cross-checks the DLL paths against FileCreate/FileModify events of the same DLL by a medium integrity process. \nOf course, we need to do some magic to filter out false positives as much as possible. So any FileCreate/FileModify done by \"NT Authoriy\\System\" and the \"RID 500\" users aren't interesting. \nAlso, we only want to see the FileCreate/FileModify actions which are performed with a default or limited token elevation. If done with a full elevated token, the user is apparently admin already.\n", "techniques": ["T1574.002"], "tactics": ["Persistence", "PrivilegeEscalation", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/DotNetToJScript.yaml", "query_name": "Detect .NET runtime being loaded in JScript for code execution", "query": "DeviceImageLoadEvents \n| where FileName in~ (\"mscoree.dll\", \"mscorlib.dll\", \"mscorlib.ni.dll\") \n| where tolower(InitiatingProcessFileName) in (\"wscript.exe\", \"cscript.exe\", \"mshta.exe\")\n", "attributes": {"description": "This query detects .NET being loaded from wscript or cscript to run .NET code, such as cactustorch and sharpshooter.\nAll based on the DotNetToJScript by James Foreshaw documented here https://github.com/tyranid/DotNetToJScript. \n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/ExcessiveSharePermissions.yaml", "query_name": "Excessive share permissions", "query": "let timeframe=1h;\nlet system_roles = datatable(role:string, system:string)                  // Link roles to systems.\n  [\"DC\",\"dc1.corp.local\",\n  \"DC\",\"dc2.corp.local\",\n  \"PRINT\",\"printer.corp.local\"\n  ];\nlet share_roles = datatable(role:string, share:string)                    // Link roles to shares.\n  [\"DC\", @\"\\\\*\\sysvol\",\n  \"DC\",@\"\\\\*\\netlogon\",\n  \"PRINT\",@\"\\\\*\\print$\"];\nlet allowed_system_shares = system_roles                                  // Link systems to shares.\n  | join kind=inner share_roles on role\n  | extend system = tolower(system), share = tolower(share)\n  | project-away role\n  | summarize allowed_shares = make_set(share) by system;\nlet monitored_principals=datatable(identifier:string, Group_Name:string)  // Define a data-table with groups to monitor.\n  [\"AN\", \"Anonymous Logon\",            // We accept the 'alias' for these well-known SIDS.\n  \"AU\", \"Authenticated Users\",\n  \"BG\",\"Built-in guests\",\n  \"BU\",\"Built-in users\",\n  \"DG\",\"Domain guests\",\n  \"DU\",\"Domain users\",\n  \"WD\",\"Everyone\",\n  \"IU\",\"Interactively Logged-on users\",\n  \"LG\",\"Local Guest\",\n  \"NU\",\"Network logon users\",\n  \"513\", \"Domain Users\",                                                  // Support matching on the last part of a SID.\n  \"514\", \"Domain Guests\",\n  \"545\", \"Builtin Users\",\n  \"546\", \"Builtin Guests\",\n  \"S-1-5-7\", \"Anonymous Logon\"                                            // For the global SIDS, we accept them as-is.\n  ];\nSecurityEvent\n| where TimeGenerated >= ago(timeframe)\n| where EventID == 5143\n| extend EventXML = parse_xml(EventData)\n| extend OldSD = tostring(EventXML[\"EventData\"][\"Data\"][13][\"#text\"])     // Grab the previous Security Descriptor.\n| extend NewSD = tostring(EventXML[\"EventData\"][\"Data\"][14][\"#text\"])     // Grab the new Security Descriptor.\n| project-away EventXML\n| where tostring(OldSD) !~ tostring(NewSD)                                // Don't bother with unchanged permissions.\n| extend system = tolower(Computer), share=tolower(ShareName)             // Normalize system and share name for matching with whitelist.\n| join kind=leftouter allowed_system_shares on system                     // Retrieve the allowed shares per system.\n| where not(set_has_element(allowed_shares, share))                       // Check if the current share is an allowed share.\n| project-away system, share, allowed_shares                              // Get rid of temporary fields.\n| extend DACLS = extract_all(@\"(D:(?:\\((?:[\\w\\-]*;){5}(?:[\\w\\-]*)\\))*)\", tostring(NewSD)) // Grab all instances of D:(DACL), in case there are multiple sets.\n| project-away OldSD, NewSD                                               // Get rid of data we no longer need.\n| mv-expand DACLS to typeof(string)                                       // In case there are any duplicate/subsequent D: entries (e.g., D:<dacls>S:<sacls>D:<dacls>) split them out to individual D: sets.\n| extend DACLS = substring(DACLS,2)                                       // Strip the leading D:.\n| extend DACLS = split(DACLS, \")\")                                        // Split the sets of DACLS ()() to an array of individual DACLS (). This removes the trailing ) character.\n| mv-expand DACLS to typeof(string)                                       // Duplicate the records in such a way that only 1 DACL per record exist. We will aggregate them back later.\n| extend DACLS = substring(DACLS, 1)                                      // Also remove the leading ( character.\n| where not(isempty(DACLS)) and DACLS startswith \"A;\"                     // Remove any empty or non-allow DACLs.\n| extend allowed_principal = tostring(split(DACLS,\";\",5)[0])              // Grab the SID what is affected by this DACL.\n| extend allowed_principal = iff(not(allowed_principal startswith \"S-\" and string_size(allowed_principal) > 15), allowed_principal, split(allowed_principal,\"-\",countof(allowed_principal,\"-\"))[0]) // This line takes only the last part (e.g., 513) of a long SID, so you can refer to groups/users without needing to supply the full SID above.\n| join kind=inner monitored_principals on $left.allowed_principal == $right.identifier // Join the found groups to the table of groups to be monitored above. Adds the more readable 'group_name).\n| project-away allowed_principal, identifier, DACLS\n| summarize Authorized_Public_Principals = make_set(Group_Name), take_any(*) by TimeGenerated, SourceComputerId, EventData // Summarize the fields back, making a set of the various group_name values for this record.\n| project-away Group_Name\n// Begin client-specific filter.\n// End client-specific filter.\n", "attributes": {"description": "The query searches for event 5143, which is triggered when a share is created or changed and includes de share permissions.\nFirst it checks to see if this is a whitelisted share for the system (e.g. domaincontroller netlogon, printserver print$ etc.).\nThe share permissions are then checked against 'allow' rule (A) for a number of well known overly permissive groups, like all users, guests, authenticated users etc.\nIf these are found, an alert is raised so the share creation may be audited.\nNote: this rule only checks for changed permissions, to prevent repeat alerts if for example a comment is changed, but the permissions are not altered.\n", "techniques": ["T1039", "T1135"], "tactics": ["Collection", "Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/ExpiredAccessCredentials.yaml", "query_name": "Expired access credentials being used in Azure", "query": "// Timeframe to search for failed logins.\nlet timeframe=1d;\n// Timeframe to look back for successful logins from the same user by IP.\nlet lookback=7d;\nlet SuspiciousSignings=(\n    SigninLogs\n    | where TimeGenerated >= ago(timeframe)\n    | where ResourceDisplayName contains \"Windows Azure Active Directory\"\n    // 50132 = SsoArtifactInvalidOrExpired - The session is not valid due to password expiration or recent password change.\n    // 50173 = FreshTokenNeeded - The provided grant has expired due to it being revoked, and a fresh auth token is needed. \n    // 70008 = ExpiredOrRevokedGrant - The refresh token has expired due to inactivity. The token was issued on XXX and was inactive for a certain period of time.\n    // 81010 = DesktopSsoAuthTokenInvalid - Seamless SSO failed because the user's Kerberos ticket has expired or is invalid.\n    | where ResultType in (50173, 50132, 70008, 81010)\n    | summarize FailedCountPerDay=count(),FailedUserAgents=make_set(UserAgent), FailedCountries=make_set(LocationDetails.countryOrRegion),FailedIps=make_set(IPAddress) by UserPrincipalName, Day=bin(TimeGenerated, 1d)\n    | where FailedCountPerDay >= 1\n);\nlet SuccessLogins=(\n    SigninLogs\n    | where TimeGenerated >= ago(lookback)\n    | where UserPrincipalName in ((SuspiciousSignings | project UserPrincipalName))\n    | where ResultType == 0\n    | summarize count() by UserPrincipalName, IPAddress\n);\nSuspiciousSignings\n| mv-expand FailedIp=FailedIps\n| extend FailedIp=tostring(FailedIp)\n| join kind=leftanti SuccessLogins on $left.FailedIp==$right.IPAddress, UserPrincipalName\n", "attributes": {"description": "This query searches for logins with an expired access credential (for example an expired cookie). It then matches the IP address from which the expired credential access occurred with the IP addresses of successful logins.\nIf there are logins with expired credentials, but no successful logins from an IP, this might indicate an attacker has copied the authentication cookie and is re-using it on another machine.\n", "techniques": ["T1528"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/MatchLegitimateNameOrLocation.yaml", "query_name": "Match Legitimate Name or Location - 2", "query": "let ProcessRelations=datatable(ImageFile:string,ExpectedParent:dynamic) [\n  \"smss.exe\", dynamic([\"smss.exe\", \"ntoskrnl.exe\", \"\"]),\n  \"crmss.exe\", dynamic([\"smss.exe\"]),\n  \"wininit.exe\", dynamic([\"smss.exe\"]),\n  \"winlogon.exe\", dynamic([\"smss.exe\"]),\n  \"services.exe\", dynamic([\"wininit.exe\"]),\n  \"lsaiso.exe\", dynamic([\"wininit.exe\"]),\n  \"lsass.exe\", dynamic([\"wininit.exe\"]),\n  \"spoolsv.exe\", dynamic([\"services.exe\"]),\n  \"dllhost.exe\", dynamic([\"svchost.exe\", \"services.exe\"]),\n  \"lsm.exe\", dynamic([\"wininit.exe\"]),\n  \"svchost.exe\", dynamic([\"services.exe\", \"msmpeng.exe\"]),\n  \"runtimebroker.exe\", dynamic([\"svchost.exe\"]),\n  \"taskhostw.exe\", dynamic([\"svchost.exe\"]),\n  \"userinit.exe\", dynamic([\"winlogon.exe\"])\n  // Explorer can have a lot of parents in some environments\n  //,\"explorer.exe\", dynamic([\"userinit.exe\"])\n];\nDeviceProcessEvents\n| extend ImageFile = tostring(tolower(parse_path(tostring(FolderPath)).Filename))\n| extend ParentFile = tostring(tolower(parse_path(tostring(InitiatingProcessFolderPath)).Filename))\n| lookup kind=inner ProcessRelations on ImageFile\n| where not(set_has_element(ExpectedParent,ParentFile))\n", "attributes": {"description": "Attackers often match or approximate the name or location of legitimate files to avoid detection rules that are based trust of certain operating system processes.\nThis query detects mismatches in the parent-child relationship of core operating system processes to uncover different masquerading attempts.\n", "techniques": ["T1036.005"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/OfficeASRFromBrowser.yaml", "query_name": "Office ASR rule triggered from browser spawned office process.", "query": "// Add your own browsers here as well. \nlet browsers = dynamic([\"iexplore.exe\", \"chrome.exe\", \"firefox.exe\", \"msedge.exe\"]);\nDeviceEvents\n| where ActionType contains \"Office\"\n| where InitiatingProcessFileName in~ (browsers) or InitiatingProcessParentFileName in~ (browsers)\n// Ignore docx, xlsx and pptx files. These don't contain macros.\n| where not(FileName endswith \".docx\" or FileName endswith \".xlsx\" or FileName endswith \".pptx\")\n", "attributes": {"description": "The attacker sends a spearphishing email to a user. The email contains a link which points to a website that eventually \npresents the user a download of an MS Office document. This document contains a malicious macro. The macro triggers one of the ASR rules. \nThis detection looks for Office ASR violations triggered by an Office document opened from a browser.\nNote: be aware that you need to have the proper ASR rules enabled for this detection to work. \n", "techniques": ["T1566.002"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/OfficeProcessInjection.yaml", "query_name": "Suspicious Process Injection from Office application", "query": "DeviceEvents \n| where ActionType in (\"CreateRemoteThreadApiCall\", \"QueueUserApcRemoteApiCall\", \"SetThreadContextRemoteApiCall\")\n| where InitiatingProcessFileName in~ (\"winword.exe\", \"excel.exe\", \"powerpnt.exe\")\n| where InitiatingProcessCommandLine !contains \"/dde\"\n| where not(InitiatingProcessCommandLine has_any (\".docx\", \"dotx\",\".xlsx\", \".xltx\", \".pptx\")) // These files can't contain macros.\n// Enable the line below if the results are too noisy.\n//| where InitiatingProcessCommandLine has_any (\".doc\", \".wbk\", \".docm\", \".dot\", \".dotm\" \".xls\", \".xlsm\", \".xltm\", \".xla\",\".xll\", \".xlam\", \".ppt\", \".pptm\", \".pot\", \".potm\", \".ppsm\", \".sldm\") \n", "attributes": {"description": "This query detects process injections using CreateRemoteThread, QueueUserAPC or SetThread context APIs, originating from an Office process (only Word/Excel/PowerPoint)\nthat might contains macros. Performing process injection from a macro is a common technique by attackers to escape out of the Office process into something\nlonger running. \n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/OracleSuspiciousCommandExecution.yaml", "query_name": "Oracle suspicious command execution", "query": "let timeframe= 1h;\nDeviceProcessEvents\n| where Timestamp >= ago(timeframe)\n| where InitiatingProcessFileName =~ \"oracle.exe\"\n| where not(FileName in~ (\"conhost.exe\", \"oradim.exe\"))\n// Begin allow-list.\n// End allow-list.\n", "attributes": {"description": "The query searches process creation events that are indicative of an attacker spawning OS commands from an Oracle database.\n", "techniques": ["T1210", "T1611"], "tactics": ["LateralMovement", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/PasswordSprayingWithMDE.yaml", "query_name": "Password Spraying", "query": "let thresholdForUniqueFailedAccounts = 20;\nlet upperBoundOfFailedLogonsPerAccount = 10;\nlet ratioSuccessFailedLogons = 0.5;\nlet timeframe = 1d;\nDeviceLogonEvents\n| where Timestamp >= ago(timeframe)\n| where LogonType != \"Unlock\" and ActionType in (\"LogonSuccess\", \"LogonFailed\")\n| where not(isempty( RemoteIP) and isempty( RemoteDeviceName))\n| extend LocalLogon=parse_json(AdditionalFields)\n| where RemoteIPType != \"Loopback\"\n| summarize SuccessLogonCount = countif(ActionType == \"LogonSuccess\"), FailedLogonCount = countif(ActionType == \"LogonFailed\"),\n    UniqueAccountFailedLogons=dcountif(AccountName, ActionType == \"LogonFailed\"), FirstFailed=minif(Timestamp, ActionType == \"LogonFailed\"),\n    LastFailed=maxif(Timestamp, ActionType == \"LogonFailed\"), LastTimestamp=arg_max(Timestamp, tostring(ReportId)) by RemoteIP, DeviceName // RemoteIP is the source of the logon attempt.\n| project-rename IPAddress=RemoteIP\n| where UniqueAccountFailedLogons > thresholdForUniqueFailedAccounts and SuccessLogonCount*ratioSuccessFailedLogons < FailedLogonCount and UniqueAccountFailedLogons*upperBoundOfFailedLogonsPerAccount > FailedLogonCount \n", "attributes": {"description": "This query detects a password spraying attack, where a single machine has performed a large number of failed login attempts, with a large number of different accounts. \nFor each account, the attacker uses just a few attempts to prevent account lockout. This query uses the DeviceLogonEvents per machine to detect a password spraying attacks. \nThe machine against which the password spraying is performed (can be DC, a server or even an endpoint) needs to be enrolled in Microsoft Defender for Endpoint.\n", "techniques": ["T1110.003"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/RecognizingBeaconingTraffic.yaml", "query_name": "Beacon Traffic Based on Common User Agents Visiting Limited Number of Domains", "query": "let timeframe = 1d; // Timeframe during which to search for beaconing behavior.\nlet lookback = 7d; // Look back period to find if browser was used for other domains by user.\nlet min_requests=50; // Minimum number of requests to consider it beacon traffic.\nlet min_hours=8; // Minimum number of different hours during which connections were made to consider it beacon traffic.\nlet trusted_user_count=10; // If visited by this many users a domain is considered 'trusted'.\nlet max_sites=3; // Maximum number of different sites visited using this user-agent.\n// Client-specific query to obtain 'browser-like' traffic from proxy logs.\nlet BrowserTraffic = (p:timespan) {\nCommonSecurityLog\n| where DeviceVendor == \"Zscaler\" and DeviceProduct == \"NSSWeblog\"\n| where TimeGenerated >ago(p)\n| project TimeGenerated, SourceUserName, DestinationHostName, RequestClientApplication\n| where (RequestClientApplication startswith \"Mozilla/\" and RequestClientApplication contains \"Gecko\")\n};\nlet CommonDomains = BrowserTraffic(timeframe)\n| summarize source_count=dcount(SourceUserName) by DestinationHostName\n| where source_count>trusted_user_count\n| project DestinationHostName;\nlet CommonUA = BrowserTraffic(timeframe)\n| summarize source_count=dcount(SourceUserName), host_count=dcount(DestinationHostName) by RequestClientApplication\n| where source_count>trusted_user_count and host_count > 100 // Normal browsers are browsers used by many people and visiting many different sites.\n| project RequestClientApplication;\n// Find browsers that are common, i.e. many users use them and they use them to visit many different sites,\n// but some users only use the browser to visit a very limited set of sites.\n// These are considered suspicious, since they might be an attacker masquerading a beacon as a legitimate browser.\nlet SuspiciousBrowers = BrowserTraffic(timeframe)\n| where RequestClientApplication in(CommonUA)\n| summarize BrowserHosts=make_set(DestinationHostName),request_count=count() by RequestClientApplication, SourceUserName\n| where array_length(BrowserHosts) <= max_sites and request_count >= min_requests\n| project RequestClientApplication, SourceUserName,BrowserHosts;\n// Just reporting on suspicious browsers gives too many false positives.\n// For example, users that have the browser open on the login screen of 1 specific application.\n// In the suspicious browsers we can search for 'beacon-like' behavior.\n// Get all browser traffic by the suspicious browsers.\nlet PotentialAlerts=SuspiciousBrowers\n| join BrowserTraffic(timeframe) on RequestClientApplication, SourceUserName\n// Find beaconing-like traffic - i.e. contacting the same host in many different hours.\n| summarize hour_count=dcount(bin(TimeGenerated,1h)), BrowserHosts=any(BrowserHosts), request_count=count() by RequestClientApplication, SourceUserName, DestinationHostName\n| where hour_count >= min_hours and request_count >= min_requests\n// Remove common domains like login.microsoft.com.\n| join kind=leftanti CommonDomains on DestinationHostName\n| summarize RareHosts=make_set(DestinationHostName), TotalRequestCount=sum(request_count), BrowserHosts=any(BrowserHosts) by RequestClientApplication, SourceUserName\n// Remove browsers that visit any common domains.\n| where array_length(RareHosts) == array_length(BrowserHosts);\n// Look back for X days to see if the browser was not used to visit more hosts.\n// This is to get rid of someone that started up the browser a long time ago, and left only a single tab open.\nPotentialAlerts\n| join BrowserTraffic(lookback) on SourceUserName, RequestClientApplication\n| summarize RareHosts=any(RareHosts),BrowserHosts1d=any(BrowserHosts),BrowserHostsLookback=make_set(DestinationHostName) by SourceUserName, RequestClientApplication\n| where array_length(RareHosts) == array_length(BrowserHostsLookback)\n", "attributes": {"description": "This query searches web proxy logs for a specific type of beaconing behavior by joining a number of sources together: \n- Traffic by actual web browsers - by looking at traffic generated by a UserAgent that looks like a browser and is used by multiple users\nto visit a large number of domains.\n- Users that make requests using one of these actual browsers, but only to a small set of domains, none of which are common domains.\n- The traffic is beacon-like; meaning that it occurs during many different hours of the day (i.e. periodic). \n", "techniques": ["T1071.001"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/RemoteDesktopProtocol.yaml", "query_name": "Remote Desktop Protocol - SharpRDP", "query": "let executions = DeviceProcessEvents\n| where InitiatingProcessFileName contains \"taskmgr\" and AccountName !contains \"_ladm\" // Include your LAPS /RID500 admin naming convention here. \n// Add the below filter to look for stock SharpRDP behavior. However, with minorchanges to the stock version of SharpRDP the filter below can be bypassed.\n//| where not(InitiatingProcessCommandLine has_any (\"/1\",\"/2\",\"/3\",\"/4\"))\n| where not(FolderPath =~ @\"c:\\Windows\\system32\\WerFault.exe\" and ProcessCommandLine contains \"-u -p\")\n| where not(FolderPath =~ @\"c:\\windows\\system32\\mmc.exe\" and ProcessCommandLine contains @\"C:\\WINDOWS\\System32\\services.msc\")\n| where not(FolderPath =~ @\"c:\\windows\\system32\\resmon.exe\");\nexecutions\n| join kind=leftsemi  (DeviceLogonEvents\n| where LogonType in ('Unlock', 'RemoteInteractive') and not (LogonType == 'Unlock' and RemoteIP == '127.0.0.1') and RemoteIP != \"\" and ActionType == \"LogonSuccess\") on DeviceId, LogonId\n", "attributes": {"description": "This detection monitors for the behavior that SharpRDP exhibits on the target system. The most relevant is leveraging taskmgr.exe to gain elevated execution, which means that taskmgr.exe is creating unexpected child processes.\n", "techniques": ["T1021.001"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/RenameSystemUtilities.yaml", "query_name": "Rename System Utilities", "query": "// Removed update.exe as LOLBIN. It's a way too generic name and causes a lot of noise. \nlet lolbin = dynamic([\"At.exe\", \"Atbroker.exe\", \"Bash.exe\", \"Bitsadmin.exe\", \"CertReq.exe\", \"Certutil.exe\", \"Cmd.exe\", \"Cmdkey.exe\", \"Cmstp.exe\", \"Control.exe\", \"Csc.exe\", \"Cscript.exe\", \"Desktopimgdownldr.exe\", \"Dfsvc.exe\", \"Diantz.exe\", \"Diskshadow.exe\", \"Dnscmd.exe\", \"Esentutl.exe\", \"Eventvwr.exe\", \"Expand.exe\", \"Extexport.exe\", \"Extrac32.exe\", \"Findstr.exe\", \"Forfiles.exe\", \"Ftp.exe\", \"GfxDownloadWrapper.exe\", \"Gpscript.exe\", \"Hh.exe\", \"Ie4uinit.exe\", \"Ieexec.exe\", \"Ilasm.exe\", \"Infdefaultinstall.exe\", \"Installutil.exe\", \"Jsc.exe\", \"Makecab.exe\", \"Mavinject.exe\", \"Microsoft.Workflow.Compiler.exe\", \"Mmc.exe\", \"MpCmdRun.exe\", \"Msbuild.exe\", \"Msconfig.exe\", \"Msdt.exe\", \"Mshta.exe\", \"Msiexec.exe\", \"Netsh.exe\", \"Odbcconf.exe\", \"Pcalua.exe\", \"Pcwrun.exe\", \"Pktmon.exe\", \"Presentationhost.exe\", \"Print.exe\", \"Psr.exe\", \"Rasautou.exe\", \"Reg.exe\", \"Regasm.exe\", \"Regedit.exe\", \"Regini.exe\", \"Register-cimprovider.exe\", \"Regsvcs.exe\", \"Regsvr32.exe\", \"Replace.exe\", \"Rpcping.exe\", \"Rundll32.exe\", \"Runonce.exe\", \"Runscripthelper.exe\", \"Sc.exe\", \"Schtasks.exe\", \"Scriptrunner.exe\", \"SyncAppvPublishingServer.exe\", \"Ttdinject.exe\", \"Tttracer.exe\", \"vbc.exe\", \"Verclsid.exe\", \"Wab.exe\", \"Wmic.exe\", \"Wscript.exe\", \"Wsreset.exe\", \"Xwizard.exe\", \"AgentExecutor.exe\", \"Appvlp.exe\", \"Bginfo.exe\", \"Cdb.exe\", \"csi.exe\", \"Devtoolslauncher.exe\", \"dnx.exe\", \"Dotnet.exe\", \"Dxcap.exe\", \"Excel.exe\", \"Mftrace.exe\", \"Msdeploy.exe\", \"msxsl.exe\", \"ntdsutil.exe\", \"Powerpnt.exe\", \"rcsi.exe\", \"Sqldumper.exe\", \"Sqlps.exe\", \"SQLToolsPS.exe\", \"Squirrel.exe\", \"te.exe\", \"Tracker.exe\", \"vsjitdebugger.exe\", \"Winword.exe\", \"Wsl.exe\"]); \nlet allHashesLolbin = materialize(\nDeviceProcessEvents\n| where FileName in~ (lolbin) and not(isempty(SHA1))\n| extend OriginalFilename = tolower(FileName)\n| summarize by SHA1, OriginalFilename);\nallHashesLolbin\n| join kind=inner hint.strategy = broadcast DeviceProcessEvents on SHA1\n| where FileName !~ OriginalFilename\n| where not(OriginalFilename =~ \"bash.exe\" and FileName =~ \"sh.exe\")\n| extend message=strcat(\"Usage of \", OriginalFilename, \". Renamed as \", FileName)\n| project-reorder message\n", "attributes": {"description": "Attackers often use LOLBINs that are renamed to avoid detection rules that are based on filenames.\nThis rule detects renamed LOLBINs by first searching for all the known SHA1 hashes of the LOLBINs in your DeviceProcessEvents. This list is then used as reference to find other files executed which have a name that doesn't match the original filename. \nThis query is really heavy on resources. Use it with care.\n", "techniques": ["T1036.003"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/SMBWindowsAdminShares.yaml", "query_name": "SMB/Windows Admin Shares", "query": "// This rule is fairly complex, hence this documentation.\n// The rule tries to detect network activity from services.exe followed by the start of a new childvprocess of services.exe (i.e. a service start).\n// The rule tries to filter false positives as much as possible. \n// Since the FileProfile info is currently super-unreliable (unsure why), we have to work around it.\n// \n// The following list of LOLBINs is used to include all results which have a high reputation, but are LOLBINs.\nlet lolbins = dynamic([\"At.exe\", \"Atbroker.exe\", \"Bash.exe\", \"Bitsadmin.exe\", \"CertReq.exe\", \"Certutil.exe\", \"Cmd.exe\", \"Cmdkey.exe\", \"Cmstp.exe\", \"Control.exe\", \"Csc.exe\", \"Cscript.exe\", \"Desktopimgdownldr.exe\", \"Dfsvc.exe\", \"Diantz.exe\", \"Diskshadow.exe\", \"Dnscmd.exe\", \"Esentutl.exe\", \"Eventvwr.exe\", \"Expand.exe\", \"Extexport.exe\", \"Extrac32.exe\", \"Findstr.exe\", \"Forfiles.exe\", \"Ftp.exe\", \"GfxDownloadWrapper.exe\", \"Gpscript.exe\", \"Hh.exe\", \"Ie4uinit.exe\", \"Ieexec.exe\", \"Ilasm.exe\", \"Infdefaultinstall.exe\", \"Installutil.exe\", \"Jsc.exe\", \"Makecab.exe\", \"Mavinject.exe\", \"Microsoft.Workflow.Compiler.exe\", \"Mmc.exe\", \"MpCmdRun.exe\", \"Msbuild.exe\", \"Msconfig.exe\", \"Msdt.exe\", \"Mshta.exe\", \"Msiexec.exe\", \"Netsh.exe\", \"Odbcconf.exe\", \"Pcalua.exe\", \"Pcwrun.exe\", \"Pktmon.exe\", \"Presentationhost.exe\", \"Print.exe\", \"Psr.exe\", \"Rasautou.exe\", \"Reg.exe\", \"Regasm.exe\", \"Regedit.exe\", \"Regini.exe\", \"Register-cimprovider.exe\", \"Regsvcs.exe\", \"Regsvr32.exe\", \"Replace.exe\", \"Rpcping.exe\", \"Rundll32.exe\", \"Runonce.exe\", \"Runscripthelper.exe\", \"Sc.exe\", \"Schtasks.exe\", \"Scriptrunner.exe\", \"SyncAppvPublishingServer.exe\", \"Ttdinject.exe\", \"Tttracer.exe\", \"vbc.exe\", \"Verclsid.exe\", \"Wab.exe\", \"Wmic.exe\", \"Wscript.exe\", \"Wsreset.exe\", \"Xwizard.exe\", \"AgentExecutor.exe\", \"Appvlp.exe\", \"Bginfo.exe\", \"Cdb.exe\", \"csi.exe\", \"Devtoolslauncher.exe\", \"dnx.exe\", \"Dotnet.exe\", \"Dxcap.exe\", \"Excel.exe\", \"Mftrace.exe\", \"Msdeploy.exe\", \"msxsl.exe\", \"ntdsutil.exe\", \"Powerpnt.exe\", \"rcsi.exe\", \"Sqldumper.exe\", \"Sqlps.exe\", \"SQLToolsPS.exe\", \"Squirrel.exe\", \"te.exe\", \"Tracker.exe\", \"Update.exe\", \"vsjitdebugger.exe\", \"Winword.exe\", \"Wsl.exe\"]);\n// First, we want to get all the network events triggered by services.exe.\nlet networkEvents = materialize(DeviceNetworkEvents\n| where InitiatingProcessFileName in~ (\"services.exe\")\n| where ActionType == \"InboundConnectionAccepted\"\n| project-rename TimestampNetworkAct=Timestamp);\n// Next, we want to get the list of child processes created by services.exe. \nlet allServices = materialize ((\nDeviceProcessEvents \n// This is for optimization purposes, as filtering is way faster than joins.\n| where DeviceId in ((networkEvents | project DeviceId))\n//svchost and sppsvc are created very often as child processes of services.exe\n| where InitiatingProcessFileName =~ \"services.exe\" \n| project TimestampChild=Timestamp, DeviceId, DeviceName, FileName, ProcessCommandLine, SHA1, \nInitiatingProcessFileName, InitiatingProcessCommandLine, InitiatingProcessSHA1, InitiatingProcessId, TimestampServicesExe=InitiatingProcessCreationTime));\n// Now we are going to join the process creations and network events \n// and filter out all the tables _after_ the join where the child process \n// of svchost is not created shortly after the network activity (between 0 and 10 seconds). \nlet serviceNetworkEvents = materialize(\n(networkEvents \n    | join kind=inner hint.strategy=shuffle allServices on DeviceId, InitiatingProcessId, InitiatingProcessFileName\n) \n| where datetime_diff(\"Second\", TimestampChild, TimestampNetworkAct) between (0 .. 10)\n// Only get the results where the network activity occured more than 1 minute after services.exe has started (i.e. system boot).\n| where datetime_diff(\"Second\", TimestampNetworkAct, TimestampServicesExe) > 60);\n// Next, we want to check the reputation of all procssess.\n// Since FileProfile is not properly working, we use the built-in DeviceFileCertificateInfo for the AntiJoin.\n// The goal is to create a list of SHA1 hashes of the spawned processess \n// which have a low prevelance and are not in de DeviceFileCertificateInfo.\nlet serviceNetworkEventsWithSHA1 = materialize(serviceNetworkEvents\n| summarize count() by SHA1\n| join kind=leftanti hint.strategy=broadcast DeviceFileCertificateInfo on SHA1\n| where count_ < 100);\n// Finally, we need to bring everything together.\n// We take our subset of the child processess created by services.exe (serviceNetworkEvents).\n// Everything which is on our deny-list of SHA1 processess OR are LOLBINs, are filtered out.\n// Additionally, we filter out msiexec, since that appears to come very often.\nserviceNetworkEvents\n| where SHA1 in ((serviceNetworkEventsWithSHA1 | project SHA1)) or FileName in~ (lolbins) \n| where ProcessCommandLine !~ \"msiexec.exe /V\" \n// This summarize is optional if you want to group similar stuff.\n//| summarize ActionType=make_set(ActionType), RemoteIPs=make_set(strcat(RemoteIP, \":\", RemotePort, \" (\", RemoteUrl, \")\")), LocalPort=make_set(LocalPort) by bin(TimestampNetworkAct, 1m), DeviceId, DeviceName, LocalIP, Protocol, AdditionalFields, bin(TimestampChild, 1m), FileName, ProcessCommandLine, SHA1, InitiatingProcessFileName, InitiatingProcessCommandLine1, bin(TimestampServicesExe, 1m) \n", "attributes": {"description": "This query is based on detecting incoming RPC/TCP on the SCM, followed by the start of a child process of services.exe. Remotely interacting with the SCM triggers the RPC/TCP traffic on services.exe, and the creation of the child processes is a result of starting the service. \nThe query might look intimidating given its size. That's why we've commented the query per logic block to walk you through the details.\n", "techniques": ["T1021.002"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/SuspiciousNamedPipes.yaml", "query_name": "Suspicious named pipes", "query": "let timeframe=1h;\nlet CobaltStrikeDefaults= dynamic([@\"msagent_\", @\"MSSE-\", @\"postex_\", @\"status_\", @\"mypipe-f\", @\"mypipe-h\",@\"ntsvcs_\",@\"scerpc_\", @\"mojo.5688.8052.\"]);\nlet CobaltStrikeMallable= dynamic([@\"win_svc\", @\"ntsvcs\", @\"scerpc\", @\"status_\", @\"SearchTextHarvester\", @\"DserNamePipe\",@\"wkssvc_\",@\"scerpc_\", @\"spoolss_\",@\"CatalogChangeListener\",@\"fullduplex_\",@\"demoagent_\",@\"PGMessagePipe\",@\"MsFteWds\",@\"postex_ssh_\",@\"windows.update.manager\",@\"\\f4c3\",@\"\\f53f\",@\"halfduplex_\"]);\nDeviceEvents\n| where Timestamp >= ago(timeframe)\n| where ActionType == \"NamedPipeEvent\"\n| extend AdditionalFields=parse_json(AdditionalFields)\n| extend ThreadId=tostring(AdditionalFields.ThreadId)\n| extend PipeName=tostring(AdditionalFields.PipeName)\n// creating string based variants of the processIDs for matching several times later\n| extend InitiatingPID=tostring(InitiatingProcessId)\n| extend InitiatingParentPID=tostring(InitiatingProcessParentId)\n// Begin allow-list.\n// End allow-list.\n| where PipeName has_any (CobaltStrikeDefaults) or\n// Mojo is generated by Chrome(ium) browsers and teams and have distinct pattern including the (parent)ProcessId and ThreadId plus a random character string, CobaltStrike generates hex.\n      (PipeName matches regex @\"\\\\mojo\\.\\d+\\.\\d+\\.\" and not(PipeName matches regex @\"\\\\mojo\\.\\d+\\.\\d+\\.\\d+$\" or PipeName has InitiatingPID or PipeName has InitiatingParentPID or PipeName has ThreadId)) or\n// Chrome(ium) browsers sync processes have distinct pattern including the (parent)ProcessId and ThreadId plus a random character string, CobaltStrike generates hex.\n      (PipeName matches regex @\"\\\\(edge|chrome)\\.sync\\.\\d+\\.\\d+\\.\" and not(PipeName matches regex @\"\\\\(edge|chrome|edge\\.sync|chrome\\.sync)\\.\\d+\\.\\d+\\.\\d+$\" or PipeName has InitiatingPID or PipeName has InitiatingParentPID or PipeName has ThreadId)) or\n// PSHost is generated by PowerShell and has a distinct pattern including the (parent)ProcessId.\n      (PipeName matches regex @\"\\\\PSHost\\.\\d+\\.\" and not(PipeName matches regex @\"\\\\PSHost\\.\\d+\\.\\d+\\.\" or PipeName has InitiatingPID or PipeName has InitiatingParentPID)) or\n// Crashpad pipes have a distinct pattern including the ProcessId and a string of upper case characters.\n      (PipeName matches regex @\"\\\\crashpad_\" and not(PipeName matches regex @\"\\\\crashpad_\\d+_[A-Z]+\" or PipeName has InitiatingPID or PipeName has InitiatingParentPID)) or\n// Firefox pipes have a distinct pattern including the ProcessId and 1-3 digits which are sequential for each new pipe.\n      (PipeName matches regex @\"\\\\cubeb-pipe-\" and not(PipeName matches regex @\"\\\\cubeb-pipe-\\d+_[0-9]{1-3}+\" or PipeName has InitiatingPID)) or\n// Based on a list of public mallable profiles and a suffix that is a random HEX string.\n      (PipeName has_any (CobaltStrikeMallable) and PipeName matches regex @\"[a-fA-F0-9]{2,10}$\") or\n      (PipeName matches regex @\"\\\\pipe\\\\[0-9a-f]{7,10}\" or PipeName matches regex @\"\\\\pipe\\\\[0-9a-f]{8}\")\n", "attributes": {"description": "This query looks for Named Pipe events that either contain one of the known IOCs or make use of patterns that can be linked to CobaltStrike usage.\n", "techniques": ["T1559", "T1055"], "tactics": ["Execution", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/SuspiciousParentProcessRelationship.yaml", "query_name": "Suspicious parentprocess relationship - Office child processes.", "query": "let browsers = dynamic([\"iexplore.exe\", \"chrome.exe\", \"firefox.exe\", \"msedge.exe\"]); // Customize this list for your environment.\nlet officeApps = dynamic([\"winword.exe\", \"excel.exe\", \"powerpnt.exe\"]); // Consider adding other Office applications such as Publisher, Visio and Access. \n// This is an allow-list of the most common child processes. This is a quick and dirty solution. Consider allow-listing the full process path instead of file name.\n// Also, make this list as short as possible. Remove anything from this list if it doesn't occur in your organization. \nlet allowList = dynamic([\"MSOSYNC.exe\", \"splwow64.exe\", \"csc.exe\", \"outlook.exe\", \"AcroRd32.exe\", \"Acrobat.exe\", \"explorer.exe\", \"DW20.exe\", \n\"Microsoft.Mashup.Container.Loader.exe\", \"Microsoft.Mashup.Container.NetFX40.exe\", \"WerFault.exe\", \"CLVIEW.exe\"]); \nDeviceProcessEvents\n| where InitiatingProcessParentFileName in~ (browsers) and InitiatingProcessFileName in~ (officeApps) and \nFileName !in~ (officeApps) and FileName !in~ (browsers) and FileName !in~ (allowList)\n| project-rename ProcessStart_Timestamp = Timestamp\n", "attributes": {"description": "The attacker sends a spearphishing email to a user. The email contains a link, which points to a website that eventually \npresents the user a download of an MS Office document. This document contains a malicious macro. The macro spawns a new child process providing initial access. \nThis detection looks for suspicious parent-process chains starting with a browser which spawns an Office application which spawns something else.\n", "techniques": ["T1566.002"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/TrustedDeveloperUtilitiesProxyExecution.yaml", "query_name": "Trusted Developer Utilities Proxy Execution", "query": "let Timeframe = 1h;\nDeviceProcessEvents\n| where Timestamp > ago(Timeframe)\n| where (FileName has_any (\"msbuild.exe\", \"msxsl.exe\")\nor (FileName has_any (\"vbc.exe\",\"csc.exe\",\"jsc.exe\") and ProcessCommandLine has_any (\"/exe\",\"/dll\",\"/pe64\",\"-exe\",\"-dll\",\"-pe64\"))\nor (FileName == (\"ilsasm.exe\") and ProcessCommandLine has_any (\"out\",\"target\",\"t:\",\"reference\",\"r:\")))\n// Filter initations by Visual Studio since this is expected behavior.\n  and not(FolderPath startswith \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\" \n  or InitiatingProcessFolderPath startswith \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\" \n  and (InitiatingProcessFileName == \"devenv.exe\" or InitiatingProcessFileName == \"WDExpress.exe\"))\n", "attributes": {"description": "This detection looks at process executions - in some cases with specific command line attributes to filter a lot of common noise.\n", "techniques": ["T1127"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/UACBypass-1-elevated-COM.yaml", "query_name": "Detecting UAC bypass - elevated COM interface", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName =~ \"dllhost.exe\"\n| where ProcessIntegrityLevel == \"High\"\n| where InitiatingProcessCommandLine has_any (\"E9495B87-D950-4AB5-87A5-FF6D70BF3E90\", \"3E5FC7F9-9A51-4367-9063-A120244FBEC7\", \"D2E7041B-2927-42fb-8E9F-7CE93B6DC937\")\n", "attributes": {"description": "This query identifies processes spawned with high integrity from dllhost.exe with a command line that contains one of three specific CLSID GUIDs.\n", "techniques": ["T1490"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/UACBypass-2-modify-ms-store.yaml", "query_name": "Detecting UAC bypass - modify Windows Store settings", "query": "DeviceProcessEvents\n| where InitiatingProcessFileName =~ \"wsreset.exe\"\n| where ProcessIntegrityLevel == \"High\"\n", "attributes": {"description": "This query identifies modification a specific registry key and then launching wsreset.exe that resets the Windows Store settings.\n", "techniques": ["T1490"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/FalconFriday/Analytic%20Rules/UACBypass-3-changePK-SLUI-tampering.yaml", "query_name": "Detecting UAC bypass - ChangePK and SLUI registry tampering", "query": "DeviceProcessEvents\n| where InitiatingProcessParentFileName =~ \"slui.exe\"\n| where InitiatingProcessFileName =~ \"changepk.exe\"\n| where ProcessIntegrityLevel == \"High\"\n", "attributes": {"description": "This query identifies setting a registry key under HKCU, launching slui.exe and then ChangePK.exe.\n", "techniques": ["T1490"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20A%20payment%20method%20was%20removed.yaml", "query_name": "(Preview) GitHub - A payment method was removed", "query": "GitHubAuditData\n| where Action == \"payment_method.remove\"\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a payment method was removed. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20Activities%20from%20Infrequent%20Country.yaml", "query_name": "GitHub Activites from a New Country", "query": "let LearningPeriod = 7d;\nlet RunTime = 1h;\nlet StartTime = 1h;\nlet EndRunTime = StartTime - RunTime;\nlet EndLearningTime = StartTime + LearningPeriod;\nlet GitHubCountryCodeLogs = (GitHubAuditData\n| where Country != \"\");\n  GitHubCountryCodeLogs\n| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime))\n| summarize makeset(Country) by Actor\n| join kind=innerunique (\n  GitHubCountryCodeLogs\n  | where TimeGenerated between (ago(StartTime) .. ago(EndRunTime))\n  | distinct Country, Actor, TimeGenerated\n) on Actor \n| where set_Country !contains Country\n| extend AccountCustomEntity = Actor , timestamp = TimeGenerated\n", "attributes": {"description": "'Detect activities from a location that was not recently or was never visited by the user or by any user in your organization.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20Oauth%20application%20-%20a%20client%20secret%20was%20removed.yaml", "query_name": "(Preview) GitHub - Oauth application - a client secret was removed", "query": "GitHubAuditData\n| where Action == \"oauth_application.remove_client_secret\"\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a client secret was removed. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20pull%20request%20was%20created.yaml", "query_name": "(Preview) GitHub - pull request was created", "query": "GitHubAuditData \n| where Action == \"pull_request.create\"\n| project Actor, Action\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a pull request was created. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20pull%20request%20was%20merged.yaml", "query_name": "(Preview) GitHub - pull request was merged", "query": "GitHubAuditData\n| where Action == \"pull_request.merge\"\n| project Actor, Action\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a pull request was merged. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20Repository%20was%20created.yaml", "query_name": "(Preview) GitHub - Repository was created", "query": "GitHubAuditData\n| where Action == \"repo.create\"\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a repository was created. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20Repository%20was%20destroyed.yaml", "query_name": "(Preview) GitHub - Repository was destroyed", "query": "GitHubAuditData\n| where Action == \"repo.destroy\"\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a repository was destroyed. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20Two%20Factor%20Authentication%20Disabled%20in%20GitHub.yaml", "query_name": "GitHub Two Factor Auth Disable", "query": "\nGitHubAuditData\n| where Action == \"org.disable_two_factor_requirement\"\n| project TimeGenerated, Action, Actor, Country, Repository\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Two-factor authentication is a process where a user is prompted during the sign-in process for an additional form of identification, such as to enter a code on their cellphone or to provide a fingerprint scan. Two factor authentication reduces the risk of account takeover. Attacker will want to disable such security tools in order to go undetected. '\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20User%20visibility%20Was%20changed.yaml", "query_name": "(Preview) GitHub - User visibility Was changed", "query": "GitHubAuditData\n| where Visibility != PreviousVisibility\n| project Actor, PreviousVisibility, Visibility\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a user visibility Was changed. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20User%20was%20added%20to%20the%20organization.yaml", "query_name": "(Preview) GitHub - User was added to the organization", "query": "GitHubAuditData\n| where Action == \"org.add_member\"\n| project Actor, Action\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a user was added to the organization. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20User%20was%20blocked.yaml", "query_name": "(Preview) GitHub - User was blocked", "query": "GitHubAuditData\n| where Action == \"org.block_user\"\n| project Actor, Action \n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a user was blocked on the repository. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Analytic%20Rules/%28Preview%29%20GitHub%20-%20User%20was%20invited%20to%20the%20repository.yaml", "query_name": "(Preview) GitHub - User was invited to the repository", "query": "GitHubAuditData \n| where Action == \"org.invite_member\"\n| project Actor, Action\n| extend AccountCustomEntity = Actor\n", "attributes": {"description": "'Detect activities when a user was invited to the repository. This query runs every day and its severity is Medium.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Hunting%20Queries/First%20Time%20User%20Invite%20and%20Add%20Member%20to%20Org.yaml", "query_name": "GitHub First Time Invite Member and Add Member to Repo", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet LearningPeriod = 7d;\nlet EndLearningTime = starttime - LearningPeriod;\nlet GitHubOrgMemberLogs = (GitHubAuditData\n| where Action == \"org.invite_member\" or Action == \"org.update_member\" or Action == \"org.add_member\" or Action == \"repo.add_member\" or Action == \"team.add_member\");\nGitHubOrgMemberLogs\n| where TimeGenerated between (EndLearningTime..starttime)\n| distinct Actor\n| join kind=rightanti (\n  GitHubOrgMemberLogs\n  | where TimeGenerated between (starttime..endtime)\n  | distinct Actor\n) on Actor\n", "attributes": {"description": "'This hunting query identifies a user that add/invite a member to the organization for the first time. This technique can be leveraged by attackers to add stealth account access to the organization.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Hunting%20Queries/Inactive%20or%20New%20Account%20Usage.yaml", "query_name": "GitHub Inactive or New Account Access or Usage", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet LearningPeriod = 7d;\nlet EndLearningTime = starttime - LearningPeriod;\nlet GitHubActorLogin = (GitHubAuditData\n| where Actor != \"\");\nlet GitHubUser = (GitHubAuditData\n| where ImpactedUser != \"\");\nlet GitHubNewActorLogin = (GitHubActorLogin\n| where TimeGenerated between (EndLearningTime .. starttime)\n| summarize makeset(Actor)\n| extend Dummy = 1\n| join kind=innerunique (\n  GitHubActorLogin\n  | where TimeGenerated between (starttime .. endtime)\n  | distinct Actor\n  | extend Dummy = 1\n) on Dummy\n| project-away Dummy\n| where set_Actor  !contains Actor);\nlet GitHubNewUser = ( GitHubUser\n| where TimeGenerated between (EndLearningTime .. starttime)\n| summarize makeset(ImpactedUser)\n| extend Dummy = 1\n| join kind=innerunique (\n  GitHubUser\n  | where TimeGenerated between (starttime .. endtime)\n  | distinct ImpactedUser\n  | extend Dummy = 1\n) on Dummy\n| project-away Dummy\n| where set_ImpactedUser !contains ImpactedUser);\nunion GitHubNewActorLogin, GitHubNewUser\n", "attributes": {"description": "'This hunting query identifies Accounts that are new or inactive and have accessed or used GitHub that may be a sign of compromise.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Hunting%20Queries/Mass%20Deletion%20of%20Repositories%20.yaml", "query_name": "GitHub Mass Deletion of repos or projects", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet LearningPeriod = 7d;\nlet BinTime = 1h;\nlet EndLearningTime = starttime - LearningPeriod;\nlet NumberOfStds = 3;\nlet MinThreshold = 10.0;\nlet GitHubRepositoryDestroyEvents = (GitHubAuditData\n| where Action == \"repo.destroy\");\nGitHubRepositoryDestroyEvents\n| where TimeGenerated between (EndLearningTime .. starttime)\n| summarize count() by bin(TimeGenerated, BinTime)\n| summarize AvgInLearning = avg(count_), StdInLearning = stdev(count_)\n| extend LearningThreshold = max_of(AvgInLearning + StdInLearning * NumberOfStds, MinThreshold)\n| extend Dummy = 1\n| join kind=innerunique (\n  GitHubRepositoryDestroyEvents\n  | where TimeGenerated between (starttime..endtime)\n  | summarize CountInRunTime = count() by bin(TimeGenerated, BinTime)\n  | extend Dummy = 1\n) on Dummy\n| project-away Dummy\n| where CountInRunTime > LearningThreshold\n", "attributes": {"description": "'This hunting query identifies GitHub activites where there are a large number of deletions that may be a sign of compromise.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Hunting%20Queries/Oauth%20App%20Restrictions%20Disabled.yaml", "query_name": "GitHub OAuth App Restrictions Disabled", "query": "\nGitHubAuditData\n| where Action == \"org.disable_oauth_app_restrictions\"\n| project TimeGenerated, Action, Actor, Country\n", "attributes": {"description": "'This hunting query identifies GitHub OAuth Apps that have restrictions disabled that may be a sign of compromise. Attacker will want to disable such security tools in order to go undetected. '\n", "techniques": ["T1505", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Hunting%20Queries/Org%20Repositories%20Default%20Permissions%20Change.yaml", "query_name": "GitHub Update Permissions", "query": "\nGitHubAuditData\n| where Action == \"org.update_default_repository_permission\"\n| project TimeGenerated, Action, Actor, Country, Repository, PreviousPermission, CurrentPermission\n", "attributes": {"description": "'This hunting query identifies GitHub activites where permissions are updated that may be a sign of compromise.'\n", "techniques": ["T1098", "T1562"], "tactics": ["Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Hunting%20Queries/Repository%20Permission%20Switched%20to%20Public.yaml", "query_name": "GitHub Repo switched from private to public", "query": "\nGitHubAuditData\n| where Action == \"repo.access\"\n| where Visibility == \"public\" and PreviousVisibility in (\"internal\", \"private\")\n| project TimeGenerated, Action, Actor, Country, Repository, Visibility\n", "attributes": {"description": "'This hunting query identifies GitHub activites where a repo was changed from private to public that may be a sign of compromise.'\n", "techniques": ["T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Hunting%20Queries/User%20First%20Time%20Repository%20Delete%20Activity.yaml", "query_name": "GitHub First Time Repo Delete", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet LearningPeriod = 7d;\nlet EndLearningTime = starttime - LearningPeriod;\nlet GitHubRepositoryDestroyEvents = (GitHubAuditData\n| where Action == \"repo.destroy\");\nGitHubRepositoryDestroyEvents\n| where TimeGenerated between (EndLearningTime .. starttime)\n| distinct Actor\n| join kind=rightanti (\n  GitHubRepositoryDestroyEvents\n  | where TimeGenerated between (starttime .. endtime)\n  | distinct Actor\n) on Actor\n", "attributes": {"description": "'This hunting query identifies GitHub activites its the first time a user deleted a repo that may be a sign of compromise.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitHub/Hunting%20Queries/User%20Grant%20Access%20and%20Grants%20Other%20Access.yaml", "query_name": "GitHub User Grants Access and Other User Grants Access", "query": "\nGitHubAuditData\n| where ImpactedUser != \"\"\n| where Action == \"org.invite_member\" or Action == \"org.add_member\" or Action == \"team.add_member\" or Action == \"repo.add_member\"\n| distinct ImpactedUser, TimeGenerated, Actor\n| project-rename firstUserAdded = ImpactedUser, firstEventTime = TimeGenerated, firstAdderUser = Actor\n| join kind= innerunique (\n  GitHubAuditData\n  | where ImpactedUser != \"\"\n  | where Action == \"org.invite_member\" or Action == \"org.add_member\" or Action == \"team.add_member\" or Action == \"repo.add_member\"\n  | distinct ImpactedUser, TimeGenerated, Actor\n  | project-rename secondUserAdded = ImpactedUser, secondEventTime = TimeGenerated, secondAdderUser = Actor\n) on $right.secondAdderUser == $left.firstUserAdded\n| where secondEventTime between (firstEventTime .. (firstEventTime + 1h))\n", "attributes": {"description": "'This hunting query identifies Accounts in GitHub that have granted access to another account which then grants access to yet another account that may be a sign of compromise.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitLab/Analytic%20Rules/GitLab_BruteForce.yaml", "query_name": "GitLab - Brute-force Attempts", "query": "let LearningPeriod = 7d; \nlet EndLearningTime = now();\nlet BinTime = 1h; \nlet RunTime = 1h; \nlet MinThreshold = 3.0; \nlet GitLabFailedLogins = (GitLabApp\n| where FailedLogin == 1\n| parse kind=regex Message with \"Failed Login: username=\" User \"ip=\" IpAddress \n| project TimeGenerated, EventTime, Computer, User, HostName, HostIP, IpAddress);\nGitLabFailedLogins \n| where EventTime between (ago(LearningPeriod) .. EndLearningTime) \n| summarize FailedLoginsCountInBinTime = count() by User, bin(EventTime, BinTime) \n| summarize AvgOfFailedLoginsInLearning = avg(FailedLoginsCountInBinTime), StdOfFailedLoginsInLearning = stdev(FailedLoginsCountInBinTime) by User \n| extend LearningThreshold = max_of(AvgOfFailedLoginsInLearning, MinThreshold) \n| join kind=innerunique ( GitLabFailedLogins \n| summarize FailedLoginsCountInRunTime = count() by User, IpAddress, EventTime = bin(EventTime, BinTime) ) on User \n| where FailedLoginsCountInRunTime >= LearningThreshold\n| project User, IpAddress, EventTime, FailedLoginsCountInRunTime, LearningThreshold\n", "attributes": {"description": "'This query relies on GitLab Application Logs to get failed logins to highlight brute-force attempts from different IP addresses in a short space of time.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitLab/Analytic%20Rules/GitLab_ExternalUser.yaml", "query_name": "GitLab - External User Added to GitLab", "query": "// List of allow-listed domains\nlet allowedDomain = pack_array(\"mydomain.com\");\nGitLabAudit\n| where AddAction == \"user\"\n| project AuthorName, IPAddress, User = EntityName\n| join (GitLabApp \n| where UserAdded == 1\n| parse kind=regex Message with \"User \\\"\" User \"\\\"\" EmailAddress \" was created\"\n| project tostring(User), EmailAddress = substring(EmailAddress,2,strlen(EmailAddress)-3)) on User\n| project  AuthorName, IPAddress, User, EmailAddress, DomainName = tostring(extract(\"@(.*)$\", 1, EmailAddress))\n| where allowedDomain !contains DomainName\n", "attributes": {"description": "'This queries GitLab Application logs to list external user accounts (i.e.: account not in allow-listed domains) which have been added to GitLab users.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitLab/Analytic%20Rules/GitLab_Impersonation.yaml", "query_name": "GitLab - User Impersonation", "query": "let impersonationStart = (GitLabAudit\n| where CustomMessage == 'Started Impersonation');\nlet impersonationStop = (GitLabAudit\n| where CustomMessage == 'Stopped Impersonation');\nimpersonationStart\n| join kind=inner impersonationStop on $left.TargetID == $right.TargetID and $left.AuthorID == $right.AuthorID \n| where EventTime1 > EventTime\n| extend TimeGenerated, AuthorID, AuthorName, TargetID, TargetDetails = TargetDetails, IPStart = IPAddress, IPStop = IPAddress1, ImpStartTime = EventTime, ImpStopTime = EventTime1, EntityName\n| join kind=inner (GitLabAudit | extend ActionTime = EventTime, AuthorName) on $left.TargetDetails == $right.AuthorName \n| where ImpStartTime < ActionTime and ActionTime > ImpStopTime\n", "attributes": {"description": "'This queries GitLab Audit Logs for user impersonation. A malicious operator or a compromised admin account could leverage the impersonation feature of GitLab to change code or\nrepository settings bypassing usual processes. This hunting queries allows you to track the audit actions done under impersonation.'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitLab/Analytic%20Rules/GitLab_LocalAuthNoMFA.yaml", "query_name": "GitLab - Local Auth - No MFA", "query": "let isAdmin = true;\nGitLabAudit\n| where AuthenticationType == \"standard\" and ((isAdmin and TargetDetails contains \"Administrator\") or (isAdmin==false));\n", "attributes": {"description": "'This query checks GitLab Audit Logs to see if a user authenticated without MFA. Ot might mean that MFA was disabled for the GitLab server or that an external authentication provider was bypassed. This rule focuses on 'admin' privileges but the parameter can be adapted to also include all users.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitLab/Analytic%20Rules/GitLab_MaliciousIP.yaml", "query_name": "GitLab - TI - Connection from Malicious IP", "query": "ThreatIntelligenceIndicator\n| where Action == true\n// Picking up only IOCs that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n//Exclude local addresses using ipv4_is_private operator\n|where ipv4_is_private(TI_ipEntity) == false and  TI_ipEntity !startswith \"fe80\" and TI_ipEntity !startswith \"::\" and TI_ipEntity !startswith \"127.\"\n| join (GitLabAccess) on $left.TI_ipEntity == $right.IPAddress\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, TimeGenerated = EventTime, TI_ipEntity, IPAddress, URI\n", "attributes": {"description": "'This query correlates Threat Intelligence data from Sentinel with GitLab NGINX Access Logs (available in GitLab CE as well) to identify access from potentially TI-flagged IPs.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitLab/Analytic%20Rules/GitLab_PAT_Repo.yaml", "query_name": "GitLab - Personal Access Tokens creation over time", "query": "// l_min_tokens_created - minimum tokens created per repository per user per day to consider\nlet l_min_tokens_created = 0;\nlet interval = 1d;\nGitLabAudit\n| where TargetType == \"PersonalAccessToken\"\n| project Severity, TimeGenerated = bin(todatetime(EventTime),1d), AuthorName, IPAddress, Repository = EntityName, Action, TargetType\n| summarize total = count() by Repository, TimeGenerated, AuthorName\n| where total >= l_min_tokens_created\n", "attributes": {"description": "'This queries GitLab Audit Logs for access tokens. Attacker can exfiltrate data from you GitLab repository after gaining access to it by generating or hijacking access tokens. \nThis hunting queries allows you to track the personal access tokens creation for each of your repositories. \nThe visualization allow you to quickly identify anomalies/excessive creation, to further investigate repo access & permissions.'\n", "techniques": ["T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitLab/Analytic%20Rules/GitLab_RepoVisibilityChange.yaml", "query_name": "GitLab - Repository visibility to Public", "query": "GitLabAudit\n| where SourceVisibility != \"Public\" and ChangeType == \"visibility\" and TargetVisibility == \"Public\"\n| project TimeGenerated, EventTime, IPAddress, AuthorName, ChangeType, TargetType, SourceVisibility,  TargetVisibility, EntityName\n", "attributes": {"description": "'This query leverages GitLab Audit Logs. A repository in GitLab changed visibility from Private or Internal to Public which could indicate compromise, error or misconfiguration leading to exposing the repository to the public.'\n", "techniques": ["T1556"], "tactics": ["Persistence", "DefenseEvasion", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitLab/Analytic%20Rules/GitLab_Repo_Deletion.yaml", "query_name": "GitLab - Abnormal number of repositories deleted", "query": "let LearningPeriod = 7d;\nlet BinTime = 1h;\nlet RunTime = 1h;\nlet StartTime = 1h;\nlet NumberOfStds = 3;\nlet MinThreshold = 10.0;\nlet EndRunTime = StartTime - RunTime;\nlet EndLearningTime = StartTime + LearningPeriod;\nlet GitLabRepositoryDestroyEvents = (GitLabAudit\n| where RemoveAction == \"project\" or RemoveAction == \"repository\");\nGitLabRepositoryDestroyEvents\n| where TimeGenerated between (ago(EndLearningTime) .. ago(StartTime))\n| summarize count() by bin(TimeGenerated, BinTime)\n| summarize AvgInLearning = avg(count_), StdInLearning = stdev(count_)\n| extend LearningThreshold = max_of(AvgInLearning + StdInLearning * NumberOfStds, MinThreshold)\n| extend Dummy = 1\n| join kind=innerunique (GitLabRepositoryDestroyEvents\n| where TimeGenerated between (ago(StartTime) .. ago(EndRunTime))\n| summarize CountInRunTime = count() by bin(TimeGenerated, BinTime)\n| extend Dummy = 1) on Dummy\n| project-away Dummy\n| where CountInRunTime > LearningThreshold\n", "attributes": {"description": "'This hunting queries identify an unusual increase of repo deletion activities adversaries may want to disrupt availability or compromise integrity by deleting business data.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GitLab/Analytic%20Rules/GitLab_SignInBurst.yaml", "query_name": "GitLab - SSO - Sign-Ins Burst", "query": "let locationCountMin = 1;\nlet appRegistrationName = \"GitLab\";\nSigninLogs\n| where AppDisplayName == appRegistrationName\n| where ResultType == 0\n| where Location != \"\"\n| summarize CountOfLocations = dcount(Location), Locations = make_set(Location) by User = Identity\n| where CountOfLocations > locationCountMin\n", "attributes": {"description": "'This query relies on Azure Active Directory sign-in activity when Azure AD is used for SSO with GitLab to highlights GitLab accounts associated with multiple authentications from different geographical locations in a short space of time.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSCVE-2021-40444.yaml", "query_name": "Google DNS - CVE-2021-40444 exploitation", "query": "GCPCloudDNS\n| where Query has_any ('hidusi.com', 'dodefoh.com', 'joxinu.com')\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects CVE-2021-40444 exploitation.'\n", "techniques": ["T1068"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSDataExfiltration.yaml", "query_name": "Google DNS - Possible data exfiltration", "query": "GCPCloudDNS\n| where Query has 'webhook.site'\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects possible data exfiltration.'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSExchangeAutodiscoverAbuse.yaml", "query_name": "Google DNS - Exchange online autodiscover abuse", "query": "GCPCloudDNS\n| where Query has_any ('autodiscover.com.br', 'autodiscover.com.cn', 'autodiscover.com.co', 'autodiscover.es', 'autodiscover.fr', 'autodiscover.in', 'autodiscover.it', 'autodiscover.sg', 'autodiscover.uk', 'autodiscover.xyz', 'autodiscover.online')\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects possible Exchange online autodiscover abuse.'\n", "techniques": ["T1566", "T1187"], "tactics": ["InitialAccess", "CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSIpCheck.yaml", "query_name": "Google DNS - IP check activity", "query": "let ip_check = dynamic(['whatismyipaddress.com', 'ip2location.com', 'ipaddress.my', 'whatismyip.com', 'ipinfo.info', 'checkmyip.com', 'myip.com', 'checkmyip.org', 'canireachthe.net', 'ipv4.icanhazip.com', 'ip.anysrc.net', 'edns.ip-api.com', 'wtfismyip.com', 'checkip.dyndns.org', 'api.2ip.ua', 'icanhazip.com', 'api.ipify.org', 'ip-api.com', 'checkip.amazonaws.com', 'ipecho.net', 'ipinfo.io', 'ipv4bot.whatismyipaddress.com', 'freegeoip.app', 'checkip.azurewebsites.net']);\nGCPCloudDNS\n| where Query in~ (ip_check)\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests to ip lookup resources.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSIpDynDns.yaml", "query_name": "Google DNS - Request to dynamic DNS service", "query": "let dyndns = dynamic(['noip.com', 'dynu.com', 'dyn.com', 'dynv6.com']);\nGCPCloudDNS\n| where Query in~ (dyndns)\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests to ip lookup resources.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSMaliciousPythonPackages.yaml", "query_name": "Google DNS - Malicous Python packages", "query": "GCPCloudDNS\n| where Query has_any ('psec.forward.io.global.prod.fastly.net', 'b0a0374cd1cb4305002e.d.requestbin.net', 'tornadodomain.000webhostapp.com', 'yxznlysc47wvrb9r9z211e1jbah15q')\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests to resources with malicious Python packages.'\n", "techniques": ["T1195"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSMultipleErrorsFromIp.yaml", "query_name": "Google DNS - Multiple errors for source", "query": "let threshold = 10;\nlet err = dynamic(['NXDOMAIN', 'SERVFAIL', 'REFUSED']);\nGCPCloudDNS\n| where EventResultDetails in~ (err)\n| summarize count() by SrcIpAddr, bin(TimeGenerated, 10m)\n| where count_ > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple errors for the same source IP address.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSMultipleErrorsQuery.yaml", "query_name": "Google DNS - Multiple errors to same domain", "query": "let threshold = 2;\nlet err = dynamic(['NXDOMAIN', 'SERVFAIL', 'REFUSED']);\nGCPCloudDNS\n| where EventResultDetails in~ (err)\n| summarize ips = makeset(SrcIpAddr) by Query, bin(TimeGenerated, 10m)\n| where array_length(ips) >= threshold\n| extend DNSCustomEntity = Query, IPCustomEntity = ips\n", "attributes": {"description": "'Detects multiple errors to same domain.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSPrintNightmare.yaml", "query_name": "Google DNS - CVE-2021-34527 (PrintNightmare) external exploit", "query": "GCPCloudDNS\n| where Query has 'gentilkiwi'\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects CVE-2021-34527 (PrintNightmare) external exploit'\n", "techniques": ["T1068"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSSIGREDPattern.yaml", "query_name": "Google DNS - CVE-2020-1350 (SIGRED) exploitation pattern", "query": "let threshold = 15;\nGCPCloudDNS\n| where QueryTypeName in~ ('SIG', 'RRSIG')\n| where NetworkProtocol =~ 'TCP'\n| summarize count() by SrcIpAddr, bin(TimeGenerated, 1m)\n| where count_ < threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects exploitation pattern of CVE-2020-1350 (SIGRED) vulnerability.'\n", "techniques": ["T1068"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Analytic%20Rules/GCPDNSUNC2452AptActivity.yaml", "query_name": "Google DNS - UNC2452 (Nobelium) APT Group activity", "query": "GCPCloudDNS\n| where Query has_any ('tomasubiera.com', 'theandersonco.com', 'stonecrestnews.com', 'nordicmademedia.com')\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects UNC2452 (Nobelium) APT Group activity.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSErrors.yaml", "query_name": "Google DNS - Errors", "query": "GCPCloudDNS\n| where TimeGenerated > ago(24h)\n| where EventResultDetails != 'NOERROR'\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for DNS requests with errors.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSIpLookup.yaml", "query_name": "Google DNS - Requests to IP lookup resources", "query": "let ip_check = dynamic(['whatismyipaddress.com', 'ip2location.com', 'ipaddress.my', 'whatismyip.com', 'ipinfo.info', 'checkmyip.com', 'myip.com', 'checkmyip.org', 'canireachthe.net', 'ipv4.icanhazip.com', 'ip.anysrc.net', 'edns.ip-api.com', 'wtfismyip.com', 'checkip.dyndns.org', 'api.2ip.ua', 'icanhazip.com', 'api.ipify.org', 'ip-api.com', 'checkip.amazonaws.com', 'ipecho.net', 'ipinfo.io', 'ipv4bot.whatismyipaddress.com', 'freegeoip.app', 'checkip.azurewebsites.net']);\nGCPCloudDNS\n| where TimeGenerated > ago(24h)\n| where Query in~ (ip_check)\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for requests to IP lookup resources.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSOnlineShares.yaml", "query_name": "Google DNS - Requests to online shares", "query": "GCPCloudDNS\n| where TimeGenerated > ago(24h)\n| where Query has_any ('dropbox.com', 'mediafire.com', 'onedrive.com', 'wire.com', 'massive.io', 'efilecabinet.com', 'c-v.sh', 'file.io', '0x0.st', 'instant.io', 'copy.com', 'mega.nz', 'icloud.com', 'pcloud.com', 'icedrive.net', 'WeTransfer.com', 'Onehub.com', 'getfilecloud.com', 'ki.tc', 'uguu.se', 'flyle.app', 'transfer.sh', 'expirebox.com', 'disk.yandex.com', 'filestage.io', 'zippyshare.com', 'drive.google.com', 'box.com', 'hubic.com', 'wikisend.com', 'dropsend.com', 'anonymousfiles.io', 'anonfiles.com', 'filedropper.com', 'privatlab.com', 'dropmefiles.com', 'onionshare.org', 'sendGB.com', 'volafile.org', 'openload.co', 'uploadfiles.io', 'gofile.io')\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for requests to online/cloud shares.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSRareDomains.yaml", "query_name": "Google DNS - Rare domains", "query": "GCPCloudDNS\n| where TimeGenerated > ago(24h)\n| summarize count() by Query\n| order by count_ asc\n| top 10 by count_\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for requests rare domains.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSRareErrors.yaml", "query_name": "Google DNS - Domains with rare errors", "query": "GCPCloudDNS\n| where TimeGenerated > ago(24h)\n| where EventResultDetails != 'NOERROR'\n| summarize count() by EventResultDetail, Query\n| order by count_ asc\n| top 10 by count_\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for Domains with rare errors.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSRequestToTOR.yaml", "query_name": "Google DNS - Requests to TOR resources", "query": "GCPCloudDNS\n| where TimeGenerated > ago(24h)\n| where Query endswith '.onion'\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for requests to TOR resources.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSServerLatency.yaml", "query_name": "Google DNS - Server latency", "query": "GCPCloudDNS\n| where TimeGenerated > ago(24h)\n| order by payload_serverLatency_d\n| extend DNSCustomEntity = Query, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for server latency.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSSourceHighErrors.yaml", "query_name": "Google DNS - Sources with high number of errors", "query": "GCPCloudDNS\n| where TimeGenerated > ago(24h)\n| where EventResultDetails != 'NOERROR'\n| summarize count() by SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for sources with high number of errors.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSUnexpectedTLD.yaml", "query_name": "Google DNS - Unexpected top level domains", "query": "GCPCloudDNS\n| where TimeGenerated > ago(24h)\n| extend tld = extract(@'.*\\.(\\w+)\\.$', 1, Query)\n| where strlen(tld) > 4\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for unexpected TLDs.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformDNS/Hunting%20Queries/GCPDNSUnusualTLD.yaml", "query_name": "Google DNS - Unusual top level domains", "query": "let known_tlds =\nGCPCloudDNS\n| where TimeGenerated between (ago(30d) .. ago(1d))\n| extend tld = extract(@'.*\\.(\\w+)\\.$', 1, Query)\n| summarize a_tld = makeset(tld)\n| extend k=1;\nknown_tlds\n| join (GCPCloudDNS\n| where TimeGenerated > ago(24h)\n| where isnotempty(Query)\n| extend tld = extract(@'.*\\.(\\w+)\\.$', 1, Query)\n| extend k=1) on k\n| where a_tld !has tld\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for unusual TLDs.'\n", "techniques": ["T1095"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMDisableDataAccessLogging.yaml", "query_name": "GCP IAM - Disable Data Access Logging", "query": "GCP_IAM\n| where PayloadMethodname == 'SetIamPolicy'\n| extend s = parse_json(todynamic(PayloadRequestPolicyAuditconfigs))[0]['auditLogConfigs']\n| where isempty(s)\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadAuthenticationinfoPrincipalemail, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when Data Access Logging is disabled.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMEmptyUA.yaml", "query_name": "GCP IAM - Empty user agent", "query": "GCP_IAM\n| where isempty(HttpUserAgentOriginal)\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadAuthenticationinfoPrincipalemail, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests where user agent is empty.'\n", "techniques": ["T1550"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMHighPrivilegedRoleAdded.yaml", "query_name": "GCP IAM - High privileged role added to service account", "query": "let privileged_roles = dynamic(['roles/iam.securityAdmin', 'roles/secretmanager.admin', 'roles/secretmanager.secretAccessor', 'roles/apigateway.admin', 'roles/logging.admin', 'roles/iam.organizationRoleAdmin', 'roles/iam.roleAdmin', 'roles/iam.serviceAccountAdmin', 'roles/iam.serviceAccountCreator', 'roles/iam.serviceAccountKeyAdmin']);\nGCP_IAM\n| where PayloadMethodname =~ 'SetIamPolicy'\n| extend action = parse_json(todynamic(PayloadServicedataPolicydeltaBindingdeltas))[0]['action']\n| where action =~ 'ADD'\n| extend role = parse_json(todynamic(PayloadServicedataPolicydeltaBindingdeltas))[0]['role']\n| where role in~ (privileged_roles)\n| project-away action\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadAuthenticationinfoPrincipalemail, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when high privileged role was added to service account.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMNewAuthenticationToken.yaml", "query_name": "GCP IAM - New Authentication Token for Service Account", "query": "GCP_IAM\n| where PayloadMethodname =~ 'google.iam.admin.v1.GenerateAccessToken'\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| extend service_account = extract(@'serviceAccounts\\/(.*?)@', 1, PayloadResponseName)\n| project-away result\n| extend timestamp = TimeGenerated, AccountCustomEntity = service_account, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when new authentication token is created for service account.'\n", "techniques": ["T1550"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMNewServiceAccount.yaml", "query_name": "GCP IAM - New Service Account", "query": "GCP_IAM\n| where PayloadMethodname =~ 'google.iam.admin.v1.CreateServiceAccount'\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| project-away result\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadRequestAccountId, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects new service account creation.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMNewServiceAccountKey.yaml", "query_name": "GCP IAM - New Service Account Key", "query": "GCP_IAM\n| where PayloadMethodname =~ 'google.iam.admin.v1.CreateServiceAccountKey'\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| extend service_account = extract(@'serviceAccounts\\/(.*?)@', 1, PayloadResponseName)\n| project-away result\n| extend timestamp = TimeGenerated, AccountCustomEntity = service_account, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects new service account key creation.'\n", "techniques": ["T1550"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMPrivilegesEnumeration.yaml", "query_name": "GCP IAM - Privileges Enumeration", "query": "let threshold = 5;\nGCP_IAM\n| where PayloadMethodname =~ 'google.iam.admin.v1.ListRoles'\n| summarize count() by PayloadAuthenticationinfoPrincipalemail, bin(TimeGenerated, 1h)\n| where count_ > threshold\n| extend AccountCustomEntity = PayloadAuthenticationinfoPrincipalemail\n", "attributes": {"description": "'Detects possible privileges enumeration.'\n", "techniques": ["T1069"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMPublicBucket.yaml", "query_name": "GCP IAM - Publicly exposed storage bucket", "query": "GCP_IAM\n| where PayloadMethodname =~ 'google.iam.v1.IAMPolicy.SetIamPolicy'\n| where ResourceType has 'bucket'\n| extend members = parse_json(todynamic(PayloadRequestPolicyBindings))[0]['members']\n| extend action = parse_json(todynamic(PayloadRequestPolicyBindings))[0]['action']\n| where members in~ ('allUsers', 'allAuthenticatedUsers')\n| where action =~ 'ADD'\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadAuthenticationinfoPrincipalemail, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects possible misconfiguration for bucket policy making it publicly available.'\n", "techniques": ["T1069"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMServiceAccountEnumeration.yaml", "query_name": "GCP IAM - Service Account Enumeration", "query": "let threshold = 5;\nGCP_IAM\n| where PayloadMethodname =~ 'google.iam.admin.v1.ListServiceAccounts'\n| summarize count() by PayloadAuthenticationinfoPrincipalemail, bin(TimeGenerated, 1h)\n| where count_ > threshold\n| extend AccountCustomEntity = PayloadAuthenticationinfoPrincipalemail\n", "attributes": {"description": "'Detects possible service account enumeration.'\n", "techniques": ["T1087"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Analytic%20Rules/GCPIAMServiceAccountKeysEnumeration.yaml", "query_name": "GCP IAM - Service Account Keys Enumeration", "query": "let threshold = 5;\nGCP_IAM\n| where PayloadMethodname =~ 'google.iam.admin.v1.ListServiceAccountsKeys'\n| summarize count() by PayloadAuthenticationinfoPrincipalemail, bin(TimeGenerated, 1h)\n| where count_ > threshold\n| extend AccountCustomEntity = PayloadAuthenticationinfoPrincipalemail\n", "attributes": {"description": "'Detects possible service account keys enumeration.'\n", "techniques": ["T1069"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMChangedRoles.yaml", "query_name": "GCP IAM - Changed roles", "query": "GCP_IAM\n| where TimeGenerated > ago(24h)\n| where PayloadMethodname =~ 'google.iam.admin.v1.UpdateRole'\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| project-away result\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadRequestAccountId, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for roles' modifications.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMDeletedServiceAccounts.yaml", "query_name": "GCP IAM - Deleted service accounts", "query": "GCP_IAM\n| where TimeGenerated > ago(24h)\n| where PayloadMethodname =~ 'google.iam.admin.v1.DeleteServiceAccount'\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| project-away result\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadRequestAccountId, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for service accounts deleted for the last 24 hours.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMDisabledServiceAccounts.yaml", "query_name": "GCP IAM - Disabled service accounts", "query": "GCP_IAM\n| where TimeGenerated > ago(24h)\n| where PayloadMethodname =~ 'google.iam.admin.v1.DisableServiceAccount'\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| project-away result\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadRequestAccountId, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for service accounts disabled for the last 24 hours.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMNewCustomRoles.yaml", "query_name": "GCP IAM - New custom roles", "query": "GCP_IAM\n| where TimeGenerated > ago(24h)\n| where PayloadMethodname =~ 'google.iam.admin.v1.CreateRole'\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| project-away result\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadRequestAccountId, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for new custom roles created for the last 24 hours.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMNewServiceAccounts.yaml", "query_name": "GCP IAM - New service accounts", "query": "GCP_IAM\n| where TimeGenerated > ago(24h)\n| where PayloadMethodname =~ 'google.iam.admin.v1.CreateServiceAccount'\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| project-away result\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadRequestAccountId, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for new service accounts created for the last 24 hours.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMNewServiceAccountsKeys.yaml", "query_name": "GCP IAM - New service account keys", "query": "GCP_IAM\n| where TimeGenerated > ago(24h)\n| where PayloadMethodname =~ 'google.iam.admin.v1.CreateServiceAccountKey'\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| project-away result\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadRequestAccountId, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for new service accounts keys created for the last 24 hours.'\n", "techniques": ["T1550"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMRareActionUser.yaml", "query_name": "GCP IAM - Rare IAM actions", "query": "let user_actions = \nGCP_IAM\n| where TimeGenerated between (ago(30d) .. (1d))\n| where isnotempty(PayloadMethodname)\n| summarize makeset(PayloadMethodname);\nGCP_IAM\n| where TimeGenerated > ago(24h)\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'true'\n| project-away result\n| where PayloadMethodname !in~ (user_actions)\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadRequestAccountId, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for rare IAM actions by users.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMRareUA.yaml", "query_name": "GCP IAM - Rare user agent", "query": "let known_UAs = \nGCP_IAM\n| where TimeGenerated between (ago(30d) .. (1d))\n| where isnotempty(HttpUserAgentOriginal)\n| summarize makeset(HttpUserAgentOriginal);\nGCP_IAM\n| where TimeGenerated > ago(24h)\n| where isnotempty(HttpUserAgentOriginal)\n| where HttpUserAgentOriginal !in~ (known_UAs)\n| extend timestamp = TimeGenerated, AccountCustomEntity = PayloadRequestAccountId, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for rare user agents.'\n", "techniques": ["T1078"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMTopServiceAccountsFailedActions.yaml", "query_name": "GCP IAM - Top service accounts by failed actions", "query": "GCP_IAM\n| where TimeGenerated > ago(24h)\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'false'\n| summarize count() by ResourceLabelsProjectId\n| top 10 by count_\n| extend AccountCustomEntity = ResourceLabelsProjectId\n", "attributes": {"description": "'Query searches for service accounts with top failed actions count.'\n", "techniques": ["T1580", "T1526"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleCloudPlatformIAM/Hunting%20Queries/GCPIAMTopSrcIpAddrFailedActions.yaml", "query_name": "GCP IAM - Top source IP addresses with failed actions", "query": "GCP_IAM\n| where TimeGenerated > ago(24h)\n| extend result = parse_json(todynamic(PayloadAuthorizationinfo))[0]['granted']\n| where result =~ 'false'\n| where isnotempty(SrcIpAddr)\n| summarize count() by SrcIpAddr\n| top 10 by count_\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for source IP addresses with top failed actions count.'\n", "techniques": ["T1580", "T1526"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspaceAdminPermissionsGranted.yaml", "query_name": "GWorkspace - Admin permissions granted", "query": "GWorkspaceActivityReports \n| where EventMessage =~ 'grant_admin_privilege'\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Triggers on admin permissions granted.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspaceAlertEvents.yaml", "query_name": "GWorkspace - Alert events", "query": "GWorkspaceActivityReports\n| where EventType has \"ALERT_CENTER\"\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Detects alert events.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspaceApiAccessToNewClient.yaml", "query_name": "GWorkspace - API Access Granted", "query": "GWorkspaceActivityReports\n| where EventMessage has \"AUTHORIZE_API_CLIENT_ACCESS\"\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Triggers when API Access has been granted to a new client.'\n", "techniques": ["T1550"], "tactics": ["DefenseEvasion", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspaceChangedUserAccess.yaml", "query_name": "GWorkspace - User access has been changed", "query": "GWorkspaceActivityReports\n| where EventMessage has \"change_user_access\"\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Detects user access change.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspaceDifferentUAsFromSingleIP.yaml", "query_name": "GWorkspace - Multiple user agents for single source", "query": "let threshold = 5;\nGWorkspaceActivityReports\n| where isnotempty(UserAgentOriginal)\n| summarize user_ua = makeset(UserAgentOriginal) by SrcIpAddr, bin(TimeGenerated, 5m)\n| where array_length(user_ua) > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests with different user agents from one source in short timeframe.'\n", "techniques": ["T1185", "T1176"], "tactics": ["Persistence", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspaceOutboundRelayAddedToSuiteDomain.yaml", "query_name": "GWorkspace - An Outbound Relay has been added to a G Suite Domain", "query": "GWorkspaceActivityReports\n| where EventMessage has \"TOGGLE_OUTBOUND_RELAY\"\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Detects outbound relays may be added to collect email.'\n", "techniques": ["T1114"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspacePossibleBruteForce.yaml", "query_name": "GWorkspace - Possible brute force attack", "query": "let threshold = 5;\nGWorkspaceActivityReports\n| where EventMessage has \"login_failure\"\n| summarize login_attempts = count() by ActorEmail, bin(TimeGenerated, 5m)\n| where login_attempts > threshold\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Detects possible brute force attack.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspacePossibleMaldocFileNamesInGDRIVE.yaml", "query_name": "GWorkspace - Possible maldoc file name in Google drive", "query": "GWorkspaceActivityReports\n| where isnotempty(DocTitle)\n| where DocTitle contains \"invoice\" or DocTitle contains \"payment\" or DocTitle contains \"order\" or DocTitle contains \"fax\" or DocTitle contains \"scan\" or DocTitle contains \"transfer\" or DocTitle contains \"report\" or DocTitle contains \"bill\"\n| extend FileCustomEntity = DocTitle, AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Detects possible maldoc file name in Google drive.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspaceTwoStepAuthenticationDisabledForUser.yaml", "query_name": "GWorkspace - Two-step authentification disabled for a user", "query": "GWorkspaceActivityReports \n| where EventMessage =~ 'TURN_OFF_2_STEP_VERIFICATION'\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Triggers on two-step authentification disabled for a user.'\n", "techniques": ["T1111"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Analytic%20Rules/GWorkspaceUnexpectedOSUpdate.yaml", "query_name": "GWorkspace - Unexpected OS update", "query": "GWorkspaceActivityReports\n| where EventMessage has \"os_updated\"\n| where isnotempty(NeqValue) and isnotempty(OldValue)\n| extend NewVersion1 = extract(@'([0-9]+)\\.([0-9]+)\\.?([0-9])?', 1, NeqValue)\n| extend NewVersion2 = extract(@'([0-9]+)\\.([0-9]+)\\.?([0-9])?', 2, NeqValue)\n| extend NewVersion3 = extract(@'([0-9]+)\\.([0-9]+)\\.?([0-9])?', 3, NeqValue)\n| extend OldVersion1 = extract(@'([0-9]+)\\.([0-9]+)\\.?([0-9])?', 1, OldValue)\n| extend OldVersion2 = extract(@'([0-9]+)\\.([0-9]+)\\.?([0-9])?', 2, OldValue)\n| extend OldVersion3 = extract(@'([0-9]+)\\.([0-9]+)\\.?([0-9])?', 3, OldValue)\n| extend NewVersion3Comparision = iff(isempty(NewVersion3), 0, tolong(NewVersion3))\n| extend OldVersion3Comparision = iff(isempty(OldVersion3), 0, tolong(OldVersion3))\n| extend Comparision1 = iff(tolong(NewVersion3Comparision) > tolong(OldVersion3Comparision), 'Expected version', 'Unexpected version')\n| extend Comparision2 = iff(tolong(NewVersion2) > tolong(OldVersion2), 'Expected version', Comparision1)\n| extend VersionCheck = iff(tolong(NewVersion1) > tolong(OldVersion1), 'Expected version', Comparision2)\n| project-away NewVersion1, NewVersion2, NewVersion3, NewVersion3Comparision, OldVersion1, OldVersion2, OldVersion3, OldVersion3Comparision, Comparision1, Comparision2\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Detects unexpected OS update.'\n", "techniques": NaN, "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceDocumentSharedExternally.yaml", "query_name": "GWorkspace - Document shared externally", "query": "GWorkspaceActivityReports \n| where TimeGenerated > ago(24h)\n| where EventType =~ 'acl_change'\n| where Visibility =~ 'shared_externally'\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Query searches document shared externally.'\n", "techniques": ["T1048", "T1565"], "tactics": ["Exfiltration", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceDocumentSharedPublicily.yaml", "query_name": "GWorkspace - Document shared publicy in web", "query": "GWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where Visibility has \"public_on_the_web\"\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Query searches document shared publicy  in web.'\n", "techniques": ["T1048", "T1565"], "tactics": ["Exfiltration", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceDocumentSharedPublicilyWithLink.yaml", "query_name": "GWorkspace - Document shared publicy with link", "query": "GWorkspaceActivityReports \n| where TimeGenerated > ago(24h)\n| where EventType =~ 'acl_change'\n| where Visibility =~ 'people_with_link'\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Query searches document shared publicy with link.'\n", "techniques": ["T1048", "T1565"], "tactics": ["Exfiltration", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceMultiIPAddresses.yaml", "query_name": "GWorkspace - Multi IP addresses by user", "query": "GWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where isnotempty(SrcIpAddr)\n| summarize UserIP = make_set(SrcIpAddr) by ActorEmail\n| where array_length(UserIP) > 3\n| extend IPCustomEntity = UserIP\n", "attributes": {"description": "'Query searches users with multi IP addresses.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspacePossibleSCAMSPAMorPhishingCalendar.yaml", "query_name": "GWorkspace - Possible SCAM/SPAM or Phishing via Calendar", "query": "let OwnDomains = \nGWorkspaceActivityReports\n| where TimeGenerated > ago(30d)\n| where isnotempty(OwnerDomain) \n| summarize domain_lst = make_set(OwnerDomain);\nGWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where isnotempty(OrganizerCalendarId) \n| extend UserDomain = extract(@\"([a-zA-Z0-9.-_]+)@([a-zA-Z0-9.-]+)\",2,OrganizerCalendarId)\n| where UserDomain !in~ (OwnDomains)\n| where ActorCallerType has \"EXTERNAL_USER\"\n| extend AccountCustomEntity = OrganizerCalendarId\n", "attributes": {"description": "'Query searches possible SCAM/SPAM or phishing via calendar.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceRareDocType.yaml", "query_name": "GWorkspace - Rare document types by users", "query": "GWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where isnotempty(DocType)\n| summarize users = makeset(ActorEmail), count() by DocType\n| top 20 by count_ asc \n| extend AccountCustomEntity = Users\n", "attributes": {"description": "'Query searches rare document types by users.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceSharedPrivateDocument.yaml", "query_name": "GWorkspace - Shared private document", "query": "GWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where OldVisibility has \"private\" and Visibility has \"shared\"\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Query searches shared private document.'\n", "techniques": ["T1048", "T1565"], "tactics": ["Exfiltration", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceSuspendedUsers.yaml", "query_name": "GWorkspace - Suspended users", "query": "GWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where EventMessage has \"suspend\"\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Query searches suspended users.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceUncommonUAsString.yaml", "query_name": "GWorkspace - Uncommon user agent strings", "query": "let length = 10;\nGWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where isnotempty(UserAgentOriginal)\n| where strlen(UserAgentOriginal) < length\n| extend UrlCustomEntity = UserAgentOriginal, AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Query searches uncommon user agent strings.'\n", "techniques": ["T1185", "T1176"], "tactics": ["Persistence", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceUnknownLoginType.yaml", "query_name": "GWorkspace - Unknown login type", "query": "GWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where EventType =~ \"login\"\n| where LoginType has \"unknown\"\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Query searches unknown login type.'\n", "techniques": ["T1550", "T1078"], "tactics": ["InitialAccess", "DefenseEvasion", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceUserReportedCalendarInviteAsSpam.yaml", "query_name": "GWorkspace - User reported calendar invite as spam", "query": "GWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where EventResponseStatus has \"spam\"\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Query searches calendar invites used to deliver spam. This query shows results when user reports a calander invite as spam.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/GoogleWorkspaceReports/Hunting%20Queries/GWorkspaceUserWithSeveralDevices.yaml", "query_name": "GWorkspace - Users with several devices", "query": "GWorkspaceActivityReports\n| where TimeGenerated > ago(24h)\n| where isnotempty(DvcModelName)\n| summarize UserDevices = make_set(DvcModelName) by ActorEmail\n| where array_length(UserDevices) >= 5\n| extend AccountCustomEntity = ActorEmail\n", "attributes": {"description": "'Query searches users with several devices.'\n", "techniques": ["T1078"], "tactics": ["InitialAcces"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Illusive%20Platform/Analytic%20Rules/Illusive_Detection_Query.yaml", "query_name": "Illusive Incidents Analytic Rule", "query": "CommonSecurityLog\n| where DeviceProduct == \"illusive\"\n| extend DeviceCustomNumber2 = coalesce(column_ifexists(\"FieldDeviceCustomNumber2\", int(null)),DeviceCustomNumber2)\n| summarize arg_max(TimeGenerated, *) by DeviceCustomNumber2, AdditionalExtensions, TimeGenerated\n| extend Category = extract(@'cat=([^;]+)(\\;|$)', 1, AdditionalExtensions), HasForensics = extract(@'cs7=([^;]+)(\\;|$)', 1, AdditionalExtensions)\n| extend Category = coalesce(column_ifexists(\"DeviceEventCategory\",\"\"),Category)\t\n| where Category == \"illusive:alerts\"\n| extend IncidentId = DeviceCustomNumber2, IncidentURL = DeviceCustomString5\n| project TimeGenerated, SourceIP, SourceHostName,Computer , DeviceEventClassID ,HasForensics ,SourceUserName, Activity, DeviceAddress,  DestinationHostName, DestinationUserName, IncidentId, IncidentURL\n", "attributes": {"description": "'Create a Sentinel incident upon a new Illusive alert (incident) and associate all related Illusive events to the relevant Sentinel alert. This is done by filtering and processing Illusive Syslog messages.'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaAbnormalProtocolUsage.yaml", "query_name": "Imperva - Abnormal protocol usage", "query": "ImpervaWAFCloud\n| where NetworkApplicationProtocol in~ ('HTTP', 'HTTPs')\n| where DstPortNumber !in ('80', '443')\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects abnormal protocol usage.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaAdminPanelUncommonIp.yaml", "query_name": "Imperva - Request from unexpected IP address to admin panel", "query": "ImpervaWAFCloud\n| where QueryString contains @'/admin'\n| where ipv4_is_private(SrcIpAddr) == False\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests from unexpected IP addresses to admin panel.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaAttackNotBlocked.yaml", "query_name": "Imperva - Critical severity event not blocked", "query": "ImpervaWAFCloud\n| where EventSeverity =~ 'CRITICAL'\n| where DvcAction !startswith 'REQ_BLOCKED' or DvcAction !startswith 'REQ_BAD_'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when critical severity event was not blocked.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaCommandInUri.yaml", "query_name": "Imperva - Possible command injection", "query": "let cmd_lst = dynamic(['%2fetc%2fpasswd', '%2fetc%2fshadow', 'ping', 'whoami', 'phpinfo', '%2fbin%2fbash', 'curl', 'exec(', 'wget', 'python', 'gcc' , 'uname', 'systeminfo', 'rout', 'hostname', 'ifconfig']);\nImpervaWAFCloud\n| where QueryString has_any (cmd_lst)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests with commands in URI.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaForbiddenCountry.yaml", "query_name": "Imperva - Request from unexpected countries", "query": "let bl_country = dynamic(['CH', 'KR']);\nImpervaWAFCloud\n| where Country in (bl_country)\n| where DvcAction !startswith 'REQ_BLOCKED' or DvcAction !startswith 'REQ_BAD_'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects request attempts from unexpected countries.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaForbiddenMethod.yaml", "query_name": "Imperva - Forbidden HTTP request method in request", "query": "let bl_http_methods = dynamic(['PUT', 'HEAD', 'OPTIONS', 'TRACE', 'POST']);\nImpervaWAFCloud\n| where HttpRequestMethod in~ (bl_http_methods)\n| extend IPCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects connections with unexpected HTTP request method.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaMaliciousClient.yaml", "query_name": "Imperva - Malicious Client", "query": "ImpervaWAFCloud\n| where ClientApp in~ ('VulnerabilityScanner', 'DDoSBot', 'ClickBot','CommentSpamBot','HackingTool', 'SpamBot', 'Worm')\n| where DvcAction !startswith 'REQ_BLOCKED' or DvcAction !startswith 'REQ_BAD_'\n| extend IPCustomEntity = SrcIpAddr, UrlCustomEntity = QueryString\n", "attributes": {"description": "'Detects connections from known malicious clients.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaMaliciousUA.yaml", "query_name": "Imperva - Malicious user agent", "query": "ImpervaWAFCloud\n| where HttpUserAgentOriginal has_any ('Nikto', 'hydra', 'advanced email extractor', 'BFAC', 'brutus', 'cgichk', 'cisco-torch', 'scanner', 'datacha0s', 'dirbuster', 'grabber', 'havij', 'internet ninja', 'masscan', 'morfeus', 'mysqloit', 'n-stealth', 'nessus', 'netsparker', 'nmap nse', 'nmap scripting engine', 'nmap-nse', 'nsauditor', 'openvas', 'pangolin', 'qualys was', 'security scan', 'springenwerk', 'sql power injector', 'sqlmap', 'sqlninja', 'w3af.sf.net', 'w3af.sourceforge.net', 'w3af.org', 'webbandit', 'webinspect', 'webvulnscan', 'xmlrpc exploit', 'WPScan', 'XSpider', 'Webster', 'fantomCrew', 'fantomBrowser')\n| summarize count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests containing known malicious user agent strings.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaMultipleUAsSource.yaml", "query_name": "Imperva - Multiple user agents from same source", "query": "let threshold = 10;\nImpervaWAFCloud\n| summarize d_uas = dcount(HttpUserAgentOriginal) by SrcIpAddr, bin(TimeGenerated, 5m)\n| where d_uas >= threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "''Detects suspicious number of user agents from the same IP address.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Analytic%20Rules/ImpervaSuspiciousDstPort.yaml", "query_name": "Imperva - Request to unexpected destination port", "query": "let bl_ports = dynamic(['22', '3389']);\nImpervaWAFCloud\n| where DvcAction !startswith 'REQ_BLOCKED' or DvcAction !startswith 'REQ_BAD_'\n| where DstPortNumber in (bl_ports)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects request attempts to unexpected destination ports.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaDestinationBlocked.yaml", "query_name": "Imperva - Top destinations with blocked requests", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| where DvcAction startswith 'REQ_BLOCKED'\n| summarize count() by DstIpAddr\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches destination IP addresses requests to which were blocked by the service.'\n", "techniques": ["T1190", "T1133", "T1498"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaInsecureWebProtocolVersion.yaml", "query_name": "Imperva - Applications with insecure web protocol version", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| where NetworkApplicationProtocoVersion !startswith 'TLSv1.2'\n| summarize count() by DstDomainHostname\n| extend DomainNameCustom = DstDomainHostname\n", "attributes": {"description": "'Query searches for with insecure web protocol version.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaNonWebApplication.yaml", "query_name": "Imperva - Non HTTP/HTTPs applications", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| where NetworkApplicationProtocol !in~ ('HTTP', 'HTTPs')\n| summarize count() by DstIpAddr, NetworkApplicationProtocol\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for non HTTP/HTTPs applications.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaRareApplications.yaml", "query_name": "Imperva - Rare applications", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| where isnotempty(NetworkApplicationProtocol)\n| summarize count() by NetworkApplicationProtocol\n| top 5 by count_ asc\n| extend AppCustomEntity = NetworkApplicationProtocol\n", "attributes": {"description": "'Query searches for rare application protocols.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaRareClientApplications.yaml", "query_name": "Imperva - Rare client applications", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| where isnotempty(ClientApp)\n| summarize count() by ClientApp\n| top 10 by count_ asc\n| extend AppCustomEntity = ClientApp\n", "attributes": {"description": "'Query searches for rare client applications used.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaRareDstPorts.yaml", "query_name": "Imperva - Rare destination ports", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| summarize count() by DstIpAddr, DstPortNumber\n| top 20 by count asc\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for requests for rare destination ports.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaRequestsFromBots.yaml", "query_name": "Imperva - request from known bots", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| where ClientApp =~ 'Bot'\n| summarize count() by SrcIpAddr, NetworkApplicationProtocol\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for requests from known bots.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaSourceBlocked.yaml", "query_name": "Imperva - Top sources with blocked requests", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| where DvcAction startswith 'REQ_BLOCKED'\n| summarize count() by SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches source IP addresses with blocked requests.'\n", "techniques": ["T1190", "T1133", "T1498"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaTopApplicationsErrors.yaml", "query_name": "Imperva - Top applications with error requests", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| where DvcAction startswith 'REQ_BAD_'\n| summarize count() by DstIpAddr, DstDomainHostname\n| top 10 by count_\n| extend IPCustomEntity = DstIpAddr, DomainNameCustom = DstDomainHostname\n", "attributes": {"description": "'Query searches for top applications with protocol or network errors.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ImpervaCloudWAF/Hunting%20Queries/ImpervaTopSourcesErrors.yaml", "query_name": "Imperva - Top sources with error requests", "query": "ImpervaWAFCloud\n| where TimeGenerated > ago(24h)\n| where DvcAction startswith 'REQ_BAD_'\n| summarize count() by SrcIpAddr\n| top 100 by count_\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for top source IP addresses with protocol or network errors.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Infoblox%20Cloud%20Data%20Connector/Analytic%20Rules/Infoblox-HighNumberOfHighThreatLevelQueriesDetected.yaml", "query_name": "Infoblox - High Number of High Threat Level Queries Detected", "query": "\nlet threshold = 200;\nInfobloxCDC\n| where DeviceEventClassID has_cs \"RPZ\"\n| where ThreatLevel_Score >=80\n| summarize count() by SourceIP\n| where count_ > threshold\n| join kind=inner (InfobloxCDC\n    | where DeviceEventClassID has_cs \"RPZ\"\n    | where ThreatLevel_Score >=80\n    ) on SourceIP\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName\n", "attributes": {"description": "'This creates an incident in the event a single host generates at least 200 high threat level RPZ queries (Threat Defense security hits) in 1 hour. Query count threshold and scheduling is customizable. This rule depends on a parser based on a Kusto Function to work as expected called [**InfobloxCDC**](https://aka.ms/sentinel-InfobloxCloudDataConnector-parser).'\n", "techniques": ["T1498", "T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Infoblox%20Cloud%20Data%20Connector/Analytic%20Rules/Infoblox-HighNumberOfNXDOMAINDNSResponsesDetected.yaml", "query_name": "Infoblox - High Number of NXDOMAIN DNS Responses Detected", "query": "\nlet threshold = 200;\nInfobloxCDC\n| where DeviceEventClassID == \"DNS Response\"\n| where InfobloxDNSRCode == \"NXDOMAIN\"\n| summarize count() by SourceIP\n| where count_ > threshold\n| join kind=inner (InfobloxCDC\n    | where DeviceEventClassID == \"DNS Response\"\n    | where InfobloxDNSRCode == \"NXDOMAIN\"\n    ) on SourceIP\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName\n", "attributes": {"description": "'This creates an incident in the event a single host generates at least 200 DNS responses for non-existent domains in 1 hour. Query count threshold and scheduling is customizable. This rule depends on a parser based on a Kusto Function to work as expected called [**InfobloxCDC**](https://aka.ms/sentinel-InfobloxCloudDataConnector-parser).'\n", "techniques": ["T1498", "T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Infoblox%20Cloud%20Data%20Connector/Analytic%20Rules/Infoblox-HighThreatLevelQueryNotBlockedDetected.yaml", "query_name": "Infoblox - High Threat Level Query Not Blocked Detected", "query": "\nlet threshold = 1;\nInfobloxCDC\n| where DeviceEventClassID has_cs \"RPZ\"\n| where ThreatLevel_Score >=80\n| where InfobloxB1PolicyAction == \"Log\" or SimplifiedDeviceAction == \"PASSTHRU\"\n| summarize count() by SourceIP\n| where count_ > threshold\n| join kind=inner (InfobloxCDC\n    | where DeviceEventClassID has_cs \"RPZ\"\n    | where ThreatLevel_Score >=80\n    | where InfobloxB1PolicyAction == \"Log\" or SimplifiedDeviceAction == \"PASSTHRU\"\n    ) on SourceIP\n| extend timestamp = TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName\n", "attributes": {"description": "'This creates an incident in the event a single host generates at least 1 high threat level query (Threat Defense security hit) that is not blocked or redirected in 1 hour. Query count threshold and scheduling is customizable. This rule depends on a parser based on a Kusto Function to work as expected called [**InfobloxCDC**](https://aka.ms/sentinel-InfobloxCloudDataConnector-parser).'\n", "techniques": ["T1498", "T1565"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Infoblox%20NIOS/Analytic%20Rules/ExcessiveNXDOMAINDNSQueries.yaml", "query_name": "Excessive NXDOMAIN DNS Queries", "query": "\nlet threshold = 200;\nInfoblox_dnsclient\n| where ProcessName =~ \"named\" and Log_Type =~ \"client\"\n| where isnotempty(DnsResponseCode)\n| where DnsResponseCode =~ \"NXDOMAIN\"\n| summarize count() by SrcIpAddr, bin(TimeGenerated,15m)\n| where count_ > threshold\n| join kind=inner (Infoblox_dnsclient\n    | where ProcessName =~ \"named\" and Log_Type =~ \"client\"\n    | where isnotempty(DnsResponseCode)\n    | where DnsResponseCode =~ \"NXDOMAIN\"\n    ) on SrcIpAddr\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'This creates an incident in the event a client generates excessive amounts of DNS queries for non-existent domains.'\n", "techniques": ["T1568", "T1008"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Infoblox%20NIOS/Analytic%20Rules/PotentialDHCPStarvationAttack.yaml", "query_name": "Potential DHCP Starvation Attack", "query": "\nlet threshold = 1000;\nInfoblox\n| where ProcessName =~ \"dhcpd\" and Log_Type =~ \"DHCPREQUEST\"\n| summarize count() by ServerIP, bin(TimeGenerated,5m)\n| where count_ > threshold\n| join kind=inner (Infoblox\n    | where ProcessName =~ \"dhcpd\" and Log_Type =~ \"DHCPREQUEST\"\n    ) on ServerIP\n| extend timestamp = TimeGenerated, IPCustomEntity = ServerIP\n", "attributes": {"description": "'This creates an incident in the event that an excessive amount of DHCPREQUEST have been recieved by a DHCP Server and could potentially be an indication of a DHCP Starvation Attack.'\n", "techniques": ["T1200"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTDenialofService.yaml", "query_name": "Denial of Service (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"Suspicion of Denial Of Service Attack\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect attacks that would prevent the use or proper operation of a DCS system including Denial of Service events.'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTExcessiveLoginAttempts.yaml", "query_name": "Excessive Login Attempts (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"Excessive Login Attempts\" \nor AlertName == \"Excessive SMB login attempts\" \nor AlertName == \"Password Guessing Attempt Detected\"\nor AlertName == \"Excessive Number of Sessions\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect excessive login attempts that may indicate improper service configuration, human error, or malicious activity on the network such as a cyber threat attempting to manipulate the SCADA network.'\n", "techniques": ["T0886"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTFirmwareUpdates.yaml", "query_name": "Firmware Updates (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"Beckhoff Software Changed\" \nor AlertName contains \"Firmware Version Changed\"\nor AlertName contains \"Firmware Change\"\nor AlertName contains \"Firmware Changed\"\nor AlertName contains \"Firmware Update\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect unauthorized firmware updates that may indicate malicious activity on the network such as a cyber threat that attempts to manipulate PLC firmware to compromise PLC function.'\n", "techniques": ["T0857"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTHighBandwidth.yaml", "query_name": "High bandwidth in the network (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"Abnormal Traffic Bandwidth\" \nor AlertName == \"Abnormal Traffic Bandwidth Between Devices\" \nor AlertName == \"ARP Spoofing\" \nor AlertName == \"ICMP Flooding\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect an unusually high bandwidth which may be an indication of a new service/process or malicious activity on the network. An example scenario is a cyber threat attempting to manipulate the SCADA network.'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTIllegalFunctionCodes.yaml", "query_name": "Illegal Function Codes for ICS traffic (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"Function Code Not Supported by Outstation\"\nor AlertName == \"Illegal BACNet message\"\nor AlertName == \"Illegal Connection Attempt on Port 0\"\nor AlertName == \"Illegal DNP3 Operation\"\nor AlertName == \"Illegal MODBUS Operation (Exception Raised by Master)\"\nor AlertName == \"Illegal MODBUS Operation (Function Code Zero)\"\nor AlertName == \"Incorrect Parameter Sent to Outstation\"\nor AlertName == \"Initiation of an Obsolete Function Code (Initialize Data)\"\nor AlertName == \"Initiation of an Obsolete Function Code (Save Config)\"\nor AlertName == \"Modbus Exception\"\nor AlertName == \"Unknown Object Sent to Outstation\"\nor AlertName == \"Usage of a Reserved Function Code\"\nor AlertName == \"Usage of Improper Formatting by Outstation\"\nor AlertName == \"Usage of Reserved Status Flags (IIN)\"\nor AlertName == \"Unauthorized communication was detected by a User Defined Protocol Rule\"\nor AlertName == \"Unauthorized Operation was detected by a User Defined whitelist Alert\"\nor AlertName == \"Illegal Protocol Version\"\nor AlertName contains \"Slave Device Received Illegal\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect Illegal function codes in SCADA equipment indicating improper application configuration or malicious activity such using illegal values within a protocol to exploit a PLC vulnerability.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTINoSensorTrafficDetected.yaml", "query_name": "No traffic on Sensor Detected (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"No Traffic Detected on Sensor Interface\" \n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect that a sensor can no longer detect the network traffic, which indicates that the system is potentially insecure.'\n", "techniques": ["T0881"], "tactics": ["InhibitResponseFunction"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTInsecurePLC.yaml", "query_name": "PLC unsecure key state (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName contains \"PLC Operating Mode Changed\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect PLC operating mode changes indicating the PLC is potentially insecure. If the PLC is compromised, devices that interact with it may be impacted. This may affect overall system security and safety.'\n", "techniques": ["T0858"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTInternetAccess.yaml", "query_name": "Internet Access (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName contains \"Internet\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect an OT device communicating with Internet which is possibly an indication of improper configuration of an application or malicious activity on the network.'\n", "techniques": ["T0883"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTMalware.yaml", "query_name": "Suspicious malware found in the network (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName contains \"Malware\"\nor AlertName contains \"Suspicion of Malicious Activity\"\nor AlertName == \"Invalid SMB Message (DoublePulsar Backdoor Implant)\"\nor AlertName == \"Connection Attempt to Known Malicious IP\"\nor AlertName == \"Malicious Domain Name Request\"\nor AlertName == \"Suspicion of Remote Code Execution with PsExec\" \nor AlertName == \"Suspicion of Remote Windows Service Management\" \nor AlertName == \"Suspicious Executable File Detected on Endpoint\" \nor AlertName == \"Suspicious Traffic Detected\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect IoT/OT malware found on the network indicating possible attempts to compromise production systems.'\n", "techniques": ["T0882"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTNetworkScanning.yaml", "query_name": "Multiple scans in the network (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName contains \"Scan\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect multiple scans on the network indicating new devices, functionality, application misconfiguration, or malicious reconnaissance activity on the network.'\n", "techniques": ["T0842"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTPLCStopCommand.yaml", "query_name": "PLC Stop Command (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"An S7 Stop PLC Command was Sent\"\nor AlertName == \"Controller Reset\"\nor AlertName == \"Controller Stop\"\nor AlertName == \"Excessive Restart Rate of an Outstation\"\nor AlertName == \"GE SRTP Stop PLC Command was Sent\"\nor AlertName == \"Outstation Restarted\"\nor AlertName == \"Outstation Restarts Frequently\"\nor AlertName == \"Profinet Device Factory Reset\"\nor AlertName == \"Slave Device Unrecoverable Failure\"\nor AlertName == \"Suspicion of Hardware Problems in Outstation\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect PLC stop commands which could indicate improper configuration or malicious activity on the network such as a threat manipulating PLC programming to affect the function of the network.'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTUnauthorizedDevice.yaml", "query_name": "Unauthorized device in the network (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"Field Device Discovered Unexpectedly\" \nor AlertName == \"New Asset Detected\" \nor AlertName == \"Abnormal usage of MAC Addresses\" \nor AlertName == \"New LLDP Device Configuration\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect a new device indicating a legitimate device recently installed on the network or an indication of malicious activity such as a cyber threat attempting to manipulate the SCADA network.'\n", "techniques": ["T0858"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTUnauthorizedNetworkConfiguration.yaml", "query_name": "Unauthorized DHCP configuration in the network (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"Device Failed to Receive a Dynamic IP Address\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect an unauthorized DHCP configuration indicating a possible unauthorized device configuration.'\n", "techniques": ["T0813"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTUnauthorizedPLCModifications.yaml", "query_name": "Unauthorized PLC changes (Microsoft Defender for IoT)", "query": "let alertList = dynamic([\"Unpermitted Usage of Internal Indication (IIN)\", \"Modbus Address Range Violation\", \"Function Code Raised Unauthorized Exception\", \"Unauthorized Access to Siemens S7 Data Block\", \"Unauthorized Access to Wonderware Tag\", \"Unauthorized MMS Program Access\", \"GOOSE Message Type Settings\", \"Sampled Values Message Type Settings\", \"Foxboro I/A Unauthorized Operation\", \"New Activity Detected - CIP Class\", \"New Activity Detected - CIP Class Service\", \"New Activity Detected - CIP PCCC Command\", \"New Activity Detected - CIP Symbol\", \"New Activity Detected - EtherNet/IP I/O Connection\", \"New Activity Detected - EtherNet/IP Protocol Command\", \"New Activity Detected - GSM Message Code\", \"New Activity Detected - LonTalk Command Codes\", \"New Activity Detected - LonTalk Network Variable\", \"New Activity Detected - Ovation Data Request\", \"New Activity Detected - Read/Write Command (AMS Index Group)\", \"New Activity Detected - Read/Write Command (AMS Index Offset)\", \"New Activity Detected - Unauthorized DeltaV Message Type\", \"New Activity Detected - Unauthorized DeltaV ROC Operation\", \"New Activity Detected - Using AMS Protocol Command\", \"New Activity Detected - Using Siemens SICAM Command\", \"New Activity Detected - Using Suitelink Protocol command\", \"New Activity Detected - Using Suitelink Protocol sessions\", \"New Activity Detected - Using Yokogawa VNetIP Command\", \"Omron FINS Unauthorized Command\", \"Toshiba Computer Link Unauthorized Command\", \"Unauthorized ABB Totalflow File Operation\", \"Unauthorized ABB Totalflow Register Operation\", \"Unauthorized Access to Siemens S7 Plus Object\", \"Unauthorized BACNet Object Access\", \"Unauthorized BACNet Route\", \"Unauthorized Emerson ROC Operation\", \"Unauthorized GE SRTP File Access\", \"Unauthorized GE SRTP Protocol Command\", \"Unauthorized GE SRTP System Memory Operation\", \"Unauthorized Mitsubishi MELSEC Command\", \"Unauthorized MMS Service\", \"Unauthorized OPC UA Activity\", \"Unauthorized OPC UA Request/Response\", \"Unauthorized Profinet Frame Type\", \"Unauthorized SAIA S-Bus Command\", \"Unauthorized Siemens S7 Execution of Control Function\", \"Unauthorized Siemens S7 Execution of User Defined Function\", \"Unauthorized Siemens S7 Plus Block Access\", \"Unauthorized Siemens S7 Plus Operation\", \"Unauthorized SNMP Operation\", \"Unpermitted Modbus Schneider Electric Extension\", \"Unpermitted Usage of ASDU Types\", \"Unpermitted Usage of DNP3 Function Code\", \"Unpermitted Usage of Modbus Function Code\", \"Unauthorized Operation was detected by a User Defined Rule\", \"Unauthorized PLC Configuration Read\", \"Unauthorized PLC Programming\", \"Unauthorized PLC Configuration Write\", \"Unauthorized PLC Program Upload\"]);\nSecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName has_any (alertList) or ExtendedProperties has \"Illegal Beckhoff AMS Command\" or ExtendedProperties has \"Beckhoff AMS Command Failure\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect unauthorized changes to PLC ladder logic code indicating new functionality in the PLC, improper configuration of an application, or malicious activity on the network.'\n", "techniques": ["T0839"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IoTOTThreatMonitoringwithDefenderforIoT/Analytic%20Rules/IoTUnauthorizedRemoteAccess.yaml", "query_name": "Unauthorized remote access to the network (Microsoft Defender for IoT)", "query": "SecurityAlert\n| where ProductName == \"Azure Security Center for IoT\"\n| where AlertName == \"Unauthorized SSH Access\"\n| where TimeGenerated <= ProcessingEndTime + 60m\n| extend DeviceId = tostring(parse_json(ExtendedProperties).DeviceId)\n| extend SourceDeviceAddress = tostring(parse_json(ExtendedProperties).SourceDeviceAddress)\n| extend DestDeviceAddress = tostring(parse_json(ExtendedProperties).DestinationDeviceAddress)\n| extend RemediationSteps = tostring(parse_json(RemediationSteps)[0])\n| extend Protocol = tostring(parse_json(ExtendedProperties).Protocol)\n| extend AlertManagementUri = tostring(parse_json(ExtendedProperties).AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri\n", "attributes": {"description": "'This alert leverages Defender for IoT to detect unauthorized remote access to network devices, if another device on the network is compromised, target devices can be accessed remotely, increasing the attack surface.'\n", "techniques": ["T0886"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/IronNet%20IronDefense/Analytic%20Rules/IronDefense_Detection_Query.yaml", "query_name": "Create Incidents from IronDefense", "query": "CommonSecurityLog\n| where DeviceProduct == \"IronDefense\"\n| summarize arg_max(TimeGenerated, *) by DeviceCustomString4, DeviceCustomString2\n| extend Category = coalesce(column_ifexists(\"DeviceEventCategory\",\"\"),extract(@'cat=([^;]+)(\\;|$)', 1, AdditionalExtensions))\t\n| extend Subcategory = extract(@'subcat=([^;]+)(\\;|$)', 1, AdditionalExtensions)\n| extend AlertDescription = strcat(Category, ': ', Subcategory)\n| extend Status = tostring(DeviceCustomString2)\n| extend IronVueUrl = replace(@'\\\\', @'', tostring(DeviceCustomString3))\n", "attributes": {"description": "'Creates incidents based on behavioral detections from IronDefense.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/LastPass/Analytic%20Rules/EmployeeAccountDeleted.yaml", "query_name": "Employee account deleted", "query": "LastPassNativePoller_CL\n| where Action_s == \"Employee Account Deleted\" or Action_s == \"Remove User From Company\"\n| extend AccountCustomEntity = Username_s, IPCustomEntity = IP_Address_s\n", "attributes": {"description": "'This rule will monitor for any employee accounts being deleted.\nDeleting an employee account can have a big potential impact as all of the data for that user will be removed.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/LastPass/Analytic%20Rules/FailedSigninDueToMFA.yaml", "query_name": "Failed sign-ins into LastPass due to MFA", "query": "LastPassNativePoller_CL\n| where Action_s == \"Log in\"\n| join (SigninLogs | where AppDisplayName == \"LastPass Enterprise\") on $left.IP_Address_s == $right.IPAddress and $left.Username_s == $right.UserPrincipalName\n| where ResultType in (50074, 50076)\n| extend AccountCustomEntity = Username_s, IPCustomEntity = IP_Address_s\n", "attributes": {"description": "'This rule will check if a sign-in failed into LastPass due to MFA.\nAn incident can indicate the potential brute forcing of a LastPass account. \nThe use of MFA is identified by combining the sign-in logs, this rule assumes LastPass is federated to AAD.'\n", "techniques": ["T1078", "T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/LastPass/Analytic%20Rules/HighlySensitivePasswordAccessed.yaml", "query_name": "Highly Sensitive Password Accessed", "query": "let watchlist = (_GetWatchlist(\"LastPass\") | project name);\nLastPassNativePoller_CL\n| where Data_s in (watchlist)\n| extend AccountCustomEntity = Username_s, IPCustomEntity = IP_Address_s, URLCustomEntity = Data_s\n", "attributes": {"description": "'This rule will monitor access to highly sensitive passwords.\nWithin the Watchlist called 'LastPass' define passwords which are deemed highly sensitive (such as password to a high privileged application).\nWhen an activity is observed against such password, an incident is created.'\n", "techniques": ["T1555", "T1087"], "tactics": ["CredentialAccess", "Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/LastPass/Analytic%20Rules/TIMapIPEntityToLastPass.yaml", "query_name": "TI map IP entity to LastPass data", "query": "let dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(NetworkIP) or isnotempty(EmailSourceIpAddress) or isnotempty(NetworkDestinationIP) or isnotempty(NetworkSourceIP)\n// As there is potentially more than 1 indicator type for matching IP, taking Network IP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = iff(isnotempty(NetworkIP), NetworkIP, NetworkDestinationIP)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(NetworkSourceIP), NetworkSourceIP, TI_ipEntity)\n| extend TI_ipEntity = iff(isempty(TI_ipEntity) and isnotempty(EmailSourceIpAddress), EmailSourceIpAddress, TI_ipEntity)\n| join (\n    LastPassNativePoller_CL | where todatetime(Time_s) >= ago(dt_lookBack)\n    | where Action_s != \"Reporting\"\n    // renaming time column so it is clear the log this came from\n    | extend LastPass_TimeGenerated = todatetime(Time_s)\n)\non $left.TI_ipEntity == $right.IP_Address_s\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, LastPass_TimeGenerated, \nTI_ipEntity, IP_Address_s, Username_s, Action_s, Data_s, NetworkIP, NetworkDestinationIP, NetworkSourceIP, EmailSourceIpAddress\n| extend timestamp = LastPass_TimeGenerated, AccountCustomEntity = Username_s, IPCustomEntity = IP_Address_s, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in LastPass table from any IP IOC from TI'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/LastPass/Analytic%20Rules/UnusualVolumeOfPasswordsUpdatedOrRemoved.yaml", "query_name": "Unusual Volume of Password Updated or Removed", "query": "let threshold = toscalar (LastPassNativePoller_CL\n| where todatetime(Time_s) >= startofday(ago(14d)) and todatetime(Time_s) < startofday(ago(1d))\n| where Action_s == \"Site Changed\" or Action_s == \"Deleted Sites\" \n| summarize count() by Username_s, bin(todatetime(Time_s),1d)\n| summarize avg(count_), stdev(count_)\n| project threshold = avg_count_+stdev_count_*2);\nLastPassNativePoller_CL\n| where Username_s != \"API\"\n| where Action_s == \"Site Changed\" or Action_s == \"Deleted Sites\" and todatetime(Time_s) >= startofday(ago(1d))\n| summarize count() by Username_s, IP_Address_s\n| where count_ > ['threshold']\n| extend AccountCustomEntity = Username_s, IPCustomEntity = IP_Address_s\n", "attributes": {"description": "'This rule will check if there is an unnormal activity of sites that are deleted or changed per user.\n The normal amount of actions is calculated based on the previous 14 days of activity. If there is a significant increase, an incident will be created.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/LastPass/Hunting%20Queries/FailedSigninsDueToMFA.yaml", "query_name": "Failed sign-ins into LastPass due to MFA.", "query": "LastPassNativePoller_CL\n| where Action_s == \"Log in\"\n| join (SigninLogs | where AppDisplayName == \"LastPass Enterprise\") on $left.IP_Address_s == $right.IPAddress and $left.Username_s == $right.UserPrincipalName\n| where ResultType in (50074, 50076)\n| extend AccountCustomEntity = Username_s, IPCustomEntity = IP_Address_s, TimestampCustomEntity = todatetime(Time_s)\n", "attributes": {"description": "'This will check for sign-ins into LastPass which are not confirmed using MFA based on the Sign-in Logs'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/LastPass/Hunting%20Queries/LoginIntoLastPassFromUnknownIP.yaml", "query_name": "Login into LastPass from a previously unknown IP.", "query": "let IPs = SigninLogs\n  | project IPAddress;\nLastPassNativePoller_CL\n| where Action_s != \"Reporting\"\n| where IP_Address_s !in (IPs)\n| summarize by IP_Address_s, Username_s, bin(todatetime(Time_s), 1d)\n| extend AccountCustomEntity = Username_s, IPCustomEntity = IP_Address_s, TimestampCustomEntity = Time_s\n", "attributes": {"description": "'This query will check how many activity there is in LastPass from IPs that are not seen before in the Sign-in Logs'\n", "techniques": ["T1078", "T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/LastPass/Hunting%20Queries/PasswordMoveToSharedFolder.yaml", "query_name": "Password moved to shared folders", "query": "LastPassNativePoller_CL\n| where Action_s == \"Move to Shared Folder\"\n| extend AccountCustomEntity = Username_s, IPCustomEntity = IP_Address_s, URLCustomEntity = Data_s, TimestampCustomEntity = todatetime(Time_s)\n", "attributes": {"description": "'This query will check for data that is shared in the LastPass environment.'\n", "techniques": ["T1039"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Lookout/Analytic%20Rules/LookoutThreatEvent.yaml", "query_name": "Lookout - New Threat events found.", "query": "Lookout_CL\n| where details_action_s == 'DETECTED' and type_s == 'THREAT'\n| extend DetailsPackageName = details_packageName_s\n| extend TargetPlatform = target_platform_s\n| extend TargetOsVersion = target_osVersion_s\n| extend Type = type_s\n| extend Severity = details_severity_s\n| extend Classifications = details_classifications_s\n| extend Platform = target_platform_s\n", "attributes": {"description": "'Created to detect new Threat events from the data which is recently synced by Lookout Solution.'\n", "techniques": ["T1057"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Analytic%20Rules/M2131AssetStoppedLogging.yaml", "query_name": "M2131_AssetStoppedLogging", "query": "let LastHeartbeatTime = Heartbeat\n| summarize LastHeartbeat_Time = arg_max(TimeGenerated, *) by ResourceId;\nHeartbeat\n| where TimeGenerated > ago(14d)\n| summarize LastHeartbeat_Hours = datetime_diff(\"hour\",now(), max(TimeGenerated)) by ResourceId\n| where ResourceId <> \"\"\n| where ResourceId <> \"None\"\n| join kind=inner (LastHeartbeatTime) on ResourceId\n| where LastHeartbeat_Hours > 24\n| project LastHeartbeat_Hours, LastHeartbeat_Time, Computer, ComputerIP, Category, OSType, OSName, ResourceId, SubscriptionId, ResourceGroup, RemoteIPCountry \n| sort by LastHeartbeat_Hours desc\n", "attributes": {"description": "'This alert is designed to monitor assets within the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when a monitored asset fails to provide a heartbeat within 24 hours.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Analytic%20Rules/M2131DataConnectorAddedChangedRemoved.yaml", "query_name": "M2131_DataConnectorAddedChangedRemoved", "query": "AzureActivity\n| where OperationNameValue contains \"Microsoft.SecurityInsights/dataConnectors/\"\n| where ActivityStatusValue == \"Succeeded\"\n| project OperationNameValue, Caller, CallerIpAddress, ActivityStatusValue, ActivitySubstatusValue, ResourceGroup, Properties, ResourceId, TimeGenerated\n| sort by TimeGenerated desc\n| extend Account = Caller\n", "attributes": {"description": "'This alert is designed to monitor data connector configurations. This alert is triggered when a data connector is added, updated, or deleted.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Analytic%20Rules/M2131EventLogManagementPostureChangedEL0.yaml", "query_name": "M2131_EventLogManagementPostureChanged_EL0", "query": "SecurityRecommendation\n| where RecommendationDisplayName <> \"\"\n| extend MaturityLevel=iff(RecommendationDisplayName has_any(\"agent\",\"extension\",\"retention\",\"logs encryption\",\"collect\",\"retained\",\"log profile\",\"CloudTrail\",\"metric\",\"AWS\",\"GCP\",\"DNS\",\"Auditing\",\"Flow\",\"logging\",\"usage\"), \"Event Logging (EL0)\",\niff(RecommendationDisplayName has_any(\"container registries\",\"logic apps\",\"Enhanced monitoring\",\"IoT Hub\",\"Event Hub\",\"App Service\", \"Kubernetes\",\"updates\",\"email\", \"automation\", \"adaptive\"), \"Advanced Event Logging (EL3)\",\niff(RecommendationDisplayName has_any(\"signatures\",\"CMK\",\"CMEK\",\"double encryption\",\"managed key\",\"KMS\",\"container\",\"Watcher\"), \"Intermediate Event Logging (EL2)\",\niff(RecommendationDisplayName has_any(\"Exploit Guard\",\"endpoint protection\",\"Antimalware\",\"health\",\"VPC\",\"Defender\",\"Vulnerabilities\",\"vulnerability\",\"diagnostic\",\"Key\",\"activity log alert\",\"\"), \"Basic Event Logging (EL1)\",\"Other\"))))\n| summarize arg_max(TimeGenerated, *) by RecommendationDisplayName, AssessedResourceId, MaturityLevel\n| summarize Failed = countif(RecommendationState == \"Unhealthy\"), Passed = countif(RecommendationState == \"Healthy\"), Total = countif(RecommendationState == \"Healthy\" or RecommendationState == \"Unhealthy\") by MaturityLevel\n| extend PassedControls = (Passed/todouble(Total))*100\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22')\n| project MaturityLevel, Total, PassedControls, Passed, Failed, RemediationLink, LastObserved=now()\n| where MaturityLevel <> ''\n| where MaturityLevel == \"Event Logging (EL0)\"\n| where PassedControls < 70 \n//Adjust Either FailedRatePercentage or PasedRatePercentage Thresholds within   Organizational Needs\n| sort by PassedControls desc\n| extend URLCustomEntity = RemediationLink\n", "attributes": {"description": "'This alert is desinged to monitor Azure policies aligned with the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when EL0 policy compliance falls below 70% within a 1 week timeframe.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Analytic%20Rules/M2131EventLogManagementPostureChangedEL1.yaml", "query_name": "M2131_EventLogManagementPostureChanged_EL1", "query": "SecurityRecommendation\n| where RecommendationDisplayName <> \"\"\n| extend MaturityLevel=iff(RecommendationDisplayName has_any(\"agent\",\"extension\",\"retention\",\"logs encryption\",\"collect\",\"retained\",\"log profile\",\"CloudTrail\",\"metric\",\"AWS\",\"GCP\",\"DNS\",\"Auditing\",\"Flow\",\"logging\",\"usage\"), \"Event Logging (EL0)\",\niff(RecommendationDisplayName has_any(\"container registries\",\"logic apps\",\"Enhanced monitoring\",\"IoT Hub\",\"Event Hub\",\"App Service\", \"Kubernetes\",\"updates\",\"email\", \"automation\", \"adaptive\"), \"Advanced Event Logging (EL3)\",\niff(RecommendationDisplayName has_any(\"signatures\",\"CMK\",\"CMEK\",\"double encryption\",\"managed key\",\"KMS\",\"container\",\"Watcher\"), \"Intermediate Event Logging (EL2)\",\niff(RecommendationDisplayName has_any(\"Exploit Guard\",\"endpoint protection\",\"Antimalware\",\"health\",\"VPC\",\"Defender\",\"Vulnerabilities\",\"vulnerability\",\"diagnostic\",\"Key\",\"activity log alert\",\"\"), \"Basic Event Logging (EL1)\",\"Other\"))))\n| summarize arg_max(TimeGenerated, *) by RecommendationDisplayName, AssessedResourceId, MaturityLevel\n| summarize Failed = countif(RecommendationState == \"Unhealthy\"), Passed = countif(RecommendationState == \"Healthy\"), Total = countif(RecommendationState == \"Healthy\" or RecommendationState == \"Unhealthy\") by MaturityLevel\n| extend PassedControls = (Passed/todouble(Total))*100\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22')\n| project MaturityLevel, Total, PassedControls, Passed, Failed, RemediationLink, LastObserved=now()\n| where MaturityLevel <> ''\n| where MaturityLevel == \"Basic Event Logging (EL1)\"\n| where PassedControls < 70 \n//Adjust Either FailedRatePercentage or PasedRatePercentage Thresholds within   Organizational Needs\n| sort by PassedControls desc\n| extend URLCustomEntity = RemediationLink\n", "attributes": {"description": "'This alert is desinged to monitor Azure policies aligned with the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when EL1 policy compliance falls below 70% within a 1 week timeframe.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Analytic%20Rules/M2131EventLogManagementPostureChangedEL2.yaml", "query_name": "M2131_EventLogManagementPostureChanged_EL2", "query": "SecurityRecommendation\n| where RecommendationDisplayName <> \"\"\n| extend MaturityLevel=iff(RecommendationDisplayName has_any(\"agent\",\"extension\",\"retention\",\"logs encryption\",\"collect\",\"retained\",\"log profile\",\"CloudTrail\",\"metric\",\"AWS\",\"GCP\",\"DNS\",\"Auditing\",\"Flow\",\"logging\",\"usage\"), \"Event Logging (EL0)\",\niff(RecommendationDisplayName has_any(\"container registries\",\"logic apps\",\"Enhanced monitoring\",\"IoT Hub\",\"Event Hub\",\"App Service\", \"Kubernetes\",\"updates\",\"email\", \"automation\", \"adaptive\"), \"Advanced Event Logging (EL3)\",\niff(RecommendationDisplayName has_any(\"signatures\",\"CMK\",\"CMEK\",\"double encryption\",\"managed key\",\"KMS\",\"container\",\"Watcher\"), \"Intermediate Event Logging (EL2)\",\niff(RecommendationDisplayName has_any(\"Exploit Guard\",\"endpoint protection\",\"Antimalware\",\"health\",\"VPC\",\"Defender\",\"Vulnerabilities\",\"vulnerability\",\"diagnostic\",\"Key\",\"activity log alert\",\"\"), \"Basic Event Logging (EL1)\",\"Other\"))))\n| summarize arg_max(TimeGenerated, *) by RecommendationDisplayName, AssessedResourceId, MaturityLevel\n| summarize Failed = countif(RecommendationState == \"Unhealthy\"), Passed = countif(RecommendationState == \"Healthy\"), Total = countif(RecommendationState == \"Healthy\" or RecommendationState == \"Unhealthy\") by MaturityLevel\n| extend PassedControls = (Passed/todouble(Total))*100\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22')\n| project MaturityLevel, Total, PassedControls, Passed, Failed, RemediationLink, LastObserved=now()\n| where MaturityLevel <> ''\n| where MaturityLevel == \"Intermediate Event Logging (EL2)\"\n| where PassedControls < 70 \n//Adjust Either FailedRatePercentage or PasedRatePercentage Thresholds within   Organizational Needs\n| sort by PassedControls desc\n| extend URLCustomEntity = RemediationLink\n", "attributes": {"description": "'This alert is desinged to monitor Azure policies aligned with the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when EL2 policy compliance falls below 70% within a 1 week timeframe.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Analytic%20Rules/M2131EventLogManagementPostureChangedEL3.yaml", "query_name": "M2131_EventLogManagementPostureChanged_EL3", "query": "SecurityRecommendation\n| where RecommendationDisplayName <> \"\"\n| extend MaturityLevel=iff(RecommendationDisplayName has_any(\"agent\",\"extension\",\"retention\",\"logs encryption\",\"collect\",\"retained\",\"log profile\",\"CloudTrail\",\"metric\",\"AWS\",\"GCP\",\"DNS\",\"Auditing\",\"Flow\",\"logging\",\"usage\"), \"Event Logging (EL0)\",\niff(RecommendationDisplayName has_any(\"container registries\",\"logic apps\",\"Enhanced monitoring\",\"IoT Hub\",\"Event Hub\",\"App Service\", \"Kubernetes\",\"updates\",\"email\", \"automation\", \"adaptive\"), \"Advanced Event Logging (EL3)\",\niff(RecommendationDisplayName has_any(\"signatures\",\"CMK\",\"CMEK\",\"double encryption\",\"managed key\",\"KMS\",\"container\",\"Watcher\"), \"Intermediate Event Logging (EL2)\",\niff(RecommendationDisplayName has_any(\"Exploit Guard\",\"endpoint protection\",\"Antimalware\",\"health\",\"VPC\",\"Defender\",\"Vulnerabilities\",\"vulnerability\",\"diagnostic\",\"Key\",\"activity log alert\",\"\"), \"Basic Event Logging (EL1)\",\"Other\"))))\n| summarize arg_max(TimeGenerated, *) by RecommendationDisplayName, AssessedResourceId, MaturityLevel\n| summarize Failed = countif(RecommendationState == \"Unhealthy\"), Passed = countif(RecommendationState == \"Healthy\"), Total = countif(RecommendationState == \"Healthy\" or RecommendationState == \"Unhealthy\") by MaturityLevel\n| extend PassedControls = (Passed/todouble(Total))*100\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22')\n| project MaturityLevel, Total, PassedControls, Passed, Failed, RemediationLink, LastObserved=now()\n| where MaturityLevel <> ''\n| where MaturityLevel == \"Advanced Event Logging (EL3)\"\n| where PassedControls < 70 \n//Adjust Either FailedRatePercentage or PasedRatePercentage Thresholds within   Organizational Needs\n| sort by PassedControls desc\n| extend URLCustomEntity = RemediationLink\n", "attributes": {"description": "'This alert is desinged to monitor Azure policies aligned with the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when EL3 policy compliance falls below 70% within a 1 week timeframe.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Analytic%20Rules/M2131LogRetentionLessThan1Year.yaml", "query_name": "M2131_LogRetentionLessThan1Year", "query": "SecurityRecommendation\n| summarize arg_max(TimeGenerated, *) by RecommendationDisplayName, AssessedResourceId\n| where RecommendationDisplayName == \"Activity log should be retained for at least one year\"\n| summarize Failed = countif(RecommendationState == \"Unhealthy\"), Passed = countif(RecommendationState == \"Healthy\"), Total = countif(RecommendationState == \"Healthy\" or RecommendationState == \"Unhealthy\") by RecommendationDisplayName, AssessedResourceId\n| extend PassedControls = (Passed/todouble(Total))*100\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22')\n| project RecommendationDisplayName, AssessedResourceId, Total, PassedControls, Passed, Failed, RemediationLink, LastObserved=now()\n| where Failed > 0\n| sort by Failed desc\n| extend URLCustomEntity = RemediationLink, ResourceId = AssessedResourceId\n", "attributes": {"description": "'This alert is designed to monitor log retention within the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when a log analytics workspace in active storage is configured for less than 1 year.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Analytic%20Rules/M2131RecommendedDatatableUnhealthy.yaml", "query_name": "M2131_RecommendedDatatableUnhealthy", "query": "let M2131Mapping = datatable(DataTable:string, MaturityLevel:string)\n[\n\"SigninLogs\",\t\"Event Logging (EL0)\",\n\"AADManagedIdentitySignInLogs\", \"Event Logging (EL0)\",\n\"AADServicePrincipalSignInLogs\",\t\"Event Logging (EL0)\",\n\"StorageBlobLogs\",\t\"Event Logging (EL0)\",\n\"StorageFileLogs\",\t\"Event Logging (EL0)\",\n\"AzureMetrics\",\t\"Event Logging (EL0)\",\n\"AuditLogs\",\t\"Event Logging (EL0)\",\n\"IdentityInfo\",\t\"Event Logging (EL0)\",\n\"CommonSecurityLog\",\t\"Event Logging (EL0)\",\n\"ThreatIntelligenceIndicator\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkInfo\",\t\"Event Logging (EL0)\",\n\"DnsEvents\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkEvents\",\t\"Event Logging (EL0)\",\n\"AzureDiagnostics\",\t\"Event Logging (EL0)\",\n\"Usage\",\t\"Event Logging (EL0)\",\n\"SecurityIncident\",\t\"Event Logging (EL0)\",\n\"SecurityAlert\",\t\"Event Logging (EL0)\",\n\"AzureActivity\",\t\"Event Logging (EL0)\",\n\"Heartbeat\",\t\"Event Logging (EL0)\",\n\"OfficeActivity\",\t\"Event Logging (EL0)\",\n\"SecurityEvent\",\t\"Event Logging (EL0)\",\n\"Syslog\",\t\"Event Logging (EL0)\",\n\"AWSCloudTrail\",\t\"Event Logging (EL0)\",\n\"GWorkspaceActivityReports\",\t\"Event Logging (EL0)\",\n\"AWSGuardDuty\",\t\"Event Logging (EL0)\",\n\"AWSVPCFlow\",\t\"Event Logging (EL0)\",\n\"Perf\",\t\"Basic Event Logging (EL1)\",\n\"SentinelHealth\",\t\"Basic Event Logging (EL1)\",\n\"DeviceLogonEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceNetworkEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceFileEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceRegistryEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"VMConnection\",\t\"Basic Event Logging (EL1)\",\n\"EmailEvents\",\t\"Basic Event Logging (EL1)\",\n\"ThreatIntelligenceIndicator\",\t\"Basic Event Logging (EL1)\",\n\"SecurityRecommendation\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationData\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationChange\",\t\"Basic Event Logging (EL1)\",\n\"GatewayDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"TunnelDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"IKEDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"RouteDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"PS2DiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"Event\",\t\"Basic Event Logging (EL1)\",\n\"SqlAtpStatus\",\t\"Basic Event Logging (EL1)\",\n\"ConstainerInstanceLog_CL\",\t\"Basic Event Logging (EL1)\",\n\"ContainerEvent_CL\",\t\"Basic Event Logging (EL1)\",\n\"InsightsMetrics\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailUrlInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailAttachmentInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"InformationProtectionLogs_CL\",\t\"Intermediate Event Logging (EL2)\",\n\"CloudAppEvents\",\t\"Intermediate Event Logging (EL2)\",\n\"ContainerInventory\",\t\"Intermediate Event Logging (EL2)\",\n\"Update\",\t\"Advanced Event Logging (EL3)\",\n\"BehaviorAnalytics\",\t\"Advanced Event Logging (EL3)\",\n\"Anomalies\",\t\"Advanced Event Logging (EL3)\",\n\"SecurityRegulatoryCompliance\",\t\"Advanced Event Logging (EL3)\"\n];\nlet LastLogTime = Usage\n| summarize LastLog_Time = arg_max(TimeGenerated, *) by DataType;\nUsage\n| summarize last_log = datetime_diff(\"day\",now(), max(TimeGenerated)) by DataType\n| where last_log > 0\n| join kind=inner (LastLogTime) on DataType\n| project DataTable = DataType, ['Last Log Received'] = last_log, LastLog_Time\n| where ['Last Log Received'] > 2\n| join kind=inner (M2131Mapping) on DataTable\n| project-away DataTable1\n| order by ['Last Log Received'] desc\n| extend CloudApplication = DataTable\n", "attributes": {"description": "'This alert is designed to monitor recommended data tables aligned to the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when a recommended data table hasn't been observed in over 48 hours.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Hunting%20Queries/M2131RecommendedDatatableNotLoggedEL0.yaml", "query_name": "M2131_RecommendedDatatableNotLogged_EL0", "query": "let M2131Mapping = datatable(DataTable:string, MaturityLevel:string)\n[\n\"SigninLogs\",\t\"Event Logging (EL0)\",\n\"AADManagedIdentitySignInLogs\", \"Event Logging (EL0)\",\n\"AADServicePrincipalSignInLogs\",\t\"Event Logging (EL0)\",\n\"StorageBlobLogs\",\t\"Event Logging (EL0)\",\n\"StorageFileLogs\",\t\"Event Logging (EL0)\",\n\"AzureMetrics\",\t\"Event Logging (EL0)\",\n\"AuditLogs\",\t\"Event Logging (EL0)\",\n\"IdentityInfo\",\t\"Event Logging (EL0)\",\n\"CommonSecurityLog\",\t\"Event Logging (EL0)\",\n\"ThreatIntelligenceIndicator\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkInfo\",\t\"Event Logging (EL0)\",\n\"DnsEvents\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkEvents\",\t\"Event Logging (EL0)\",\n\"AzureDiagnostics\",\t\"Event Logging (EL0)\",\n\"Usage\",\t\"Event Logging (EL0)\",\n\"SecurityIncident\",\t\"Event Logging (EL0)\",\n\"SecurityAlert\",\t\"Event Logging (EL0)\",\n\"AzureActivity\",\t\"Event Logging (EL0)\",\n\"Heartbeat\",\t\"Event Logging (EL0)\",\n\"OfficeActivity\",\t\"Event Logging (EL0)\",\n\"SecurityEvent\",\t\"Event Logging (EL0)\",\n\"Syslog\",\t\"Event Logging (EL0)\",\n\"AWSCloudTrail\",\t\"Event Logging (EL0)\",\n\"GWorkspaceActivityReports\",\t\"Event Logging (EL0)\",\n\"AWSGuardDuty\",\t\"Event Logging (EL0)\",\n\"AWSVPCFlow\",\t\"Event Logging (EL0)\",\n\"Perf\",\t\"Basic Event Logging (EL1)\",\n\"SentinelHealth\",\t\"Basic Event Logging (EL1)\",\n\"DeviceLogonEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceNetworkEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceFileEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceRegistryEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"VMConnection\",\t\"Basic Event Logging (EL1)\",\n\"EmailEvents\",\t\"Basic Event Logging (EL1)\",\n\"ThreatIntelligenceIndicator\",\t\"Basic Event Logging (EL1)\",\n\"SecurityRecommendation\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationData\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationChange\",\t\"Basic Event Logging (EL1)\",\n\"GatewayDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"TunnelDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"IKEDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"RouteDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"PS2DiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"Event\",\t\"Basic Event Logging (EL1)\",\n\"SqlAtpStatus\",\t\"Basic Event Logging (EL1)\",\n\"ConstainerInstanceLog_CL\",\t\"Basic Event Logging (EL1)\",\n\"ContainerEvent_CL\",\t\"Basic Event Logging (EL1)\",\n\"InsightsMetrics\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailUrlInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailAttachmentInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"InformationProtectionLogs_CL\",\t\"Intermediate Event Logging (EL2)\",\n\"CloudAppEvents\",\t\"Intermediate Event Logging (EL2)\",\n\"ContainerInventory\",\t\"Intermediate Event Logging (EL2)\",\n\"Update\",\t\"Advanced Event Logging (EL3)\",\n\"BehaviorAnalytics\",\t\"Advanced Event Logging (EL3)\",\n\"Anomalies\",\t\"Advanced Event Logging (EL3)\",\n\"SecurityRegulatoryCompliance\",\t\"Advanced Event Logging (EL3)\"\n];\nUsage\n  | summarize Entries = count(), Size = sum(Quantity), last_log = datetime_diff(\"second\",now(), max(TimeGenerated)) by DataType\n  | join kind=fullouter(M2131Mapping) on $left.DataType == $right.DataTable\n  | project RecommendedDataTable=DataTable, ExistingDataTable=DataType, MaturityLevel, Size\n  | summarize Logged = countif(Size > 0), NotLogged = countif(isempty(Size)) by RecommendedDataTable, MaturityLevel\n  | where NotLogged > 0 and MaturityLevel == \"Event Logging (EL0)\" and RecommendedDataTable <> \"Usage\"\n  //| where RecommendedDataTable <> \"Data Table Name\" \n  | project RecommendedDataTable, MaturityLevel, NotLogged, TimeObserved=now()\n  | extend CloudApplication = RecommendedDataTable\n", "attributes": {"description": "'This alert audits your logging architecture for recommended data tables aligned to Event Logging (EL0) of the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when recommended data tables in EL0 are not present.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Hunting%20Queries/M2131RecommendedDatatableNotLoggedEL1.yaml", "query_name": "M2131_RecommendedDatatableNotLogged_EL1", "query": "let M2131Mapping = datatable(DataTable:string, MaturityLevel:string)\n[\n\"SigninLogs\",\t\"Event Logging (EL0)\",\n\"AADManagedIdentitySignInLogs\", \"Event Logging (EL0)\",\n\"AADServicePrincipalSignInLogs\",\t\"Event Logging (EL0)\",\n\"StorageBlobLogs\",\t\"Event Logging (EL0)\",\n\"StorageFileLogs\",\t\"Event Logging (EL0)\",\n\"AzureMetrics\",\t\"Event Logging (EL0)\",\n\"AuditLogs\",\t\"Event Logging (EL0)\",\n\"IdentityInfo\",\t\"Event Logging (EL0)\",\n\"CommonSecurityLog\",\t\"Event Logging (EL0)\",\n\"ThreatIntelligenceIndicator\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkInfo\",\t\"Event Logging (EL0)\",\n\"DnsEvents\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkEvents\",\t\"Event Logging (EL0)\",\n\"AzureDiagnostics\",\t\"Event Logging (EL0)\",\n\"Usage\",\t\"Event Logging (EL0)\",\n\"SecurityIncident\",\t\"Event Logging (EL0)\",\n\"SecurityAlert\",\t\"Event Logging (EL0)\",\n\"AzureActivity\",\t\"Event Logging (EL0)\",\n\"Heartbeat\",\t\"Event Logging (EL0)\",\n\"OfficeActivity\",\t\"Event Logging (EL0)\",\n\"SecurityEvent\",\t\"Event Logging (EL0)\",\n\"Syslog\",\t\"Event Logging (EL0)\",\n\"AWSCloudTrail\",\t\"Event Logging (EL0)\",\n\"GWorkspaceActivityReports\",\t\"Event Logging (EL0)\",\n\"AWSGuardDuty\",\t\"Event Logging (EL0)\",\n\"AWSVPCFlow\",\t\"Event Logging (EL0)\",\n\"Perf\",\t\"Basic Event Logging (EL1)\",\n\"SentinelHealth\",\t\"Basic Event Logging (EL1)\",\n\"DeviceLogonEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceNetworkEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceFileEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceRegistryEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"VMConnection\",\t\"Basic Event Logging (EL1)\",\n\"EmailEvents\",\t\"Basic Event Logging (EL1)\",\n\"ThreatIntelligenceIndicator\",\t\"Basic Event Logging (EL1)\",\n\"SecurityRecommendation\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationData\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationChange\",\t\"Basic Event Logging (EL1)\",\n\"GatewayDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"TunnelDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"IKEDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"RouteDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"PS2DiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"Event\",\t\"Basic Event Logging (EL1)\",\n\"SqlAtpStatus\",\t\"Basic Event Logging (EL1)\",\n\"ConstainerInstanceLog_CL\",\t\"Basic Event Logging (EL1)\",\n\"ContainerEvent_CL\",\t\"Basic Event Logging (EL1)\",\n\"InsightsMetrics\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailUrlInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailAttachmentInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"InformationProtectionLogs_CL\",\t\"Intermediate Event Logging (EL2)\",\n\"CloudAppEvents\",\t\"Intermediate Event Logging (EL2)\",\n\"ContainerInventory\",\t\"Intermediate Event Logging (EL2)\",\n\"Update\",\t\"Advanced Event Logging (EL3)\",\n\"BehaviorAnalytics\",\t\"Advanced Event Logging (EL3)\",\n\"Anomalies\",\t\"Advanced Event Logging (EL3)\",\n\"SecurityRegulatoryCompliance\",\t\"Advanced Event Logging (EL3)\"\n];\nUsage\n  | summarize Entries = count(), Size = sum(Quantity), last_log = datetime_diff(\"second\",now(), max(TimeGenerated)) by DataType\n  | join kind=fullouter(M2131Mapping) on $left.DataType == $right.DataTable\n  | project RecommendedDataTable=DataTable, ExistingDataTable=DataType, MaturityLevel, Size\n  | summarize Logged = countif(Size > 0), NotLogged = countif(isempty(Size)) by RecommendedDataTable, MaturityLevel\n  | where NotLogged > 0 and MaturityLevel == \"Basic Event Logging (EL1)\" and RecommendedDataTable <> \"Usage\"\n  //| where RecommendedDataTable <> \"Data Table Name\"\n  | project RecommendedDataTable, MaturityLevel, NotLogged, TimeObserved=now()\n  | extend CloudApplication = RecommendedDataTable\n", "attributes": {"description": "'This alert audits your logging architecture for recommended data tables aligned to Basic Event Logging (EL1) of the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when recommended data tables in EL1 are not present.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Hunting%20Queries/M2131RecommendedDatatableNotLoggedEL2.yaml", "query_name": "M2131_RecommendedDatatableNotLogged_EL2", "query": "let M2131Mapping = datatable(DataTable:string, MaturityLevel:string)\n[\n\"SigninLogs\",\t\"Event Logging (EL0)\",\n\"AADManagedIdentitySignInLogs\", \"Event Logging (EL0)\",\n\"AADServicePrincipalSignInLogs\",\t\"Event Logging (EL0)\",\n\"StorageBlobLogs\",\t\"Event Logging (EL0)\",\n\"StorageFileLogs\",\t\"Event Logging (EL0)\",\n\"AzureMetrics\",\t\"Event Logging (EL0)\",\n\"AuditLogs\",\t\"Event Logging (EL0)\",\n\"IdentityInfo\",\t\"Event Logging (EL0)\",\n\"CommonSecurityLog\",\t\"Event Logging (EL0)\",\n\"ThreatIntelligenceIndicator\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkInfo\",\t\"Event Logging (EL0)\",\n\"DnsEvents\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkEvents\",\t\"Event Logging (EL0)\",\n\"AzureDiagnostics\",\t\"Event Logging (EL0)\",\n\"Usage\",\t\"Event Logging (EL0)\",\n\"SecurityIncident\",\t\"Event Logging (EL0)\",\n\"SecurityAlert\",\t\"Event Logging (EL0)\",\n\"AzureActivity\",\t\"Event Logging (EL0)\",\n\"Heartbeat\",\t\"Event Logging (EL0)\",\n\"OfficeActivity\",\t\"Event Logging (EL0)\",\n\"SecurityEvent\",\t\"Event Logging (EL0)\",\n\"Syslog\",\t\"Event Logging (EL0)\",\n\"AWSCloudTrail\",\t\"Event Logging (EL0)\",\n\"GWorkspaceActivityReports\",\t\"Event Logging (EL0)\",\n\"AWSGuardDuty\",\t\"Event Logging (EL0)\",\n\"AWSVPCFlow\",\t\"Event Logging (EL0)\",\n\"Perf\",\t\"Basic Event Logging (EL1)\",\n\"SentinelHealth\",\t\"Basic Event Logging (EL1)\",\n\"DeviceLogonEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceNetworkEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceFileEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceRegistryEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"VMConnection\",\t\"Basic Event Logging (EL1)\",\n\"EmailEvents\",\t\"Basic Event Logging (EL1)\",\n\"ThreatIntelligenceIndicator\",\t\"Basic Event Logging (EL1)\",\n\"SecurityRecommendation\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationData\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationChange\",\t\"Basic Event Logging (EL1)\",\n\"GatewayDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"TunnelDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"IKEDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"RouteDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"PS2DiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"Event\",\t\"Basic Event Logging (EL1)\",\n\"SqlAtpStatus\",\t\"Basic Event Logging (EL1)\",\n\"ConstainerInstanceLog_CL\",\t\"Basic Event Logging (EL1)\",\n\"ContainerEvent_CL\",\t\"Basic Event Logging (EL1)\",\n\"InsightsMetrics\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailUrlInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailAttachmentInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"InformationProtectionLogs_CL\",\t\"Intermediate Event Logging (EL2)\",\n\"CloudAppEvents\",\t\"Intermediate Event Logging (EL2)\",\n\"ContainerInventory\",\t\"Intermediate Event Logging (EL2)\",\n\"Update\",\t\"Advanced Event Logging (EL3)\",\n\"BehaviorAnalytics\",\t\"Advanced Event Logging (EL3)\",\n\"Anomalies\",\t\"Advanced Event Logging (EL3)\",\n\"SecurityRegulatoryCompliance\",\t\"Advanced Event Logging (EL3)\"\n];\nUsage\n  | summarize Entries = count(), Size = sum(Quantity), last_log = datetime_diff(\"second\",now(), max(TimeGenerated)) by DataType\n  | join kind=fullouter(M2131Mapping) on $left.DataType == $right.DataTable\n  | project RecommendedDataTable=DataTable, ExistingDataTable=DataType, MaturityLevel, Size\n  | summarize Logged = countif(Size > 0), NotLogged = countif(isempty(Size)) by RecommendedDataTable, MaturityLevel\n  | where NotLogged > 0 and MaturityLevel == \"Intermediate Event Logging (EL2)\"\n  //| where RecommendedDataTable <> \"Data Table Name\" \n  | project RecommendedDataTable, MaturityLevel, NotLogged, TimeObserved=now()\n  | extend CloudApplication = RecommendedDataTable\n", "attributes": {"description": "'This alert audits your logging architecture for recommended data tables aligned to Intermediate Event Logging (EL2) of the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when recommended data tables in EL2 are not present.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MaturityModelForEventLogManagementM2131/Hunting%20Queries/M2131RecommendedDatatableNotLoggedEL3.yaml", "query_name": "M2131_RecommendedDatatableNotLogged_EL3", "query": "let M2131Mapping = datatable(DataTable:string, MaturityLevel:string)\n[\n\"SigninLogs\",\t\"Event Logging (EL0)\",\n\"AADManagedIdentitySignInLogs\", \"Event Logging (EL0)\",\n\"AADServicePrincipalSignInLogs\",\t\"Event Logging (EL0)\",\n\"StorageBlobLogs\",\t\"Event Logging (EL0)\",\n\"StorageFileLogs\",\t\"Event Logging (EL0)\",\n\"AzureMetrics\",\t\"Event Logging (EL0)\",\n\"AuditLogs\",\t\"Event Logging (EL0)\",\n\"IdentityInfo\",\t\"Event Logging (EL0)\",\n\"CommonSecurityLog\",\t\"Event Logging (EL0)\",\n\"ThreatIntelligenceIndicator\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkInfo\",\t\"Event Logging (EL0)\",\n\"DnsEvents\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkEvents\",\t\"Event Logging (EL0)\",\n\"AzureDiagnostics\",\t\"Event Logging (EL0)\",\n\"Usage\",\t\"Event Logging (EL0)\",\n\"SecurityIncident\",\t\"Event Logging (EL0)\",\n\"SecurityAlert\",\t\"Event Logging (EL0)\",\n\"AzureActivity\",\t\"Event Logging (EL0)\",\n\"Heartbeat\",\t\"Event Logging (EL0)\",\n\"OfficeActivity\",\t\"Event Logging (EL0)\",\n\"SecurityEvent\",\t\"Event Logging (EL0)\",\n\"Syslog\",\t\"Event Logging (EL0)\",\n\"AWSCloudTrail\",\t\"Event Logging (EL0)\",\n\"GWorkspaceActivityReports\",\t\"Event Logging (EL0)\",\n\"AWSGuardDuty\",\t\"Event Logging (EL0)\",\n\"AWSVPCFlow\",\t\"Event Logging (EL0)\",\n\"Perf\",\t\"Basic Event Logging (EL1)\",\n\"SentinelHealth\",\t\"Basic Event Logging (EL1)\",\n\"DeviceLogonEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceNetworkEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceFileEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceRegistryEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"VMConnection\",\t\"Basic Event Logging (EL1)\",\n\"EmailEvents\",\t\"Basic Event Logging (EL1)\",\n\"ThreatIntelligenceIndicator\",\t\"Basic Event Logging (EL1)\",\n\"SecurityRecommendation\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationData\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationChange\",\t\"Basic Event Logging (EL1)\",\n\"GatewayDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"TunnelDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"IKEDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"RouteDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"PS2DiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"Event\",\t\"Basic Event Logging (EL1)\",\n\"SqlAtpStatus\",\t\"Basic Event Logging (EL1)\",\n\"ConstainerInstanceLog_CL\",\t\"Basic Event Logging (EL1)\",\n\"ContainerEvent_CL\",\t\"Basic Event Logging (EL1)\",\n\"InsightsMetrics\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailUrlInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailAttachmentInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"InformationProtectionLogs_CL\",\t\"Intermediate Event Logging (EL2)\",\n\"CloudAppEvents\",\t\"Intermediate Event Logging (EL2)\",\n\"ContainerInventory\",\t\"Intermediate Event Logging (EL2)\",\n\"Update\",\t\"Advanced Event Logging (EL3)\",\n\"BehaviorAnalytics\",\t\"Advanced Event Logging (EL3)\",\n\"Anomalies\",\t\"Advanced Event Logging (EL3)\",\n\"SecurityRegulatoryCompliance\",\t\"Advanced Event Logging (EL3)\"\n];\nUsage\n  | summarize Entries = count(), Size = sum(Quantity), last_log = datetime_diff(\"second\",now(), max(TimeGenerated)) by DataType\n  | join kind=fullouter(M2131Mapping) on $left.DataType == $right.DataTable\n  | project RecommendedDataTable=DataTable, ExistingDataTable=DataType, MaturityLevel, Size\n  | summarize Logged = countif(Size > 0), NotLogged = countif(isempty(Size)) by RecommendedDataTable, MaturityLevel\n  | where NotLogged > 0 and MaturityLevel == \"Advanced Event Logging (EL3)\"\n  //| where RecommendedDataTable <> \"Data Table Name\" \n  | project RecommendedDataTable, MaturityLevel, NotLogged, TimeObserved=now()\n  | extend CloudApplication = RecommendedDataTable\n", "attributes": {"description": "'This alert audits your logging architecture for recommended data tables aligned to Advanced Event Logging (EL3) of the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when recommended data tables in EL3 are not present.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOAgentHandlerDown.yaml", "query_name": "McAfee ePO - Agent Handler down", "query": "McAfeeEPOEvent\n| where EventId == '16025'\n| extend IPCustomEntity = DvcIpAddr, HostCustomEntity = DvcHostname\n", "attributes": {"description": "'Detects when AgentHandler is down.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOAlertError.yaml", "query_name": "McAfee ePO - Error sending alert", "query": "McAfeeEPOEvent\n| where EventId == '1062'\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Detects when error sending alert occurs.'\n", "techniques": ["T1562", "T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOAttemptUninstallAgent.yaml", "query_name": "McAfee ePO - Attempt uninstall McAfee agent", "query": "McAfeeEPOEvent\n| where EventId == '2413'\n| extend IPCustomEntity = DvcIpAddr, HostCustomEntity = DvcHostname\n", "attributes": {"description": "'Detects attempts uninstalling McAfee agent on host.'\n", "techniques": ["T1562", "T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPODeploymentFailed.yaml", "query_name": "McAfee ePO - Deployment failed", "query": "McAfeeEPOEvent\n| where EventId == '2412'\n| extend IPCustomEntity = DvcIpAddr, HostCustomEntity = DvcHostname\n", "attributes": {"description": "'Detects when errors occur during deployment new changes/policies.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOExceptionAdded.yaml", "query_name": "McAfee ePO - File added to exceptions", "query": "McAfeeEPOEvent\n| where EventId in ('1029', '2005', '2015')\n| project DvcIpAddr, DstFileName\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Detects when file was added to exception list on a host.'\n", "techniques": ["T1562", "T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOFirewallDisabled.yaml", "query_name": "McAfee ePO - Firewall disabled", "query": "McAfeeEPOEvent\n| where EventId in ('35009')\n| extend IPCustomEntity = DvcIpAddr, HostCustomEntity = DvcHostname\n", "attributes": {"description": "'Detects when firewall was disabled from Mctray.'\n", "techniques": ["T1562", "T1071"], "tactics": ["DefenseEvasion", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOLoggingError.yaml", "query_name": "McAfee ePO - Logging error occurred", "query": "McAfeeEPOEvent\n| where EventId in ('1040', '1076', '3032', '3033', '3034', '3036', '3038')\n| extend EventMessage = case(EventId == '1040', 'Activity Log error',\n                              EventId == '1076', 'Error logging information',\n                              EventId == '3032', 'Error while trying to open/create activity log file',\n                              EventId == '3033', 'Activity log file maximum size reached',\n                              EventId == '3034', 'Unable to write the activity log file',\n                              EventId == '3036', 'Error during initialization of the activity log file',\n                              'Error writing to log')\n| project DvcIpAddr, EventId, EventMessage\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Detects when logging errors on agent.'\n", "techniques": ["T1562", "T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOMultipleThreatsSameHost.yaml", "query_name": "McAfee ePO - Multiple threats on same host", "query": "McAfeeEPOEvent\n| where isnotempty(ThreatName)\n| where ThreatName != '_'\n| summarize th_cnt = dcount(ThreatName), th_list = makeset(ThreatName) by DvcIpAddr\n| where th_cnt > 1\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Rule fires when multiple threat events were detected on the same host.'\n", "techniques": ["T1562", "T1070", "T1189", "T1195", "T1543", "T1055"], "tactics": ["InitialAccess", "Persistence", "DefenseEvasion", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOScanningEngineDisabled.yaml", "query_name": "McAfee ePO - Scanning engine disabled", "query": "McAfeeEPOEvent\n| where EventId == '1127'\n| extend IPCustomEntity = DvcIpAddr, HostCustomEntity = DvcHostname\n", "attributes": {"description": "'Detects when OAS scanning engine was disabled.'\n", "techniques": ["T1562", "T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOSpamEmail.yaml", "query_name": "McAfee ePO - Spam Email detected", "query": "McAfeeEPOEvent\n| where EventId == '4650'\n| extend IPCustomEntity = DvcIpAddr, HostCustomEntity = DvcHostname\n", "attributes": {"description": "'Detects when email was marked as spam.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOTaskError.yaml", "query_name": "McAfee ePO - Task error", "query": "McAfeeEPOEvent\n| where EventId in ('1003', '1067')\n| extend EventMessage = case(EventId == '1003', 'Error starting Task',\n                              'Unable to start scheduled task')\n| project DvcIpAddr, EventId, EventMessage\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Detects when task error occurs.'\n", "techniques": ["T1562", "T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOThreatNotBlocked.yaml", "query_name": "McAfee ePO - Threat was not blocked", "query": "McAfeeEPOEvent\n| where ThreatActionTaken in~ ('none', 'IDS_ACTION_WOULD_BLOCK')\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Detects when a threat was not blocked on a host.'\n", "techniques": ["T1562", "T1070", "T1068", "T1189", "T1195"], "tactics": ["InitialAccess", "PrivilegeEscalation", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOUnableCleanDeleteInfectedFile.yaml", "query_name": "McAfee ePO - Unable to clean or delete infected file", "query": "McAfeeEPOEvent\n| where EventId in ('1026', '1028', '1298', '1310', '1055', '2002', '2004', '2009')\n| extend EventMessage = case(EventId == '1026', 'Unable to clean infected file',\n                              EventId == '1028', 'Unable to delete infected file',\n                              EventId == '1298', 'File infected. Delete failed, quarantine failed',\n                              EventId == '1310', 'Multiple extension heuristic detection - delete failed, quarantine failed',\n                              EventId == '1055', 'Unable to delete infected file',\n                              EventId == '2002', 'Unable to clean infected file',\n                              EventId == '2004', 'Unable to delete infected file',\n                              'Unable to move infected file to quarantine')\n| project DvcIpAddr, EventId, EventMessage, DstFileName\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Detects when McAfee failed to clean or delete infected file.'\n", "techniques": ["T1562", "T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Analytic%20Rules/McAfeeEPOUpdateFailed.yaml", "query_name": "McAfee ePO - Update failed", "query": "McAfeeEPOEvent\n| where EventId in ('2402', '1119', '1123')\n| extend IPCustomEntity = DvcIpAddr, HostCustomEntity = DvcHostname\n", "attributes": {"description": "'Detects when update failed event occurs on agent.'\n", "techniques": ["T1562", "T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOAgentErrors.yaml", "query_name": "McAfee ePO - Agent Errors", "query": "let lbtime = 24h;\nMcAfeeEPOEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('2402', '2412', '1119', '1123', '2201', '2202', '2204', '2208', '3020', '3021')\n| extend EventMessage = case(EventId == '2402', \"Update Failed\",\n                              EventId == '2412', \"Deployment Failed\",\n                              EventId == '1119', \n                              \"The update failed; see event log\",\n                              EventId == '1123', \"The upgrade failed; see event log\",\n                              EventId == '2201', \"McAfee Agent: Failed to install software package\",\n                              EventId == '2202', \"McAfee Agent: Install retry limit reached for software package\",\n                              EventId == '2204', \"McAfee Agent: Insufficient disk space to install software\", \n                              EventId == '2208', \"McAfee Agent: Insufficient disk space to download software\",\n                              EventId == '3020', \"Invalid virus signature files\",\n                              \"Scan engine error\")\n| project DvcIpAddr, EventId, EventMessage\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for error events from McAfee agents.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOApplicationsBlocked.yaml", "query_name": "McAfee ePO - Applications blocked or contained", "query": "let lbtime = 24h;\nMcAfeeEPOEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('18002', '37275')\n| extend Reason = case(EventId == '18002', \"Application blocked\",\n                      \"Application contained\")\n| project DvcIpAddr, DstFileName\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for blocked or contained applications.'\n", "techniques": ["T1204", "T1189"], "tactics": ["InitialAccess", "Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOEmailThreats.yaml", "query_name": "McAfee ePO - Email Treats", "query": "let lbtime = 24h;\nMcAfeeEPOEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('1417', '1418', '1419', '1420', '1500', '1501', '1502', '1503', '1504', '1505', '1506', '1507', '1513', '1514')\n| extend EventMessage = case(EventId == '1417', \"Email message deleted (user defined detection)\",\n                              EventId == '1418', \"Email message deleted (user defined detection), Clean failed\",\n                              EventId == '1419', \n                              \"Email message deleted (user defined detection), Move failed\",\n                              EventId == '1420', \"Email message deleted (user defined detection), Delete failed\",\n                              EventId == '1500', \"Infected email cleaned (Medium)\",\n                              EventId == '1501', \"Infected email quarantined\",\n                              EventId == '1502', \"Unable to clean infected mail\", \n                              EventId == '1503', \"Infected email detected\",\n                              EventId == '1504', \"Infected mail item deleted\",\n                              EventId == '1505', \"Email content filtered\",\n                              EventId == '1506', \"Email content blocked\",\n                              EventId == '1507', \"Inbound email suspended for low disk\",\n                              EventId == '1513', \"Mail virus quarantined and cleaned\",\n                              \"Mail virus quarantined (not cleaned)\")\n| project DvcIpAddr, EventId, EventMessage\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for email related threat events.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOInfectedFiles.yaml", "query_name": "McAfee ePO - Infected files by source", "query": "let lbtime = 24h;\nMcAfeeEPOEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('1024', '1053', '2000', '3004')\n| summarize ['Infected Files List'] = makeset(DstFileName) by DvcIpAddr\n| project DvcIpAddr, ['Infected Files List']\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for infected files which were detected.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOInfectedSystems.yaml", "query_name": "McAfee ePO - Infected Systems", "query": "let lbtime = 24h;\nMcAfeeEPOEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('1038', '3043')\n| project DvcIpAddr, DvcHostname\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for infected systems based on scan results.'\n", "techniques": ["T1189", "T1195"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOLongTermInfectedSystems.yaml", "query_name": "McAfee ePO - Long term infected systems", "query": "let lbperiod_30d = 30d;\nlet infected_systems = McAfeeEPOEvent\n| where TimeGenerated > ago(lbperiod_30d)\n| where EventId in ('1038', '3043')\n| summarize LastScanTimeInfected = max(TimeGenerated) by DvcIpAddr\n| extend SystemStatus = 'Infected';\nlet clean_systems = McAfeeEPOEvent\n| where TimeGenerated > ago(lbperiod_30d - 1h)\n| where EventId in ('1034', '3039')\n| summarize LastScanTimeClean = max(TimeGenerated) by DvcIpAddr\n| extend SystemStatus = 'Clean';\nlet clean_systems2 = McAfeeEPOEvent\n| where TimeGenerated > ago(lbperiod_30d - 1h)\n| where EventId in ('1034', '3039')\n| summarize makeset(DvcIpAddr);\ninfected_systems\n| extend tmp_key = 1\n| join (clean_systems\n          | extend tmp_key = 1) on tmp_key\n| where  LastScanTimeInfected > LastScanTimeClean or DvcIpAddr !in (clean_systems2)\n| project LastScanTimeInfected, DvcIpAddr\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for infected systems which were not cleaned for long term.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOMultipleThreats.yaml", "query_name": "McAfee ePO - Sources with multiple threats", "query": "let lbtime = 24h;\nlet threshold = 1;\nMcAfeeEPOEvent\n| where TimeGenerated > ago(lbtime)\n| where isnotempty(ThreatName)\n| where ThreatName != '_'\n| summarize ThreatList = makeset(ThreatName) by DvcIpAddr\n| where array_length(ThreatList) > threshold\n| project DvcIpAddr, ThreatList\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for sources with several different threats.'\n", "techniques": ["T1189", "T1195"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOObjectsNotScanned.yaml", "query_name": "McAfee ePO - Objects not scanned", "query": "let lbtime = 24h;\nMcAfeeEPOEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('1051', '34925', '34926')\n| extend Reason = case(EventId == '1051', \"Unable to scan password protected\",\n                              EventId == '34925', \"The object was not scanned because the scanner does not have enough rights to read it\",\n                              \"The object was not scanned because the file size exceeds the configured maximum file size to scan\")\n| project DvcIpAddr, EventId, Reason, DstFileName\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for unscanned objects.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOScanErrors.yaml", "query_name": "McAfee ePO - Scan Errors", "query": "let lbtime = 24h;\nMcAfeeEPOEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('3021', '1086', '1059', '1128', '1035', '1051', '1048', '1049', '3053', '3054', '3046')\n| extend Reason = case(EventId == '3021', \"Scan engine error\",\n                              EventId == '1086', \"Scan Process Error\",\n                              EventId == '1059', \"Scan Timed Out\",\n                              EventId == '1128', \"Scan time exceeded\",\n                              EventId == '1035', \"Scan was canceled\",\n                              EventId == '1051', \"Unable to scan password protected\",\n                              EventId == '1048', \"Scan reports general system error\",\n                              EventId == '1049', \"Scan reported an internal application error\",\n                              EventId == '3053', \"Centralized Alerting - Scan reports general system error\",\n                              EventId == '3054', \"Centralized Alerting - Scan reported an internal application error\",\n                              \"Centralized Alerting - Scan reports memory allocation error\")\n| project DvcIpAddr, EventId, Reason\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for scan error events.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/McAfee%20ePolicy%20Orchestrator/Hunting%20Queries/McAfeeEPOThreatNotBlocked.yaml", "query_name": "McAfee ePO - Threats detected and not blocked, cleaned or deleted", "query": "let lbtime = 24h;\nMcAfeeEPOEvent\n| where TimeGenerated > ago(lbtime)\n| where EventId in ('1095', '1096', '1099', '34937', '35102', '34938', '35106', '35111', '35117')\n| extend EventMessage = case(EventId == '1095', \"Access Protection rule violation detected and NOT blocked\",\n                              EventId == '1096', \"Port blocking rule violation detected and NOT blocked\",\n                              EventId == '1099', \n                              \"Buffer Overflow detected and NOT blocked\",\n                              EventId == '34937', \"Script security violation detected, AMSI would block\",\n                              EventId == '35102', \"Adaptive Threat Protection Would Block\",\n                              EventId == '34938', \"Script security violation detected, AMSI would delete\",\n                              EventId == '35106', \"Adaptive Threat Protection Would Clean\", \n                              EventId == '35111', \"Adaptive Threat Protection Would Contain\",\n                              \"Adaptive Threat Protection Would Block Source\")\n| project DvcIpAddr, EventId, EventMessage\n| extend IPCustomEntity = DvcIpAddr\n", "attributes": {"description": "'Query searches for events where threats were detected and not blocked, cleaned or deleted.'\n", "techniques": ["T1574", "T1055"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20365%20Defender/Analytic%20Rules/AVdetectionsrelatedtoUkrainebasedthreats.yaml", "query_name": "AV detections related to Ukraine threats", "query": "let UA_threats = dynamic([\"FoxBlade\", \"WhisperGate\", \"Lasainraw\", \"SonicVote\"]);\n  SecurityAlert\n  | where ProviderName == \"MDATP\"\n  | extend ThreatFamilyName = tostring(parse_json(ExtendedProperties).ThreatFamilyName)\n  | where ThreatFamilyName in (UA_threats)\n", "attributes": {"description": "'This query looks for Microsoft Defender AV detections for malware observed in relation to the war in Ukraine.\n  Ref: https://msrc-blog.microsoft.com/2022/02/28/analysis-resources-cyber-threat-activity-ukraine/ '\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20365%20Defender/Analytic%20Rules/AVSpringShell.yaml", "query_name": "AV detections related to SpringShell Vulnerability", "query": "let SpringShell_threats = dynamic([\"Trojan:Python/SpringShellExpl\", \"Exploit:Python/SpringShell\", \"Backdoor:PHP/Remoteshell.V\", \"SpringShell\"]);\nDeviceInfo\n| extend DeviceName = tolower(DeviceName)\n| join kind=inner ( SecurityAlert\n| where ProviderName == \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| extend ThreatFamilyName = tostring(parse_json(ExtendedProperties).ThreatFamilyName)\n| where ThreatName in~ (SpringShell_threats) or ThreatFamilyName in~ (SpringShell_threats)\n| extend CompromisedEntity = tolower(CompromisedEntity)\n) on $left.DeviceName == $right.CompromisedEntity\n| summarize by DisplayName, ThreatName, ThreatFamilyName, PublicIP, AlertSeverity, Description, tostring(LoggedOnUsers), DeviceId, TenantId , bin(TimeGenerated, 1d), CompromisedEntity, tostring(LoggedOnUsers), ProductName, Entities\n", "attributes": {"description": "'This query looks for Microsoft Defender AV detections related to SpringShell Vulnerability. In Microsoft Sentinel the SecurityAlerts table includes only the Device Name of the affected device, \n this query joins the DeviceInfo table to clearly connect other information such as Device group, ip, logged on users etc. This would allow the Microsoft Sentinel analyst to have more context related to the alert, if available.\n Reference: https://www.microsoft.com/security/blog/2022/04/04/springshell-rce-vulnerability-guidance-for-protecting-against-and-detecting-cve-2022-22965/'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20365%20Defender/Analytic%20Rules/AVTarrask.yaml", "query_name": "AV detections related to Tarrask malware", "query": "let Tarrask_threats = dynamic([\"HackTool:Win64/Tarrask!MS\", \"HackTool:Win64/Ligolo!MSR\", \"Behavior:Win32/ScheduledTaskHide.A\", \"Tarrask\"]);\nDeviceInfo\n| extend DeviceName = tolower(DeviceName)\n| join kind=rightouter ( SecurityAlert\n| where ProviderName == \"MDATP\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| extend ThreatFamilyName = tostring(parse_json(ExtendedProperties).ThreatFamilyName)\n| where ThreatName in~ (Tarrask_threats) or ThreatFamilyName in~ (Tarrask_threats)\n| extend CompromisedEntity = tolower(CompromisedEntity)\n) on $left.DeviceName == $right.CompromisedEntity\n", "attributes": {"description": "'This query looks for Microsoft Defender AV detections related to Tarrask malware. In Microsoft Sentinel the SecurityAlerts table \n includes only the Device Name of the affected device, this query joins the DeviceInfo table to clearly connect other information such as Device group, ip, logged on users etc. \n This would allow the Microsoft Sentinel analyst to have more context related to the alert, if available.\n Reference: https://www.microsoft.com/security/blog/2022/04/12/tarrask-malware-uses-scheduled-tasks-for-defense-evasion/'\n", "techniques": ["T1053"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20365%20Defender/Analytic%20Rules/PotentialBuildProcessCompromiseMDE.yaml", "query_name": "Potential Build Process Compromise - MDE", "query": "// How far back to look for events from\nlet timeframe = 1d;\n// How close together build events and file modifications should occur to alert (make this smaller to reduce FPs)\nlet time_window = 5m;\n// Edit this to include build processes used\nlet build_processes = dynamic([\"MSBuild.exe\", \"dotnet.exe\", \"VBCSCompiler.exe\"]);\n// Include any processes that you want to allow to edit files during/around the build process\nlet allow_list = dynamic([]);\nDeviceProcessEvents\n| where TimeGenerated > ago(timeframe)\n// Look for build process starts\n| where FileName has_any (build_processes)\n| summarize by BuildParentProcess=InitiatingProcessFileName, BuildProcess=FileName, BuildAccount = AccountName, DeviceName, BuildCommand=ProcessCommandLine, timekey= bin(TimeGenerated, time_window), BuildProcessTime=TimeGenerated\n| join kind=inner(\nDeviceFileEvents\n| where TimeGenerated > ago(timeframe)\n| where InitiatingProcessFileName !in (allow_list)\n| where ActionType == \"FileCreated\"  or ActionType == \"FileModified\"\n// Look for code files, edit this to include file extensions used in build.\n| where FileName endswith \".cs\" or FileName endswith \".cpp\"\n| summarize by FileEditParentProcess=InitiatingProcessParentFileName, FileEditAccount = InitiatingProcessAccountName, DeviceName, FileEdited=FileName, FileEditProcess=InitiatingProcessFileName, timekey= bin(TimeGenerated, time_window), FileEditTime=TimeGenerated)\n// join where build processes and file modifications seen at same time on same host\non timekey, DeviceName\n// Limit to only where the file edit happens after the build process starts\n| where BuildProcessTime <= FileEditTime\n| summarize make_set(FileEdited), make_set(FileEditProcess), make_set(FileEditAccount) by timekey, DeviceName, BuildParentProcess, BuildProcess\n| extend HostCustomEntity=DeviceName, timestamp=timekey\n", "attributes": {"description": "'The query looks for source code files being modified immediately after a build process is started. The purpose of this is to look for malicious code injection during the build process. This query uses Microsoft Defender for Endpoint telemetry.\nMore details: https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-the-software-supply-chain-with-azure-sentinel/ba-p/2176463'\n", "techniques": ["T1554"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20365%20Defender/Analytic%20Rules/SolarWinds_SUNBURST_%26_SUPERNOVA_File-IOCs.yaml", "query_name": "SUNBURST and SUPERNOVA backdoor hashes", "query": "\nlet SunburstMD5=dynamic([\"b91ce2fa41029f6955bff20079468448\",\"02af7cec58b9a5da1c542b5a32151ba1\",\"2c4a910a1299cdae2a4e55988a2f102e\",\"846e27a652a5e1bfbd0ddd38a16dc865\",\"4f2eb62fa529c0283b28d05ddd311fae\"]);\nlet SupernovaMD5=\"56ceb6d0011d87b6e4d7023d7ef85676\";\nDeviceFileEvents\n| where MD5 in(SunburstMD5) or MD5 in(SupernovaMD5)\n| extend\n    timestamp = TimeGenerated,\n    AccountCustomEntity = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName),\n    HostCustomEntity = DeviceName,\n    AlgorithmCustomEntity = \"MD5\",\n    FileHashCustomEntity = MD5\n", "attributes": {"description": "Identifies SolarWinds SUNBURST and SUPERNOVA backdoor file hash IOCs in DeviceFileEvents\nReferences:\n- https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n- https://gist.github.com/olafhartong/71ffdd4cab4b6acd5cbcd1a0691ff82f\n", "techniques": ["T1195", "T1059", "T1546"], "tactics": ["Execution", "Persistence", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20365%20Defender/Analytic%20Rules/SolarWinds_SUNBURST_Network-IOCs.yaml", "query_name": "SUNBURST network beacons", "query": "\nlet SunburstURL=dynamic([\"panhardware.com\",\"databasegalore.com\",\"avsvmcloud.com\",\"freescanonline.com\",\"thedoccloud.com\",\"deftsecurity.com\"]);\nDeviceNetworkEvents\n| where ActionType == \"ConnectionSuccess\"\n| where RemoteUrl in(SunburstURL)\n| extend\n    timestamp = TimeGenerated,\n    AccountCustomEntity = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName),\n    HostCustomEntity = DeviceName,\n    FileHashCustomEntity = InitiatingProcessMD5, \n    HashAlgorithm = 'MD5',\n    URLCustomEntity = RemoteUrl,\n    IPCustomEntity = RemoteIP\n", "attributes": {"description": "Identifies SolarWinds SUNBURST domain beacon IOCs in DeviceNetworkEvents\nReferences:\n- https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n- https://gist.github.com/olafhartong/71ffdd4cab4b6acd5cbcd1a0691ff82f\n", "techniques": ["T1195", "T1059", "T1546"], "tactics": ["Execution", "Persistence", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20365%20Defender/Analytic%20Rules/SolarWinds_TEARDROP_Process-IOCs.yaml", "query_name": "TEARDROP memory-only dropper", "query": "\nDeviceEvents\n| where ActionType has \"ExploitGuardNonMicrosoftSignedBlocked\"\n| where InitiatingProcessFileName contains \"svchost.exe\" and FileName contains \"NetSetupSvc.dll\"\n| extend timestamp = TimeGenerated, AccountCustomEntity = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName),\nHostCustomEntity = DeviceName, FileHashCustomEntity = InitiatingProcessSHA1, FileHashType = \"SHA1\"\n", "attributes": {"description": "Identifies SolarWinds TEARDROP memory-only dropper IOCs in Window's defender Exploit Guard activity\nReferences:\n- https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n- https://gist.github.com/olafhartong/71ffdd4cab4b6acd5cbcd1a0691ff82f\n", "techniques": ["T1543", "T1059", "T1027"], "tactics": ["Execution", "Persistence", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20365%20Defender/Analytic%20Rules/SUNSPOTHashes.yaml", "query_name": "SUNSPOT malware hashes", "query": "let SUNSPOT_Hashes = dynamic([\"c45c9bda8db1d470f1fd0dcc346dc449839eb5ce9a948c70369230af0b3ef168\", \"0819db19be479122c1d48743e644070a8dc9a1c852df9a8c0dc2343e904da389\"]);\nunion isfuzzy=true(\nDeviceEvents\n| where InitiatingProcessSHA256 in (SUNSPOT_Hashes)),\n(DeviceImageLoadEvents\n| where InitiatingProcessSHA256 in (SUNSPOT_Hashes))\n| extend HostCustomEntity = DeviceName, timestamp=TimeGenerated\n", "attributes": {"description": "'This query uses Microsoft Defender for Endpoint data to look for IoCs associated with the SUNSPOT malware shared by Crowdstrike.\nMore details: \n  - https://www.crowdstrike.com/blog/sunspot-malware-technical-analysis/ \n  - https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-your-software-build-process-with-azure-sentinel/ba-p/2140807'\n", "techniques": ["T1554"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Microsoft%20Defender%20for%20Cloud%20Apps/Analytic%20Rules/AdditionalFilesUploadedByActor.yaml", "query_name": "Linked Malicious Storage Artifacts", "query": "\n//Collect the alert events\nlet alertData = SecurityAlert \n| where DisplayName has \"Potential malware uploaded to\" \n| extend Entities = parse_json(Entities) \n| mv-expand Entities;\n//Parse the IP address data\nlet ipData = alertData \n| where Entities['Type'] =~ \"ip\" \n| extend AttackerIP = tostring(Entities['Address']), AttackerCountry = tostring(Entities['Location']['CountryName']);\n//Parse the file data\nlet FileData = alertData \n| where Entities['Type'] =~ \"file\" \n| extend MaliciousFileDirectory = tostring(Entities['Directory']), MaliciousFileName = tostring(Entities['Name']), MaliciousFileHashes = tostring(Entities['FileHashes']);\n//Combine the File and IP data together\nipData \n| join (FileData) on VendorOriginalId \n| summarize by TimeGenerated, AttackerIP, AttackerCountry, DisplayName, ResourceId, AlertType, MaliciousFileDirectory, MaliciousFileName, MaliciousFileHashes\n//Create a type column so we can track if it was a File storage or blobl storage upload \n| extend type = iff(DisplayName has \"file\", \"File\", \"Blob\") \n| join (\n  union\n  StorageFileLogs, \n  StorageBlobLogs \n  //File upload operations \n  | where OperationName =~ \"PutBlob\" or OperationName =~ \"PutRange\"\n  //Parse out the uploader IP \n  | extend ClientIP = tostring(split(CallerIpAddress, \":\", 0)[0])\n  //Extract the filename from the Uri \n  | extend FileName = extract(@\"\\/([\\w\\-. ]+)\\?\", 1, Uri)\n  //Base64 decode the MD5 filehash, we will encounter non-ascii hex so string operations don't work\n  //We can work around this by making it an array then converting it to hex from an int \n  | extend base64Char = base64_decode_toarray(ResponseMd5) \n  | mv-expand base64Char \n  | extend hexChar = tohex(toint(base64Char))\n  | extend hexChar = iff(strlen(hexChar) < 2, strcat(\"0\", hexChar), hexChar) \n  | extend SourceTable = iff(OperationName has \"range\", \"StorageFileLogs\", \"StorageBlobLogs\") \n  | summarize make_list(hexChar) by CorrelationId, ResponseMd5, FileName, AccountName, TimeGenerated, RequestBodySize, ClientIP, SourceTable \n  | extend Md5Hash = strcat_array(list_hexChar, \"\")\n  //Pack the file information the summarise into a ClientIP row \n  | extend p = pack(\"FileName\", FileName, \"FileSize\", RequestBodySize, \"Md5Hash\", Md5Hash, \"Time\", TimeGenerated, \"SourceTable\", SourceTable) \n  | summarize UploadedFileInfo=make_list(p), FilesUploaded=count() by ClientIP \n      | join kind=leftouter (\n        union\n        StorageFileLogs,\n        StorageBlobLogs               \n        | where OperationName =~ \"DeleteFile\" or OperationName =~ \"DeleteBlob\"         \n        | extend ClientIP = tostring(split(CallerIpAddress, \":\", 0)[0])         \n        | extend FileName = extract(@\"\\/([\\w\\-. ]+)\\?\", 1, Uri)         \n        | extend SourceTable = iff(OperationName has \"range\", \"StorageFileLogs\", \"StorageBlobLogs\")         \n        | extend p = pack(\"FileName\", FileName, \"Time\", TimeGenerated, \"SourceTable\", SourceTable)         \n        | summarize DeletedFileInfo=make_list(p), FilesDeleted=count() by ClientIP\n        ) on ClientIP\n  ) on $left.AttackerIP == $right.ClientIP \n| mvexpand UploadedFileInfo \n| extend LinkedMaliciousFileName = UploadedFileInfo.FileName \n| extend LinkedMaliciousFileHash = UploadedFileInfo.Md5Hash     \n| project AlertTimeGenerated = TimeGenerated, tostring(LinkedMaliciousFileName), tostring(LinkedMaliciousFileHash), AlertType, AttackerIP, AttackerCountry, MaliciousFileDirectory, MaliciousFileName, FilesUploaded, UploadedFileInfo \n| extend FileHashCustomEntity = LinkedMaliciousFileName, HashAlgorithm = \"MD5\", IPCustomEntity = AttackerIP\n", "attributes": {"description": "'An IP address which uploaded malicious content to an Azure Blob or File Storage container (triggering a malware alert) also uploaded additional files.'\n", "techniques": ["T1071", "T1567"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftDefenderForEndpoint/Analytic%20Rules/ActiniumAVHits.yaml", "query_name": "ACTINIUM AV hits - Feb 2022", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/ActiniumIOC.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet AVHits = (iocs | where Type =~ \"AVDetection\"| project IoC);\nSecurityAlert\n| where ProviderName == 'MDATP'\n| extend ThreatName_ = tostring(parse_json(ExtendedProperties).ThreatName)\n| where ThreatName_ has_any (AVHits)\n| extend Directory = tostring(parse_json(Entities)[0].Directory), SHA256 = tostring(parse_json(tostring(parse_json(Entities)[0].FileHashes))[2].Value), FileName = tostring(parse_json(Entities)[0].Name), Hostname = tostring(parse_json(Entities)[6].FQDN)| extend AccountName = tostring(parse_json(tostring(parse_json(Entities)[6].LoggedOnUsers))[0].AccountName)\n| project TimeGenerated, AlertName, ThreatName_, ProviderName, AlertSeverity, Description, RemediationSteps, ExtendedProperties, Entities, FileName,SHA256, Directory, Hostname, AccountName\n| extend timestamp = TimeGenerated, HostCustomEntity = Hostname , AccountCustomEntity = AccountName,  FileHashCustomEntity = SHA256\n", "attributes": {"description": "'Identifies a match in the Security Alert table for MDATP hits related to the ACTINIUM actor'\n", "techniques": ["T1137"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftDefenderForEndpoint/Hunting%20Queries/MDE_Process-IOCs.yaml", "query_name": "SUNBURST suspicious SolarWinds child processes", "query": "\nlet excludeProcs = dynamic([@\"\\SolarWinds\\Orion\\APM\\APMServiceControl.exe\", @\"\\SolarWinds\\Orion\\ExportToPDFCmd.Exe\", @\"\\SolarWinds.Credentials\\SolarWinds.Credentials.Orion.WebApi.exe\", @\"\\SolarWinds\\Orion\\Topology\\SolarWinds.Orion.Topology.Calculator.exe\", @\"\\SolarWinds\\Orion\\Database-Maint.exe\", @\"\\SolarWinds.Orion.ApiPoller.Service\\SolarWinds.Orion.ApiPoller.Service.exe\", @\"\\Windows\\SysWOW64\\WerFault.exe\"]);\nDeviceProcessEvents\n| where InitiatingProcessFileName =~ \"solarwinds.businesslayerhost.exe\"\n| where not(FolderPath has_any (excludeProcs))\n| extend\n    timestamp = TimeGenerated,\n    AccountCustomEntity = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName),\n    HostCustomEntity = DeviceName,\n    FileHashCustomEntity = MD5\n", "attributes": {"description": "'Identifies suspicious child processes of SolarWinds.Orion.Core.BusinessLayer.dll that may be evidence of the SUNBURST backdoor'\n", "techniques": NaN, "tactics": ["Execution", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftDefenderForEndpoint/Hunting%20Queries/MDE_Usage.yaml", "query_name": "Probable AdFind Recon Tool Usage", "query": "\nlet args = dynamic([\"objectcategory\",\"domainlist\",\"dcmodes\",\"adinfo\",\"trustdmp\",\"computers_pwdnotreqd\",\"Domain Admins\", \"objectcategory=person\", \"objectcategory=computer\", \"objectcategory=*\",\"dclist\"]);\nlet parentProcesses = dynamic([\"pwsh.exe\",\"powershell.exe\",\"cmd.exe\"]);\nDeviceProcessEvents\n//looks for execution from a shell\n| where InitiatingProcessFileName in (parentProcesses)\n// main filter\n| where FileName =~ \"AdFind.exe\" or SHA256 == \"c92c158d7c37fea795114fa6491fe5f145ad2f8c08776b18ae79db811e8e36a3\"\n   // AdFind common Flags to check for from various threat actor TTPs\n    or ProcessCommandLine has_any (args)\n| extend AccountCustomEntity = AccountName, HostCustomEntity = DeviceName, ProcessCustomEntity = InitiatingProcessFileName, CommandLineCustomEntity = ProcessCommandLine, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = SHA256\n", "attributes": {"description": "'Identifies the host and account that executed AdFind by hash and filename in addition to common and unique flags that are used by many threat actors in discovery.'\n", "techniques": ["T1018"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Analytic%20Rules/InsiderRiskHighUserAlertsCorrelation.yaml", "query_name": "Insider Risk_High User Security Alert Correlations", "query": "let AlertLinks = SecurityAlert\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize AlertLinks=make_set(AlertLink) by UPN;\nlet LastTimeObserved = SecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| project UPN, AlertName, Severity, ProductName, TimeGenerated | summarize arg_max(AlertName, Severity, ProductName, TimeGenerated) by UPN;\nSecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| project UPN, AlertName, Severity, ProductName\n| evaluate basket(0.001)\n| where UPN <> \"\"\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UPN == $right.SearchKey\n| project UPN, Percent, AlertName, Severity, ProductName\n| join (LastTimeObserved) on UPN\n| sort by Percent desc\n| extend LastObserved = TimeGenerated\n| join kind=inner (AlertLinks) on UPN\n| project UPN, AlertName, Severity, ProductName, Percent, LastObserved, AlertLinks\n| extend AccountCustomEntity = UPN\n", "attributes": {"description": "'This alert joins SecurityAlerts from Microsoft Products with SecurityIncidents from Microsoft Sentinel and Microsoft 365 Defender. This join allows for identifying patterns in user principal names associated with respective security alerts. A machine learning function (Basket) is leveraged with a .001 threshold. Baset finds all frequent patterns of discrete attributes (dimensions) in the data. It returns the frequent patterns passed the frequency threshold. This query evaluates UserPrincipalName for patterns in SecurityAlerts and Reporting Security Tools. This query can be further tuned/configured for higher confidence percentages, security products, or alert severities pending the needs of the organization. There is an option for configuration of correlations against Azure Sentinel watchlists. For more information on the basket plugin, see [basket plugin](https://docs.microsoft.com/azure/data-explorer/kusto/query/basketplugin)'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Analytic%20Rules/InsiderRiskHighUserIncidentsCorrelation.yaml", "query_name": "Insider Risk_High User Security Incidents Correlation", "query": "let PreviousIncidents =\nSecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize PreviousIncidents = make_set(IncidentNumber) by UPN;\nlet LastTimeObserved =\nSecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize arg_max(TimeGenerated, IncidentName) by UPN;\n  SecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize count() by UPN, IncidentName, IncidentNumber, IncidentUrl, Severity, ProductName\n| extend SecurityIncidents = count_\n| where SecurityIncidents > 5 //Adjust & Tune within Organzational Requirements\n| join (LastTimeObserved) on UPN\n| project-rename LastObserved = TimeGenerated, LastIncident = IncidentNumber\n| project-away IncidentName, count_, UPN1, IncidentName1, Severity, IncidentUrl\n| join kind=inner (PreviousIncidents) on UPN\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UPN == $right.SearchKey\n| project UPN, SecurityIncidents, LastIncident, ProductName, LastObserved, PreviousIncidents\n| sort by SecurityIncidents desc\n| limit 25\n| extend AccountCustomEntity = UPN\n", "attributes": {"description": "'This alert joins SecurityAlerts to SecurityIncidents to associate Security Alerts and Incidents with user accounts. This aligns all Microsoft Alerting Products with Microsoft Incident Generating Products (Microsoft Sentinel, M365 Defender) for a count of user security incidents over time. The default threshold is 5 security incidents, and this is customizable per the organization's requirements. Results include UserPrincipalName (UPN), SecurityIncident, LastIncident, ProductName, LastObservedTime, and Previous Incidents. There is an option for configuration of correlations against Microsoft Sentinel watchlists. For more information, see [Investigate incidents with Microsoft Sentinel]( https://docs.microsoft.com/azure/sentinel/investigate-cases).'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Analytic%20Rules/InsiderRiskM365IRMAlertObserved.yaml", "query_name": "Insider Risk_Microsoft Purview Insider Risk Management Alert Observed", "query": "let AlertLinks = SecurityAlert\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize PreciousSecurityAlertLinks=make_set(AlertLink) by UPN;\nSecurityAlert\n| where ProductName == \"Microsoft 365 Insider Risk Management\"\n    | summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n    | mv-expand todynamic(Entities)\n    | where Entities[\"Type\"] =~ \"account\"\n    | extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n        Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n    | extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| join kind=inner (AlertLinks) on UPN\n| extend UserPrincipalName = UPN\n| extend PreviousAlertsLinks = strcat(PreciousSecurityAlertLinks)\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| project UserPrincipalName, AlertName, ProductName, Tactics, Status, AlertLink, PreviousAlertsLinks, TimeGenerated\n| sort by TimeGenerated desc\n| limit 25\n| extend AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'This alert is triggered when a Microsoft Purview Insider Risk Management alert is recieved in Microsoft Sentinel via the Microsoft Purview Insider Risk Management Connector. The alert extracts usernames from security alerts to provide UserPrincipalName, Alert Name, Reporting Product Name, Status, Alert Link, Previous Alerts Links, Time Generated. There is an option for configuration of correlations against Azure Sentinel watchlists. For more information, see [Learn about insider risk management](https://docs.microsoft.com/microsoft-365/compliance/insider-risk-management)'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Analytic%20Rules/InsiderRiskSensitiveDataAccessOutsideOrgGeo.yaml", "query_name": "Insider Risk_Sensitive Data Access Outside Organizational Geo-location", "query": "InformationProtectionLogs_CL\n| extend UserPrincipalName = UserId_s\n| where LabelName_s <> \"\"\n| join kind=inner (SigninLogs) on UserPrincipalName\n| extend City = tostring(LocationDetails.city)\n// | where City <> \"New York\" // Configure Location Details within Organizational Requirements\n| extend State = tostring(LocationDetails.state)\n// | where State <> \"Texas\" // Configure Location Details within Organizational Requirements\n| extend Country_Region = tostring(LocationDetails.countryOrRegion)\n// | where Country_Region <> \"US\" // Configure Location Details within Organizational Requirements\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| summarize count() by UserPrincipalName, LabelName_s, Activity_s, City, State, Country_Region, TimeGenerated\n| sort by count_ desc\n| limit 25\n| extend AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'This alert joins Azure Information Protection Logs (InformationProtectionLogs_CL) with Azure Active Directory Sign in Logs (SigninLogs) to provide a correlation of sensitive data access by geo-location. Results include User Principal Name, Label Name, Activity, City, State, Country/Region, and Time Generated. Recommended configuration is to include (or exclude) Sign in geo-locations (City, State, Country and/or Region) for trusted organizational locations. There is an option for configuration of correlations against Microsoft Sentinel watchlists. Accessing sensitive data from a new or unauthorized geo-location warrants further review. For more information see [Sign-in logs in Azure Active Directory: Location Filtering](https://docs.microsoft.com/azure/active-directory/reports-monitoring/concept-sign-ins)'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Analytic%20Rules/InsiderRiskyAccessByApplication.yaml", "query_name": "Insider Risk_Risky User Access By Application", "query": "SigninLogs\n| where RiskState == \"atRisk\"\n| project UserPrincipalName, Location, AppDisplayName, RiskState\n| evaluate basket(0.01) // Adjust & Tune Thresholds within Organzational Requirements\n// | where Percent > 50 // Adjust & Tune Thresholds within Organzational Requirements\n| where UserPrincipalName <> \"\"\n| where AppDisplayName <> \"\"\n| project Percent, UserPrincipalName, Location, AppDisplayName, RiskState\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| sort by Percent desc\n| limit 25\n| extend AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'This alert evaluates Azure Active Directory Sign in risk via Machine Learning correlations in the basket operator. The basket threshold is adjustable, and the default is set to .01. There is an optional configuration to configure the percentage rates. The correlations are designed to leverage machine learning to identify patterns of risky user application access. There is an option for configuration of correlations against Microsoft Sentinel watchlists. For more information, see [Tutorial: Use risk detections for user sign-ins to trigger Azure AD Multi-Factor Authentication or password changes](https://docs.microsoft.com/azure/active-directory/authentication/tutorial-risk-based-sspr-mfa)'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Hunting%20Queries/InsiderEntityAnomalyFollowedByIRMAlert.yaml", "query_name": "Insider Risk_Entity Anomaly Followed by IRM Alert", "query": "let InsiderRiskManagementAlerts = SecurityAlert\n| where ProductName == \"Microsoft 365 Insider Risk Management\"\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UserPrincipalName = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UserPrincipalName <> \"\"\n| summarize PreviousSecurityAlertLinks=make_set(AlertLink) by UserPrincipalName, AlertLink;\nBehaviorAnalytics\n| where UserPrincipalName <> \"\"\n| where ActivityInsights contains \"True\"\n| extend EntityAnomalies = strcat(ActivityInsights)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, EntityAnomalies\n| join kind=innerunique (InsiderRiskManagementAlerts) on UserPrincipalName\n| project UserPrincipalName, EntityAnomalies, StartTime, EndTime, AlertLink, PreviousSecurityAlertLinks\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| extend AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'This query joins Microsoft Sentinel Entity Insights with Microsoft Purview Insider Risk Management Alerts. There is also an option for configuration of correlations against watchlists. For more information, see https://docs.microsoft.com/azure/sentinel/watchlists'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Hunting%20Queries/InsiderISPAnomalyCorrelatedToExfiltrationAlert.yaml", "query_name": "Insider Risk_ISP Anomaly to Exfil", "query": "let ExfiltrationAlerts = SecurityAlert\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UserPrincipalName = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UserPrincipalName <> \"\"\n| where Tactics contains \"exfiltration\"\n| summarize PreviousSecurityAlertLinks=make_set(AlertLink) by UserPrincipalName, AlertName, TimeGenerated\n| where PreviousSecurityAlertLinks contains \"https\";\nBehaviorAnalytics\n| where ActivityInsights contains \"ISP\"\n| extend ISPAnomalies = strcat(ActivityInsights)\n| join kind=innerunique(ExfiltrationAlerts) on UserPrincipalName\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| project UserPrincipalName, AlertName, PreviousSecurityAlertLinks, ISPAnomalies, TimeGenerated\n| sort by TimeGenerated desc\n| limit 25\n| extend AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'This query joins UEBA to Security Alerts from Microsoft products for a correlation of Internet Service Provider anomalies to data exfiltration (watchlist options). For more information, see https://docs.microsoft.com/azure/sentinel/watchlists'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Hunting%20Queries/InsiderMultipleEntityAnomalies.yaml", "query_name": "Insider Risk_Multiple Entity-Based Anomalies", "query": "let UncommonActionVolume = BehaviorAnalytics\n| extend UncommonActionVolume = tostring(ActivityInsights.UncommonHighVolumeOfActions)\n| where UncommonActionVolume == \"True\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ActivityType = make_set(ActivityType), make_set(ActionType), UncommonActionVolume = countif(UncommonActionVolume==\"True\") by UserPrincipalName;\nlet UncommonAction = BehaviorAnalytics\n| extend UncommonAction = tostring(ActivityInsights.ActionUncommonlyPerformedByUser)\n| where UncommonAction == \"True\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ActivityType = make_set(ActivityType), make_set(ActionType), UncommonAction = countif(UncommonAction==\"True\") by UserPrincipalName;\nlet Uncommon = UncommonActionVolume | join kind = inner (UncommonAction) on UserPrincipalName;\nlet FirstTimeDeviceLogon = BehaviorAnalytics\n| extend FirstTimeDeviceLogon = tostring(ActivityInsights.FirstTimeUserLoggedOnToDevice)\n| where FirstTimeDeviceLogon == \"True\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ActivityType = make_set(ActivityType), make_set(ActionType), FirstTimeDeviceLogon = countif(FirstTimeDeviceLogon==\"True\") by UserPrincipalName;\nlet FirstTimeUserAction = BehaviorAnalytics\n| extend FirstTimeUserAction = tostring(ActivityInsights.FirstTimeUserPerformedAction)\n| where FirstTimeUserAction == \"True\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ActivityType = make_set(ActivityType), make_set(ActionType), FirstTimeUserAction = countif(FirstTimeUserAction==\"True\") by UserPrincipalName;\nlet FirstTime = FirstTimeUserAction | join(FirstTimeDeviceLogon) on UserPrincipalName;\nUncommon | join kind= inner (FirstTime) on UserPrincipalName\n| where UserPrincipalName <> \"\"\n| project UserPrincipalName, UncommonActionVolume, UncommonAction, FirstTimeUserAction, FirstTimeDeviceLogon, StartTime, EndTime, ActivityType,set_ActionType\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| sort by UncommonActionVolume desc\n| limit 25\n| extend AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'This query returns entity counts by anomaly and user principal name including ranges for start/end time observed (watchlists configurable). For more information, see https://docs.microsoft.com/azure/sentinel/watchlists'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Hunting%20Queries/InsiderPossibleSabotage.yaml", "query_name": "Insider Risk_Possible Sabotage", "query": "let RemoveActions = AzureActivity\n| where OperationName contains \"delete\" or OperationName contains \"remove\"\n| extend UserPrincipalName = Caller\n| project UserPrincipalName, OperationName, Category, Resource, ResourceId, ActivityStatus, TimeGenerated;\nlet InsiderRiskManagementAlerts = SecurityAlert\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UserPrincipalName = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UserPrincipalName <> \"\"\n| summarize PreviousSecurityAlertLinks=make_set(AlertLink) by UserPrincipalName, AlertLink, AlertName;\nBehaviorAnalytics\n| where UserPrincipalName <> \"\"\n| where ActivityInsights contains \"True\"\n| extend EntityAnomalies = strcat(ActivityInsights)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserPrincipalName, EntityAnomalies\n| join kind=innerunique (InsiderRiskManagementAlerts) on UserPrincipalName\n| join kind=innerunique (RemoveActions) on UserPrincipalName\n| project UserPrincipalName, EntityAnomalies, AlertName, AlertLink, PreviousSecurityAlertLinks, OperationName, Category, Resource, ResourceId, ActivityStatus, TimeGenerated\n//| lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| sort by TimeGenerated desc\n| limit 50\n| extend AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'This query correlates users with entity anomalies, security alerts, and delete/remove actions for identification of possible sabotage activities (watchlists configurable). For more information, see https://docs.microsoft.com/azure/sentinel/watchlists'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/MicrosoftPurviewInsiderRiskManagement/Hunting%20Queries/InsiderSignInRiskFollowedBySensitiveDataAccessyaml.yaml", "query_name": "Insider Risk_Sign In Risk Followed By Sensitive Data Access", "query": "let RiskySignIns = SigninLogs\n| where RiskState == \"atRisk\"\n| where RiskLevelDuringSignIn == \"high\" or RiskLevelDuringSignIn == \"medium\"\n| extend RiskTypes = strcat(RiskEventTypes_V2);\nInformationProtectionLogs_CL\n| extend UserPrincipalName = UserId_s\n| where LabelName_s <> \"\"\n| join kind=inner (SigninLogs) on UserPrincipalName\n| extend City = tostring(LocationDetails.city)\n// | where City <> \"New York\" // Configure Location Details within Organizational Requirements\n| extend State = tostring(LocationDetails.state)\n// | where State <> \"Texas\" // Configure Location Details within Organizational Requirements\n| extend Country_Region = tostring(LocationDetails.countryOrRegion)\n// | where Country_Region <> \"US\" // Configure Location Details within Organizational Requirements\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| summarize count() by UserPrincipalName, LabelName_s, Activity_s, City, State, Country_Region, TimeGenerated\n| join kind=inner (RiskySignIns) on UserPrincipalName\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| project UserPrincipalName, RiskTypes, City, State, Country_Region, LabelName_s, Activity_s, count_, TimeGenerated\n| sort by count_ desc\n| limit 100\n| extend AccountCustomEntity = UserPrincipalName\n", "attributes": {"description": "'This query correlates a risky user sign ins with access to sensitive data classified by data loss prevention capabilities (watchlist configurable). For more information, see https://docs.microsoft.com/azure/sentinel/watchlists'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXCommandsInRequest.yaml", "query_name": "NGINX - Command in URI", "query": "let cmd_list = dynamic(['cat%20/etc/passwd', '/etc/passwd', 'ping -i', '/usr/bin/id(', '%2f%75%73%72%2f%62%69%6e%2f%69%64', 'phpinfo()', '%70%68%70%69%6e%66%6f%28%29', ';id', '%3b%69%64', '/bin/bash -c', '%2f%62%69%6e%2f%62%61%73%68%20%2d%63%27', '/bin/bash', '%2f%62%69%6e%2f%62%61%73%68', 'sleep(', '%73%6c%65%65%70%28', 'curl', '%63%75%72%6c', '&dir', '%26%64%69%72', '& dir', '%26%20%64%69%72', '<script>', '%3c%73%63%72%69%70%74%3e', 'eval(', '%65%76%61%6c%28', 'exec(', '%65%78%65%63%28', 'whoami', '%77%68%6f%61%6d%69', 'wget', 'python', 'gcc', 'uname', 'systeminfo', '%77%67%65%74', '%70%79%74%68%6f%6e', '%75%6e%61%6d%65', '%73%79%73%74%65%6d%69%6e%66%6f']);\nNGINXHTTPServer\n| where UrlOriginal has_any (cmd_list)\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects command in URI'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXCoreDump.yaml", "query_name": "NGINX - Core Dump", "query": "NGINXHTTPServer\n| where EventType =~ \"ErrorLog\"\n| where EventMessage contains 'exited on signal 6 (core dumped)'\n| extend ProcessIdCustomEntity = ProcessId\n", "attributes": {"description": "'Detects a core dump of a crashing Nginx worker process, which could be a signal of a serious problem or exploitation attempts.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXDifferentUAsFromSingleIP.yaml", "query_name": "NGINX - Multiple user agents for single source", "query": "let threshold = 5;\nNGINXHTTPServer\n| summarize makeset(HttpUserAgentOriginal) by SrcIpAddr, bin(TimeGenerated, 5m)\n| extend ua_count = array_length(set_HttpUserAgentOriginal)\n| where ua_count > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests with different user agents from one source in short timeframe.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXKnownMaliciousUserAgent.yaml", "query_name": "NGINX - Known malicious user agent", "query": "let mal_ua_list = dynamic(['Nikto', '(hydra)', '.nasl', 'absinthe', 'advanced email extractor', 'arachni/', 'autogetcontent', 'bilbo', 'BFAC', 'brutus', 'brutus/aet', 'bsqlbf', 'cgichk', 'cisco-torch', 'commix', 'core-project/1.0', 'crimscanner/', 'datacha0s', 'dirbuster', 'domino hunter', 'dotdotpwn', 'email extractor', 'fhscan core 1.', 'floodgate', 'get-minimal', 'gootkit auto-rooter scanner', 'grabber', 'grendel-scan', 'havij', 'inspath', 'internet ninja', 'jaascois', 'zmeu', 'masscan', 'metis', 'morfeus', 'mysqloit', 'n-stealth', 'nessus', 'netsparker', 'nmap nse', 'nmap scripting engine', 'nmap-nse', 'nsauditor', 'openvas', 'pangolin', 'paros', 'pmafind', 'prog.customcrawler', 'qualys was', 's.t.a.l.k.e.r.', 'security scan', 'springenwerk', 'sql power injector', 'sqlmap', 'sqlninja', 'teh forest lobster', 'this is an exploit', 'toata dragostea', 'toata dragostea mea pentru diavola', 'uil2pn', 'user-agent:', 'vega/', 'voideye', 'w3af.sf.net', 'w3af.sourceforge.net', 'w3af.org', 'webbandit', 'webinspect', 'webshag', 'webtrends security analyzer', 'webvulnscan', 'whatweb', 'whcc/', 'wordpress hash grabber', 'xmlrpc exploit', 'WPScan', 'XSpider', 'SF/', 'FooBar/42', 'ScanAlert', 'Webscanner', 'Webster', 'fantomCrew', 'fantomBrowser', 'visvo', 'magereport', 'ltx71', 'websiteprotection', 'BigCliqueBOT', '(BOT for JCE)']);\nNGINXHTTPServer\n| where HttpUserAgentOriginal has_any (mal_ua_list)\n| extend IPCustomEntity = SrcIpAddr, MalwareCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Detects known malicious user agents'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXMultipleClientErrorsFromSingleIP.yaml", "query_name": "NGINX - Multiple client errors from single IP address", "query": "let threshold = 100;\nNGINXHTTPServer\n| where tolong(HttpStatusCode) >= 400 and tolong(HttpStatusCode) <= 499 \n| summarize MultipleClientErrors = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where MultipleClientErrors > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple client errors from one source in short timeframe'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXMultipleServerErrorsFromSingleIP.yaml", "query_name": "NGINX - Multiple server errors from single IP address", "query": "let threshold = 100;\nNGINXHTTPServer\n| where tolong(HttpStatusCode) >= 500 and tolong(HttpStatusCode) <= 599 \n| summarize MultipleServerErrors = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where MultipleServerErrors > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple server errors from one source in short timeframe'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXPrivateIPinUrl.yaml", "query_name": "NGINX - Private IP address in URL", "query": "NGINXHTTPServer\n| where UrlOriginal matches regex @'(10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})|(172\\.1[6-9]\\.\\d{1,3}\\.\\d{1,3})|(172\\.2[0-9]\\.\\d{1,3}\\.\\d{1,3})|(172\\.3[0-1]\\.\\d{1,3}\\.\\d{1,3})|(192\\.168\\.\\d{1,3}\\.\\d{1,3})'\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects requests to unusual URL'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXPutAndGetFileFromSameIP.yaml", "query_name": "NGINX - Put file and get file from same IP address", "query": "let p = NGINXHTTPServer\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| sort by EventStartTime asc\n| summarize post_time=min(EventStartTime) by SrcIpAddr, tostring(UrlOriginal);\nNGINXHTTPServer\n| where HttpRequestMethod =~ 'GET'\n| sort by EventStartTime asc\n| summarize get_time=min(EventStartTime) by SrcIpAddr, tostring(UrlOriginal)\n| join kind=innerunique (p) on UrlOriginal, SrcIpAddr\n| extend second = datetime_diff('second',get_time,post_time)\n| where second between (1 .. 300)\n| project second, post_time, get_time, SrcIpAddr, UrlOriginal\n| extend IPCustomEntity = SrcIpAddr, UrlCustomEntity = tostring(UrlOriginal)\n", "attributes": {"description": "'Detects put or get files from one source in short timeframe' \n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXRequestToSensitiveFiles.yaml", "query_name": "NGINX - Request to sensitive files", "query": "let forbidden_files = dynamic(['shadow', 'passwd', 'id_rsa']);\nNGINXHTTPServer\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where File in (forbidden_files)\n| extend FileCustomEntity = File, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects request to sensitive files.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Analytic%20Rules/NGINXSqlPattern.yaml", "query_name": "NGINX - Sql injection patterns", "query": "let sql_patterns = dynamic([@\"1/*'*/\", @\"1'||'asd'||'\", @\"'1'='1\", @\"1' or '1'='1\", @\"1 or 1=1\", @\"1=1\", @\"1/*!1111'*/\", @\"'or''='\"]);\nNGINXHTTPServer\n| where UrlOriginal has_any (sql_patterns)\n| extend IPCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects possible sql injection patterns'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXAbnormalRequestSize.yaml", "query_name": "NGINX - Abnormal request size", "query": "let Average_Body_Bytes = NGINXHTTPServer\n| where TimeGenerated > ago(30d)\n| summarize Avg_Size = avg(tolong(HttpResponseBodyBytes))\n| extend K = 1;\nNGINXHTTPServer\n| where TimeGenerated > ago(24h)\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| extend K = 1\n| join kind=inner Average_Body_Bytes on K\n| where tolong(HttpResponseBodyBytes) > Avg_Size\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows abnormal request size.'\n", "techniques": ["T1530", "T1537"], "tactics": ["Exfiltration", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXRareFilesRequested.yaml", "query_name": "NGINX - Rare files requested", "query": "NGINXHTTPServer\n| where TimeGenerated > ago(24h)\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| summarize RareFiles = count() by File\n| top 20 by RareFiles asc \n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows rare files requested'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXRareURLsRequested.yaml", "query_name": "NGINX - Rare URLs requested", "query": "NGINXHTTPServer\n| where TimeGenerated > ago(24h)\n| summarize count() by tostring(UrlOriginal)\n| top 20 by count_ asc \n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows rare URLs requested.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXRequestsFromBotsCrawlers.yaml", "query_name": "NGINX - Requests from bots and crawlers", "query": "NGINXHTTPServer\n| where HttpUserAgentOriginal matches regex @'bot|crawler|baiduspider|80legs|ia_archiver|voyager|curl|wget|yahoo!|slurp|mediapartners-google'\n| extend UrlCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Query searches requests from bots and crawlers.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXRequestsToUnexistingFiles.yaml", "query_name": "NGINX - Requests to unexisting files", "query": "NGINXHTTPServer\n| where TimeGenerated > ago(24h)\n| where EventType =~ \"ErrorLog\"\n| where EventMessage contains \"File does not exist\"\n| extend File = extract(@\"(.*\\/)(.*)\", 2, tostring(EventMessage))\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows list of requests to unexisting files'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXTopFilesRequested.yaml", "query_name": "NGINX - Top files requested", "query": "NGINXHTTPServer\n| where TimeGenerated > ago(24h)\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| summarize TotalFile = count() by File\n| top 20 by TotalFile desc\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows list of files requested'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXTopFilesWithErrorRequests.yaml", "query_name": "NGINX - Top files with error requests", "query": "NGINXHTTPServer\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 599 \n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| summarize TotalFile = count() by File\n| top 20 by TotalFile desc\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows list of files with error requests.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXTopURLsClientErrors.yaml", "query_name": "NGINX - Top URLs client errors", "query": "NGINXHTTPServer\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499\n| summarize TopUrls = count() by (tostring(UrlOriginal))\n| top 20 by TopUrls desc \n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows URLs list with client errors.'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXTopURLsServerErrors.yaml", "query_name": "NGINX - Top URLs server errors", "query": "NGINXHTTPServer\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 500 and HttpStatusCode <= 599\n| summarize TopUrls = count() by tostring(UrlOriginal)\n| top 20 by TopUrls desc \n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows URLs list with server errors.'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NGINX%20HTTP%20Server/Hunting%20Queries/NGINXUncommonUAsString.yaml", "query_name": "NGINX - Uncommon user agent strings", "query": "let length = 20;\nNGINXHTTPServer\n| where TimeGenerated > ago(100d)\n| where strlen(HttpUserAgentOriginal) < length\n| extend UrlCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Query searches uncommon user agent strings.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/NISTSP80053/Analytic%20Rules/NISTSP80053PostureChanged.yaml", "query_name": "NIST SP 800-53 Posture Changed", "query": "let Last_Evaluated=SecurityRecommendation | join kind=fullouter(SecurityRegulatoryCompliance| where ComplianceStandard == \"NIST-SP-800-53-R4\") on RecommendationName | summarize arg_max(TimeGenerated, *) by AssessedResourceId, RecommendationName | extend ComplianceDomain=iff(ComplianceControl contains \"AC.\", \"Access Control\", iff(ComplianceControl contains \"AT.\", \"Security Awareness & Training\", iff(ComplianceControl contains \"AU.\", \"Audit & Accountability\", iff(ComplianceControl contains \"CA.\", \"Security Assessment\", iff(ComplianceControl contains \"CM.\", \"Configuration Management\", iff(ComplianceControl contains \"CP.\", \"Contingency Planning\", iff(ComplianceControl contains \"IA.\", \"Identification & Authentication\", iff(ComplianceControl contains \"IR.\", \"Incident Response\", iff(ComplianceControl contains \"MA.\", \"System Maintenance\", iff(ComplianceControl contains \"MP.\", \"Media Protection\", iff(ComplianceControl contains \"PE.\", \"Physical Protection\", iff(ComplianceControl contains \"PL.\", \"Security Planning\", iff(ComplianceControl contains \"PS.\", \"Personnel Security\",iff(ComplianceControl contains \"RA.\", \"Risk Assessment\",iff(ComplianceControl contains \"SA.\", \"System & Services Acquisition\",iff(ComplianceControl contains \"SC.\", \"System & Communications Protection\",iff(ComplianceControl contains \"SI.\", \"System & Information Integrity\",\"Other\"))))))))))))))))) | summarize Failed = countif(RecommendationState == \"Unhealthy\"), Passed = countif(RecommendationState == \"Healthy\"), Total = countif(RecommendationState == \"Healthy\" or RecommendationState == \"Unhealthy\") by ComplianceDomain, TimeGenerated; SecurityRecommendation | join kind=fullouter(SecurityRegulatoryCompliance| where ComplianceStandard == \"NIST-SP-800-53-R4\") on RecommendationName | summarize arg_max(TimeGenerated, *) by AssessedResourceId, RecommendationName | extend ComplianceDomain=iff(ComplianceControl contains \"AC.\", \"Access Control\", iff(ComplianceControl contains \"AT.\", \"Security Awareness & Training\", iff(ComplianceControl contains \"AU.\", \"Audit & Accountability\", iff(ComplianceControl contains \"CA.\", \"Security Assessment\", iff(ComplianceControl contains \"CM.\", \"Configuration Management\", iff(ComplianceControl contains \"CP.\", \"Contingency Planning\", iff(ComplianceControl contains \"IA.\", \"Identification & Authentication\", iff(ComplianceControl contains \"IR.\", \"Incident Response\", iff(ComplianceControl contains \"MA.\", \"System Maintenance\", iff(ComplianceControl contains \"MP.\", \"Media Protection\", iff(ComplianceControl contains \"PE.\", \"Physical Protection\", iff(ComplianceControl contains \"PL.\", \"Security Planning\", iff(ComplianceControl contains \"PS.\", \"Personnel Security\",iff(ComplianceControl contains \"RA.\", \"Risk Assessment\",iff(ComplianceControl contains \"SA.\", \"System & Services Acquisition\",iff(ComplianceControl contains \"SC.\", \"System & Communications Protection\",iff(ComplianceControl contains \"SI.\", \"System & Information Integrity\",\"Other\"))))))))))))))))) | summarize Failed = countif(RecommendationState == \"Unhealthy\"), Passed = countif(RecommendationState == \"Healthy\"), Total = countif(RecommendationState == \"Healthy\" or RecommendationState == \"Unhealthy\") by ComplianceDomain | extend PassedControlsPercentage = (Passed/todouble(Total))*100 | join (Last_Evaluated) on ComplianceDomain | project ComplianceDomain, Total, PassedControlsPercentage, Passed, Failed, LastEvaluated=TimeGenerated | summarize arg_max(LastEvaluated, *) by ComplianceDomain, Total, PassedControlsPercentage, Passed, Failed | where PassedControlsPercentage < 70 | sort by PassedControlsPercentage, Passed desc | extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/22') | extend URLCustomEntity = RemediationLink", "attributes": {"description": "'This alert is desinged to monitor Azure policies aligned with the NIST SP 800-53 Regulatory Compliance initative. The alert triggers when policy compliance falls below 70% within a 1 week timeframe.'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Okta%20Single%20Sign-On/Analytic%20Rules/FailedLoginsFromUnknownOrInvalidUser.yaml", "query_name": "Failed Logins from Unknown or Invalid User", "query": "\nlet FailureThreshold = 15;\nlet FailedLogins = Okta_CL\n| where eventType_s =~ \"user.session.start\" and outcome_reason_s =~ \"VERIFICATION_ERROR\"\n| summarize count() by actor_alternateId_s, client_ipAddress_s, bin(TimeGenerated, 5m)\n| where count_ > FailureThreshold\n| project client_ipAddress_s, actor_alternateId_s;\nOkta_CL\n| join kind=inner (FailedLogins) on client_ipAddress_s, actor_alternateId_s\n| where eventType_s =~ \"user.session.start\" and outcome_reason_s =~ \"VERIFICATION_ERROR\"\n| summarize count() by actor_alternateId_s, ClientIP = client_ipAddress_s, City = client_geographicalContext_city_s, Country = client_geographicalContext_country_s, column_ifexists('published_t', now())\n| sort by column_ifexists('published_t', now()) desc\n| extend timestamp = column_ifexists('published_t', now()), IPCustomEntity = ClientIP, AccountCustomEntity = actor_alternateId_s\n", "attributes": {"description": "'This query searches for numerous login attempts to the management console with an unknown or invalid user name'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Okta%20Single%20Sign-On/Analytic%20Rules/LoginfromUsersfromDifferentCountrieswithin3hours.yaml", "query_name": "User Login from Different Countries within 3 hours", "query": "\nlet timeframe = ago(3h);\nlet threshold = 2;\nOkta_CL\n| where column_ifexists('published_t', now()) >= timeframe\n| where eventType_s =~ \"user.session.start\"\n| where outcome_result_s =~ \"SUCCESS\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), NumOfCountries = dcount(client_geographicalContext_country_s) by actor_alternateId_s\n| where NumOfCountries >= threshold\n| extend timestamp = StartTime, AccountCustomEntity = actor_alternateId_s\n", "attributes": {"description": "'This query searches for successful user logins to the Okta Console from different countries within 3 hours'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Okta%20Single%20Sign-On/Analytic%20Rules/PasswordSpray.yaml", "query_name": "Potential Password Spray Attack", "query": "\nlet FailureThreshold = 15;\nlet FailedEvents = Okta_CL\n| where eventType_s =~ \"user.session.start\"and outcome_reason_s in (\"VERIFICATION_ERROR\",\"INVALID_CREDENTIALS\")\n| summarize dcount(actor_alternateId_s) by client_ipAddress_s, bin(TimeGenerated, 5m)\n| where dcount_actor_alternateId_s > FailureThreshold\n| project client_ipAddress_s, TimeGenerated;\nOkta_CL\n| where eventType_s =~ \"user.session.start\"and outcome_reason_s in (\"VERIFICATION_ERROR\",\"INVALID_CREDENTIALS\")\n| summarize Users = make_set(actor_alternateId_s) by client_ipAddress_s, City = client_geographicalContext_city_s, Country = client_geographicalContext_country_s, bin(TimeGenerated, 5m)\n| join kind=inner (FailedEvents) on client_ipAddress_s, TimeGenerated\n| sort by TimeGenerated desc\n| extend timestamp = TimeGenerated, IPCustomEntity = client_ipAddress_s\n", "attributes": {"description": "'This query searches for failed attempts to log into the Okta console from more than 15 various users within a 5 minute timeframe from the same source. This is a potential indication of a password spray attack'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Okta%20Single%20Sign-On/Hunting%20Queries/AdminPrivilegeGrant.yaml", "query_name": "Admin privilege granted (Okta)", "query": "let Events = dynamic([\"group.privilege.grant\", \"user.account.privilege.grant\"]);\nOkta_CL\n| where eventType_s in (Events)\n| where outcome_result_s =~ \"SUCCESS\"\n| extend Target=parsejson(target_s)\n| mvexpand bagexpansion=array (Target)\n| evaluate bag_unpack(Target)\n| extend Target_Id = tostring(column_ifexists('id', \"\")), Target_type = tostring(column_ifexists('type', \"\")), Target_user = tostring(column_ifexists('displayName', \"\")), Target_alternateId = tostring(column_ifexists('alternateId', \"\"))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by actor_id_s, actor_type_s, actor_alternateId_s, actor_displayName_s, Target_alternateId, Target_Id, Target_type, Target_user,debugContext_debugData_privilegeGranted_s,domain_s,\n authenticationContext_externalSessionId_s, eventType_s, displayMessage_s, transaction_id_s, uuid_g\n", "attributes": {"description": "'This query searches for successful grant of administrator permissions to user/groups. Adversaries often attempt to assign administrator permission to users/group to maintain access as well as to elevate privileges.\n Please verify that the behavior is known and filter out anything that is expected.\n Refrence: https://developer.okta.com/docs/reference/api/event-types/'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Okta%20Single%20Sign-On/Hunting%20Queries/CreateAPIToken.yaml", "query_name": "Create API Token (Okta)", "query": "let Events = dynamic([\"system.api_token.create\"]);\nOkta_CL\n| where eventType_s in (Events)\n| where outcome_result_s =~ \"SUCCESS\"\n", "attributes": {"description": "'Okta API tokens are used to authenticate requests to Okta APIs. This query searches for attempts to create new API Token.\n Refrence: https://developer.okta.com/docs/reference/api/event-types/'\n", "techniques": ["T1134"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Okta%20Single%20Sign-On/Hunting%20Queries/ImpersonationSession.yaml", "query_name": "Initiate impersonation session (Okta)", "query": "let Events = dynamic([\"user.session.impersonation.initiate\", \"user.session.impersonation.grant\", \"user.session.impersonation.extend\", \"user.session.impersonation.end\", \"user.session.impersonation.revoke\"]);\nOkta_CL\n| where eventType_s in (Events)\n| where outcome_result_s =~ \"SUCCESS\"\n", "attributes": {"description": "'User.session.impersonation are generally speaking rare events normally triggered when an Okta Support person requests admin access for troubleshooting. This query searches for impersonation events used in LAPSUS$ breach.\n Please review user.session.impersonation events and co-relate that with legitimate opened Okta support tickets to determine if these are anomalous.\n Refrence: https://developer.okta.com/docs/reference/api/event-types/\n Refrence: https://twitter.com/JimmyVo/status/1506306703788326915\n Refrence: https://blog.cloudflare.com/cloudflare-investigation-of-the-january-2022-okta-compromise/'\n", "techniques": ["T1195"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Okta%20Single%20Sign-On/Hunting%20Queries/RareMFAOperation.yaml", "query_name": "Rare MFA Operations (Okta)", "query": "let Events = dynamic([\"user.mfa.factor.update\", \"system.mfa.factor.deactivate\", \"user.mfa.attempt_bypass\", \"user.mfa.factor.reset_all\"]);\nOkta_CL\n| where eventType_s in (Events)\n| where outcome_result_s =~ \"SUCCESS\"\n| extend Target=parsejson(target_s)\n| mvexpand bagexpansion=array (Target)\n| evaluate bag_unpack(Target)\n| extend Target_Id = tostring(column_ifexists('id', \"\")), Target_type = tostring(column_ifexists('type', \"\")), Target_user = tostring(column_ifexists('displayName', \"\")), Target_alternateId = tostring(column_ifexists('alternateId', \"\"))\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by actor_id_s, actor_type_s, actor_alternateId_s, actor_displayName_s, Target_alternateId, Target_Id, Target_type, Target_user,debugContext_debugData_requestUri_s,\n  debugContext_debugData_requestId_s, domain_s, authenticationContext_externalSessionId_s, eventType_s, displayMessage_s, transaction_id_s, uuid_g, client_userAgent_rawUserAgent_s, client_userAgent_os_s, client_userAgent_browser_s, \n  client_ipAddress_s, client_geographicalContext_city_s, client_geographicalContext_state_s, client_geographicalContext_country_s, securityContext_isp_s\n", "attributes": {"description": "'Multi-Factor Authentication (MFA) helps prevent credential compromise.This query searches for rare MFA operations like deactivating, updating, resetting and attempts to bypass MFA.\n Adversaries often attempt these operations to compromise networks and high-value accounts.Please verify that the behavior is known and filter out anything that is expected.\n Refrence: https://developer.okta.com/docs/reference/api/event-types/'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Okta%20Single%20Sign-On/Hunting%20Queries/UserPasswordReset.yaml", "query_name": "User password reset(Okta)", "query": "let Events = dynamic([\"user.account.reset_password\"]);\nOkta_CL\n| where eventType_s in (Events)\n| where outcome_result_s =~ \"SUCCESS\"\n", "attributes": {"description": "'Adversaries often manipulate accounts to maintain access to victim systems. Account manipulation may consist of actions that preserves adversary access to a compromised account, such as by modifying credentials. \n This query searches for attempts to reset user passwords in Okta logs by an admin. Since this can also be a known activity, please filter out anything that is expected.\n Reference: https://developer.okta.com/docs/reference/api/event-types/\n Reference: https://blog.cloudflare.com/cloudflare-investigation-of-the-january-2022-okta-compromise/'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCIDiscoveryActivity.yaml", "query_name": "OCI - Discovery activity", "query": "let threshold = 20;\nOCILogs\n| where data_eventName_s startswith 'List' or data_eventName_s startswith 'Get'\n| summarize count() by data_definedTags_Oracle_Tags_CreatedBy_s, bin(TimeGenerated, 10m)\n| where count_ > threshold\n| extend AccountCustomEntity = data_definedTags_Oracle_Tags_CreatedBy_s\n", "attributes": {"description": "'Detects possible discovery activity.'\n", "techniques": ["T1580"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCIEventRuleDeleted.yaml", "query_name": "OCI - Event rule deleted", "query": "OCILogs\n| where data_eventName_s =~ 'DeleteRule'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when event rule was deleted.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCIInboundSSHConnection.yaml", "query_name": "OCI - Inbound SSH connection", "query": "OCILogs\n| where EventType contains 'vcn.flowlogs'\n| where data_action_s =~ 'ACCEPT'\n| where ipv4_is_private(DstIpAddr)\n| where ipv4_is_private(SrcIpAddr) == False\n| where DstPortNumber == 22\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects inbound SSH connection.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCIInsecureMetadataEndpoint.yaml", "query_name": "OCI - Insecure metadata endpoint", "query": "OCILogs\n| where data_request_headers_oci_original_url_s contains '/opc/v1' or data_request_headers_oci_original_url_s contains '/openstack'\n| where HttpStatusCode == 200\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects insecure metadata endpoint.'\n", "techniques": ["T1069"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCIMetadataEndpointIpAccess.yaml", "query_name": "OCI - Instance metadata access", "query": "OCILogs\n| where EventType contains 'vcn.flowlogs'\n| where data_action_s =~ 'ACCEPT'\n| where DstIpAddr == '169.254.169.254'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects instance metadata access.'\n", "techniques": ["T1069"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCIMultipleInstancesLaunched.yaml", "query_name": "OCI - Multiple instances launched", "query": "let threshold = 5;\nOCILogs\n| where data_eventName_s =~ 'LaunchInstance'\n| summarize count() by SrcIpAddr, bin(TimeGenerated, 10m)\n| where count_ >= threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when multiple instances were launched.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCIMultipleInstancesTerminated.yaml", "query_name": "OCI - Multiple instances terminated", "query": "let threshold = 5;\nOCILogs\n| where data_eventName_s =~ 'TerminateInstance'\n| summarize count() by SrcIpAddr, bin(TimeGenerated, 10m)\n| where count_ >= threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when multiple instances were terminated.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCIMultipleRejects.yaml", "query_name": "OCI - Multiple rejects on rare ports", "query": "let threshold = 50;\nlet r_dports = \nOCILogs\n| where EventType contains 'vcn.flowlogs'\n| where ipv4_is_private(DstIpAddr)\n| where ipv4_is_private(SrcIpAddr) == False\n| summarize count() by DstPortNumber\n| top 10 by count_ asc\n| summarize dports = makeset(DstPortNumber)\n| extend k = 1;\nOCILogs\n| where EventType contains 'vcn.flowlogs'\n| where data_action_s =~ 'REJECT'\n| where ipv4_is_private(DstIpAddr)\n| where ipv4_is_private(SrcIpAddr) == False\n| extend k = 1\n| join kind=innerunique (r_dports) on k\n| where dports has tostring(DstPortNumber)\n| summarize count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple rejects on rare ports.'\n", "techniques": ["T1595"], "tactics": ["Reconnaissance"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCISSHScan.yaml", "query_name": "OCI - SSH scanner", "query": "let threshold = 5;\nOCILogs\n| where EventType contains 'vcn.flowlogs'\n| where data_action_s =~ 'REJECT'\n| where ipv4_is_private(DstIpAddr)\n| where ipv4_is_private(SrcIpAddr) == False\n| where DstPortNumber == 22\n| summarize p_count = dcount(DstIpAddr) by SrcIpAddr, bin(TimeGenerated, 5m)\n| where p_count > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects possible SSH scanning activity.'\n", "techniques": ["T1595"], "tactics": ["Reconnaissance"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Analytic%20Rules/OCIUnexpectedUserAgent.yaml", "query_name": "OCI - Unexpected user agent", "query": "OCILogs\n| where isnotempty(HttpUserAgentOriginal)\n| where strlen(HttpUserAgentOriginal) <= 10\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects unexpected user agent strings.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCIDestinationsIn.yaml", "query_name": "OCI - Destination ports (inbound traffic)", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where EventType contains 'vcn.flowlogs'\n| where data_action_s =~ 'ACCEPT'\n| where ipv4_is_private(DstIpAddr)\n| where ipv4_is_private(SrcIpAddr) == False\n| summarize count() by DstIpAddr, DstPortNumber\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query searches for destination ports of inbound traffic.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCIDestinationsOut.yaml", "query_name": "OCI - Destination ports (outbound traffic)", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where EventType contains 'vcn.flowlogs'\n| where data_action_s =~ 'ACCEPT'\n| where ipv4_is_private(SrcIpAddr)\n| where ipv4_is_private(DstIpAddr) == False\n| summarize count() by SrcIpAddr, DstIpAddr, DstPortNumber\n| extend IPCustomEntity = data_sourceAddress_s\n", "attributes": {"description": "'Query searches for destination ports of outbound traffic.'\n", "techniques": ["T1020"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCILaunchedInstances.yaml", "query_name": "OCI - Launched instances", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where EventType endswith 'LaunchInstance'\n| extend AccountCustomEntity = data_definedTags_Oracle_Tags_CreatedBy_s\n", "attributes": {"description": "'Query searches for new launched instances.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCIUpdateActivities.yaml", "query_name": "OCI - Update activities", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where data_eventName_s startswith 'Update'\n| project TimeGenerated, data_eventName_s, data_definedTags_Oracle_Tags_CreatedBy_s\n| extend AccountCustomEntity = data_definedTags_Oracle_Tags_CreatedBy_s\n", "attributes": {"description": "'Query searches for update activities performed by users.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCIUserDeleteActions.yaml", "query_name": "OCI - Delete operations", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where data_eventName_s startswith 'Delete'\n| extend AccountCustomEntity = data_definedTags_Oracle_Tags_CreatedBy_s\n", "attributes": {"description": "'Query searches for delete operations performed by user.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCIUserDeletedUsers.yaml", "query_name": "OCI - Deleted users", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where data_eventName_s =~ 'DeleteUser'\n| extend AccountCustomEntity = data_definedTags_Oracle_Tags_CreatedBy_s\n", "attributes": {"description": "'Query searches for users being deleted.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCIUserNewUsers.yaml", "query_name": "OCI - New users", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where data_eventName_s =~ 'CreateUser'\n| extend AccountCustomEntity = data_definedTags_Oracle_Tags_CreatedBy_s\n", "attributes": {"description": "'Query searches for new users created.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCIUserSources.yaml", "query_name": "OCI - User source IP addresses", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where data_eventName_s startswith 'InteractiveLogin'\n| summarize makeset(SrcIpAddr) by data_definedTags_Oracle_Tags_CreatedBy_s\n| extend AccountCustomEntity = data_definedTags_Oracle_Tags_CreatedBy_s\n", "attributes": {"description": "'Query searches for user source IP addresses.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCIUserTerminatedInstances.yaml", "query_name": "OCI - Terminated instances", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where data_eventName_s =~ 'TerminateInstance'\n| extend AccountCustomEntity = data_definedTags_Oracle_Tags_CreatedBy_s\n", "attributes": {"description": "'Query searches for terminated instances.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Oracle%20Cloud%20Infrastructure/Hunting%20Queries/OCIUserUpdatedInstances.yaml", "query_name": "OCI - Updated instances", "query": "OCILogs\n| where TimeGenerated > ago(24h)\n| where data_eventName_s =~ 'UpdateInstance'\n| extend AccountCustomEntity = data_definedTags_Oracle_Tags_CreatedBy_s\n", "attributes": {"description": "'Query searches for updated instances.'\n", "techniques": ["T1578"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditConnectFromExternalIp.yaml", "query_name": "OracleDBAudit - Connection to database from external IP", "query": "OracleDatabaseAuditEvent\n| where isnotempty(SrcIpAddr)\n| where isnotempty(Action)\n| where DbAction =~ 'connect'\n| where ipv4_is_private(SrcIpAddr) == 'false'\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when connection to database is from external IP source.'\n", "techniques": ["T1190", "T1133", "T1078", "T1119", "T1029"], "tactics": ["InitialAccess", "Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditDropManyTables.yaml", "query_name": "OracleDBAudit - Multiple tables dropped in short time", "query": "let tbl_threshold = 10;\nOracleDatabaseAuditEvent\n| where isnotempty(DstUserName)\n| where DbAction =~ 'DROP'\n| extend TableName = replace(@'[,\\(\\)]', '', extract(@'(?i)SELECT(.*?)FROM\\s(.*?)\\s', 2, Action))\n| where isnotempty(TableName)\n| where TableName !~ 'SELECT'\n| summarize tbl_count = dcount(TableName) by DstUserName\n| where tbl_count > tbl_threshold\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when user drops many tables in short period of time.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditForbiddenSrcIpAddr.yaml", "query_name": "OracleDBAudit - Connection to database from unknown IP", "query": "let ip_allowlist = dynamic(['127.0.0.2']);\nOracleDatabaseAuditEvent\n| where isnotempty(SrcIpAddr)\n| where DbAction =~ 'CONNECT'\n| where SrcIpAddr !in (ip_allowlist)\n| project SrcIpAddr, DstUserName\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when user connects to a database from IP address which is not present in AllowList.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditNewIpForUser.yaml", "query_name": "OracleDBAudit - User connected to database from new IP", "query": "let lbtime_d = 14d;\nlet lbtime_24h = 24h;\nOracleDatabaseAuditEvent\n| where TimeGenerated between (ago(lbtime_d) .. ago(lbtime_24h))\n| where isnotempty(SrcIpAddr)\n| where isnotempty(DstUserName)\n| summarize knownIPs = make_set(SrcIpAddr) by DstUserName\n| join (OracleDatabaseAuditEvent\n      | where isnotempty(SrcIpAddr)\n      | where isnotempty(DstUserName)\n      | where DbAction =~ 'connect'\n      ) on DstUserName\n| where knownIPs !contains SrcIpAddr\n| project DstUserName, SrcIpAddr\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when a user connects to database from new IP address.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditNewUserDetected.yaml", "query_name": "OracleDBAudit - New user account", "query": "let lbtime_d = 14d;\nlet lbtime_24h = 24h;\nlet known_users = OracleDatabaseAuditEvent\n| where TimeGenerated between (ago(lbtime_d) .. ago(lbtime_24h))\n| where isnotempty(DstUserName)\n| where isnotempty(Action)\n| summarize makeset(DstUserName);\nOracleDatabaseAuditEvent\n| where isnotempty(DstUserName)\n| where isnotempty(Action)\n| where DstUserName !in (known_users)\n| project DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when an action was made by new user.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditQueryOnSensitiveTable.yaml", "query_name": "OracleDBAudit - Query on Sensitive Table", "query": "let sensitive_tbls = dynamic(['table_name1', 'table_name2']);\nOracleDatabaseAuditEvent\n| where isnotempty(DstUserName)\n| where isnotempty(Action)\n| extend TableName = replace(@'[,\\(\\)]', '', extract(@'(?i)SELECT(.*?)FROM\\s(.*?)\\s', 2, Action))\n| where isnotempty(TableName)\n| where TableName in (sensitive_tbls)\n| project TableName, DstUserName, DbAction\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when user queries sensitive tables.'\n", "techniques": NaN, "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditRareUserActivity.yaml", "query_name": "OracleDBAudit - User activity after long inactivity time", "query": "let lbtime_14d = 14d;\nlet lbtime_7d = 7d;\nlet lbtime_24h = 24h;\nlet known_users_14d = OracleDatabaseAuditEvent\n| where TimeGenerated between (ago(lbtime_14d) .. ago(lbtime_14d))\n| where isnotempty(DstUserName)\n| where isnotempty(Action)\n| summarize makeset(DstUserName);\nlet known_users_7d = OracleDatabaseAuditEvent\n| where TimeGenerated between (ago(lbtime_7d) .. ago(lbtime_24h))\n| where isnotempty(DstUserName)\n| where isnotempty(Action)\n| summarize makeset(DstUserName);\nOracleDatabaseAuditEvent\n| where isnotempty(DstUserName)\n| where isnotempty(Action)\n| where DstUserName !in (known_users_7d)\n| where DstUserName in (known_users_14d)\n| project DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when an action was made by a user which last activity was observed more than 30 days ago.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditSelectOnManyTables.yaml", "query_name": "OracleDBAudit - Unusual user activity on multiple tables", "query": "let tbl_threshold = 10;\nOracleDatabaseAuditEvent\n| where isnotempty(DstUserName)\n| where DbAction =~ 'SELECT'\n| extend TableName = replace(@'[,\\(\\)]', '', extract(@'(?i)SELECT(.*?)FROM\\s(.*?)\\s', 2, Action))\n| where isnotempty(TableName)\n| where TableName !~ 'SELECT'\n| summarize tbl_count = dcount(TableName) by DstUserName, bucket = bin(TimeGenerated, 5m)\n| where tbl_count > tbl_threshold\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when user queries many tables in short period of time.'\n", "techniques": ["T1119"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditShutdownServer.yaml", "query_name": "OracleDBAudit - Shutdown Server", "query": "OracleDatabaseAuditEvent\n| where isnotempty(SrcIpAddr)\n| where DbAction =~ 'SHUTDOWN'\n| project SrcIpAddr, DstUserName\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when \"SHUTDOWN\" command was sent to server.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Analytic%20Rules/OracleDBAuditSQLInjectionPatterns.yaml", "query_name": "OracleDBAudit - SQL injection patterns", "query": "OracleDatabaseAuditEvent\n| where isnotempty(DstUserName)\n| where Action has_any (\"admin' --\" ,\"admin' #\", \"admin'/*\", \"0=1\", \"1=0\", \"1=1\", \"1=2\", \"' or 1=1--\", \"' or 1=1#\", \"' or 1=1/*\", \"') or '1'='1--\", \"') or ('1'='1--\")\n| project SrcIpAddr, DstUserName, Action\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects common known SQL injection patterns used in automated scripts.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditActionsByIp.yaml", "query_name": "OracleDBAudit - Action by Ip", "query": "let lbtime = 24h;\nOracleDatabaseAuditEvent\n| where TimeGenerated > ago(lbtime)\n| where isnotempty(DbAction)\n| where isnotempty(SrcIpAddr)\n| where DbAction in~ ('SELECT', 'DROP', 'INSERT')\n| extend TableName = replace(@'[,\\(\\)]', '', extract(@'(?i)SELECT(.*?)FROM\\s(.*?)\\s', 2, Action))\n| where isnotempty(TableName)\n| where TableName !~ 'select'\n| summarize TablesAffected = makeset(TableName) by SrcIpAddr, DbAction\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches sources from which DbActions were made.'\n", "techniques": ["T1485", "T1005", "T1119", "T1078"], "tactics": ["InitialAccess", "DefenseEvasion", "Collection", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditActionsByUser.yaml", "query_name": "OracleDBAudit - Action by user", "query": "let lbtime = 24h;\nOracleDatabaseAuditEvent\n| where TimeGenerated > ago(lbtime)\n| where isnotempty(DbAction)\n| where isnotempty(DstUserName)\n| where DbAction in~ ('SELECT', 'DROP', 'INSERT')\n| extend TableName = replace(@'[,\\(\\)]', '', extract(@'(?i)SELECT(.*?)FROM\\s(.*?)\\s', 2, Action))\n| where isnotempty(TableName)\n| where TableName !~ 'select'\n| summarize TablesAffected = makeset(TableName) by DstUserName, DbAction\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches actions made by user.'\n", "techniques": ["T1485", "T1005", "T1119", "T1078"], "tactics": ["InitialAccess", "DefenseEvasion", "Collection", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditActiveUsers.yaml", "query_name": "OracleDBAudit - Active Users", "query": "OracleDatabaseAuditEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(Action) and isnotempty(DstUserName) and isnotempty(SrcIpAddr)\n| summarize count() by DstUserName\n| order by count_\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query for searching active database user accounts.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditDbConnectNonOperationalTime.yaml", "query_name": "OracleDBAudit - Users connected to databases during non-operational hours.", "query": "let lbtime = 24h;\nOracleDatabaseAuditEvent\n| where TimeGenerated > ago(lbtime)\n| where DbAction =~ 'CONNECT'\n| where isnotempty(DstUserName)\n| extend day_of_week = dayofweek(TimeGenerated)\n| extend hour_of_day = hourofday(TimeGenerated)\n| where day_of_week in~ ('0.00:00:00', '6.00:00:00') or hour_of_day between (18 .. 8)\n| project TimeGenerated, DstUserName, SrcIpAddr\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for users who have connected to databases during non-operational hours.'\n", "techniques": ["T1485", "T1005", "T1119", "T1078"], "tactics": ["InitialAccess", "DefenseEvasion", "Collection", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditDroppedTables.yaml", "query_name": "OracleDBAudit - Dropped Tables", "query": "let lbtime = 24h;\nOracleDatabaseAuditEvent\n| where TimeGenerated > ago(lbtime)\n| where DbAction =~ 'DROP'\n| extend TableName = replace(@'[,\\(\\)]', '', extract(@'(?i)SELECT(.*?)FROM\\s(.*?)\\s', 2, Action))\n| where isnotempty(TableName)\n| where TableName !~ 'select'\n| project TimeGenerated, DstUserName, TableName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for dropped tables.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditInactiveUsers.yaml", "query_name": "OracleDBAudit - Inactive Users", "query": "let lbtime_30d = 30d;\nlet lbtime_1d = 1d;\nlet known_users_gt_30d = OracleDatabaseAuditEvent\n| where TimeGenerated < ago(lbtime_30d)\n| where isnotempty(DstUserName)\n| where isnotempty(Action)\n| summarize makeset(DstUserName);\nlet known_users_ls_30d = OracleDatabaseAuditEvent\n| where TimeGenerated between (ago(lbtime_30d) .. ago(lbtime_1d))\n| where isnotempty(DstUserName)\n| where isnotempty(Action)\n| summarize makeset(DstUserName);\nOracleDatabaseAuditEvent\n| where TimeGenerated > ago(lbtime_1d)\n| where isnotempty(DstUserName)\n| where DbAction =~ 'CONNECT'\n| where DstUserName in (known_users_gt_30d)\n| where DstUserName !in (known_users_ls_30d)\n| project DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query for searching user accounts which last activity was more than 30 days ago.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditLargeQueries.yaml", "query_name": "OracleDBAudit - Audit large queries", "query": "let lbtime_30d = 30d;\nlet lbtime_1d = 1d;\nOracleDatabaseAuditEvent\n| where TimeGenerated > ago(lbtime_30d)\n| where isnotempty(ActionLength)\n| summarize avg_action_length = avg(toint(ActionLength))\n| extend a = 1\n| join (OracleDatabaseAuditEvent\n  | where TimeGenerated > ago(lbtime_1d)\n  | where isnotempty(ActionLength)\n  | extend a = 1) on a\n| where toint(ActionLength) > 2*avg_action_length\n| project avg_action_length, ActionLength, Action, DstUserName,SrcIpAddr\n| extend AccountCustomEntity = DstUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query for auditing large queries.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditListOfTablesQueried.yaml", "query_name": "OracleDBAudit - Top tables queries", "query": "let lbtime = 24h;\nOracleDatabaseAuditEvent\n| where TimeGenerated > ago(lbtime)\n| where DbAction =~ 'SELECT'\n| extend TableName = replace(@'[,\\(\\)]', '', extract(@'(?i)SELECT(.*?)FROM\\s(.*?)\\s', 2, Action))\n| where isnotempty(TableName)\n| where TableName !~ 'select'\n| summarize count() by TableName, DstUserName\n| order by count_\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for tables queries.'\n", "techniques": ["T1005", "T1119"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditUsersNewPrivilegesAdded.yaml", "query_name": "OracleDBAudit - Users with new privileges", "query": "let lbtime_30d = 30d;\nlet lbtime_1d = 1d;\nOracleDatabaseAuditEvent\n| where TimeGenerated between (ago(lbtime_30d) .. ago(lbtime_1d))\n| where isnotempty(Privilege) and isnotempty(DstUserName)\n| summarize Privileges = makeset(Privilege) by DstUserName\n| join (OracleDatabaseAuditEvent\n      | where TimeGenerated > ago(lbtime_1d)\n      | where isnotempty(DstUserName) and isnotempty(Privilege)\n      | project DstUserName, Privilege\n      ) on DstUserName\n|mv-expand Privileges\n|extend Privileges = tostring(Privileges)\n| where Privilege != Privileges\n", "attributes": {"description": "'Query for searching user accounts whith new privileges.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleDatabaseAudit/Hunting%20Queries/OracleDBAuditUsersPrivilegesReview.yaml", "query_name": "OracleDBAudit - Users Privileges Review", "query": "let lbtime = 30d;\nOracleDatabaseAuditEvent\n| where TimeGenerated > ago(lbtime)\n| where isnotempty(DstUserName)\n| where isnotempty(Privilege)\n| summarize makeset(Privilege) by DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for user accounts and their privileges.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicCommandInURI.yaml", "query_name": "Oracle - Command in URI", "query": "OracleWebLogicServerEvent\n| where UrlOriginal has_any ('cat%20/etc/passwd', '/etc/passwd', 'ping -i', '/usr/bin/id(', '%2f%75%73%72%2f%62%69%6e%2f%69%64', 'phpinfo()' , '%70%68%70%69%6e%66%6f%28%29', ';id', '%3b%69%64', '/bin/bash -c', '%2f%62%69%6e%2f%62%61%73%68%20%2d%63%27', '/bin/bash', '%2f%62%69%6e%2f%62%61%73%68', 'sleep(', '%73%6c%65%65%70%28', 'curl', '%63%75%72%6c', '&dir', '%26%64%69%72', '& dir', '%26%20%64%69%72', '<script>', '%3c%73%63%72%69%70%74%3e', 'eval(', '%65%76%61%6c%28', 'exec(', '%65%78%65%63%28' , 'whoami', '%77%68%6f%61%6d%69', 'wget', 'python', 'gcc' , 'uname', 'systeminfo', '%77%67%65%74', '%70%79%74%68%6f%6e', '%75%6e%61%6d%65', '%73%79%73%74%65%6d%69%6e%66%6f') \n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects command in URI'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicDifferentUAsFromSingleIP.yaml", "query_name": "Oracle - Multiple user agents for single source", "query": "let threshold = 5;\nOracleWebLogicServerEvent\n| where isnotempty(HttpUserAgentOriginal)\n| summarize ua_count=makeset(HttpUserAgentOriginal) by SrcIpAddr, bin(TimeGenerated, 5m)\n| where array_length(ua_count) > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests with different user agents from one source in short timeframe.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicExploitCVE-2021-2109.yaml", "query_name": "Oracle - Oracle WebLogic Exploit CVE-2021-2109", "query": "OracleWebLogicServerEvent\n| where HttpRequestMethod =~ \"GET\"\n| where UrlOriginal has_all (\"ldap://\", \"com.bea.console.handles.JndiBindingHandle\", \"AdminServer\")\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects exploitation of Oracle WebLogic vulnerability CVE-2021-2109'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicKnownMaliciousUserAgents.yaml", "query_name": "Oracle - Malicious user agent", "query": "OracleWebLogicServerEvent\n| where isnotempty(HttpUserAgentOriginal)\n| where HttpUserAgentOriginal has_any ('Nikto', '(hydra)', '.nasl', 'absinthe', 'advanced email extractor', 'arachni/', 'autogetcontent', 'bilbo', 'BFAC', 'brutus', 'brutus/aet', 'bsqlbf', 'cgichk', 'cisco-torch', 'commix', 'core-project/1.0', 'crimscanner/', 'datacha0s', 'dirbuster', 'domino hunter', 'dotdotpwn', 'email extractor', 'fhscan core 1.', 'floodgate', 'get-minimal', 'gootkit auto-rooter scanner', 'grabber', 'grendel-scan', 'havij', 'inspath', 'internet ninja', 'jaascois', 'zmeu', 'masscan', 'metis', 'morfeus', 'mysqloit', 'n-stealth', 'nessus', 'netsparker', 'nmap nse', 'nmap scripting engine', 'nmap-nse', 'nsauditor', 'openvas', 'pangolin', 'paros', 'pmafind', 'prog.customcrawler', 'qualys was', 's.t.a.l.k.e.r.', 'security scan', 'springenwerk', 'sql power injector', 'sqlmap', 'sqlninja', 'teh forest lobster', 'this is an exploit', 'toata dragostea', 'toata dragostea mea pentru diavola', 'uil2pn', 'user-agent:', 'vega/', 'voideye', 'w3af.sf.net', 'w3af.sourceforge.net', 'w3af.org', 'webbandit', 'webinspect', 'webshag', 'webtrends security analyzer', 'webvulnscan', 'whatweb', 'whcc/', 'wordpress hash grabber', 'xmlrpc exploit', 'WPScan', 'XSpider', 'SF/', 'FooBar/42', 'ScanAlert', 'Webscanner', 'Webster', 'fantomCrew', 'fantomBrowser', 'visvo', 'magereport', 'ltx71', 'websiteprotection', 'BigCliqueBOT', '(BOT for JCE)')\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects known malicious user agent strings'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicMultipleClientErrorsFromSingleIP.yaml", "query_name": "Oracle - Multiple client errors from single IP", "query": "let threshold = 100;\nOracleWebLogicServerEvent\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499 \n| summarize MultipleClientErrors = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where MultipleClientErrors > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple client errors from one source in short timeframe'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicMultipleServerErrorsRequestsFromSingleIP.yaml", "query_name": "Oracle - Multiple server errors from single IP", "query": "let threshold = 100;\nOracleWebLogicServerEvent\n| where HttpStatusCode >= 500 and HttpStatusCode <= 599 \n| summarize MultipleServerErrors = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where MultipleServerErrors > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple server errors from one source in short timeframe'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicPrivateIpInUrl.yaml", "query_name": "Oracle - Private IP in URL", "query": "OracleWebLogicServerEvent\n| where isnotempty(UrlOriginal)\n| where UrlOriginal matches regex @'(10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})|(172\\.1[6-9]\\.\\d{1,3}\\.\\d{1,3})|(172\\.2[0-9]\\.\\d{1,3}\\.\\d{1,3})|(172\\.3[0-1]\\.\\d{1,3}\\.\\d{1,3})|(192\\.168\\.\\d{1,3}\\.\\d{1,3})'\n| extend IPCustomEntity = SrcIpAddr, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects requests to unusual URL'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicPutAndGetFileFromSameIP.yaml", "query_name": "Oracle - Put file and get file from same IP address", "query": "let p = OracleWebLogicServerEvent\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| sort by EventStartTime asc\n| summarize post_time=min(EventStartTime) by SrcIpAddr, tostring(UrlOriginal);\nOracleWebLogicServerEvent\n| where HttpRequestMethod =~ 'GET'\n| sort by EventStartTime asc\n| summarize get_time=min(EventStartTime) by SrcIpAddr, tostring(UrlOriginal)\n| join kind=innerunique (p) on UrlOriginal, SrcIpAddr\n| extend second = datetime_diff('second',get_time,post_time)\n| where second between (1 .. 300)\n| project second, post_time, get_time, SrcIpAddr, UrlOriginal\n| extend IPCustomEntity = SrcIpAddr, UrlCustomEntity = tostring(UrlOriginal)\n", "attributes": {"description": "'Detects put or get files from one source in short timeframe' \n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicPutSuspiciousFiles.yaml", "query_name": "Oracle - Put suspicious file", "query": "OracleWebLogicServerEvent\n| where HttpRequestMethod in~ (\"POST\", \"PUT\") \n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| where File matches regex @\"([a-zA-Z0-9-_]+\\.)([a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+)\"\n| extend IPCustomEntity = SrcIpAddr, FileCustomEntity = File, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects PUT or POST of suspicious file'\n", "techniques": ["T1190", "T1133", "T1048"], "tactics": ["InitialAccess", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Analytic%20Rules/OracleWebLogicRequestToSensitiveFiles.yaml", "query_name": "Oracle - Request to sensitive files", "query": "let forbidden_files = dynamic(['shadow', 'passwd', 'hosts', 'id_rsa']);\nOracleWebLogicServerEvent    \n| extend File = extract(@'(.*\\/)?(.*)', 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| where File in~ (forbidden_files)\n| extend FileCustomEntity = File, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects request to sensitive files.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogic403RequestsFiles.yaml", "query_name": "Oracle - Request to forbidden files", "query": "OracleWebLogicServerEvent\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode == 403\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows request to forbidden files.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogicAbnormalRequestSize.yaml", "query_name": "Oracle - Abnormal request size", "query": "let Average_Body_Bytes = OracleWebLogicServerEvent\n| where TimeGenerated > ago(30d)\n| summarize Avg_Size = avg(tolong(HttpResponseBodyBytes))\n| extend K = 1;\nOracleWebLogicServerEvent\n| where TimeGenerated > ago(24h)\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| extend K = 1\n| join kind=inner Average_Body_Bytes on K\n| where tolong(HttpResponseBodyBytes) > Avg_Size\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows abnormal request size.'\n", "techniques": ["T1530", "T1537"], "tactics": ["Exfiltration", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogicCriticalEventSeverity.yaml", "query_name": "Oracle - Critical event severity", "query": "OracleWebLogicServerEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(EventSeverity)\n| where EventSeverity has_any (\"CRITICAL\", 'ALERT', 'EMERGENCY')\n| extend UrlCustomEntity = UrlOriginal, AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query shows critical event severity'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogicErrors.yaml", "query_name": "Oracle - Error messages", "query": "OracleWebLogicServerEvent\n| where EventMessage has_any (\"error\", \"Invalid\")\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows error messages.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogicFilesErrorRequests.yaml", "query_name": "Oracle - Top files requested by users with error", "query": "OracleWebLogicServerEvent\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 599 \n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| summarize TotalFile = count() by File\n| top 20 by TotalFile desc\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows list of files with error requests.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogicRareUAWithClientErrors.yaml", "query_name": "Oracle - Rare user agents with client errors", "query": "OracleWebLogicServerEvent\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499\n| where isnotempty(HttpUserAgentOriginal)\n| summarize Total_UA_Count = count() by tostring(HttpUserAgentOriginal)\n| top 20 by Total_UA_Count desc\n| extend UrlCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Query shows rare user agent strings with client errors'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogicRareURLsRequested.yaml", "query_name": "Oracle - Rare URLs requested", "query": "OracleWebLogicServerEvent\n| where TimeGenerated > ago(24h)\n| summarize count() by tostring(UrlOriginal)\n| top 20 by count_ asc\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows rare URLs requested.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogicUncommonUserAgents.yaml", "query_name": "Oracle - Rare user agents", "query": "OracleWebLogicServerEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(HttpUserAgentOriginal)\n| summarize UAs = count() by tostring(HttpUserAgentOriginal)\n| top 20 by UAs asc\n| extend UrlCustomEntity = UAs\n", "attributes": {"description": "'Query shows rare user agents'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogicUrlClienterrors.yaml", "query_name": "Oracle - Top URLs client errors", "query": "OracleWebLogicServerEvent\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499\n| summarize TopUrls = count() by tostring(UrlOriginal)\n| top 20 by TopUrls desc\n| extend UrlCustomEntity = TopUrls\n", "attributes": {"description": "'Query shows URLs list with client errors.'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/OracleWebLogicServer/Hunting%20Queries/OracleWebLogicUrlServerErrors.yaml", "query_name": "Oracle - Top URLs server errors", "query": "OracleWebLogicServerEvent\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 500 and HttpStatusCode <= 599\n| summarize TopUrls = count() by tostring(UrlOriginal)\n| top 20 by TopUrls desc\n| extend UrlCustomEntity = TopUrls\n", "attributes": {"description": "'Query shows URLs list with server errors.'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Palo%20Alto%20-%20XDR%20%28Cortex%29/Detection%20Queries/Preventive%20Alerts.yaml", "query_name": "Palo Alto Prevention alert", "query": "CommonSecurityLog\n| where DeviceVendor == \"Palo Alto Networks\"\n| where DeviceProduct == \"Cortex XDR\"\n| where DeviceAction == \"Prevented (Blocked)\"\n| where LogSeverity =~ \"6\"\n| summarize by TimeGenerated,DeviceProduct, DeviceEventClassID, LogSeverity, Activity, DeviceAction, Computer, DeviceVersion, FileHash, FileName, FilePath, RequestURL, SourceHostName, SourceUserName\n| sort by TimeGenerated\n", "attributes": {"description": "'The query checks for all malicious events prevented events across all devices having LogSeverity of '6' and summarize the result.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Palo%20Alto%20-%20XDR%20%28Cortex%29/Detection%20Queries/WildFire%20Malware%20Detection.yaml", "query_name": "Palo Alto WildFire Malware Detection", "query": "CommonSecurityLog\n| where ingestion_time() > ago(1d)\n| where DeviceVendor == \"Palo Alto Networks\"\n| where DeviceProduct == \"Cortex XDR\"\n| where Activity == \"WildFire Malware\"\n| summarize (Timestamp, ReportId,Severity, AttackType)=arg_max(TimeGenerated, ExternalID, LogSeverity, Activity, SourceUserName, SourceHostName), count() by Computer\n| where count_ > 5\n", "attributes": {"description": "'The query checks for specifically WildFire Malware and returns the result with Entities and hosts involved and count of attakcs.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAlto-PAN-OS/Analytic%20Rules/FileHashEntity_Covid19_CommonSecurityLog.yaml", "query_name": "Microsoft COVID-19 file hash indicator matches", "query": "\nlet dt_lookBack = 1h;\nlet covidIndicators = (externaldata(TimeGenerated:datetime, FileHashValue:string, FileHashType: string, TlpLevel: string, Product: string, ThreatType: string, Description: string )\n[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.Covid19.Indicators.csv\"] with (format=\"csv\"));\nlet fileHashIndicators = covidIndicators\n| where isnotempty(FileHashValue);\n// Handle matches against both lower case and uppercase versions of the hash:\n(fileHashIndicators | extend FileHashValue = tolower(FileHashValue)\n| union (fileHashIndicators | extend FileHashValue = toupper(FileHashValue)))\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n|  join kind=innerunique (\n   CommonSecurityLog | where TimeGenerated >= ago(dt_lookBack) \n   | where isnotempty(FileHash)\n   | extend CommonSecurityLog_TimeGenerated = TimeGenerated\n   )\non $left.FileHashValue == $right.FileHash\n| summarize CommonSecurityLog_TimeGenerated = arg_max(CommonSecurityLog_TimeGenerated, *) by FileHashValue\n| project CommonSecurityLog_TimeGenerated, FileHashValue, FileHashType, Description, ThreatType,  \nSourceIP, SourcePort, DestinationIP, DestinationPort, SourceUserID, SourceUserName, DeviceName, DeviceAction, \nRequestURL, DestinationUserName, DestinationUserID, ApplicationProtocol, Activity\n| extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, AccountCustomEntity = SourceUserName\n", "attributes": {"description": "'Identifies a match in CommonSecurityLog Event data from any FileHash published in the Microsoft COVID-19 Threat Intel Feed - as described at https://www.microsoft.com/security/blog/2020/05/14/open-sourcing-covid-threat-intelligence/'\n", "techniques": NaN, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAlto-PAN-OS/Analytic%20Rules/PaloAlto-NetworkBeaconing.yaml", "query_name": "Palo Alto - potential beaconing detected", "query": "\nlet starttime = 2d;\nlet endtime = 1d;\nlet TimeDeltaThreshold = 25;\nlet TotalEventsThreshold = 30;\nlet MostFrequentTimeDeltaThreshold = 25;\nlet PercentBeaconThreshold = 80;\nCommonSecurityLog\n| where DeviceVendor == \"Palo Alto Networks\" and Activity == \"TRAFFIC\"\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where ipv4_is_private(DestinationIP)== false\n| project TimeGenerated, DeviceName, SourceUserID, SourceIP, SourcePort, DestinationIP, DestinationPort, ReceivedBytes, SentBytes\n| sort by SourceIP asc,TimeGenerated asc, DestinationIP asc, DestinationPort asc\n| serialize\n| extend nextTimeGenerated = next(TimeGenerated, 1), nextSourceIP = next(SourceIP, 1)\n| extend TimeDeltainSeconds = datetime_diff('second',nextTimeGenerated,TimeGenerated)\n| where SourceIP == nextSourceIP\n//Whitelisting criteria/ threshold criteria\n| where TimeDeltainSeconds > TimeDeltaThreshold \n| summarize count(), sum(ReceivedBytes), sum(SentBytes)\nby TimeDeltainSeconds, bin(TimeGenerated, 1h), DeviceName, SourceUserID, SourceIP, DestinationIP, DestinationPort\n| summarize (MostFrequentTimeDeltaCount, MostFrequentTimeDeltainSeconds) = arg_max(count_, TimeDeltainSeconds), TotalEvents=sum(count_), TotalSentBytes = sum(sum_SentBytes), TotalReceivedBytes = sum(sum_ReceivedBytes) \nby bin(TimeGenerated, 1h), DeviceName, SourceUserID, SourceIP, DestinationIP, DestinationPort\n| where TotalEvents > TotalEventsThreshold and MostFrequentTimeDeltaCount > MostFrequentTimeDeltaThreshold\n| extend BeaconPercent = MostFrequentTimeDeltaCount/toreal(TotalEvents) * 100\n| where BeaconPercent > PercentBeaconThreshold\n| extend timestamp = TimeGenerated, IPCustomEntity = DestinationIP, AccountCustomEntity = SourceUserID, HostCustomEntity = DeviceName \n", "attributes": {"description": "'Identifies beaconing patterns from Palo Alto Network traffic logs based on recurrent timedelta patterns. \nThe query leverages various KQL functions to calculate time deltas and then compares it with total events observed in a day to find percentage of beaconing. \nThis outbound beaconing pattern to untrusted public networks should be investigated for any malware callbacks or data exfiltration attempts.\nReference Blog:\nhttp://www.austintaylor.io/detect/beaconing/intrusion/detection/system/command/control/flare/elastic/stack/2017/06/10/detect-beaconing-with-flare-elasticsearch-and-intrusion-detection-systems/\nhttps://techcommunity.microsoft.com/t5/microsoft-sentinel-blog/detect-network-beaconing-via-intra-request-time-delta-patterns/ba-p/779586'\n", "techniques": ["T1071", "T1571"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAlto-PAN-OS/Analytic%20Rules/PaloAlto-PortScanning.yaml", "query_name": "Palo Alto - possible internal to external port scanning", "query": "\nCommonSecurityLog\n| where isnotempty(DestinationPort) and DeviceAction !in (\"reset-both\", \"deny\") \n// filter out common usage ports. Add ports that are legitimate for your environment\n| where DestinationPort !in (\"443\", \"53\", \"389\", \"80\", \"0\", \"880\", \"8888\", \"8080\")\n| where ApplicationProtocol == \"incomplete\" \n// filter out IANA ephemeral or negotiated ports as per https://en.wikipedia.org/wiki/Ephemeral_port\n| where DestinationPort !between (toint(49512) .. toint(65535)) \n| where Computer != \"\" \n| where DestinationIP !startswith \"10.\"\n| extend Reason = coalesce(\n                              column_ifexists(\"Reason\", \"\"), \n                              extract(\"reason=(.+?)(;|$)\", 1, AdditionalExtensions),\n                              \"\"\n                          )\n// Filter out any graceful reset reasons of AGED OUT which occurs when a TCP session closes with a FIN due to aging out. \n| where Reason !has \"aged-out\" \n// Filter out any TCP FIN which occurs when a TCP FIN is used to gracefully close half or both sides of a connection.\n| where Reason !has \"tcp-fin\" \n// Uncomment one of the following where clauses to trigger on specific TCP reset reasons\n// See Palo Alto article for details - https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClUvCAK\n// TCP RST-server - Occurs when the server sends a TCP reset to the client\n// | where AdditionalExtensions has \"reason=tcp-rst-from-server\"  \n// TCP RST-client - Occurs when the client sends a TCP reset to the server\n// | where AdditionalExtensions has \"reason=tcp-rst-from-client\"  \n// Already performed\n//| extend reason = tostring(split(AdditionalExtensions, \";\")[3])\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by DeviceName, SourceUserID, SourceIP, ApplicationProtocol, Reason, DestinationPort, Protocol, DeviceVendor, DeviceProduct, DeviceAction, DestinationIP\n| where count_ >= 10\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), makeset(DestinationIP), totalcount = sum(count_) by DeviceName, SourceUserID, SourceIP, ApplicationProtocol, Reason, DestinationPort, Protocol, DeviceVendor, DeviceProduct, DeviceAction\n| extend timestamp = StartTimeUtc, IPCustomEntity = SourceIP, AccountCustomEntity = SourceUserID, HostCustomEntity = DeviceName \n", "attributes": {"description": "'Identifies a list of internal Source IPs (10.x.x.x Hosts) that have triggered 10 or more non-graceful tcp server resets from one or more Destination IPs which \nresults in an \"ApplicationProtocol = incomplete\" designation. The server resets coupled with an \"Incomplete\" ApplicationProtocol designation can be an indication \nof internal to external port scanning or probing attack. \nReferences: https://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClUvCAK and\nhttps://knowledgebase.paloaltonetworks.com/KCSArticleDetail?id=kA10g000000ClTaCAK'\n", "techniques": ["T1046"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAlto-PAN-OS/Analytic%20Rules/PaloAlto-UnusualThreatSignatures.yaml", "query_name": "Palo Alto Threat signatures from Unusual IP addresses", "query": "let starttime = 7d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet HistThreshold = 25; \nlet CurrThreshold = 10; \nlet HistoricalThreats = CommonSecurityLog\n| where isnotempty(SourceIP)\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where DeviceVendor =~ \"Palo Alto Networks\"\n| where Activity =~ \"THREAT\" and SimplifiedDeviceAction =~ \"alert\" \n| where DeviceEventClassID in ('spyware', 'scan', 'file', 'vulnerability', 'flood', 'packet', 'virus','wildfire', 'wildfire-virus')\n| summarize TotalEvents = count(), ThreatTypes = make_set(DeviceEventClassID), DestinationIpList = make_set(DestinationIP), FirstSeen = min(TimeGenerated) , LastSeen = max(TimeGenerated) by SourceIP, DeviceAction, DeviceVendor;\nlet CurrentHourThreats =  CommonSecurityLog\n| where isnotempty(SourceIP)\n| where TimeGenerated > ago(timeframe)\n| where DeviceVendor =~ \"Palo Alto Networks\"\n| where Activity =~ \"THREAT\" and SimplifiedDeviceAction =~ \"alert\" \n| where DeviceEventClassID in ('spyware', 'scan', 'file', 'vulnerability', 'flood', 'packet', 'virus','wildfire', 'wildfire-virus')\n| summarize TotalEvents = count(), ThreatTypes = make_set(DeviceEventClassID), DestinationIpList = make_set(DestinationIP), FirstSeen = min(TimeGenerated) , LastSeen = max(TimeGenerated) by SourceIP, DeviceAction, DeviceProduct, DeviceVendor;\nCurrentHourThreats \n| where TotalEvents < CurrThreshold\n| join kind = leftanti (HistoricalThreats \n| where TotalEvents > HistThreshold) on SourceIP\n", "attributes": {"description": "'Identifies Palo Alto Threat signatures from unusual IP addresses which are not historically seen. \nThis detection is also leveraged and required for MDE and PAN Fusion scenario\nhttps://docs.microsoft.com/Azure/sentinel/fusion-scenario-reference#network-request-to-tor-anonymization-service-followed-by-anomalous-traffic-flagged-by-palo-alto-networks-firewall'\n", "techniques": ["T1046", "T1030", "T1071.001"], "tactics": ["Discovery", "Exfiltration", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAlto-PAN-OS/Hunting%20Queries/PaloAlto-HighRiskPorts.yaml", "query_name": "Palo Alto - high-risk ports", "query": "\nlet HighRiskPorts = datatable (Port:int, Protocol:string, RiskType:string, RiskDescription:string)[\n13,\"udp\",\"3rd Party Attacks\",\"Daytime protocol used in reflection/amplification attacks\",\n17,\"udp\",\"3rd Party Attacks\",\"QOTD protocol, reflection/amplification attacks\",\n19,\"udp\",\"3rd Party Attacks\",\"Chargen protocol, reflection/amplification attacks\",\n20,\"tcp\",\"Unencrypted\",\"Unencrypted FTP Traffic\",\n21,\"tcp\",\"Unencrypted\",\"Unencrypted FTP Traffic\",\n22,\"tcp\",\"Management\",\"SSH, brute force attacks common\",\n23,\"tcp\",\"Management\",\"Telnet, allows unauthenticated and/or unencrypted\",\n53,\"udp\",\"3rd Party Attacks\",\"DNS, reflection/amplification attacks\",\n69,\"udp\",\"Management\",\"TFTP, allows unauthenticated and/or unencrypted\",\n111,\"udp\",\"Management\",\"RPC, unencrypted authentication allowed\",\n111,\"tcp\",\"Management\",\"RPC, unencrypted authentication allowed\",\n119,\"tcp\",\"Unsecure\",\"NNTP, unencrypted authentication\",\n123,\"udp\",\"3rd Party Attacks\",\"Network Time Protocol, reflection/amplification attacks\",\n135,\"tcp\",\"Management\",\"End Point Mapper, multiple remote management srvcs\",\n135,\"udp\",\"Management\",\"End Point Mapper, multiple remote management srvcs\",\n137,\"tcp\",\"Hacker Recon\",\"Netbios Name Service\",\n137,\"udp\",\"Hacker Recon\",\"Netbios Name Service\",\n138,\"tcp\",\"Hacker Recon\",\"Netbios Datagram Service\",\n138,\"udp\",\"Hacker Recon\",\"Netbios Datagram Service\",\n139,\"tcp\",\"Hacker Recon\",\"Netbios Session Service\",\n161,\"tcp\",\"Unsecure/3rd Party Attacks\",\"SNMP, unsecure / no authentication UDP Reflection attacks\",\n161,\"udp\",\"Unsecure/3rd Party Attacks\",\"SNMP, unsecure / no authentication UDP Reflection attacks\",\n162,\"tcp\",\"Unsecure\",\"SNMP Trap, unsecure / no authentication\",\n162,\"udp\",\"Unsecure\",\"SNMP Trap, unsecure / no authentication\",\n389,\"tcp\",\"Hacker Recon/3rd Party Attacks\",\"LDAP/CLDAP\",\n389,\"udp\",\"Hacker Recon/3rd Party Attacks\",\"LDAP/CLDAP\",\n443,\"udp\",\"3rd Party Attacks\",\"UDP Reflection / Amplification attacks\",\n445,\"tcp\",\"Unsecure\",\"SMB - well known attack vector\",\n512,\"tcp\",\"Management\",\"Rexec on Linux, remote commands w/o encrypt auth\",\n514,\"tcp\",\"Management\",\"Remote Shell, remote commands w/o auth or encrypt\",\n593,\"tcp\",\"Management\",\"HTTP RPC EPMAP, unencrypted remote procedure call\",\n593,\"udp\",\"Management\",\"HTTP RPC EPMAP, unencrypted remote procedure call\",\n636,\"tcp\",\"Hacker Recon\",\"Lightweight Directory Access Protocol\",\n873,\"tcp\",\"Management\",\"Rsync, unencrypted file transfer\",\n1433,\"tcp\",\"Data Access/Mgmt\",\"MS SQL Management & Data Access\",\n1434,\"udp\",\"Data Access/Mgmt\",\"MS SQL Monitor Port\",\n1900,\"udp\",\"Hacker Recon/3rd Party Attacks\",\"Simple Service Discovery Protocol, unencrypted\",\n2049,\"tcp\",\"Unsecure\",\"Network File System\",\n2049,\"udp\",\"Unsecure\",\"Network File System\",\n2301,\"tcp\",\"Hacker Recon\",\"Compaq Management Service, no recent incidents\",\n2381,\"tcp\",\"Management\",\"Compaq Management Service, no recent incidents\",\n3268,\"tcp\",\"Hacker Recon\",\"Microsoft Global Catalog LDAP\",\n3306,\"tcp\",\"Data Access/Mgmt\",\"MySQL Database Management Port\",\n3389,\"tcp\",\"Management/3rd Party Attacks\",\"RDP, Common brute force attack port\",\n3389,\"udp\",\"Management/3rd Party Attacks\",\"RDP, Common brute force attack port\",\n4333,\"tcp\",\"Data Access/Mgmt\",\"MSql\",\n5353,\"udp\",\"3rd Party Attacks\",\"mDNS\",\n5432,\"tcp\",\"Data Access/Mgmt\",\"PostgresSQL Database Management\",\n5800,\"tcp\",\"Management\",\"VNC Remote Frame Buffer over HTTP\",\n5900,\"tcp\",\"Management\",\"VNC Remote Frame Buffer over HTTP\",\n5985,\"tcp\",\"Management\",\"Windows Powershell\",\n5986,\"tcp\",\"Management\",\"Windows Powershell\",\n6379,\"tcp\",\"Data Access/Mgmt\",\"Redis\",\n7000,\"tcp\",\"Data Access/Mgmt\",\"Cassandra\",\n7001,\"tcp\",\"Data Access/Mgmt\",\"Cassandra\",\n7199,\"tcp\",\"Data Access/Mgmt\",\"Cassandra\",\n9042,\"tcp\",\"Data Access/Mgmt\",\"Cassandra\",\n9160,\"tcp\",\"Data Access/Mgmt\",\"Cassandra\",\n9200,\"tcp\",\"Data Access/Mgmt\",\"Elastic Search\",\n9300,\"tcp\",\"Data Access/Mgmt\",\"Elastic Search\",\n9987,\"udp\",\"3rd Party Attack\",\"DSM/SCM Target Interface\",\n11211,\"udp\",\"Unencrypted\",\"Memcached\",\n16379,\"tcp\",\"Data Access/Mgmt\",\"Redis\",\n26379,\"tcp\",\"Data Access/Mgmt\",\"Redis\",\n27017,\"tcp\",\"Data Access/Mgmt\",\"MongoDB\",\n];\nHighRiskPorts\n| join kind=inner (\n  CommonSecurityLog\n  | where DeviceVendor == \"Palo Alto Networks\" and Activity == \"TRAFFIC\" and DeviceAction != \"deny\"\n  | where SentBytes > 0 and ReceivedBytes > 0\n  //Remove private IP communation from DestinationIP\n  | extend result = ipv4_is_private(DestinationIP) \n  | where result == 0\n  | summarize\n      Count = count(),\n      StartTime = min(TimeGenerated),\n      EndTime = max(TimeGenerated)\n      by \n      DeviceName,\n      SourceIP,\n      DestinationIP,\n      DestinationPort,\n      Protocol\n) on $left.Port == $right.DestinationPort and $left.Protocol == $right.Protocol\n| project-away Protocol1, Port\n| order by DeviceName asc, SourceIP asc, DestinationIP asc, DestinationPort asc\n| extend timestamp = StartTime, IPCustomEntity = SourceIP\n", "attributes": {"description": "'Identifies network connections whose ports are frequent targets of attacks and should not cross network boundaries or reach untrusted public networks.\nConsider updating the firewall policies to block the connections.'\n", "techniques": NaN, "tactics": ["InitialAccess", "Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLConflictingMacAddress.yaml", "query_name": "PaloAlto - MAC address conflict", "query": "let threshold = 2;\nPaloAltoCDLEvent\n| where EventResourceId =~ 'TRAFFIC'\n| where isnotempty(DestinationMACAddress) and isnotempty(DstUsername)\n| summarize UserSet = make_set(DstUsername) by DestinationMACAddress\n| extend Users = array_length(UserSet)\n| where Users >= threshold\n| extend AccountCustomEntity = UserSet, IPCustomEntity = DestinationMACAddress\n", "attributes": {"description": "'Detects several users with the same MAC address.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLDroppingSessionWithSentTraffic.yaml", "query_name": "PaloAlto - Dropping or denying session with traffic", "query": "let threshold = 100;\nPaloAltoCDLEvent\n| where EventResourceId =~ 'TRAFFIC'\n| where EventResult has_any (\"deny\", \"drop\", \"reject\") \n| where tolong(DstBytes) > 0\n| where tolong(NetworkPackets) > 0\n| summarize count() by SrcIpAddr, DstUsername, bin(TimeGenerated, 10m)\n| where count_ > threshold\n| extend AccountCustomEntity = DstUsername, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects dropping or denying session with traffic.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLFileTypeWasChanged.yaml", "query_name": "PaloAlto - File type changed", "query": "PaloAltoCDLEvent\n| where EventResourceId =~ 'THREAT'\n| where EventResult =~ 'file'\n| where FileType != OldFileType\n| extend FileCustomEntity = SrcFileName, AccountCustomEntity = DstUsername\n", "attributes": {"description": "'Detects when file type changed.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLInboundRiskPorts.yaml", "query_name": "PaloAlto - Inbound connection to high risk ports", "query": "let HighRiskPorts = dynamic(['21', '22', '23', '25', '53', '443', '110', '135', '137', '138', '139', '1433', '1434']);\nPaloAltoCDLEvent\n| where EventResourceId =~ 'TRAFFIC'\n| where ipv4_is_private(SrcIpAddr) == false\n| where DstPortNumber in (HighRiskPorts)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects inbound connection to high risk ports.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLPossibleAttackWithoutResponse.yaml", "query_name": "PaloAlto - Possible attack without response", "query": "PaloAltoCDLEvent\n| where EventResourceId =~ 'THREAT'\n| where DvcAction !has \"block\" or DvcAction !has \"override\" or DvcAction !has \"deny\"\n| extend AccountCustomEntity = DstUsername, IPCustomEntity = SrcIpAddr, UrlCustomEntity = Url\n", "attributes": {"description": "'Detects possible attack without response.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLPossibleFlooding.yaml", "query_name": "PaloAlto - Possible flooding", "query": "PaloAltoCDLEvent\n| where EventResourceId =~ 'TRAFFIC'\n| where isnotempty(NetworkSessionId)\n| where DstBytes == 0 and tolong(NetworkPackets) > 0\n| extend AccountCustomEntity = DstUsername, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects possible flooding.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLPossiblePortScan.yaml", "query_name": "PaloAlto - Possible port scan", "query": "let threshold = 10;\nPaloAltoCDLEvent\n| where EventResourceId =~ 'TRAFFIC'\n| where isnotempty(DstPortNumber) and isnotempty(SrcIpAddr)\n| summarize PortSet = make_set(DstPortNumber) by SrcIpAddr, bin(TimeGenerated, 5m)\n| where array_length(PortSet) > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects possible port scan.'\n", "techniques": ["T1595"], "tactics": ["Reconnaissance"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLPrivilegesWasChanged.yaml", "query_name": "PaloAlto - User privileges was changed", "query": "let q_period = 14d;\nlet dt_lookBack = 24h;\nlet p = PaloAltoCDLEvent\n| where TimeGenerated between (ago(q_period)..ago(dt_lookBack))\n| summarize OldPrivileges = make_set(DestinationUserPrivileges) by DstUsername;\nPaloAltoCDLEvent\n| where TimeGenerated > ago(dt_lookBack)\n| summarize NewPrivileges = make_set(DestinationUserPrivileges) by DstUsername\n| join kind=innerunique (p) on DstUsername\n| where tostring(OldPrivileges) != tostring(NewPrivileges)\n| extend AccountCustomEntity = DstUsername\n", "attributes": {"description": "'Detects changing of user privileges.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLPutMethodInHighRiskFileType.yaml", "query_name": "PaloAlto - Put and post method request in high risk file type", "query": "let HighRiskFileType = dynamic(['.exe', '.msi', '.msp', '.jar', '.bat', '.cmd', '.js', '.jse', 'ws', '.ps1', '.ps2', '.msh']);\nPaloAltoCDLEvent\n| where EventResourceId =~ 'THREAT'\n| where EventResult =~ 'file'\n| where HttpRequestMethod has_any (\"POST\", \"PUT\")\n| where FileType in (HighRiskFileType)\n| extend FileCustomEntity = SrcFileName\n", "attributes": {"description": "'Detects put and post method request in high risk file type.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Analytic%20Rules/PaloAltoCDLUnexpectedCountries.yaml", "query_name": "PaloAlto - Forbidden countries", "query": "let bl_countries = dynamic(['CH', 'RU']);\nPaloAltoCDLEvent \n| where EventResourceId =~ 'TRAFFIC'\n| where MaliciousIPCountry  in (bl_countries)\n| summarize count() by DstUsername, SrcIpAddr \n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUsername\n", "attributes": {"description": "'Detects suspicious connections from forbidden countries.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLCriticalEventResult.yaml", "query_name": "PaloAlto - Critical event result", "query": "PaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where EventSeverity has 'critical'  or tostring(ThreatSeverity) has_any ('high', 'critical')\n| extend UrlCustomEntity = Url, AccountCustomEntity = DstUsername\n", "attributes": {"description": "'Query shows critical event result'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLFilePermissionWithPutRequest.yaml", "query_name": "PaloAlto - File permission with PUT or POST request", "query": "PaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where HttpRequestMethod contains \"PUT\" or HttpRequestMethod contains \"POST\"\n| where isnotempty(FilePermission)\n| summarize Permissions = count() by FilePermission, DstUsername\n| extend AccountCustomEntity = DstUsername\n", "attributes": {"description": "'Query shows file permission with PUT or POST request'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLIncompleteApplicationProtocol.yaml", "query_name": "PaloAlto - Incomplete application protocol", "query": "PaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where NetworkApplicationProtocol has_any (\"incomplete\", \"Not-Applicable\", \"insufficient\")\n| extend UrlCustomEntity = Url, IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query shows incomplete application protocol'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLIPsByPorts.yaml", "query_name": "PaloAlto - Destination ports by IPs", "query": "PaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(DstPortNumber)\n| summarize IP_Dst = make_set(tostring(DstNatIpAddr)) by DstPortNumber\n| extend IPCustomEntity = IP_Dst\n", "attributes": {"description": "'Query shows destination ports by IP address.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLMultiDenyResultbyUser.yaml", "query_name": "PaloAlto - Multiple Deny result by user", "query": "let threshold = 20;\nPaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where DvcAction has 'deny'\n| summarize DenyCount = count() by DvcAction, DstUsername\n| where DenyCount > threshold\n| extend AccountCustomEntity = DstUsername\n", "attributes": {"description": "'Query shows multiple Deny results by user'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLOutdatedAgentVersions.yaml", "query_name": "PaloAlto - Agent versions", "query": "let cur_ver = dynamic(['0.1']); //put latest agent version here\nPaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(PanOSAgentVersion)\n| where PanOSAgentVersion != cur_ver\n| project SrcIpAddr, PanOSAgentVersion\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query shows agents which are not updated to the latest version'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLOutdatedConfigVersions.yaml", "query_name": "PaloAlto - Outdated config vesions", "query": "let cur_ver = dynamic(['0.1']); //put latest config version here\nPaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(PanOSConfigVersion)\n| where PanOSConfigVersion != cur_ver\n| project SrcIpAddr, PanOSConfigVersion\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query shows outdated config vesions'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLRareApplicationLayerProtocol.yaml", "query_name": "PaloAlto - Rare application layer protocols", "query": "PaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(NetworkApplicationProtocol) \n| summarize ApplicationLayerProtocol = count() by NetworkApplicationProtocol\n| top 10 by ApplicationLayerProtocol asc\n| extend UrlCustomEntity = NetworkApplicationProtocol\n", "attributes": {"description": "'Query shows Rare application layer protocols'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLRareFileRequests.yaml", "query_name": "PaloAlto - Rare files observed", "query": "PaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(SrcFileName)\n| summarize RareFiles = count() by SrcFileName\n| top 20 by RareFiles asc\n| extend FileCustomEntity = SrcFileName\n", "attributes": {"description": "'Query shows rare files observed'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoCDL/Hunting%20Queries/PaloAltoCDLRarePortsbyUser.yaml", "query_name": "PaloAlto - Rare ports by user", "query": "PaloAltoCDLEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(DstPortNumber) \n| summarize RarePorts = count() by DstPortNumber, DstIpAddr, DstUsername\n| top 20 by RarePorts asc \n| extend IPCustomEntity = DstIpAddr, AccountCustomEntity = DstUsername\n", "attributes": {"description": "'Query shows rare ports by user.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudAclAccessKeysNotRotated.yaml", "query_name": "Palo Alto Prisma Cloud - Access keys are not rotated for 90 days", "query": "PaloAltoPrismaCloud\n| where Reason =~ 'NEW_ALERT'\n| where Status =~ 'open'\n| where AlertMessage has 'access keys are not rotated for 90 days'\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects access keys which were not rotated for 90 days.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudAclAllowAllOut.yaml", "query_name": "Palo Alto Prisma Cloud - Network ACL allow all outbound traffic", "query": "PaloAltoPrismaCloud\n| where Reason =~ 'NEW_ALERT'\n| where Status =~ 'open'\n| where AlertMessage has 'Network ACLs with Outbound rule to allow All Traffic'\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects network ACLs with outbound rule to allow all traffic.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudAclAllowInToAdminPort.yaml", "query_name": "Palo Alto Prisma Cloud - Network ACL allow ingress traffic to server administration ports", "query": "PaloAltoPrismaCloud\n| where Reason =~ 'NEW_ALERT'\n| where Status =~ 'open'\n| where AlertMessage has 'Network ACLs allow ingress traffic to server administration ports'\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects Network ACLs allow ingress traffic to server administration ports.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudAclInAllowAll.yaml", "query_name": "Palo Alto Prisma Cloud - Network ACLs Inbound rule to allow All Traffic", "query": "PaloAltoPrismaCloud\n| where Reason =~ 'NEW_ALERT'\n| where Status =~ 'open'\n| where AlertMessage has 'Network ACLs with Inbound rule to allow All Traffic'\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects Network ACLs with Inbound rule to allow All Traffic.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudAnomalousApiKeyActivity.yaml", "query_name": "Palo Alto Prisma Cloud - Anomalous access key usage", "query": "let threshold = 10;\nPaloAltoPrismaCloud\n| where ResourceType =~ 'Login'\n| where EventResult =~ 'Failed'\n| where EventMessage has 'access key'\n| summarize count() by UserName, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects anomalous API key usage activity.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudHighRiskScoreAlert.yaml", "query_name": "Palo Alto Prisma Cloud - High risk score alert", "query": "PaloAltoPrismaCloud\n| where Reason =~ 'NEW_ALERT'\n| where Status =~ 'open'\n| extend r_score = 0.85 * toint(RiskDetailRiskScoreMaxScore)\n| extend i_RiskDetailRiskScoreScore = toint(RiskDetailRiskScoreScore)\n| where i_RiskDetailRiskScoreScore > r_score\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects alerts with high risk score value.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudHighSeverityAlertOpenedForXDays.yaml", "query_name": "Palo Alto Prisma Cloud - High severity alert opened for several days", "query": "PaloAltoPrismaCloud\n| where Reason =~ 'NEW_ALERT'\n| where AlertSeverity =~ 'high'\n| where Status =~ 'open'\n| extend alert_time = now() - TimeGenerated\n| where alert_time > 1d\n| extend ['Opened Days'] = strcat('Alert opened for ', strcat(toint(alert_time / 1d), ' days'))\n| project AlertMessage, AlertSeverity, ['Opened Days'], ResourceId, UserName\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects high severity alert which is opened for several days.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudIamAdminGroup.yaml", "query_name": "Palo Alto Prisma Cloud - IAM Group with Administrator Access Permissions", "query": "PaloAltoPrismaCloud\n| where Reason =~ 'NEW_ALERT'\n| where Status =~ 'open'\n| where AlertMessage has 'IAM Groups with Administrator Access Permissions'\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects IAM Groups with Administrator Access Permissions.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudInactiveUser.yaml", "query_name": "Palo Alto Prisma Cloud - Inactive user", "query": "PaloAltoPrismaCloud\n| where Status =~ 'open'\n| where AlertMessage has 'Inactive users for more than 30 days'\n| extend AccountCustomEntity = ResourceId\n", "attributes": {"description": "'Detects users inactive for 30 days.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudMaxRiskScoreAlert.yaml", "query_name": "Palo Alto Prisma Cloud - Maximum risk score alert", "query": "PaloAltoPrismaCloud\n| where Reason =~ 'NEW_ALERT'\n| where Status =~ 'open'\n| where RiskDetailRiskScoreScore == RiskDetailRiskScoreMaxScore\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects alerts with maximum risk score value.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Analytic%20Rules/PaloAltoPrismaCloudMultipleFailedLoginsUser.yaml", "query_name": "Palo Alto Prisma Cloud - Multiple failed logins for user", "query": "let threshold = 10;\nPaloAltoPrismaCloud\n| where ResourceType =~ 'Login'\n| where EventResult =~ 'Failed'\n| where EventMessage !has 'access key'\n| summarize count() by UserName, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Detects multiple failed logins for the same user account.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Hunting%20Queries/PaloAltoPrismaCloudAccessKeysUsed.yaml", "query_name": "Palo Alto Prisma Cloud - Access keys used", "query": "PaloAltoPrismaCloud\n| where TimeGenerated > ago(30d)\n| where ResourceType =~ 'Login'\n| where EventMessage has 'access key'\n| summarize by UserName, SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for access keys used for programmatic access.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Hunting%20Queries/PaloAltoPrismaCloudFailedLoginsSources.yaml", "query_name": "Palo Alto Prisma Cloud - Top sources of failed logins", "query": "PaloAltoPrismaCloud\n| where TimeGenerated > ago(24h)\n| where ResourceType =~ 'Login'\n| where EventMessage !has 'access key'\n| summarize count() by SrcIpAddr\n| order by count_ desc\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for top source IP addresses of failed logins.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Hunting%20Queries/PaloAltoPrismaCloudFailedLoginsUsers.yaml", "query_name": "Palo Alto Prisma Cloud - Top users by failed logins", "query": "PaloAltoPrismaCloud\n| where TimeGenerated > ago(24h)\n| where ResourceType =~ 'Login'\n| where EventMessage !has 'access key'\n| summarize count() by UserName\n| order by count_ desc\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for users who have large number of failed logins.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Hunting%20Queries/PaloAltoPrismaCloudHighRiskScoreOpenedAlerts.yaml", "query_name": "Palo Alto Prisma Cloud - High risk score opened alerts", "query": "PaloAltoPrismaCloud\n| where TimeGenerated > ago(24h)\n| where Reason =~ 'NEW_ALERT'\n| where Status =~ 'open'\n| extend r_score = 0.85 * toint(RiskDetailRiskScoreMaxScore)\n| extend i_RiskDetailRiskScoreScore = toint(RiskDetailRiskScoreScore)\n| where i_RiskDetailRiskScoreScore > r_score\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for alerts with high risk score value.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Hunting%20Queries/PaloAltoPrismaCloudHighSeverityAlerts.yaml", "query_name": "Palo Alto Prisma Cloud - High severity alerts", "query": "PaloAltoPrismaCloud\n| where TimeGenerated > ago(24h)\n| where Reason =~ 'NEW_ALERT'\n| where AlertSeverity =~ 'high'\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for high severity alerts.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Hunting%20Queries/PaloAltoPrismaCloudNewUsers.yaml", "query_name": "Palo Alto Prisma Cloud - New users", "query": "let known_users = \nPaloAltoPrismaCloud\n| where TimeGenerated between (ago(30d) .. (1d))\n| where ResourceType =~ 'Login'\n| where EventMessage !has 'access key'\n| summarize makeset(UserName);\nPaloAltoPrismaCloud\n| where TimeGenerated > ago(24h)\n| where ResourceType =~ 'Login'\n| where EventMessage !has 'access key'\n| where UserName !in (known_users)\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches for new users.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Hunting%20Queries/PaloAltoPrismaCloudOpenedAlerts.yaml", "query_name": "Palo Alto Prisma Cloud - Opened alerts", "query": "PaloAltoPrismaCloud\n| where TimeGenerated > ago(24h)\n| where Reason =~ 'NEW_ALERT'\n| where Status =~ 'open'\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches opened alerts.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Hunting%20Queries/PaloAltoPrismaCloudTopResources.yaml", "query_name": "Palo Alto Prisma Cloud - Top recources with alerts", "query": "PaloAltoPrismaCloud\n| where TimeGenerated > ago(24h)\n| where Reason =~ 'NEW_ALERT'\n| summarize count() by ResourceName\n| order by count_ desc\n| extend AccountCustomEntity = ResourceName\n", "attributes": {"description": "'Query searches for resources which appeared in different alerts.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PaloAltoPrismaCloud/Hunting%20Queries/PaloAltoPrismaCloudUpdatedResources.yaml", "query_name": "Palo Alto Prisma Cloud - Updated resources", "query": "PaloAltoPrismaCloud\n| where TimeGenerated > ago(24h)\n| where Reason =~ 'RESOURCE_UPDATED'\n| extend AccountCustomEntity = UserName\n", "attributes": {"description": "'Query searches recently updated resources.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateAbnormalPasswordResetsAttempts.yaml", "query_name": "Ping Federate - Abnormal password reset attempts", "query": "let threshold = 10;\nPingFederateEvent\n| where EventType =~ 'PWD_RESET_REQUEST'\n| summarize count() by DstUserName, bin(TimeGenerated, 30m)\n| where count_ > threshold\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects abnormal password reset attempts for user in short period of time.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateAuthFromNewSource.yaml", "query_name": "Ping Federate - Authentication from new IP.", "query": "let known_src = \nPingFederateEvent\n| where TimeGenerated between (ago(14d) .. (1d))\n| where EventType in~ ('AUTHN_ATTEMPT', 'SSO')\n| where isnotempty(SrcIpAddr)\n| summarize makeset(SrcIpAddr);\nPingFederateEvent\n| where EventType in~ ('AUTHN_ATTEMPT', 'SSO')\n| where isnotempty(SrcIpAddr)\n| where SrcIpAddr !in (known_src)\n| extend AccountCustomEntity = DstUserName\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects authentication requests from new IP address.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateForbiddenCountry.yaml", "query_name": "Ping Federate - Forbidden country", "query": "let forbidden_geo = dynamic(['CH']);\nPingFederateEvent\n| where isnotempty(DstGeoCountry)\n| where tostring(DstGeoCountry) in~ (forbidden_geo)\n| extend AccountCustomEntity = DstUserName\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests from forbidden countries.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateMultiplePasswordResetsForUser.yaml", "query_name": "Ping Federate - Abnormal password resets for user", "query": "let threshold = 10;\nPingFederateEvent\n| where EventType =~ 'PWD_RESET'\n| summarize count() by DstUserName\n| where count_ > threshold\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects multiple password reset for user.'\n", "techniques": ["T1078", "T1098", "T1134"], "tactics": ["InitialAccess", "Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateNewUserSSO.yaml", "query_name": "Ping Federate - New user SSO success login", "query": "let known_usrs = \nPingFederateEvent\n| where TimeGenerated between (ago(14d) .. (1d))\n| where isnotempty(DstUserName)\n| summarize makeset(DstUserName);\nPingFederateEvent\n| where EventType =~ 'SSO'\n| where EventMessage has 'success'\n| where DstUserName !in (known_usrs)\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects new user SSO success login.'\n", "techniques": ["T1078", "T1136"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateOauthOld.yaml", "query_name": "Ping Federate - OAuth old version", "query": "PingFederateEvent\n| where isnotempty(DeviceCustomString3)\n| extend proto = extract(@'(OAuth)', 1, DeviceCustomString3)\n| extend ver = extract(@'(\\d+)', 1, DeviceCustomString3)\n| where proto =~ 'OAuth'\n| where ver !~ '20'\n| extend AccountCustomEntity = DstUserName\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests using not the latest version of OAuth protocol.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederatePasswordRstReqUnexpectedSource.yaml", "query_name": "Ping Federate - Password reset request from unexpected source IP address..", "query": "let known_src = \nPingFederateEvent\n| where TimeGenerated between (ago(14d) .. (1d))\n| where isnotempty(SrcIpAddr)\n| summarize makeset(SrcIpAddr);\nPingFederateEvent\n| where EventType =~ 'PWD_RESET_REQUEST'\n| where isnotempty(SrcIpAddr)\n| where SrcIpAddr !in (known_src)\n| extend AccountCustomEntity = DstUserName\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects password reset requests from unexpected source IP address.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateSamlOld.yaml", "query_name": "Ping Federate - SAML old version", "query": "PingFederateEvent\n| where isnotempty(DeviceCustomString3)\n| extend proto = extract(@'(SAML)', 1, DeviceCustomString3)\n| extend ver = extract(@'(\\d+)', 1, DeviceCustomString3)\n| where proto =~ 'SAML'\n| where ver !~ '20'\n| extend AccountCustomEntity = DstUserName\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests using not the latest version of SAML protocol.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateUnexpectedAuthUrl.yaml", "query_name": "Ping Federate - Unexpected authentication URL.", "query": "let known_domains = \nPingFederateEvent\n| where TimeGenerated between (ago(14d) .. (1d))\n| where isnotempty(DeviceCustomString1)\n| extend url_parsed = parse_url(DeviceCustomString1)\n| extend url_domain = extract(@'.*\\.(.*\\.[a-z]+)', 1, tostring(url_parsed.Host))\n| summarize makeset(url_domain);\nPingFederateEvent\n| where isnotempty(DeviceCustomString1)\n| extend url_parsed = parse_url(DeviceCustomString1)\n| extend url_domain = extract(@'.*\\.(.*\\.[a-z]+)', 1, tostring(url_parsed.Host))\n| where url_domain !in (known_domains)\n| extend AccountCustomEntity = DstUserName\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects unexpected authentication URL.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateUnexpectedUserCountry.yaml", "query_name": "Ping Federate - Unexpected country for user", "query": "let known_countries = \nPingFederateEvent\n| where TimeGenerated between (ago(1d) .. (1h))\n| where isnotempty(DstGeoCountry)\n| summarize makeset(DstGeoCountry);\nPingFederateEvent\n| where isnotempty(DstGeoCountry)\n| where DstGeoCountry !in (known_countries)\n| extend AccountCustomEntity = DstUserName\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects requests from different countries for user in shotr term.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Analytic%20Rules/PingFederateUnusualMailDomain.yaml", "query_name": "Ping Federate - Unusual mail domain.", "query": "let known_domains = \nPingFederateEvent\n| where TimeGenerated between (ago(14d) .. (1d))\n| extend email = extract(@'email=(.*?),.*', 1, AdditionalExtensions)\n| extend m_domain = extract(@'@(.*)', 1, email)\n| where isnotempty(m_domain)\n| summarize makeset(m_domain);\nPingFederateEvent\n| extend email = extract(@'email=(.*?),.*', 1, AdditionalExtensions)\n| extend m_domain = extract(@'@(.*)', 1, email)\n| where isnotempty(m_domain)\n| where m_domain !in (known_domains)\n| extend AccountCustomEntity = DstUserName\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects unusual mail domain in authentication requests.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederateAuthUrls.yaml", "query_name": "Ping Federate - Authentication URLs", "query": "PingFederateEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(DeviceCustomString1)\n| summarize count() by DeviceCustomString1\n| project URL = DeviceCustomString1, Total = count_\n| extend UrlCustomEntity = URL\n", "attributes": {"description": "'Query searches for authentication URLs used.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederateFailedAuthentications.yaml", "query_name": "Ping Federate - Failed Authentication", "query": "PingFederateEvent\n| where TimeGenerated > ago(24h)\n| extend EventResultDetails = extract(@'description=(.*?),.*', 1, AdditionalExtensions)\n| where isnotempty(EventResultDetails) or EventMessage contains \"fail\"\n| summarize count() by DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for failed authentication events'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederateNewUsers.yaml", "query_name": "Ping Federate - New users", "query": "let known_users = \nPingFederateEvent\n| where TimeGenerated between (ago(30d) .. (1d))\n| where isnotempty(DstUserName)\n| summarize makeset(DstUserName);\nPingFederateEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(DstUserName)\n| where DstUserName !in (known_users)\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for new users.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederatePasswordResetRequests.yaml", "query_name": "Ping Federate - Password reset requests", "query": "PingFederateEvent\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'PWD_RESET_REQUEST' or EventSubType =~ 'PWD_RESET_REQUEST'\n| extend AccountCustomEntity = DstUserName\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for password reset requests events.'\n", "techniques": ["T1078", "T1098"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederateRareSources.yaml", "query_name": "Ping Federate - Rare source IP addresses", "query": "PingFederateEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(SrcIpAddr)\n| summarize count() by SrcIpAddr\n| top 10 by count_ asc\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for rare source IP addresses of requests'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederateSAMLSubjects.yaml", "query_name": "Ping Federate - SAML subjects", "query": "PingFederateEvent\n| where TimeGenerated > ago(24h)\n| extend SamlSubject = extract(@'SAML_SUBJECT==(\\w+),.*', 1, AdditionalExtensions)\n| where isnotempty(SamlSubject)\n| summarize count() by SamlSubject, SrcIpAddr\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for SAML subjects used in requests'\n", "techniques": ["T1528"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederateTopSources.yaml", "query_name": "Ping Federate - Top source IP addresses", "query": "PingFederateEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(SrcIpAddr)\n| summarize count() by SrcIpAddr\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for source IP addresses with the most requests'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederateUnusualCountry.yaml", "query_name": "Ping Federate - Requests from unusual countries", "query": "let known_geo = \nPingFederateEvent\n| where TimeGenerated between (ago(30d) .. (1d))\n| where isnotempty(DstGeoCountry)\n| summarize makeset(DstGeoCountry);\nPingFederateEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(DstGeoCountry)\n| where DstGeoCountry !in (known_geo)\n| extend IpCustomEntity = SrcIpAddr\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for requests from unusual countries.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederateUnusualSources.yaml", "query_name": "Ping Federate - Authentication from unusual sources", "query": "let known_src = \nPingFederateEvent\n| where TimeGenerated between (ago(30d) .. (1d))\n| where isnotempty(SrcIpAddr)\n| summarize makeset(SrcIpAddr);\nPingFederateEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(SrcIpAddr)\n| where SrcIpAddr !in (known_src)\n| extend IpCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for unusual sources of authentication.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/PingFederate/Hunting%20Queries/PingFederateUsersPaswordsReset.yaml", "query_name": "Ping Federate - Users recently reseted password", "query": "PingFederateEvent\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'PWD_RESET' or EventSubType =~ 'PWD_RESET'\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for users who recently reseted their passwords.'\n", "techniques": ["T1078", "T1098"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ProofPointTap/Analytic%20Rules/MalwareAttachmentDelivered.yaml", "query_name": "Malware attachment delivered", "query": "\nProofPointTAPMessagesDelivered_CL\n| mv-expand todynamic(threatsInfoMap_s)\n| mv-expand todynamic(messageParts_s)\n| extend threatType = tostring(threatsInfoMap_s.threatType), classification = tostring(threatsInfoMap_s.classification)\n| extend filename = tostring(messageParts_s.filename)\n| where threatType =~ \"attachment\" and classification =~ \"malware\"\n| summarize filenames = make_set(filename), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by TimeGenerated, Sender = sender_s, SenderIPAddress = senderIP_s, Recipient = recipient_s, threatType, classification,  Subject = subject_s\n| extend timestamp = StartTime, AccountCustomEntity = Recipient, IPCustomEntity = SenderIPAddress\n", "attributes": {"description": "'This query identifies a message containing a malware attachment that was delivered.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ProofPointTap/Analytic%20Rules/MalwareLinkClicked.yaml", "query_name": "Malware Link Clicked", "query": "\nProofPointTAPClicksPermitted_CL\n| where classification_s =~ \"malware\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by TimeGenerated, Sender = sender_s, SenderIPAddress = senderIP_s, Recipient = recipient_s, TimeClicked = clickTime_t, URLClicked = url_s\n| extend timestamp = StartTime, AccountCustomEntity = Recipient, IPCustomEntity = SenderIPAddress, URLCustomEntity = URLClicked\n", "attributes": {"description": "'This query identifies a user clicking on an email link whose threat category is classified as a malware'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Pulse%20Connect%20Secure/Analytic%20Rules/PulseConnectSecureVPN-BruteForce.yaml", "query_name": "PulseConnectSecure - Potential Brute Force Attempts", "query": "\nlet threshold = 20;\nPulseConnectSecure\n| where Messages contains \"Login failed\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by User, Source_IP\n| where count_ > threshold\n| extend timestamp = StartTime, AccountCustomEntity = User, IPCustomEntity = Source_IP\n", "attributes": {"description": "'This query identifies evidence of potential brute force attack by looking at multiple failed attempts to log into the VPN server'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Pulse%20Connect%20Secure/Analytic%20Rules/PulseConnectSecureVPN-DistinctFailedUserLogin.yaml", "query_name": "PulseConnectSecure - Large Number of Distinct Failed User Logins", "query": "\nlet threshold = 100;\nPulseConnectSecure\n| where Messages startswith \"Login failed\"\n| summarize dcount(User) by Computer, bin(TimeGenerated, 15m)\n| where dcount_User > threshold\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer\n", "attributes": {"description": "'This query identifies evidence of failed login attempts from a large number of distinct users on a Pulse Connect Secure VPN server'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/QualysVM/Analytic%20Rules/HighNumberofVulnDetectedV2.yaml", "query_name": "High Number of Urgent Vulnerabilities Detected", "query": "\nlet threshold = 10;\nQualysHostDetectionV2_CL\n| where Severity_s == \"5\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by NetBios_s, IPAddress\n| where count_ >= threshold\n| extend timestamp = StartTime, HostCustomEntity = NetBios_s, IPCustomEntity = IPAddress\n", "attributes": {"description": "'This Creates an incident when a host has a high number of Urgent, severity 5, vulnerabilities detected.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/QualysVM/Analytic%20Rules/NewHighSeverityVulnDetectedAcrossMulitpleHostsV2.yaml", "query_name": "New High Severity Vulnerability Detected Across Multiple Hosts", "query": "\nlet threshold = 10;\nQualysHostDetectionV2_CL\n| extend Status = tostring(Status_s), Vulnerability = tostring(QID_s), Severity = tostring(Severity_s)\n| where Status =~ \"New\" and Severity == \"5\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), dcount(NetBios_s) by tostring(QID_s)\n| where dcount_NetBios_s >= threshold\n| extend timestamp = StartTime\n", "attributes": {"description": "'This creates an incident when a new high severity vulnerability is detected across multilple hosts'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Recorded%20Future/Analytic%20Rules/RecordedFutureDomainMalwareC2inDNSEvents.yaml", "query_name": "Detection of Malware C2 Domains in DNS Events", "query": "// Identifies a match in DnsEvent from the Recorded Future DOMAIN Malware C2 DNS Name \nlet dt_lookBack = 1h;\nlet ioc_lookBack = 1d;\n//Create a list of TLDs in our threat feed for later validation\nlet list_tlds = ThreatIntelligenceIndicator\n| where TimeGenerated > ago(ioc_lookBack)\n// Picking up only Recorded Future IOC's that are pertinent to the use case (Malware C2 Detection)\n| where Description == 'Recorded Future - DOMAIN - C2 DNS Name'\n| where isnotempty(DomainName)\n| extend parts = split(DomainName, '.')\n| extend tld = parts[(array_length(parts)-1)]\n| summarize count() by tostring(tld)\n| summarize make_list(tld);\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n// Picking up only Recorded Future IOC's that are pertinent to the use case (Malware C2 Detection)\n| where Description == 'Recorded Future - DOMAIN - C2 DNS Name'\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(DomainName)\n| join (\n  DnsEvents\n  | where TimeGenerated > ago(dt_lookBack)\n  //Extract Domain patterns from syslog message\n  | where isnotempty(Name)\n  | extend parts = split(Name, '.')\n  //Split out the TLD\n  | extend tld = parts[(array_length(parts)-1)]\n  //Validate parsed Domain by checking if the TLD is in the list of TLDs in our threat feed\n  | where tld in~ (list_tlds)\n  | extend DNS_TimeGenerated = TimeGenerated\n  ) \non $left.DomainName==$right.Name\n| where DNS_TimeGenerated >= TimeGenerated and DNS_TimeGenerated < ExpirationDateTime\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, DomainName, Description, ConfidenceScore, AdditionalInformation, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, DNS_TimeGenerated, Computer, ClientIP, Name, QueryType\n| extend timestamp = DNS_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = ClientIP, DomainCustomEntity = DomainName\n", "attributes": {"description": "'Identifies a match in DNSEvents from Recorded Future C2 DNS Name Domains Risklist.'\n", "techniques": null, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Recorded%20Future/Analytic%20Rules/RecordedFutureDomainMalwareC2inSyslogEvents.yaml", "query_name": "Detection of Malware C2 Domains in Syslog Events", "query": "// Identifies a match in Syslog from the Recorded Future DOMAIN Malware C2 DNS Name \nlet dt_lookBack = 1h;\nlet ioc_lookBack = 1d;\n//Create a list of TLDs in our threat feed for later validation\nlet list_tlds = ThreatIntelligenceIndicator\n| where TimeGenerated > ago(ioc_lookBack)\n// Picking up only Recorded Future IOC's that are pertinent to the use case (Malware C2 Detection)\n| where Description == 'Recorded Future - DOMAIN - C2 DNS Name'\n| where isnotempty(DomainName)\n| extend parts = split(DomainName, '.')\n| extend tld = parts[(array_length(parts)-1)]\n| summarize count() by tostring(tld)\n| summarize make_list(tld);\nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n// Picking up only Recorded Future IOC's that are pertinent to the use case (Malware C2 Detection)\n| where Description == 'Recorded Future - DOMAIN - C2 DNS Name'\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(DomainName)\n| join (\n  Syslog\n  | where TimeGenerated > ago(dt_lookBack)\n  //Extract domain patterns from syslog message\n  | extend domain = extract(\"(([a-z0-9]+(-[a-z0-9]+)*\\\\.)+[a-z]{2,})\",1, tolower(SyslogMessage))\n  | where isnotempty(domain)\n  | extend parts = split(domain, '.')\n  //Split out the TLD\n  | extend tld = parts[(array_length(parts)-1)]\n  //Validate parsed domain by checking if the TLD is in the list of TLDs in our threat feed\n  | where tld in~ (list_tlds)\n  | extend Syslog_TimeGenerated = TimeGenerated\n  ) \non $left.DomainName==$right.domain\n| where Syslog_TimeGenerated >= TimeGenerated and Syslog_TimeGenerated < ExpirationDateTime\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Syslog_TimeGenerated, SyslogMessage, Computer, ProcessName, domain, HostIP, Url\n| extend timestamp = Syslog_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = HostIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in Syslog from Recorded Future C2 DNS Name Domains Risklist.'\n", "techniques": null, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Recorded%20Future/Analytic%20Rules/RecordedFutureHashObservedInUndergroundinCommonSecurityLog.yaml", "query_name": "Detection of Specific Hashes in CommonSecurityLog", "query": "// Identifies a match in CommonSecurityLog from the Recorded Future Hashes Observed in Underground Virus Testing Sites\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 1d;\nlet fileHashIndicators = ThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n// Picking up only Recorded Future IOC's that have been observed in undersground testing sites\n| where Description == \"Recorded Future - HASH - Observed in Underground Virus Testing Sites\"\n| where Active == true\n| where isnotempty(FileHashValue);\n// Handle matches against both lower case and uppercase versions of the hash:\n(fileHashIndicators | extend  FileHashValue = tolower(FileHashValue)\n| union (fileHashIndicators | extend FileHashValue = toupper(FileHashValue)))\n| join (\n  CommonSecurityLog | where TimeGenerated >= ago(dt_lookBack)\n  | where isnotempty(FileHash)\n  | extend CommonSecurityLog_TimeGenerated = TimeGenerated\n  )\non $left.FileHashValue == $right.FileHash\n| where CommonSecurityLog_TimeGenerated >= TimeGenerated and CommonSecurityLog_TimeGenerated < ExpirationDateTime\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore,\nCommonSecurityLog_TimeGenerated, SourceIP, SourcePort, DestinationIP, DestinationPort, SourceUserID, SourceUserName, DeviceName, DeviceAction, RequestURL, DestinationUserName, DestinationUserID, ApplicationProtocol, Activity, FileHash, AdditionalInformation\n| extend timestamp = CommonSecurityLog_TimeGenerated, IPCustomEntity = SourceIP, HostCustomEntity = DeviceName, AccountCustomEntity = SourceUserName, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in CommonSecurityLog from Recorded Future Hash Observed in Underground Virus Testing Sites RiskList.'\n", "techniques": ["T1587.001"], "tactics": ["PreAttack"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Recorded%20Future/Analytic%20Rules/RecordedFutureIPMalwareC2inAzureActivityEvents.yaml", "query_name": "Detection of Malware C2 IPs in Azure Act. Events", "query": "// Identifies a match in AzureActivity from the Recorded Future C2 Malware Detection IPs (Actively Communicating C&C Server RiskList)\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 1d;\nThreatIntelligenceIndicator\n// Picking up only Recorded Future IOC's that are pertinent to the use case (Malware C2 Detection)\n| where Description == \"Recorded Future - IP - Actively Communicating C&C Server\"\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n| extend TI_ipEntity = NetworkIP\n| join (\n  AzureActivity | where TimeGenerated >= ago(dt_lookBack)\n  // renaming time column so it is clear the log this came from\n  | extend AzureActivity_TimeGenerated = TimeGenerated\n  )\non $left.TI_ipEntity == $right.CallerIpAddress\n| where AzureActivity_TimeGenerated >= TimeGenerated and AzureActivity_TimeGenerated < ExpirationDateTime\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, AzureActivity_TimeGenerated, TI_ipEntity, CallerIpAddress, Caller, OperationNameValue, ActivityStatusValue, CategoryValue, ResourceId, NetworkIP, Description, AdditionalInformation\n| extend timestamp = AzureActivity_TimeGenerated, IPCustomEntity = CallerIpAddress, AccountCustomEntity = Caller, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in Azure Activity Events from Recorded Future Actively Communicating C&C Server Risklist.'\n", "techniques": null, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Recorded%20Future/Analytic%20Rules/RecordedFutureIPMalwareC2inDNSEvents.yaml", "query_name": "Detection of Malware C2 IPs in DNS Events", "query": "// Identifies a match in DnsEvent from the Recorded Future C2 Malware Detection IPs (Actively Communicating C&C Server RiskList)\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 1d;\nThreatIntelligenceIndicator\n// Picking up only Recorded Future IOC's that are pertinent to the use case (Malware C2 Detection)\n| where Description == \"Recorded Future - IP - Actively Communicating C&C Server\"\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n| extend TI_ipEntity = NetworkIP\n| join (\n  DnsEvents | where TimeGenerated >= ago(dt_lookBack)\n  | where SubType =~ \"LookupQuery\" and isnotempty(IPAddresses)\n  | extend SingleIP = split(IPAddresses, \",\")\n  | mvexpand SingleIP\n  | extend SingleIP = tostring(SingleIP)\n  // renaming time column so it is clear the log this came from\n  | extend DNS_TimeGenerated = TimeGenerated\n  )\non $left.TI_ipEntity == $right.SingleIP\n| where DNS_TimeGenerated >= TimeGenerated and DNS_TimeGenerated < ExpirationDateTime\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, ActivityGroupNames, IndicatorId, ThreatType, Url, ExpirationDateTime, ConfidenceScore, DNS_TimeGenerated, TI_ipEntity, Computer, EventId, SubType, ClientIP, Name, IPAddresses, NetworkIP, Description, AdditionalInformation\n| extend timestamp = DNS_TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in DnsEvents from Recorded Future Actively Communicating C&C Server Risklist.'\n", "techniques": null, "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Recorded%20Future/Analytic%20Rules/RecordedFutureUrlReportedbyInsiktGroupinSyslogEvents.yaml", "query_name": "Detection of Malicious URLs in Syslog Events", "query": "// Identifies a match in Syslog from the Recorded Future URLs Recently Reported by Insikt Group\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 1d;\nThreatIntelligenceIndicator\n// Picking up only Recorded Future IOC's that have been recently reported as malicious by Insikt Group\n| where Description == 'Recorded Future - URL - Recently Reported by Insikt Group'\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(Url)\n| join (\n  Syslog\n  | where TimeGenerated >= ago(dt_lookBack)\n  // Extract URL from the Syslog message but only take messages that include URLs\n  | extend Url = extract(\"(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+)\", 1,SyslogMessage)\n  | where isnotempty(Url)\n  | extend Syslog_TimeGenerated = TimeGenerated\n  ) \non Url\n| where Syslog_TimeGenerated >= TimeGenerated and Syslog_TimeGenerated < ExpirationDateTime\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Syslog_TimeGenerated, SyslogMessage, Computer, ProcessName, Url, AdditionalInformation, HostIP\n| extend timestamp = Syslog_TimeGenerated, HostCustomEntity = Computer, IPCustomEntity = HostIP, URLCustomEntity = Url\n", "attributes": {"description": "'Identifies a match in Syslog from Recorded Future URLs Recently Reported as malicious by Insikt Group.'\n", "techniques": null, "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Red%20Canary/Analytic%20Rules/RedCanaryThreatDetection.yaml", "query_name": "Red Canary Threat Detection", "query": "RedCanaryDetections_CL\n| extend    process_ioc_array = todynamic(process_iocs_s),\n            child_process_ioc_array = todynamic(child_process_iocs_s),\n            cross_process_ioc_array = todynamic(cross_process_iocs_s),\n            file_mod_ioc_array = todynamic(file_modification_iocs_s),\n            identities_array = todynamic(identities_s)\n| extend    entities = array_concat(process_ioc_array, child_process_ioc_array, cross_process_ioc_array, file_mod_ioc_array, identities_array)\n| mv-expand entities\n| evaluate  bag_unpack(entities)\n| extend    file_hash_array = todynamic(column_ifexists('file_hashes', '[]'))\n| mv-expand file_hash_array\n| evaluate  bag_unpack(file_hash_array, 'file_hash_')\n| project   detection_id_s = column_ifexists('detection_id_s', ''),\n            detection_url_s = column_ifexists('detection_url_s', ''),\n            detection_headline_s = column_ifexists('detection_headline_s', ''),\n            detection_details_s = column_ifexists('detection_details_s', ''),\n            detection_severity_s = column_ifexists('detection_severity_s', ''),\n            host_name_s = column_ifexists('host_name_s', ''),\n            host_full_name_s = column_ifexists('host_full_name_s', ''),\n            host_os_family_s = column_ifexists('host_os_family_s', ''),\n            host_os_version_s = column_ifexists('host_os_version_s', ''),\n            tactics_s = column_ifexists('tactics_s', ''),\n            process_id = column_ifexists('process_id', ''),\n            process_command_line = column_ifexists('process_command_line', ''),\n            process_creation_time_utc = column_ifexists('process_creation_time_utc', ''),\n            file_hash_algorithm = column_ifexists('file_hash_algorithm', ''),\n            file_hash_value = column_ifexists('file_hash_value', ''),\n            file_directory = column_ifexists('file_directory', ''),\n            file_name = column_ifexists('file_name', ''),\n            user_name = column_ifexists('user_name', ''),\n            user_uid = column_ifexists('user_uid', '')\n", "attributes": {"description": "Triggers Incidents using detection data assembled by Red Canary.", "techniques": [], "tactics": ["Collection", "CommandAndControl", "CredentialAccess", "DefenseEvasion", "Discovery", "Execution", "Exfiltration", "Impact", "InitialAccess", "LateralMovement", "Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SailPointIdentityNow/Analytic%20Rules/SailPointIdentityNowAlertsForTriggers.yaml", "query_name": "SailPointIdentityNowAlertForTriggers", "query": "declare query_parameters(lbperiod:timespan = 14d, triggerId:string = \"idn:aggregation-accounts-collected\");\n  SailPointIDN_Triggers_CL\n  | where TimeGenerated > ago(lbperiod)\n  | where Metadata_triggerId_s == triggerId\n", "attributes": {"description": "'Create alerts for SailPoint IdentityNow Event Trigger Service.'\n", "techniques": ["T1133", "T1005"], "tactics": ["InitialAccess", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SailPointIdentityNow/Analytic%20Rules/SailPointIdentityNowEventType.yaml", "query_name": "SailPointIdentityNowEventType", "query": "declare query_parameters(lbperiod:timespan = 14d, type:string = \"ACCESS_ITEM\");\nSailPointIDN_Events_CL\n| where TimeGenerated > ago(lbperiod)\n| where type_s == type\n| where status_s == \"FAILED\"\n| sort by created_t\n", "attributes": {"description": "'Created to detect failed events of particular type from SailPointIDN_Events.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SailPointIdentityNow/Analytic%20Rules/SailPointIdentityNowEventTypeTechnicalName.yaml", "query_name": "SailPointIdentityNowEventTypeTechnicalName", "query": "declare query_parameters(lbperiod:timespan = 14d, technicalName:string = \"ENTITLEMENT_ADD_FAILED\", type:string = 'ACCESS_ITEM');\n  SailPointIDN_Events_CL\n  | where TimeGenerated > ago(lbperiod)\n  | where type_s == type\n  | where technicalName_s == technicalName\n  | where status_s == \"FAILED\"\n  | sort by created_t\n", "attributes": {"description": "'Created to detect new threat events from the data in SailPointIDN_Events.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SailPointIdentityNow/Analytic%20Rules/SailPointIdentityNowFailedEvents.yaml", "query_name": "SailPointIdentityNowFailedEvents", "query": "declare query_parameters(lbperiod:timespan = 14d);\n  SailPointIDN_Events_CL\n  | where TimeGenerated > ago(lbperiod) and status_s == \"FAILED\"\n  | project technicalName_s, operation_s, type_s\n", "attributes": {"description": "'Detects all events with status failed.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SailPointIdentityNow/Analytic%20Rules/SailPointIdentityNowFailedEventsBasedOnTime.yaml", "query_name": "SailPointIdentityNowFailedEventsBasedOnTime", "query": "declare query_parameters(lbperiod:timespan = 14d, createdTime:string = \"2020-08-19T20:34:38.676Z\");\n  SailPointIDN_Events_CL\n  | where TimeGenerated > ago(lbperiod)\n  | where status_s == \"FAILED\"\n  | where created_t >= created_t\n  | sort by created_t\n", "attributes": {"description": "'Detects failed events based on created time.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SailPointIdentityNow/Analytic%20Rules/SailPointIdentityNowUserWithFailedEvents.yaml", "query_name": "SailPointIdentityNowUserWithFailedEvent", "query": "declare query_parameters(lbperiod:timespan = 14d, type:string = \"ACCESS_ITEM\", actorName:string = \"test.tester\", targetName:string = \"test.tester\");\n  SailPointIDN_Events_CL\n  | where TimeGenerated > ago(lbperiod)\n  | where type_s == type\n  | where status_s == \"FAILED\"\n  | where actor_name_s == actorName\n  | where target_name_s == targetName\n  | sort by created_t\n", "attributes": {"description": "'Detects any failed event for a particular user.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SecurityBridge%20App/Analytical%20Rules/CriticalEventTriggered.yaml", "query_name": "SecurityBridge: A critical event occured", "query": "\nSecurityBridgeLogs\n| where Severity contains \"Critical\"\n", "attributes": {"description": "'This rule alerts if there is any critical event occured in the SAP system'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SecurityThreatEssentialSolution/Analytic%20Rules/Threat_Essentials_Mail_redirect_via_ExO_transport_rule.yaml", "query_name": "Threat Essentials - Mail redirect via ExO transport rule", "query": "\nOfficeActivity\n| where OfficeWorkload == \"Exchange\"\n| where Operation in~ (\"New-TransportRule\", \"Set-TransportRule\")\n| extend p = parse_json(Parameters)\n| extend RuleName = case(\n  Operation =~ \"Set-TransportRule\", tostring(OfficeObjectId),\n  Operation =~ \"New-TransportRule\", tostring(p[1].Value),\n  \"Unknown\"\n  ) \n| mvexpand p\n| where (p.Name =~ \"BlindCopyTo\" or p.Name =~ \"RedirectMessageTo\") and isnotempty(p.Value)\n| extend RedirectTo = p.Value\n| extend ClientIPOnly = case( \n  ClientIP has \".\" and ClientIP has \":\", tostring(split(ClientIP,\":\")[0]), \n  ClientIP has \".\" and ClientIP has \"-\", tostring(split(ClientIP,\"-\")[0]), \n  ClientIP has \"[\", tostring(trim_start(@'[[]',tostring(split(ClientIP,\"]\")[0]))),\n  ClientIP\n  )  \n| extend Port = case(\n  ClientIP has \".\" and ClientIP has \":\", (split(ClientIP,\":\")[1]),\n  ClientIP has \".\" and ClientIP has \"-\", (split(ClientIP,\"-\")[1]),\n  ClientIP has \"[\" and ClientIP has \":\", tostring(split(ClientIP,\"]:\")[1]),\n  ClientIP has \"[\" and ClientIP has \"-\", tostring(split(ClientIP,\"]-\")[1]),\n  ClientIP\n  )\n| extend ClientIP = ClientIPOnly\n| project TimeGenerated, RedirectTo, ClientIP, Port, UserId, Operation, RuleName\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP \n", "attributes": {"description": "'Identifies when Exchange Online transport rule configured to forward emails.\nThis could be an adversary mailbox configured to collect mail from multiple user accounts.'\n", "techniques": ["T1114", "T1020"], "tactics": ["Collection", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SecurityThreatEssentialSolution/Analytic%20Rules/Threat_Essentials_MultipleAdmin_membership_removals_from_NewAdmin.yaml", "query_name": "Threat Essentials - Multiple admin membership removals from newly created admin.", "query": "let lookback = 7d; \nlet timeframe = 1h; \nlet GlobalAdminsRemoved = AuditLogs \n| where TimeGenerated > ago(timeframe) \n| where Category =~ \"RoleManagement\" \n| where AADOperationType in (\"Unassign\", \"RemoveEligibleRole\") \n| where ActivityDisplayName has_any (\"Remove member from role\", \"Remove eligible member from role\") \n| mv-expand TargetResources \n| mv-expand TargetResources.modifiedProperties \n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName) \n| where displayName_ =~ \"Role.DisplayName\" \n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.oldValue))) \n| where RoleName == \"Global Administrator\" // Add other Privileged role if applicable \n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName) \n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) \n| where Initiator != \"MS-PIM\"  // Filtering PIM events \n| extend Target = tostring(TargetResources.userPrincipalName) \n| summarize RemovedGlobalAdminTime = max(TimeGenerated), TargetAdmins = make_set(Target) by OperationName,  RoleName, Initiator, Result; \nlet GlobalAdminsAdded = AuditLogs \n| where TimeGenerated > ago(lookback) \n| where Category =~ \"RoleManagement\" \n| where AADOperationType in (\"Assign\", \"AssignEligibleRole\") \n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\") and Result == \"success\" \n| mv-expand TargetResources \n| mv-expand TargetResources.modifiedProperties \n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName) \n| where displayName_ =~ \"Role.DisplayName\" \n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue))) \n| where RoleName == \"Global Administrator\" // Add other Privileged role if applicable \n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName) \n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) \n| where Initiator != \"MS-PIM\"  // Filtering PIM events \n| extend Target = tostring(TargetResources.userPrincipalName) \n| summarize AddedGlobalAdminTime = max(TimeGenerated) by OperationName,  RoleName, Target, Initiator, Result \n| extend AccountCustomEntity = Target; \nGlobalAdminsAdded \n| join kind= inner GlobalAdminsRemoved on $left.Target == $right.Initiator \n| where AddedGlobalAdminTime < RemovedGlobalAdminTime \n| extend NoofAdminsRemoved = array_length(TargetAdmins) \n| where NoofAdminsRemoved > 1\n| project AddedGlobalAdminTime, Initiator, Target, AccountCustomEntity, RemovedGlobalAdminTime, TargetAdmins, NoofAdminsRemoved\n", "attributes": {"description": "'This query detects when newly created Global admin removes multiple existing global admins which can be an attempt by adversaries to lock down organization and retain sole access. \n Investigate reasoning and intention of multiple membership removal by new Global admins and take necessary actions accordingly.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SecurityThreatEssentialSolution/Analytic%20Rules/Threat_Essentials_NRT_UseraddedtoPrivilgedGroups.yaml", "query_name": "Threat Essentials - NRT User added to Azure Active Directory Privileged Groups", "query": "let OperationList = dynamic([\"Add member to role\",\"Add member to role in PIM requested (permanent)\"]);\nlet PrivilegedGroups = dynamic([\"UserAccountAdmins\",\"PrivilegedRoleAdmins\",\"TenantAdmins\"]);\nAuditLogs\n//| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"RoleManagement\"\n| where OperationName in~ (OperationList)\n| mv-expand TargetResources\n| extend modProps = parse_json(TargetResources).modifiedProperties\n| mv-expand bagexpansion=array modProps\n| evaluate bag_unpack(modProps)\n| extend displayName = column_ifexists(\"displayName\", \"NotAvailable\"), newValue = column_ifexists(\"newValue\", \"NotAvailable\")\n| where displayName =~ \"Role.WellKnownObjectName\"\n| extend DisplayName = displayName, GroupName = replace('\"','',newValue)\n| extend initByApp = parse_json(InitiatedBy).app, initByUser = parse_json(InitiatedBy).user\n| extend AppId = initByApp.appId,\nInitiatedByDisplayName = case(isnotempty(initByApp.displayName), initByApp.displayName, isnotempty(initByUser.displayName), initByUser.displayName, \"not available\"),\nServicePrincipalId = tostring(initByApp.servicePrincipalId),\nServicePrincipalName = tostring(initByApp.servicePrincipalName),\nUserId = initByUser.id,\nUserIPAddress = initByUser.ipAddress,\nUserRoles = initByUser.roles,\nUserPrincipalName = tostring(initByUser.userPrincipalName),\nTargetUserPrincipalName = tostring(TargetResources.userPrincipalName)\n| where GroupName in~ (PrivilegedGroups)\n// If you don't want to alert for operations from PIM, remove below filtering for MS-PIM.\n//| where InitiatedByDisplayName != \"MS-PIM\"\n| project TimeGenerated, AADOperationType, Category, OperationName, AADTenantId, AppId, InitiatedByDisplayName, ServicePrincipalId, ServicePrincipalName, DisplayName, GroupName, UserId, UserIPAddress, UserRoles, UserPrincipalName, TargetUserPrincipalName\n| extend AccountCustomEntity = case(isnotempty(ServicePrincipalName), ServicePrincipalName, isnotempty(ServicePrincipalId), ServicePrincipalId, isnotempty(UserPrincipalName), UserPrincipalName, \"not available\")\n", "attributes": {"description": "'This will alert when a user is added to any of the Privileged Groups.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.\nFor Administrator role permissions in Azure Active Directory please see https://docs.microsoft.com/azure/active-directory/users-groups-roles/directory-assign-admin-roles'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SecurityThreatEssentialSolution/Analytic%20Rules/Threat_Essentials_TimeSeriesAnomaly-MultiVendor_DataExfiltration.yaml", "query_name": "Threat Essentials - Time series anomaly for data size transferred to public internet", "query": "\nlet starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet scorethreshold = 5;\nlet bytessentperhourthreshold = 10;\nlet PrivateIPregex = @'^127\\.|^10\\.|^172\\.1[6-9]\\.|^172\\.2[0-9]\\.|^172\\.3[0-1]\\.|^192\\.168\\.';\nlet TimeSeriesData = (union isfuzzy=true\n(\nVMConnection\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where isnotempty(DestinationIp) and isnotempty(SourceIp)\n| extend DestinationIpType = iff(DestinationIp matches regex PrivateIPregex,\"private\" ,\"public\" )\n| where DestinationIpType == \"public\" | extend DeviceVendor = \"VMConnection\"\n| project TimeGenerated, BytesSent, DeviceVendor\n| make-series TotalBytesSent=sum(BytesSent) on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by DeviceVendor\n),\n(\nCommonSecurityLog\n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where isnotempty(DestinationIP) and isnotempty(SourceIP)\n| extend DestinationIpType = iff(DestinationIP matches regex PrivateIPregex,\"private\" ,\"public\" )\n| where DestinationIpType == \"public\"\n| project TimeGenerated, SentBytes, DeviceVendor\n| make-series TotalBytesSent=sum(SentBytes) on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by DeviceVendor\n)\n);\n//Filter anomolies against TimeSeriesData\nlet TimeSeriesAlerts = materialize(TimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(TotalBytesSent, scorethreshold, -1, 'linefit')\n| mv-expand TotalBytesSent to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double),score to typeof(double), baseline to typeof(long)\n| where anomalies > 0 | extend AnomalyHour = TimeGenerated\n| extend TotalBytesSentinMBperHour = round(((TotalBytesSent / 1024)/1024),2), baselinebytessentperHour = round(((baseline / 1024)/1024),2), score = round(score,2)\n| project DeviceVendor, AnomalyHour, TimeGenerated, TotalBytesSentinMBperHour, baselinebytessentperHour, anomalies, score);\nlet AnomalyHours = materialize(TimeSeriesAlerts  | where TimeGenerated > ago(2d) | project TimeGenerated);\n//Union of all BaseLogs aggregated per hour\nlet BaseLogs = (union isfuzzy=true\n(\nCommonSecurityLog\n| where isnotempty(DestinationIP) and isnotempty(SourceIP)\n| where TimeGenerated > ago(2d)\n| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour\n| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours\n| extend DestinationIpType = iff(DestinationIP matches regex PrivateIPregex,\"private\" ,\"public\" )\n| where DestinationIpType == \"public\"\n| extend SentBytesinMB = ((SentBytes / 1024)/1024), ReceivedBytesinMB = ((ReceivedBytes / 1024)/1024)\n| summarize HourlyCount = count(), TimeGeneratedMax=arg_max(TimeGenerated, *), DestinationIPList=make_set(DestinationIP, 100), DestinationPortList = make_set(DestinationPort,100), TotalSentBytesinMB = sum(SentBytesinMB), TotalReceivedBytesinMB = sum(ReceivedBytesinMB) by SourceIP, DeviceVendor, TimeGeneratedHour=bin(TimeGenerated,1h)\n| where TotalSentBytesinMB > bytessentperhourthreshold\n| sort by TimeGeneratedHour asc, TotalSentBytesinMB desc\n| extend Rank=row_number(1, prev(TimeGeneratedHour) != TimeGeneratedHour) // Ranking the dataset per Hourly Partition\n| where Rank < 10  // Selecting Top 10 records with Highest BytesSent in each Hour\n| project DeviceVendor, TimeGeneratedHour, TimeGeneratedMax, SourceIP, DestinationIPList, DestinationPortList, TotalSentBytesinMB, TotalReceivedBytesinMB, Rank\n),\n(\nVMConnection\n| where isnotempty(DestinationIp) and isnotempty(SourceIp)\n| where TimeGenerated > ago(2d)\n| extend DateHour = bin(TimeGenerated, 1h) // create a new column and round to hour\n| where DateHour in ((AnomalyHours)) //filter the dataset to only selected anomaly hours\n| extend SourceIP = SourceIp, DestinationIP = DestinationIp\n| extend DestinationIpType = iff(DestinationIp matches regex PrivateIPregex,\"private\" ,\"public\" )\n| where DestinationIpType == \"public\" | extend DeviceVendor = \"VMConnection\"\n| extend SentBytesinMB = ((BytesSent / 1024)/1024), ReceivedBytesinMB = ((BytesReceived / 1024)/1024)\n| summarize HourlyCount = count(),TimeGeneratedMax=arg_max(TimeGenerated, *), DestinationIPList=make_set(DestinationIP, 100), DestinationPortList = make_set(DestinationPort, 100), TotalSentBytesinMB = sum(SentBytesinMB),TotalReceivedBytesinMB = sum(ReceivedBytesinMB) by SourceIP, DeviceVendor, TimeGeneratedHour=bin(TimeGenerated,1h)\n| where TotalSentBytesinMB > bytessentperhourthreshold\n| sort by TimeGeneratedHour asc, TotalSentBytesinMB desc\n| extend Rank=row_number(1, prev(TimeGeneratedHour) != TimeGeneratedHour) // Ranking the dataset per Hourly Partition\n| where Rank < 10  // Selecting Top 10 records with Highest BytesSent in each Hour\n| project DeviceVendor, TimeGeneratedHour, TimeGeneratedMax, SourceIP, DestinationIPList, DestinationPortList, TotalSentBytesinMB, TotalReceivedBytesinMB, Rank\n)\n);\n// Join against base logs to retrive records associated with the hour of anomoly\nTimeSeriesAlerts\n| where TimeGenerated > ago(2d)\n| join (\n    BaseLogs | extend AnomalyHour = TimeGeneratedHour\n) on DeviceVendor, AnomalyHour | sort by score desc\n| project DeviceVendor, AnomalyHour,TimeGeneratedMax, SourceIP, DestinationIPList, DestinationPortList, TotalSentBytesinMB, TotalReceivedBytesinMB, TotalBytesSentinMBperHour, baselinebytessentperHour, score, anomalies\n| summarize EventCount = count(), StartTimeUtc= min(TimeGeneratedMax), EndTimeUtc= max(TimeGeneratedMax), SourceIPMax= arg_max(SourceIP,*), TotalBytesSentinMB = sum(TotalSentBytesinMB), TotalBytesReceivedinMB = sum(TotalReceivedBytesinMB), SourceIPList = make_set(SourceIP, 100), DestinationIPList = make_set(DestinationIPList, 100) by AnomalyHour,TotalBytesSentinMBperHour, baselinebytessentperHour, score, anomalies\n| project DeviceVendor, AnomalyHour, StartTimeUtc, EndTimeUtc, SourceIPMax, SourceIPList, DestinationIPList, DestinationPortList, TotalBytesSentinMB, TotalBytesReceivedinMB, TotalBytesSentinMBperHour, baselinebytessentperHour, score, anomalies, EventCount\n| extend timestamp =EndTimeUtc, IPCustomEntity = SourceIPMax\n", "attributes": {"description": "'Identifies anomalous data transfer to public networks. The query leverages built-in KQL anomaly detection algorithms that detects large deviations from a baseline pattern.\nA sudden increase in data transferred to unknown public networks is an indication of data exfiltration attempts and should be investigated.\nThe higher the score, the further it is from the baseline value.\nThe output is aggregated to provide summary view of unique source IP to destination IP address and port bytes sent traffic observed in the flagged anomaly hour.\nThe source IP addresses which were sending less than bytessentperhourthreshold have been exluded whose value can be adjusted as needed .\nYou may have to run queries for individual source IP addresses from SourceIPlist to determine if anything looks suspicious'\n", "techniques": ["T1030"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SecurityThreatEssentialSolution/Analytic%20Rules/Threat_Essentials_TimeSeriesAnomaly_Mass_Cloud_Resource_Deletions.yaml", "query_name": "Threat Essentials - Mass Cloud resource deletions Time Series Anomaly", "query": "let starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1h;\nlet TotalEventsThreshold = 25; \nlet TimeSeriesData = \nAzureActivity \n| where TimeGenerated between (startofday(ago(starttime))..startofday(ago(endtime)))\n| where OperationNameValue endswith \"delete\" \n| project TimeGenerated, Caller \n| make-series Total = count() on TimeGenerated from startofday(ago(starttime)) to startofday(ago(endtime)) step timeframe by Caller; \nlet TimeSeriesAlerts = materialize(TimeSeriesData \n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 3, -1, 'linefit') \n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long) \n| where anomalies > 0 \n| project Caller, TimeGenerated, Total, baseline, anomalies, score \n| where Total > TotalEventsThreshold and baseline > 0 ); \nTimeSeriesAlerts \n| where TimeGenerated > (ago(endtime)) \n| project TimeGenerated, Caller \n| join (AzureActivity \n| where TimeGenerated > (ago(endtime)) \n| where OperationNameValue endswith \"delete\" \n| summarize count(), make_set(OperationNameValue), make_set(Resource) by bin(TimeGenerated, 1h), Caller) on TimeGenerated, Caller \n| extend timestamp = TimeGenerated, AccountCustomEntity = Caller\n", "attributes": {"description": "'This query generates baseline pattern of cloud resource deletions by an user and generated anomaly \nwhen any unusual spike is detected.\nThese anomalies from unusual or privileged users could be an indication of cloud infrastructure \ntake-down by an adversary '\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SecurityThreatEssentialSolution/Analytic%20Rules/Threat_Essentials_UserAssignedPrivilegedRole.yaml", "query_name": "Threat Essentials - User Assigned Privileged Role", "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where AADOperationType in (\"Assign\", \"AssignEligibleRole\")\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-expand TargetResources\n| mv-expand TargetResources.modifiedProperties\n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n| where displayName_ =~ \"Role.DisplayName\"\n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n| where RoleName contains \"Admin\"\n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n| extend Target = tostring(TargetResources.userPrincipalName)\n| summarize by bin(TimeGenerated, 1h), OperationName,  RoleName, Target, Initiator, Result\n| extend AccountCustomEntity = Target\n", "attributes": {"description": "'Identifies when a new privileged role is assigned to a user.  Any account eligible for a role is now being given privileged access. If the assignment is unexpected or into a role that isn't the responsibility of the account holder, investigate.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1'\n", "techniques": ["T1078.004"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SecurityThreatEssentialSolution/Hunting%20Queries/Signins-from-NordVPN-Providers.yaml", "query_name": "Threat Essentials - Signins from Nord VPN Providers", "query": "let nord_vpn_feed = (externaldata(id:int,ip_address: string,search_keywords: dynamic,categories:dynamic,name: string,domain:string,price:int,flag:string,country:string,location:dynamic ,load: int ,features:dynamic)\n  [@\"https://raw.githubusercontent.com/microsoft/mstic/master/nordvpn-servers.csv\"] with (format=\"csv\", ignoreFirstRecord=True));\nSigninLogs \n  | where TimeGenerated > ago(4h) \n  | where ResultType == 0 \n  | summarize TotalEvents = count(), AppList = make_set(AppDisplayName),  StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by IPAddress, UserPrincipalName, ClientAppUsed, ConditionalAccessStatus, AuthenticationRequirement, RiskDetail \n  | join kind= inner nord_vpn_feed on $left.IPAddress == $right.ip_address\n  | project StartTime , EndTime, IPAddress, UserPrincipalName, AppList, ClientAppUsed, ConditionalAccessStatus, AuthenticationRequirement, RiskDetail, categories, domain, country\n  | extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'This query looks for signin activity from NordVPN providers using the Public feed leveraging NordVPN API .Investigation any unknown signin attempts from VPN providers such as Nord VPN unless it is commonly seen from users in the organization'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SecurityThreatEssentialSolution/Hunting%20Queries/Signins-From-VPS-Providers.yaml", "query_name": "Threat Essentials - Signins From VPS Providers", "query": "\nlet IP_Data = (externaldata(network:string)\n[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/VPS_Networks.csv\"] with (format=\"csv\"));\nSigninLogs\n| where ResultType == 0\n| extend additionalDetails = tostring(Status.additionalDetails)\n| evaluate ipv4_lookup(IP_Data, IPAddress, network, return_unmatched = false)\n| summarize make_set(additionalDetails), StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by IPAddress, UserPrincipalName\n// Uncomment the remaining lines to only see logons from VPS providers with token only logons.\n//| where array_length(set_additionalDetails) == 2\n//| where (set_additionalDetails[1] == \"MFA requirement satisfied by claim in the token\" and set_additionalDetails[0] == \"MFA requirement satisfied by claim provided by external provider\") or (set_additionalDetails[0] == \"MFA requirement satisfied by claim in the token\" and set_additionalDetails[1] == \"MFA requirement satisfied by claim provided by external provider\")\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = IPAddress\n", "attributes": {"description": "'Looks for successful logons from known VPS provider network ranges with suspicious token based logon patterns.This is not an exhaustive list of VPS provider ranges but covers some of the most prevelent providers observed.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Semperis%20Directory%20Services%20Protector/Analytic%20Rules/SemperisDSP_EvidenceOfMimikatzDCShadowAttack.yaml", "query_name": "Semperis DSP Mimikatz's DCShadow Alert", "query": "dsp_parser\n| where EventID == 9212\n| where SecurityIndicatorName == \"Evidence of Mimikatz DCShadow attack\"\n", "attributes": {"description": "'Mimikatz's DCShadow switch allows a user who has compromised an AD domain, to inject arbitrary changes into AD using a \"fake\" domain controller. These changes bypass the security event log and can't be spotted using normal AD tools. This rule looks for evidence that a machine has been used in this capacity.'\n", "techniques": ["T1207"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Semperis%20Directory%20Services%20Protector/Analytic%20Rules/SemperisDSP_KerberoskrbtgtAccount.yaml", "query_name": "Semperis DSP Kerberos krbtgt account with old password", "query": "dsp_parser\n| where EventID == 9212\n| where SecurityIndicatorName == \"Kerberos krbtgt account with old password\"\n", "attributes": {"description": "'The krbtgt user account is a special (disabled) user account in every Active Directory domain that has a special role in Kerberos function. If this account's password is compromised, Golden Ticket attacks can be performed to get access to any resource in the AD domain. This indicator looks for a krbtgt user account whose password hasn't been changed in the past 180 days. While Microsoft recommends changing the password every year, STIG recommends changing it every 180 days.'\n", "techniques": NaN, "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Semperis%20Directory%20Services%20Protector/Analytic%20Rules/SemperisDSP_RecentsIDHistoryChangesOnADObjects.yaml", "query_name": "Semperis DSP Recent sIDHistory changes on AD objects", "query": "dsp_parser\n| where EventID == 9212\n| where SecurityIndicatorName == \"Recent sIDHistory changes on objects\"\n", "attributes": {"description": "'This indicator detects any recent changes to sIDHistory on AD objects, including changes to non-privileged accounts where privileged SIDs are added.'\n", "techniques": NaN, "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Semperis%20Directory%20Services%20Protector/Analytic%20Rules/SemperisDSP_WellKnownPrivilegedSIDsInsIDHistory.yaml", "query_name": "Semperis DSP Well-known privileged SIDs in sIDHistory", "query": "dsp_parser\n| where EventID == 9212\n| where SecurityIndicatorName == \"Well-known privileged SIDs in sIDHistory\"\n", "attributes": {"description": "'This indicator looks for security principals that contain specific SIDs of accounts from built-in privileged groups within their sIDHistory attribute. This would allow those security principals to have the same privileges as those privileged accounts, but in a way that is not obvious to monitor (e.g. through group membership).'\n", "techniques": ["T1134"], "tactics": ["PrivilegeEscalation", "DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Semperis%20Directory%20Services%20Protector/Analytic%20Rules/SemperisDSP_ZerologonVulnerability.yaml", "query_name": "Semperis DSP Zerologon vulnerability", "query": "dsp_parser\n| where EventID == 9212\n| where SecurityIndicatorName == \"Zerologon vulnerability\"\n", "attributes": {"description": "'This indicator looks for security vulnerability to CVE-2020-1472, which was patched by Microsoft in August 2020. Without this patch, an unauthenticated attacker can exploit CVE-2020-1472 to elevate their privileges and get administrative access on the domain.'\n", "techniques": NaN, "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/AdminMFA.yaml", "query_name": "Azure secure score admin MFA", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScoreAdminMFAV2'\n", "attributes": {"description": "'This query searches for requiring multi-factor authentication (MFA) for all administrative roles makes it harder\n for attackers to access accounts. Administrative roles have higher permissions than typical users.\n If any of those accounts are compromised, critical devices and data is open to attack.'\n", "techniques": ["T1529", "T1498"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/AppsNoClientCredentials.yaml", "query_name": "SenservaPro AD Applications Not Using Client Credentials", "query": "SenservaPro_CL\n| where ControlName_s == 'ApplicationNotUsingClientCredentials'\n", "attributes": {"description": "'Searches for logs of AD Applications without Client Credentials (Key or Secret)'\n", "techniques": ["T1529", "T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/BlockLegacyAuthentication.yaml", "query_name": "Azure secure score block legacy authentication", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScoreBlockLegacyAuthentication'\n", "attributes": {"description": "'This query searches for most compromising sign-in attempts come from legacy authentication. \n Older office clients such as Office 2010 do not support modern authentication \n and use legacy protocols such as IMAP, SMTP, and POP3. \n Legacy authentication does not support multi-factor authentication (MFA).\n Even if an MFA policy is configured in your environment, bad actors can \n bypass these enforcements through legacy protocols.'\n", "techniques": ["T1212", "T1556"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/GlobaAdminRoleOverlap.yaml", "query_name": "Azure secure score role overlap", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScoreRoleOverlap'\n", "attributes": {"description": "'This query searches for accounts that have been assigned Global Administrator do not need other roles assigned. \n  Global Administrators have access to all aspects of Azure'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/MFARegistration.yaml", "query_name": "Azure secure score MFA registration V2", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScoreMFARegistrationV2'\n", "attributes": {"description": "'This query searches for multi-factor authentication (MFA) helps protect devices and data \n that are accessible to these users. Adding more authentication methods,\n such as the Microsoft Authenticator app or a phone number, increases the level of protection \n if one factor is compromised.'\n", "techniques": ["T1056"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/NonAdminGuest.yaml", "query_name": "Non-admin guest", "query": "SenservaPro_CL\n| where ControlName_s == 'UserNonAdminGuest'\n", "attributes": {"description": "'This query searches for guest is not an admin in Azure'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/NotUsingClientCredentials.yaml", "query_name": "Service principal not using client credentials", "query": "SenservaPro_CL\n| where ControlName_s == 'ServicePrincipalNotUsingClientCredentials'\n", "attributes": {"description": "'This query searches for an service principal is not using a client certificate or secret is not secure. \n It is recommended that you review your needs and use an Authentication method \n for sign-in.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/OneGlobalAdmin.yaml", "query_name": "Azure secure score one admin", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScoreOneAdmin'\n", "attributes": {"description": "'This query searches for having 1 Global Administrator reduces the surface area of attack for your Azure tenant, \n but sets up a single point of failure for the whole tenant. Global Administrators have access\n to all aspects of Azure'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/PasswordAgePolicyNew.yaml", "query_name": "Azure secure score PW age policy new", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScorePWAgePolicyNew'\n", "attributes": {"description": "'This query searches for having found that when periodic password resets are enforced,\n passwords become less secure. Users tend to pick a weaker password and vary it slightly for each reset. \n If a user creates a strong password (long, complex and without any pragmatic words present)\n it should remain just as strong in the future as it is today. It is Microsoft's official security position\n to not expire passwords periodically without a specific reason, and recommends \n that cloud-only tenants set the password policy to never expire.'\n", "techniques": ["T1555", "T1606", "T1040"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/SearchStaleLastPasswordChange.yaml", "query_name": "Stale last password change", "query": "SenservaPro_CL\n| where ControlName_s == 'UserStaleLastPasswordChange'\n", "attributes": {"description": "'This query searches for stale last password change'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/SelfServicePasswordReset.yaml", "query_name": "Azure Secure Score Self Service Password Reset", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScoreSelfServicePasswordReset'\n", "attributes": {"description": "'This query searches for requires you to setup Azure AD Connect. \n Azure AD Connect is free with all Azure Subscriptions'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/SignInRiskPolicy.yaml", "query_name": "Azure secure score sign in risk policy", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScoreSignInRiskPolicy'\n", "attributes": {"description": "'This query searches for an active Azure Premium P2 license is required to use and edit this policy. \n You will be required to have setup the MFA Policy before activating this policy'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/ThirdPartyIntegratedApps.yaml", "query_name": "Third party integrated apps", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScoreIntegratedApps'\n", "attributes": {"description": "'This query searches for your services by regulating the access of third-party integrated apps. \n Only allow access to necessary apps that support robust security controls. \n Third-party applications are not created by Microsoft, \n so there is a possibility they could be used for malicious purposes like exfiltrating data from your tenancy.\n Attackers can maintain persistent access to your services through these integrated apps, without relying on compromised accounts.'\n", "techniques": ["T1020"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/UserAccountDisabled.yaml", "query_name": "UserAccountDisabled", "query": "SenservaPro_CL\n| where ControlName_s == 'UserDisabled'\n", "attributes": {"description": "'This query searches for account is Disabled. Does not effect score as its easily enabled.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Analytic%20Rules/UserRiskPolicy.yaml", "query_name": "Azure secure score user risk policy", "query": "SenservaPro_CL\n| where ControlName_s == 'AzureSecureScoreUserRiskPolicy'\n", "attributes": {"description": "'This query searches for an active Azure Premium P2 license is required to use and edit this policy. \n You will be required to have setup the MFA Policy before activating this policy'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/ApplicationNotUsingClientCredentials.yaml", "query_name": "Application not using client credentials", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'ApplicationNotUsingClientCredentials'", "attributes": {"description": "'This query searches for application not using a client certificate or secret is not secure.'    \n", "techniques": ["T1529", "T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScoreAdminMFAV2.yaml", "query_name": "Azure secure score admin MFA V2", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'Azure Secure Score AdminMFAV2'", "attributes": {"description": "'This query searches for requiring multi-factor authentication (MFA) for all administrative roles makes it harder\n for attackers to access accounts. Administrative roles have higher permissions than typical users.'\n", "techniques": ["T1529", "T1498"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScoreBlockLegacyAuthentication.yaml", "query_name": "Azure secure score block legacy authentication", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'AzureSecureScoreBlockLegacyAuthentication'", "attributes": {"description": "'This query searches for most compromising sign-in attempts come from legacy authentication. \n Older office clients such as Office 2010 do not support modern authentication \n and use legacy protocols such as IMAP, SMTP, and POP3.'\n", "techniques": ["T1212", "T1556"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScoreIntegratedApps.yaml", "query_name": "Azure secure score integrated apps", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'AzureSecureScoreIntegratedApps'", "attributes": {"description": "'This query searches for your services by regulating the access of third-party integrated apps. \nOnly allow access to necessary apps that support robust security controls.'\n", "techniques": ["T1020"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScoreMFARegistrationV2.yaml", "query_name": "Azure secure score MFA registration V2", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'AzureSecureScoreMFARegistrationV2'", "attributes": {"description": "'This query searches for multi-factor authentication (MFA) helps protect devices and data \n that are accessible to these users. Adding more authentication methods, increases the level of protection \n if one factor is compromised.'\n", "techniques": ["T1056"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScoreOneAdmin.yaml", "query_name": "Azure secure score one admin", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'AzureSecureScoreOneAdmin'\n", "attributes": {"description": "'This query searches for having 1 Global Administrator reduces the surface area of attack for your Azure tenant, \n but sets up a single point of failure for the whole tenant. Global Administrators have access\n to all aspects of Azure'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScorePWAgePolicyNew.yaml", "query_name": "Azure secure score PW age policy new", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'AzureSecureScorePWAgePolicyNew'", "attributes": {"description": "'This query searches for having found that when periodic password resets are enforced,\n passwords become less secure. Users tend to pick a weaker password and vary it slightly for each reset.'\n", "techniques": ["T1555", "T1606", "T1040"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScoreRoleOverlap.yaml", "query_name": "Azure secure score role overlap", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'AzureSecureScoreRoleOverlap'\n", "attributes": {"description": "'This query searches for accounts that have been assigned Global Administrator do not need other roles assigned. \n  Global Administrators have access to all aspects of Azure'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScoreSelfServicePasswordReset.yaml", "query_name": "Azure Secure Score Self Service Password Reset", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'AzureSecureScoreSelfServicePasswordReset'\n", "attributes": {"description": "'This query searches for requires you to setup Azure AD Connect. \n Azure AD Connect is free with all Azure Subscriptions'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScoreSigninRiskPolicy.yaml", "query_name": "Azure secure score sign in risk policy", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'AzureSecureScoreSigninRiskPolicy'", "attributes": {"description": "'This query searches for an active Azure Premium P2 license is required to use and edit this policy. \n You will be required to have setup the MFA Policy before activating this policy'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/AzureSecureScoreUserRiskPolicy.yaml", "query_name": "Azure secure score user risk policy", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'AzureSecureScoreUserRiskPolicy'", "attributes": {"description": "'This query searches for an active Azure Premium P2 license is required to use and edit this policy. \n You will be required to have setup the MFA Policy before activating this policy'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/NonAdminGuest.yaml", "query_name": "Non-admin guest", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'UserNonAdminGuest'", "attributes": {"description": "'This query searches for guest is not an admin in Azure'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/ServicePrincipalNotUsingClientCredentials.yaml", "query_name": "Service principal not using client credentials", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'ServicePrincipalNotUsingClientCredentials'", "attributes": {"description": "'This query searches for an service principal is not using a client certificate or secret is not secure. \n It is recommended that you review your needs and use an Authentication method \n for sign-in.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/StaleLastPasswordChange.yaml", "query_name": "Stale last password change", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'UserStaleLastPasswordChange'", "attributes": {"description": "'This query searches for stale last password change'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SenservaPro/Hunting%20Queries/UserAccountDisabled.yaml", "query_name": "UserAccountDisabled", "query": "let timeframe = 14d;\nSenservaPro_CL\n| where TimeGenerated >= ago(timeframe)\n| where ControlName_s == 'UserDisabled'", "attributes": {"description": "'This query searches for account is Disabled. Does not effect score as its easily enabled.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneAdminLoginNewIP.yaml", "query_name": "Sentinel One - Admin login from new location", "query": "let lback_period = 14d;\nlet lback_time = 1h;\nSentinelOne\n| where TimeGenerated between(ago(lback_period)..ago(lback_time))\n| where ActivityType == 27\n| where DataRole =~ 'Admin'\n| extend SrcIpAddr = extract(@'Address\\s(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})', 1, EventOriginalMessage)\n| where isnotempty(SrcIpAddr)\n| summarize ip_lst = makeset(SrcIpAddr) by SrcUserName\n| join (SentinelOne\n        | where ActivityType == 27\n        | where DataRole =~ 'Admin'\n        | extend SrcIpAddr = extract(@'Address\\s(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})', 1, EventOriginalMessage)\n        | where isnotempty(SrcIpAddr)) on SrcUserName\n| where ip_lst !has SrcIpAddr\n| extend AccountCustomEntity = SrcUserName, IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects admin user login from new location (IP address).'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneAgentUninstalled.yaml", "query_name": "Sentinel One - Agent uninstalled from multiple hosts", "query": "SentinelOne\n| where ActivityType == 31\n| summarize count() by DataComputerName, bin(TimeGenerated, 30m)\n| where count_ > 1\n| extend HostCustomEntity = DataComputerName\n", "attributes": {"description": "'Detects when agent was uninstalled from multiple hosts.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneAlertFromCustomRule.yaml", "query_name": "Sentinel One - Alert from custom rule", "query": "SentinelOne\n| where ActivityType == 3608\n| extend RuleName = extract(@'Custom Rule:\\s(.*?)\\sin Group', 1, EventOriginalMessage)\n| extend DstHostname = extract(@'detected on\\s(\\S+)\\.', 1, EventOriginalMessage)\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Detects when alert from custom rule received.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneBlacklistHashDeleted.yaml", "query_name": "Sentinel One - Blacklist hash deleted", "query": "SentinelOne\n| where ActivityType == 3020\n| project EventCreationTime, SrcUserName, Hash=EventSubStatus\n| extend AccountCustomEntity = SrcUserName, HashCustomEntity = Hash, HashAlgorithmCustomEntity = \"SHA1\"\n", "attributes": {"description": "'Detects when blacklist hash was deleted.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneExclusionAdded.yaml", "query_name": "Sentinel One - Exclusion added", "query": "SentinelOne\n| where EventOriginalMessage has_all ('added', 'exclusion')\n| project EventCreationTime, SrcUserName, EventOriginalMessage\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects when new exclusion added.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneMultipleAlertsOnHost.yaml", "query_name": "Sentinel One - Multiple alerts on host", "query": "SentinelOne\n| where ActivityType == 3608\n| extend RuleName = extract(@'Custom Rule:\\s(.*?)\\sin Group', 1, EventOriginalMessage)\n| extend DstHostname = extract(@'detected on\\s(\\S+)\\.', 1, EventOriginalMessage)\n| summarize count() by DstHostname, bin(TimeGenerated, 15m)\n| where count_ > 1\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Detects when multiple alerts received from same host.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneNewAdmin.yaml", "query_name": "Sentinel One - New admin created", "query": "SentinelOne\n| where ActivityType == 23\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Detects when new admin user is created.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneRuleDeleted.yaml", "query_name": "Sentinel One - Rule deleted", "query": "SentinelOne\n| where ActivityType == 3602\n| project EventCreationTime, DataRuleName, DataRuleQueryDetails, DataUserName\n| extend AccountCustomEntity = DataUserName\n", "attributes": {"description": "'Detects when a rule was deleted.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneRuleDisabled.yaml", "query_name": "Sentinel One - Rule disabled", "query": "SentinelOne\n| where ActivityType == 3603\n| project EventCreationTime, DataRuleName, DataRuleQueryDetails, DataUserName\n| extend AccountCustomEntity = DataUserName\n", "attributes": {"description": "'Detects when a rule was disabled.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneSameCustomRuleHitOnDiffHosts.yaml", "query_name": "Sentinel One - Same custom rule triggered on different hosts", "query": "SentinelOne\n| where ActivityType == 3608\n| extend RuleName = extract(@'Custom Rule:\\s(.*?)\\sin Group', 1, EventOriginalMessage)\n| extend DstHostname = extract(@'detected on\\s(\\S+)\\.', 1, EventOriginalMessage)\n| summarize hosts = makeset(DstHostname) by RuleName, bin(TimeGenerated, 15m)\n| where array_length(hosts) > 1\n| extend HostCustomEntity = hosts\n", "attributes": {"description": "'Detects when same custom rule was triggered on different hosts.'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Analytic%20Rules/SentinelOneViewAgentPassphrase.yaml", "query_name": "Sentinel One - User viewed agent's passphrase", "query": "SentinelOne\n| where ActivityType == 64\n| extend AccountCustomEntity = SrcUserName, HostCustomEntity = DataComputerName\n", "attributes": {"description": "'Detects when a user viewed agent's passphrase.'\n", "techniques": ["T1555"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneAgentNotUpdated.yaml", "query_name": "Sentinel One - Agent not updated", "query": "//Latest agent version can be checked in Management Console>Sentinels>Packages\nlet upd_ver = dynamic(['21.7.4.1043', '21.7.4.5853', '21.10.3.3', '21.12.1.5913']);\nSentinelOne\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'Agents.'\n| where AgentVersion !in (upd_ver)\n| extend HostCustomEntity = ComputerName\n", "attributes": {"description": "'Query shows agent which are not updated to the latest version.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneAgentStatus.yaml", "query_name": "Sentinel One - Agent status", "query": "SentinelOne\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'Agents.'\n| extend Properties = pack('IsActive', IsActive,'ActiveThreats',ActiveThreats,'FirewallEnabled',FirewallEnabled,'Infected',Infected,'IsUpToDate',IsUpToDate,'MitigationMode',MitigationMode,'MitigationModeSuspicious',MitigationModeSuspicious,'NetworkStatus',NetworkStatus)\n| summarize max(TimeGenerated) by ComputerName, tostring(Properties)\n| extend HostCustomEntity = ComputerName\n", "attributes": {"description": "'Query shows agent properties.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneAlertTriggers.yaml", "query_name": "Sentinel One - Alert triggers (files, processes, strings)", "query": "SentinelOne\n| where TimeGenerated > ago(24h)\n| where ActivityType == 3608\n| order by EventCreationTime\n| extend trigger = extract(@'Alert created for\\s+(.*?)\\sfrom Custom', 1, EventOriginalMessage)\n| extend MalwareCustomEntity = trigger\n", "attributes": {"description": "'Query shows alert triggers (e.g. files, processes, etc.).'\n", "techniques": ["T1204"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneHostNotScanned.yaml", "query_name": "Sentinel One - Hosts not scanned recently", "query": "let scanned_agents = SentinelOne\n| where TimeGenerated > ago(24h)\n| where ActivityType == 92\n| order by TimeGenerated\n| summarize makeset(DataComputerName);\nSentinelOne\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'Agents.'\n| where ComputerName !in (scanned_agents)\n| extend HostCustomEntity = ComputerName\n", "attributes": {"description": "'Query searches for hosts wich were not scanned recently.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneNewRules.yaml", "query_name": "Sentinel One - New rules", "query": "SentinelOne\n| where TimeGenerated > ago(24h)\n| where ActivityType == 3600\n| order by EventCreationTime\n| project EventCreationTime, DataRuleName, DataRuleQueryDetails, DataStatus, DataUserName\n| extend AccountCustomEntity = DataUserName\n", "attributes": {"description": "'Query shows new rules.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneRulesDeleted.yaml", "query_name": "Sentinel One - Deleted rules", "query": "SentinelOne\n| where TimeGenerated > ago(24h)\n| where ActivityType == 3602\n| order by EventCreationTime\n| project EventCreationTime, DataRuleName, DataRuleQueryDetails, DataStatus, DataUserName\n| extend AccountCustomEntity = DataUserName\n", "attributes": {"description": "'Query shows deleted rules.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneScannedHosts.yaml", "query_name": "Sentinel One - Scanned hosts", "query": "SentinelOne\n| where TimeGenerated > ago(24h)\n| where ActivityType == 92\n| order by TimeGenerated\n| project EventCreationTime, DataComputerName\n| extend HostCustomEntity = DataComputerName\n", "attributes": {"description": "'Query searches for hosts with completed full scan.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneSourcesByAlertCount.yaml", "query_name": "Sentinel One - Sources by alert count", "query": "SentinelOne\n| where TimeGenerated > ago(24h)\n| where ActivityType == 3608\n| extend DstHostname = extract(@'detected on\\s(\\S+)\\.', 1, EventOriginalMessage)\n| summarize count() by DstHostname\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query shows sources (hosts) by alert count.'\n", "techniques": ["T1204"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneUninstalledAgents.yaml", "query_name": "Sentinel One - Uninstalled agents", "query": "SentinelOne\n| where TimeGenerated > ago(24h)\n| where ActivityType == 31\n| extend HostCustomEntity = DataComputerName\n", "attributes": {"description": "'Query shows uninstalled agents.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SentinelOne/Hunting%20Queries/SentinelOneUsersByAlertCount.yaml", "query_name": "Sentinel One - Users by alert count", "query": "SentinelOne\n| where TimeGenerated > ago(24h)\n| where ActivityType == 3608\n| extend DstHostname = extract(@'detected on\\s(\\S+)\\.', 1, EventOriginalMessage)\n| join (SentinelOne \n      | where EventType =~ 'Agents.'\n      | where isnotempty(LastLoggedInUserName)\n      | project DstHostname=ComputerName, LastLoggedInUserName) on DstHostname\n| summarize count() by LastLoggedInUserName\n| extend AccountCustomEntity = LastLoggedInUserName\n", "attributes": {"description": "'Query shows users by alert count.'\n", "techniques": ["T1204"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Analytic%20Rules/SlackAuditEmptyUA.yaml", "query_name": "SlackAudit - Empty User Agent", "query": "SlackAudit\n| where isempty(UserAgentOriginal)\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query shows connections to the Slack Workspace with empty User Agent.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Analytic%20Rules/SlackAuditMultipleArchivedFilesUploadedInShortTimePeriod.yaml", "query_name": "SlackAudit - Multiple archived files uploaded in short period of time", "query": "let threshold = 10;\nSlackAudit\n| where DvcAction =~ 'file_uploaded'\n| extend FE = extract(@'.*\\.(.*)$', 1, EntityFileName)\n| where FE in~ ('tar', 'bz2', 'gz', 'tgz', 'Z', 'tbz2', 'zst', 'zip', 'zipx', '7z', 'rar', 'sfx')\n| summarize count() by SrcUserName, bucket = bin(TimeGenerated, 15m)\n| where count_ > threshold\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query helps to detect when a user uploads multiple archived files in short period of time.'\n", "techniques": ["T1567"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Analytic%20Rules/SlackAuditMultipleFailedLoginsForUser.yaml", "query_name": "SlackAudit - Multiple failed logins for user", "query": "let threshold = 10;\nSlackAudit\n| where DvcAction =~ 'user_login_failed'\n| summarize count() by SrcUserName, bucket = bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query helps to detect bruteforce of a user account.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Analytic%20Rules/SlackAuditSensitiveFile.yaml", "query_name": "SlackAudit - Public link created for file which can contain sensitive information.", "query": "SlackAudit\n| where Action =~ 'file_public_link_created'\n| where EntityFileName == 'id_rsa' or EntityFileName contains 'password' or EntityFileName contains 'key' or EntityFileName contains '_key' or EntityFileName contains '.ssh' or EntityFileName endswith '.npmrc' or EntityFileName endswith '.muttrc' or EntityFileName contains 'config.json' or EntityFileName contains '.gitconfig' or EntityFileName endswith '.netrc' or EntityFileName endswith 'package.json' or EntityFileName endswith 'Gemfile' or EntityFileName endswith 'bower.json' or EntityFileName endswith 'config.gypi' or EntityFileName endswith 'travis.yml'\n| extend AccountCustomEntity = SrcUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects public links for files which potentialy may contain sensitive data such as passwords, authentication tokens, secret keys.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Analytic%20Rules/SlackAuditSuspiciousFileDownloaded.yaml", "query_name": "SlackAudit - Suspicious file downloaded.", "query": "SlackAudit\n| where DvcAction =~ 'file_downloaded'\n| extend fe = split(EntityFileName, '.')\n| where array_length(fe) > 2\n| where fe[1] matches regex @\"\\D+\"\n| where strlen(fe[1]) < 5\n| project EntityFileName, SrcUserName\n| extend AccountCustomEntity = SrcUserName\n| extend FileCustomEntity = EntityFileName\n", "attributes": {"description": "'Detects potentialy suspicious downloads.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Analytic%20Rules/SlackAuditUnknownUA.yaml", "query_name": "SlackAudit - Unknown User Agent", "query": "let lbperiod = 14d;\nlet known_UAs = SlackAudit\n| where TimeGenerated > ago(lbperiod)\n| where isnotempty(UserAgentOriginal)\n| summarize makeset(UserAgentOriginal);\nSlackAudit\n| where UserAgentOriginal !in (known_UAs)\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query helps to detect who trying to connect to the Slack Workspace with unknown User Agent.'\n", "techniques": NaN, "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Analytic%20Rules/SlackAuditUserChangedToAdminOrOwner.yaml", "query_name": "SlackAudit - User role changed to admin or owner", "query": "SlackAudit\n| where DvcAction in~ ('role_change_to_admin', 'role_change_to_owner')\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query helps to detect a change in the users role to admin or owner.'\n", "techniques": ["T1098", "T1078"], "tactics": ["Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Analytic%20Rules/SlackAuditUserEmailChanged.yaml", "query_name": "SlackAudit - User email linked to account changed.", "query": "SlackAudit\n| where TimeGenerated between (ago(14d) .. (1d))\n| summarize max(TimeGenerated) by SrcUserName, SrcUserEmail\n| join (SlackAudit \n      | where Action =~ 'user_login'\n      | project SrcIpAddr, SrcUserName, NewUserEmail = SrcUserEmail) on SrcUserName\n| where NewUserEmail != SrcUserEmail\n| extend AccountCustomEntity = SrcUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when user email linked to account changes.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Analytic%20Rules/SlackAuditUserLoginAfterDeactivated.yaml", "query_name": "SlackAudit - User login after deactivated.", "query": "let lbperiod_max_d = 14d;\nlet lbperiod_min_d = 1d;\nlet lb_time_max_h = 24h;\nSlackAudit\n| where TimeGenerated between (ago(lbperiod_max_d) .. (lbperiod_min_d))\n| where Action =~ 'user_deactivated'\n| summarize deactivation_time = max(TimeGenerated) by EntityUserEmail, EntityUserId\n| project deactivation_time, EntityUserEmail, EntityUserId\n| join (SlackAudit\n      | where TimeGenerated > ago(lb_time_max_h)\n      | where Action =~ 'user_login'\n      | summarize new_login_time = max(TimeGenerated) by SrcUserEmail, SrcUserIdentity\n      | project new_login_time, SrcUserEmail, EntityUserId = SrcUserIdentity) on EntityUserId\n| where EntityUserEmail == SrcUserEmail\n| where deactivation_time < new_login_time\n| extend AccountCustomEntity = SrcUserEmail\n", "attributes": {"description": "'Detects when user email linked to account changes.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "Persistence", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditApplicationsInstalled.yaml", "query_name": "SlackAudit - Applications installed", "query": "SlackAudit\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'app_installed'\n| summarize by SrcUserName, EntityAppName\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query searches for application installation events.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditDeactivatedUsers.yaml", "query_name": "SlackAudit - Deactivated users", "query": "SlackAudit\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'user_deactivated'\n| summarize by SrcUserName\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query searches for deactivated user accounts.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditDownloadedFilesByUser.yaml", "query_name": "SlackAudit - Downloaded files stats", "query": "SlackAudit\n| where TimeGenerated > ago(24h)\n| where Action =~ 'file_downloaded'\n| summarize filelist = makeset(EntityFileName) by SrcUserName\n| project filelist, fcount = array_length(filelist), SrcUserName\n| top 10 by fcount\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query shows top users by downloads over time.'\n", "techniques": ["T1189", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditFailedLoginsUnknownUsername.yaml", "query_name": "SlackAudit - Failed logins with unknown username", "query": "let lbtime = 24h;\nlet lbperiod = 30d;\nlet known_users = SlackAudit\n| where TimeGenerated > ago(lbperiod)\n| where DvcAction =~ 'user_login'\n| where isnotempty(SrcUserName)\n| summarize makeset(SrcUserName);\nSlackAudit\n| where TimeGenerated > ago(lbtime)\n| where DvcAction =~ 'user_login_failed'\n| where isnotempty(SrcUserName)\n| where SrcUserName !in (known_users)\n| project SrcUserName, SrcIpAddr\n| extend AccountCustomEntity = SrcUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'This query shows failed login attempts where username is unknown.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditNewUsers.yaml", "query_name": "SlackAudit - New User created", "query": "SlackAudit\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'user_created'\n| extend AccountCustomEntity = SrcUserName\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'This query shows new user created.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditSuspiciousFilesDownloaded.yaml", "query_name": "SlackAudit - Suspicious files downloaded", "query": "SlackAudit\n| where DvcAction =~ 'file_downloaded'\n| extend fe = split(EntityFileName, '.')\n| where array_length(fe) > 2\n| where fe[1] matches regex @\"\\D+\"\n| where strlen(fe[1]) < 5\n| project EntityFileName, SrcUserName\n| extend AccountCustomEntity = SrcUserName\n| extend FileCustomEntity = EntityFileName\n", "attributes": {"description": "'This query searches for potentialy suspicious files downloads.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditUploadedFilesByUser.yaml", "query_name": "SlackAudit - Uploaded files stats", "query": "SlackAudit\n| where TimeGenerated > ago(24h)\n| where Action =~ 'file_uploaded'\n| summarize filelist = makeset(EntityFileName) by SrcUserName\n| project filelist, fcount = array_length(filelist), SrcUserName\n| top 10 by fcount\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query shows top users by uploads over time.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditUserLoginsByIP.yaml", "query_name": "SlackAudit - User logins by IP", "query": "SlackAudit\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'user_login'\n| summarize makeset(SrcIpAddr) by SrcUserName\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'This query shows user IP table statistics for login events.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditUserPermissionsChanged.yaml", "query_name": "SlackAudit - User Permission Changed", "query": "SlackAudit\n| where TimeGenerated > ago(24h)\n| where DvcAction in~ ('user_added_to_usergroup', 'user_removed_from_usergroup')\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for user permissions changes events.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SlackAudit/Hunting%20Queries/SlackAuditUsersJoinedChannelsWithoutInvites.yaml", "query_name": "SlackAudit - Users joined channels without invites", "query": "SlackAudit\n| where TimeGenerated > ago(24h)\n| where DvcAction =~ 'user_channel_join'\n| where DetailsType =~ 'JOINED'\n| extend AccountCustomEntity = SrcUserName\n", "attributes": {"description": "'Query searches for users which joined channels without invites.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakeDiscoveryActivity.yaml", "query_name": "Snowflake - Possible discovery activity", "query": "let threshold = 20;\nSnowflake\n| where QUERY_TYPE_s =~ 'SHOW'\n| where EXECUTION_STATUS_s =~ 'SUCCESS'\n| summarize count() by TargetUsername, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Detects possible discovery activity.'\n", "techniques": NaN, "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakeLongQueryProcessTime.yaml", "query_name": "Snowflake - Abnormal query process time", "query": "let threshold = 10000;\nSnowflake\n| where TOTAL_ELAPSED_TIME_d > threshold\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Detects query with abnormal proccess time.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakeMultipleFailedQueries.yaml", "query_name": "Snowflake - Multiple failed queries", "query": "let threshold = 50;\nSnowflake\n| where EXECUTION_STATUS_s !~ 'SUCCESS'\n| summarize count() by TargetUsername, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Detects multiple failed queries in short timeframe.'\n", "techniques": ["T1518", "T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakeMultipleLoginFailure.yaml", "query_name": "Snowflake - Multiple login failures by user", "query": "let threshold = 10;\nSnowflake\n| where EventType =~ 'LOGIN'\n| where IS_SUCCESS_s =~ 'No'\n| summarize count() by TargetUsername, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Detects multiple login failures by user.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakeMultipleLoginFailureFromIP.yaml", "query_name": "Snowflake - Multiple login failures from single IP", "query": "let threshold = 10;\nSnowflake\n| where EventType =~ 'LOGIN'\n| where IS_SUCCESS_s =~ 'No'\n| summarize count() by SrcDvcIpAddr, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend IPCustomEntity = SrcDvcIpAddr\n", "attributes": {"description": "'Detects Mmltiple login failures from single IP.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakePossibleDataDestruction.yaml", "query_name": "Snowflake - Possible data destraction", "query": "let threshold = 10;\nSnowflake\n| where QUERY_TYPE_s =~ 'DROP'\n| where EXECUTION_STATUS_s =~ 'SUCCESS'\n| summarize count() by TargetUsername, bin(TimeGenerated, 5m)\n| where count_ > threshold\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Detects possible data destruction.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakePrivilegesDiscovery.yaml", "query_name": "Snowflake - Possible privileges discovery activity", "query": "Snowflake\n| where QUERY_TYPE_s =~ 'SHOW'\n| where QUERY_TEXT_s has_all ('SHOW', 'ROLES')\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Detects possible privileges discovery activity.'\n", "techniques": ["T1087"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakeQueryOnSensitiveTable.yaml", "query_name": "Snowflake - Query on sensitive or restricted table", "query": "let r_tbl = dynamic(['table_name']);\nSnowflake\n| where QUERY_TYPE_s =~ 'SELECT'\n| where EXECUTION_STATUS_s =~ 'SUCCESS'\n| extend tbl = extract(@'(FROM|from)\\s(\\S+)\\s', 2, QUERY_TEXT_s)\n| where tbl in~ (r_tbl)\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Detects query on sensitive or restricted table.'\n", "techniques": ["T1119"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakeUnusualQuery.yaml", "query_name": "Snowflake - Unusual query", "query": "Snowflake\n| where QUERY_TYPE_s =~ 'SELECT'\n| where EXECUTION_STATUS_s =~ 'SUCCESS'\n| where QUERY_TEXT_s startswith @'SELECT *'\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Detects unusual query.'\n", "techniques": ["T1119"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Analytic%20Rules/SnowflakeUserAddAdminPrivileges.yaml", "query_name": "Snowflake - User granted admin privileges", "query": "let adm_roles = dynamic(['SECURITYADMIN', 'SYSADMIN', 'ACCOUNTADMIN']);\nSnowflake\n| where QUERY_TYPE_s =~ 'GRANT'\n| where QUERY_TEXT_s startswith 'GRANT ROLE'\n| extend granted_role = extract(@'GRANT ROLE\\s(\\S+)\\sto\\suser', 1, QUERY_TEXT_s)\n| where granted_role in~ (adm_roles)\n| extend usr = extract(@'GRANT ROLE\\s(\\S+)\\sto\\suser(\\S+)', 2, QUERY_TEXT_s)\n| extend AccountCustomEntity = usr\n", "attributes": {"description": "'Detects when user asigned admin privileges.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeAdminSources.yaml", "query_name": "Snowflake - Privileged users' source IP addresses", "query": "Snowflake\n| where TimeGenerated > ago(24h)\n| where QUERY_TYPE_s =~ 'SELECT'\n| summarize roles = makeset(ROLE_NAME_s) by TargetUsername\n| join(Snowflake\n      | where TimeGenerated > ago(24h)\n      | where EventType =~ 'LOGIN') on TargetUsername\n| project-away TargetUsername1\n| where roles has_any ('SECURITYADMIN', 'SYSADMIN', 'ACCOUNTADMIN')\n| summarize ip_lst = makeset(SrcDvcIpAddr) by TargetUsername\n| extend AccountCustomEntity = TargetUsername, IPCustomEntity = ip_lst\n", "attributes": {"description": "'Query searches for privileged users' source IP addresses.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeDeletedDatabases.yaml", "query_name": "Snowflake - Deleted databases", "query": "Snowflake\n| where TimeGenerated > ago(24h)\n| where QUERY_TYPE_s =~ 'DROP'\n| where QUERY_TEXT_s has 'database'\n| where EXECUTION_STATUS_s =~ 'SUCCESS'\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Query searches for deleted databases.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeDeletedTables.yaml", "query_name": "Snowflake - Deleted tables", "query": "Snowflake\n| where TimeGenerated > ago(24h)\n| where QUERY_TYPE_s =~ 'DROP'\n| where QUERY_TEXT_s has 'table'\n| where EXECUTION_STATUS_s =~ 'SUCCESS'\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Query searches for deleted tables.'\n", "techniques": ["T1485"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeDormantUser.yaml", "query_name": "Snowflake - Rarely used account", "query": "Snowflake\n| where TimeGenerated > ago(30d)\n| where EventType =~ 'LOGIN'\n| where IS_SUCCESS_s =~ 'Yes'\n| summarize last_login_time = max(TimeGenerated) by TargetUsername\n| where last_login_time < ago(20d)\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Query searches for rarely used accounts.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeFailedLogins.yaml", "query_name": "Snowflake - Failed logins", "query": "Snowflake\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'LOGIN'\n| where IS_SUCCESS_s =~ 'No'\n| summarize count() by TargetUsername\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Query searches for failed logins.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeHighCreditConsumingQueries.yaml", "query_name": "Snowflake - Credit consuming queries", "query": "| let acceptable_credits = 0.00001;\nSnowflake\n| where TimeGenerated > ago(24h)\n| where CREDITS_USED_CLOUD_SERVICES_d > acceptable_credits\n| summarize by QUERY_TEXT_s, CREDITS_USED_CLOUD_SERVICES_d, TargetUsername\n| order by CREDITS_USED_CLOUD_SERVICES_d\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Query searches for queries which consume abnormal amount of credits.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeTimeConsumingQueries.yaml", "query_name": "Snowflake - Time consuming queries", "query": "| let acceptable_duration = 1000;\nSnowflake\n| where TimeGenerated > ago(24h)\n| where TOTAL_ELAPSED_TIME_d > acceptable_duration\n| summarize by QUERY_TEXT_s, TOTAL_ELAPSED_TIME_d, TargetUsername\n| order by TOTAL_ELAPSED_TIME_d\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Query searches for time consuming queries.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeUnknownQueryType.yaml", "query_name": "Snowflake - Unknown query type", "query": "Snowflake\n| where TimeGenerated > ago(24h)\n| where QUERY_TYPE_s =~ 'UNKNOWN'\n| summarize by QUERY_TEXT_s, TargetUsername\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Query searches for queries of type UNKNOWN.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeUnusedAdmins.yaml", "query_name": "Snowflake - Rarely used privileged users", "query": "Snowflake\n| where TimeGenerated > ago(30d)\n| where QUERY_TYPE_s =~ 'SELECT'\n| summarize roles = makeset(ROLE_NAME_s) by TargetUsername\n| join(Snowflake\n      | where TimeGenerated > ago(30d)\n      | where EventType =~ 'LOGIN'\n      | summarize last_login_t = max(TimeGenerated) by TargetUsername) on TargetUsername\n| project-away TargetUsername1\n| where roles has_any ('SECURITYADMIN', 'SYSADMIN', 'ACCOUNTADMIN')\n| where last_login_t < ago(20d)\n| extend AccountCustomEntity = TargetUsername\n", "attributes": {"description": "'Query searches for rarely used privileged users.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Snowflake/Hunting%20Queries/SnowflakeUserSources.yaml", "query_name": "Snowflake - Users' source IP addresses", "query": "Snowflake\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'LOGIN'\n| where IS_SUCCESS_s =~ 'Yes'\n| summarize ip_lst = makeset(SrcDvcIpAddr) by TargetUsername\n| extend AccountCustomEntity = TargetUsername, IPCustomEntity = ip_lst\n", "attributes": {"description": "'Query searches for users' source IP addresses.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SonraiSecurity/Analytic%20Rules/SonraiNewTicket.yaml", "query_name": "New Sonrai Ticket", "query": "Sonrai_Tickets_CL\n| where action_d == 1\n", "attributes": {"description": "'Checks for new Sonrai tickets. \nIt uses the action type to check if a ticket has been created'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SonraiSecurity/Analytic%20Rules/SonraiTicketAssigned.yaml", "query_name": "Sonrai Ticket Assigned", "query": "Sonrai_Tickets_CL\n| where action_d == 4\n", "attributes": {"description": "'Checks if Sonrai tickets have been assigned. \nIt uses the action type to check if a ticket has been assigned'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SonraiSecurity/Analytic%20Rules/SonraiTicketClosed.yaml", "query_name": "Sonrai Ticket Closed", "query": "Sonrai_Tickets_CL\n| where action_d == 2\n", "attributes": {"description": "'Checks if Sonrai tickets have been closed. \nIt uses the action type to check if a ticket has been closed'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SonraiSecurity/Analytic%20Rules/SonraiTicketCommentAdded.yaml", "query_name": "Sonrai Ticket Escalation Executed", "query": "Sonrai_Tickets_CL\n| where action_d == 9\n", "attributes": {"description": "'Checks if Sonrai tickets have had a comment added. \nIt uses the action type to check if a ticket has had a comment added'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SonraiSecurity/Analytic%20Rules/SonraiTicketEscalationExecuted.yaml", "query_name": "Sonrai Ticket Escalation Executed", "query": "Sonrai_Tickets_CL\n| where action_d == 8\n", "attributes": {"description": "'Checks if Sonrai tickets have had an escalation executed. \nIt uses the action type to check if a ticket has had an escalation executed'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SonraiSecurity/Analytic%20Rules/SonraiTicketReopened.yaml", "query_name": "Sonrai Ticket Reopened", "query": "Sonrai_Tickets_CL\n| where action_d == 3\n", "attributes": {"description": "'Checks if Sonrai tickets have been reopened. \nIt uses the action type to check if a ticket has been reopened'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SonraiSecurity/Analytic%20Rules/SonraiTicketRiskAccepted.yaml", "query_name": "Sonrai Ticket Risk Accepted", "query": "Sonrai_Tickets_CL\n| where action_d == 7\n", "attributes": {"description": "'Checks if Sonrai tickets have had their risk accepted. \nIt uses the action type to check if a ticket has had it's risk accepted'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SonraiSecurity/Analytic%20Rules/SonraiTicketSnoozed.yaml", "query_name": "Sonrai Ticket Snoozed", "query": "Sonrai_Tickets_CL\n| where action_d == 6\n", "attributes": {"description": "'Checks if Sonrai tickets have been snoozed. \nIt uses the action type to check if a ticket has been snoozed'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SonraiSecurity/Analytic%20Rules/SonraiTicketUpdated.yaml", "query_name": "Sonrai Ticket Updated", "query": "Sonrai_Tickets_CL\n| where action_d == 5\n", "attributes": {"description": "'Checks if Sonrai tickets have been updated. \nIt uses the action type to check if a ticket has been updated'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Sophos%20XG%20Firewall/Analytic%20Rules/ExcessiveAmountofDeniedConnectionsfromASingleSource.yaml", "query_name": "Excessive Amount of Denied Connections from a Single Source", "query": "\nlet threshold = 5000;\nSophosXGFirewall\n| where Log_Type =~ \"Firewall\" and Status =~ \"Deny\"\n| summarize count() by Src_IP, bin(TimeGenerated,5m)\n| where count_ > threshold\n| extend timestamp = TimeGenerated, IPCustomEntity = Src_IP\n", "attributes": {"description": "'This creates an incident in the event that a single source IP address generates a excessive amount of denied connections.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Sophos%20XG%20Firewall/Analytic%20Rules/PortScanDetected.yaml", "query_name": "Port Scan Detected", "query": "\nlet threshold = 50;\nSophosXGFirewall\n| where Log_Type =~ \"Firewall\"\n| where not(ipv4_is_match(\"10.0.0.0\",Src_IP,8) or ipv4_is_match(\"172.16.0.0\",Src_IP,12) or ipv4_is_match(\"192.168.0.0\",Src_IP,16))\n| summarize dcount(Dst_Port) by Src_IP, bin(TimeGenerated, 5m)\n| where dcount_Dst_Port > threshold\n| extend timestamp = TimeGenerated, IPCustomEntity = Src_IP\n", "attributes": {"description": "'This alert creates an incident when a source IP addresses attempt to communicate with a large amount of distinct ports within a short period.'\n", "techniques": ["T1046"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Symantec%20Endpoint%20Protection/Analytic%20Rules/ExcessiveBlockedTrafficGeneratedbyUser.yaml", "query_name": "Excessive Blocked Traffic Events Generated by User", "query": "\nlet threshold = 15;\nlet NoteableEvents = SymantecEndpointProtection\n| where LogType == \"Agent Traffic Logs\"\n| where Action =~ \"Blocked\"\n| summarize TotalBlockedEvents = count() by UserName\n| where TotalBlockedEvents > threshold;\nSymantecEndpointProtection\n| where LogType =~ \"Agent Traffic Logs\"\n| where Action =~ \"Blocked\"\n| join kind=inner (NoteableEvents) on UserName\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), Total = count() by UserName, RuleName, ServerName, LocalHostIpAddr, LocalPortNumber, TrafficDirection, RemoteHostIpAddr, RemotePortNumber, ApplicationName\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserName, HostCustomEntity = ServerName, IPCustomEntity = LocalHostIpAddr\n", "attributes": {"description": "'Creates an incident when a Symantec Endpoint Proection agent detects excessive amounts of blocked traffic generated by a single user.'\n", "techniques": NaN, "tactics": NaN}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Symantec%20Endpoint%20Protection/Analytic%20Rules/MalwareDetected.yaml", "query_name": "Malware Detected", "query": "\nSymantecEndpointProtection\n| where LogType == \"Agent Risk Logs\"\n| where CategorySet == \"Malware\"\n| where ActualAction !contains \"Cleaned\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by SrcIpAddr, SrcHostName, UserName, FilePath, ActualAction, CategorySet, CategoryType \n| extend timestamp = StartTimeUtc, IPCustomEntity = SrcIpAddr, HostCustomEntity = SrcHostName, AccountCustomEntity = UserName\n", "attributes": {"description": "'Creates an incident when a Symantec Endpoint Proection agent detects malware and the malware was not cleaned.'\n", "techniques": NaN, "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Symantec%20VIP/Analytical%20Rules/ClientDeniedAccess.yaml", "query_name": "ClientDeniedAccess", "query": "\nlet threshold = 15;\nlet rejectedAccess = SymantecVIP\n| where isnotempty(RADIUSAuth)\n| where RADIUSAuth =~ \"Reject\"\n| summarize Total = count() by ClientIP, bin(TimeGenerated, 15m)\n| where Total > threshold\n| project ClientIP;\nSymantecVIP\n| where isnotempty(RADIUSAuth)\n| where RADIUSAuth =~ \"Reject\"\n| join kind=inner rejectedAccess on ClientIP\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by ClientIP, User\n| extend timestamp = StartTime, IPCustomEntity = ClientIP, AccountCustomEntity = User\n", "attributes": {"description": "'Creates an incident in the event a Client has an excessive amounts of denied access requests.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Symantec%20VIP/Analytical%20Rules/ExcessiveFailedAuthenticationsfromInvalidInputs.yaml", "query_name": "Excessive Failed Authentication from Invalid Inputs", "query": "\nlet threshold = 15;\nSymantecVIP\n| where isnotempty(RADIUSAuth)\n| where RADIUSAuth =~ \"Reject\"\n| summarize Total = count() by bin(TimeGenerated, 15m), User, ClientIP\n| where Total > threshold\n| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, AccountCustomEntity = User\n", "attributes": {"description": "'Creates an incident in the event that a user generates an excessive amount of failed authentications due to invalid inputs, indications of a potential brute force.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SymantecProxySG/Analytic%20Rules/ExcessiveDeniedProxyTraffic.yaml", "query_name": "Excessive Denied Proxy Traffic", "query": "\nlet threshold = 100;\nSymantecProxySG \n| where sc_filter_result =~ \"DENIED\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by c_ip, cs_host\n| where count_ > threshold\n| extend timestamp = StartTime, HostCustomEntity = cs_host, IPCustomEntity = c_ip\n", "attributes": {"description": "'This alert creates an incident when a client generates an excessive amounts of denied proxy traffic.'\n", "techniques": NaN, "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/SymantecProxySG/Analytic%20Rules/UserAccessedSuspiciousURLCategories.yaml", "query_name": "User Accessed Suspicious URL Categories", "query": "\nSymantecProxySG\n| mv-expand cs_categories\n| where cs_categories has_any (\"Suspicious\",\"phishing\", \"hacking\")\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by sc_filter_result, cs_userdn, c_ip, cs_host, Computer,  tostring(cs_categories)\n| extend timestamp = StartTime, AccountCustomEntity = cs_userdn, IPCustomEntity = c_ip, HostCustomEntity = Computer\n", "attributes": {"description": "'Creates an incident in the event the requested URL accessed by the user has been identified as Suspicious, Phishing, or Hacking.'\n", "techniques": NaN, "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tanium/Analytic%20Rules/TaniumThreatResponseAlerts.yaml", "query_name": "Tanium Threat Response Alerts", "query": "let cap = (s:string) { strcat(toupper(substring(s,0,1)), substring(s,1))  };\nTaniumThreatResponse_CL\n| extend TaniumUrl = pack(\"computer_name\", Computer_Name_s, \"alert_guid\", Alert_Id_g, \"ip_address\", Computer_IP_s, \"platform\", Match_Details_finding_system_info_platform_s)\n| extend TaniumTHRLabel = strcat(cap(Intel_Type_s),\" - \", cap(Intel_Name_s), \" - \", cap(Match_Details_match_type_s))\n| where Computer_IP_s !contains \"N/A\"\n", "attributes": {"description": "Alerts from Tanium Threat Response (THR) that can be acted upon by Microsoft Sentinel Playbook", "techniques": [], "tactics": []}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdADAttacksPathways.yaml", "query_name": "Tenable.ad Active Directory attacks pathways", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nlet SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nlet codeNameList = datatable(Codename:string)[\"C-PRIV-ACCOUNTS-SPN\", \"C-SDPROP-CONSISTENCY\", \"C-DANG-PRIMGROUPID\", \"C-GPO-HARDENING\", \"C-DC-ACCESS-CONSISTENCY\", \"C-DANGEROUS-TRUST-RELATIONSHIP\", \"C-UNCONST-DELEG\", \"C-ABNORMAL-ENTRIES-IN-SCHEMA\"];\nafad_parser\n| where MessageType == 0 and Codename in~ (codeNameList)\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures related to Active Directory attacks pathways.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdDCShadow.yaml", "query_name": "Tenable.ad DCShadow", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nafad_parser\n  | where MessageType == 2 and Codename == \"DCShadow\"\n", "attributes": {"description": "'Searches for DCShadow attacks.'\n", "techniques": ["T1207"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdDCSync.yaml", "query_name": "Tenable.ad DCSync", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nafad_parser\n  | where MessageType == 2 and Codename == \"DCSync\"\n", "attributes": {"description": "'Searches for DCSync attacks.'\n", "techniques": ["T1003.006"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdGoldenTicket.yaml", "query_name": "Tenable.ad Golden Ticket", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nafad_parser\n  | where MessageType == 2 and Codename == \"Golden Ticket\"\n", "attributes": {"description": "'Searches for Golden Ticket attacks.'\n", "techniques": ["T1558.001"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdIndicatorsOfAttack.yaml", "query_name": "Tenable.ad Indicators of Attack", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nlet SeverityTable=datatable(Severity:string,Level:int) [\n  \"low\", 1,\n  \"medium\", 2,\n  \"high\", 3,\n  \"critical\", 4\n  ];\n  afad_parser\n  | where MessageType == 2\n  | lookup kind=leftouter SeverityTable on Severity\n  | order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Attack.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdIndicatorsOfExposures.yaml", "query_name": "Tenable.ad Indicators of Exposures", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nlet SeverityTable=datatable(Severity:string,Level:int) [\n  \"low\", 1,\n  \"medium\", 2,\n  \"high\", 3,\n  \"critical\", 4\n  ];\n  afad_parser\n  | where MessageType == 0\n  | lookup kind=leftouter SeverityTable on Severity\n  | order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdLSASSMemory.yaml", "query_name": "Tenable.ad LSASS Memory", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nafad_parser\n  | where MessageType == 2 and Codename == \"OS Credential Dumping: LSASS Memory\"\n", "attributes": {"description": "'Searches for OS Credentials dumping attacks.'\n", "techniques": ["T1003.001"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdPasswordGuessing.yaml", "query_name": "Tenable.ad Password Guessing", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nafad_parser\n  | where MessageType == 2 and Codename == \"Password Guessing\"\n", "attributes": {"description": "'Searches for bruteforce Password Guessing attacks.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdPasswordIssues.yaml", "query_name": "Tenable.ad Password issues", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nlet SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nlet codeNameList = datatable(Codename:string)[\"C-CLEARTEXT-PASSWORD\", \"C-PASSWORD-DONT-EXPIRE\", \"C-USER-REVER-PWDS\", \"C-PASSWORD-POLICY\", \"C-USER-PASSWORD\", \"C-KRBTGT-PASSWORD\", \"C-AAD-SSO-PASSWORD\", \"C-REVER-PWD-GPO\"];\nafad_parser\n| where MessageType == 0 and Codename in~ (codeNameList)\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures related to password issues.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdPasswordSpraying.yaml", "query_name": "Tenable.ad Password Spraying", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nafad_parser\n  | where MessageType == 2 and Codename == \"Password Spraying\"\n", "attributes": {"description": "'Searches for Password spraying attacks.'\n", "techniques": ["T1110.003"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdPrivilegedAccountIssues.yaml", "query_name": "Tenable.ad privileged accounts issues", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nlet SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nlet codeNameList = datatable(Codename:string)[\"C-PRIV-ACCOUNTS-SPN\", \"C-NATIVE-ADM-GROUP-MEMBERS\", \"C-KRBTGT-PASSWORD\", \"C-PROTECTED-USERS-GROUP-UNUSED\", \"C-ADMINCOUNT-ACCOUNT-PROPS\", \"C-ADM-ACC-USAGE\", \"C-LAPS-UNSECURE-CONFIG\", \"C-DISABLED-ACCOUNTS-PRIV-GROUPS\"];\nafad_parser\n| where MessageType == 0 and Codename in~ (codeNameList)\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures related to privileged accounts issues.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/TenableAD/Analytic%20Rules/TenableAdUserAccountIssues.yaml", "query_name": "Tenable.ad user accounts issues", "query": "// For the query to work properly, make sure you have imported the afad_parser.kql parser into the workspace\n// Retrieve the parser here: https://raw.githubusercontent.com/tenable/Azure-Sentinel/Tenable.ad-connector/Solutions/TenableAD/Parsers/afad_parser.kql\n// Then, create the Kusto Function with alias afad_parser\nlet SeverityTable=datatable(Severity:string,Level:int) [\n\"low\", 1,\n\"medium\", 2,\n\"high\", 3,\n\"critical\", 4\n];\nlet codeNameList = datatable(Codename:string)[\"C-ACCOUNTS-DANG-SID-HISTORY\", \"C-PRE-WIN2000-ACCESS-MEMBERS\", \"C-PASSWORD-DONT-EXPIRE\", \"C-SLEEPING-ACCOUNTS\", \"C-DANG-PRIMGROUPID\", \"C-PASSWORD-NOT-REQUIRED\", \"C-USER-PASSWORD\"];\nafad_parser\n| where MessageType == 0 and Codename in~ (codeNameList)\n| lookup kind=leftouter SeverityTable on Severity\n| order by Level\n", "attributes": {"description": "'Searches for triggered Indicators of Exposures related to user accounts issues.'\n", "techniques": ["T1110"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatCommandsinRequest.yaml", "query_name": "Tomcat - Commands in URI", "query": "let commands = dynamic(['cat%20/etc/passwd', '/etc/passwd', 'ping -i', '/usr/bin/id(', '%2f%75%73%72%2f%62%69%6e%2f%69%64', 'phpinfo()', '%70%68%70%69%6e%66%6f%28%29', ';id', '%3b%69%64', '/bin/bash -c', '%2f%62%69%6e%2f%62%61%73%68%20%2d%63%27', '/bin/bash', '%2f%62%69%6e%2f%62%61%73%68', 'sleep(', '%73%6c%65%65%70%28', 'curl', '%63%75%72%6c', '&dir', '%26%64%69%72', '& dir', '%26%20%64%69%72', '<script>', '%3c%73%63%72%69%70%74%3e', 'eval(', '%65%76%61%6c%28', 'exec(', '%65%78%65%63%28', 'whoami', '%77%68%6f%61%6d%69', 'wget', 'python', 'gcc', 'uname', 'systeminfo', '%70%79%74%68%6f%6e', '%75%6e%61%6d%65', '%73%79%73%74%65%6d%69%6e%66%6f']);\nTomcatEvent\n| where UrlOriginal has_any (commands)\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects commands in URI'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatKnownMaliciousUserAgent.yaml", "query_name": "Tomcat - Known malicious user agent", "query": "let malicious_ua = dynamic(['Nikto', 'hydra', '.nasl', 'absinthe', 'advanced email extractor', 'arachni', 'autogetcontent', 'bilbo', 'BFAC', 'brutus', 'brutus/aet', 'bsqlbf', 'cgichk', 'cisco-torch', 'commix', 'core-project', 'crimscanner', 'datacha0s', 'dirbuster', 'domino hunter', 'dotdotpwn', 'email extractor', 'fhscan core', 'floodgate', 'get-minimal', 'gootkit auto-rooter scanner', 'grabber', 'grendel-scan', 'havij', 'inspath', 'internet ninja', 'jaascois', 'zmeu', 'masscan', 'metis', 'morfeus', 'mysqloit', 'n-stealth', 'nessus', 'netsparker', 'nmap nse', 'nmap scripting engine', 'nmap-nse', 'nsauditor', 'openvas', 'pangolin', 'paros', 'pmafind', 'prog.customcrawler', 'qualys was', 's.t.a.l.k.e.r.', 'security scan', 'springenwerk', 'sql power injector', 'sqlmap', 'sqlninja', 'teh forest lobster', 'this is an exploit', 'toata dragostea', 'toata dragostea mea pentru diavola', 'uil2pn', 'vega', 'voideye', 'w3af.sf.net', 'w3af.sourceforge.net', 'w3af.org', 'webbandit', 'webinspect', 'webshag', 'webtrends security analyzer', 'webvulnscan', 'whatweb', 'whcc', 'wordpress hash grabber', 'xmlrpc exploit', 'WPScan', 'XSpider', 'SF/', 'FooBar/42', 'ScanAlert', 'Webscanner', 'Webster', 'fantomCrew', 'fantomBrowser', 'visvo', 'magereport', 'ltx71', 'websiteprotection', 'BigCliqueBOT', 'BOT for JCE']);\nTomcatEvent\n| where HttpUserAgentOriginal has_any (malicious_ua)\n| extend MalwareCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Detects known malicious user agents'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatMultipleClientErrorsFromSingleIP.yaml", "query_name": "Tomcat - Multiple client errors from single IP address", "query": "let threshold = 100;\nTomcatEvent\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499 \n| summarize MultipleClientErrors = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where MultipleClientErrors > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple client errors from one source in short timeframe'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatMultipleEmptyRequestsFromSameIP.yaml", "query_name": "Tomcat - Multiple empty requests from same IP", "query": "let threshold = 50;\nTomcatEvent\n| where HttpResponseBodyBytes == 0\n| summarize MultipleClientErrors = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where MultipleClientErrors > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple empty requests from same IP'\n", "techniques": ["T1190", "T1133", "T1499"], "tactics": ["InitialAccess", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatMultipleServerErrorsFromSingleIP.yaml", "query_name": "Tomcat - Multiple server errors from single IP address", "query": "let threshold = 100;\nTomcatEvent\n| where HttpStatusCode >= 500 and HttpStatusCode <= 599 \n| summarize MultipleServerErrors = count() by SrcIpAddr, bin(TimeGenerated, 5m)\n| where MultipleServerErrors > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple server errors from one source in short timeframe'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatPutAndGetFileFromSameIP.yaml", "query_name": "Tomcat - Put file and get file from same IP address", "query": "let p = TomcatEvent\n| where HttpRequestMethod in~ ('POST', 'PUT')\n| sort by EventStartTime asc\n| summarize post_time=min(EventStartTime) by SrcIpAddr, tostring(UrlOriginal);\nTomcatEvent\n| where HttpRequestMethod =~ 'GET'\n| sort by EventStartTime asc\n| summarize get_time=min(EventStartTime) by SrcIpAddr, tostring(UrlOriginal)\n| join kind=innerunique (p) on UrlOriginal, SrcIpAddr\n| extend second = datetime_diff('second',get_time,post_time)\n| where second between (1 .. 300)\n| project second, post_time, get_time, SrcIpAddr, UrlOriginal\n| extend IPCustomEntity = SrcIpAddr, UrlCustomEntity = tostring(UrlOriginal)\n", "attributes": {"description": "'Detects put or get files from one source in short timeframe' \n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatRequestFromLocalhostIP.yaml", "query_name": "Tomcat - Request from localhost IP address", "query": "TomcatEvent\n| where SrcIpAddr == \"127.0.0.1\"\n| extend File = extract(@'(.*\\/)?(.*)', 2, tostring(UrlOriginal))\n| extend IPCustomEntity = SrcIpAddr, FileCustomEntity = File\n", "attributes": {"description": "'Detects request from localhost IP address.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatRequestSensitiveFiles.yaml", "query_name": "Tomcat - Request to sensitive files", "query": "let forbidden_files = dynamic(['shadow', 'passwd', 'id_rsa']);\nTomcatEvent\n| extend File = extract(@'(.*\\/)?(.*)', 2, tostring(UrlOriginal))\n| where File in (forbidden_files)\n| extend FileCustomEntity = File, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects request to sensitive files.'\n", "techniques": ["T1189"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatServerErrorsAfterMultipleRequestsFromSameIP.yaml", "query_name": "Tomcat - Server errors after multiple requests from same IP", "query": "let multi_errors = TomcatEvent\n| where toint(HttpStatusCode) >= 500 and toint(HttpStatusCode) <= 599\n| sort by EventStartTime asc\n| summarize MultipleServerErrors = count() by SrcIpAddr, bin(EventStartTime, 5m)\n| where MultipleServerErrors > 10;\nlet error_time_table = TomcatEvent\n| where toint(HttpStatusCode) >= 500 and toint(HttpStatusCode) <= 599\n| summarize error_time=min(EventStartTime) by SrcIpAddr\n| join kind=innerunique (multi_errors) on SrcIpAddr;\nTomcatEvent\n| where toint(HttpStatusCode) >= 100 and toint(HttpStatusCode) <= 399\n| summarize success_time=max(EventStartTime) by SrcIpAddr\n| join kind=innerunique (error_time_table) on SrcIpAddr\n| extend time_between_error_and_success = datetime_diff('second', error_time, success_time)\n| where time_between_error_and_success between (1 .. 300)\n| project time_between_error_and_success, error_time, success_time, SrcIpAddr\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects server errors after multiple requests from same IP address.'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Analytic%20Rules/TomcatSQLiPattern.yaml", "query_name": "Tomcat - Sql injection patterns", "query": "let commands = dynamic([\"1/*'*/\", \"1'||'asd'||'\", \"'1'='1\", \"1' or '1'='1\", \"1 or 1=1\", \"1=1\", \"1/*!1111'*/\", \"'or''='\"]);\nTomcatEvent\n| where UrlOriginal has_any (commands)\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects possible sql injection patterns'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/Tomcat403RequestsFiles.yaml", "query_name": "Tomcat - Request to forbidden file", "query": "TomcatEvent\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode == 403\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows request to forbidden files.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatAbnormalRequestSize.yaml", "query_name": "Tomcat - Abnormal request size", "query": "let Average_Body_Bytes = TomcatEvent\n| where TimeGenerated > ago(30d)\n| summarize Avg_Size = avg(HttpResponseBodyBytes)\n| extend K = 1;\nTomcatEvent\n| where TimeGenerated > ago(24h)\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| extend K = 1\n| join kind=inner Average_Body_Bytes on K\n| where tolong(HttpResponseBodyBytes) > Avg_Size\n| extend FileCustomEntity = File, UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows abnormal request size.'\n", "techniques": ["T1530", "T1537"], "tactics": ["Exfiltration", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatERRORs.yaml", "query_name": "Tomcat - Catalina errors", "query": "TomcatEvent\n| where TimeGenerated > ago(24d)\n| where EventType =~ 'ErrorLog'\n| where EventMessage has \"error\"\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows errors events.'\n", "techniques": ["T1070"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatRareFilesRequested.yaml", "query_name": "Tomcat - Rare files requested", "query": "TomcatEvent\n| where TimeGenerated > ago(24h)\n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| summarize RareFiles = count() by File\n| top 20 by RareFiles asc\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows rare files requested'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatRareURLsRequested.yaml", "query_name": "Tomcat - Rare URLs requested", "query": "TomcatEvent\n| where TimeGenerated > ago(24h)\n| summarize count() by tostring(UrlOriginal)\n| top 20 by count_ asc\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows rare URLs requested.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatTopFilesWithErrorRequests.yaml", "query_name": "Tomcat - Top files with error requests", "query": "TomcatEvent\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 599 \n| extend File = extract(@\"(.*\\/)?(.*)\", 2, tostring(UrlOriginal))\n| where isnotempty(File)\n| summarize TotalFile = count() by File\n| top 20 by TotalFile desc\n| extend FileCustomEntity = File\n", "attributes": {"description": "'Query shows list of files with error requests.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatTopURLsClientErrors.yaml", "query_name": "Tomcat - Top URLs client errors", "query": "TomcatEvent\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499\n| summarize TopUrls = count() by (tostring(UrlOriginal))\n| top 20 by TopUrls desc\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows URLs list with client errors.'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatTopURLsServerErrors.yaml", "query_name": "Tomcat - Top URLs server errors", "query": "TomcatEvent\n| where TimeGenerated > ago(24h)\n| where HttpStatusCode >= 500 and HttpStatusCode <= 599\n| summarize TopUrls = count() by tostring(UrlOriginal)\n| top 20 by TopUrls desc\n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Query shows URLs list with server errors.'\n", "techniques": ["T1498", "T1190", "T1133"], "tactics": ["Impact", "InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatUncommonUAs.yaml", "query_name": "Tomcat - Uncommon user agent strings", "query": "let ua_length = 20;\nTomcatEvent\n| where TimeGenerated > ago(24h)\n| where strlen(HttpUserAgentOriginal) < ua_length\n| extend UrlCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Query searches uncommon user agent strings.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatUncommonUAsWithClientErrors.yaml", "query_name": "Tomcat - Rare user agents with client errors", "query": "TomcatEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(HttpUserAgentOriginal)\n| where HttpStatusCode >= 400 and HttpStatusCode <= 499\n| summarize UAs = count() by (tostring(HttpUserAgentOriginal))\n| top 20 by UAs asc\n| extend UrlCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Query shows rare user agent strings with client errors'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Tomcat/Hunting%20Queries/TomcatUncommonUAsWithServerErrors.yaml", "query_name": "Tomcat - Rare user agents with server errors", "query": "TomcatEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(HttpUserAgentOriginal)\n| where HttpStatusCode >= 500 and HttpStatusCode <= 599\n| summarize UAs = count() by tostring(HttpUserAgentOriginal)\n| top 20 by UAs asc\n| extend UrlCustomEntity = HttpUserAgentOriginal\n", "attributes": {"description": "'Query shows rare user agent strings with server errors'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOneAttackDiscoveryDetectionRisks.yaml", "query_name": "ApexOne - Attack Discovery Detection", "query": "TMApexOneEvent\n| where EventMessage has \"Attack Discovery Detection\"\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects Attack Discovery Detection events.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOneCommandLineSuspiciousRequests.yaml", "query_name": "ApexOne - Suspicious commandline arguments", "query": "TMApexOneEvent\n| where EventMessage has \"Endpoint Application\"\n| where Command has_any (\"whoami\", \"dpkg\", \"useradd\", \"sudo\")\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects suspicious commandline arguments.'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOneCommandsInRequest.yaml", "query_name": "ApexOne - Commands in Url", "query": "TMApexOneEvent\n| where EventSubType in (\"WB:7\", \"CnC:Block\", \"VAD\", \"700106\") \n| where UrlOriginal contains 'cat%20/etc/passwd' or UrlOriginal contains '/etc/passwd' or UrlOriginal contains 'ping -i' or UrlOriginal contains '/usr/bin/id(' or UrlOriginal contains '%2f%75%73%72%2f%62%69%6e%2f%69%64' or UrlOriginal contains 'phpinfo()' or UrlOriginal contains '%70%68%70%69%6e%66%6f%28%29' or UrlOriginal contains ';id' or UrlOriginal contains '%3b%69%64' or UrlOriginal contains '/bin/bash -c' or UrlOriginal contains '%2f%62%69%6e%2f%62%61%73%68%20%2d%63%27' or UrlOriginal contains '/bin/bash' or UrlOriginal contains '%2f%62%69%6e%2f%62%61%73%68' or UrlOriginal contains 'sleep(' or UrlOriginal contains '%73%6c%65%65%70%28' or UrlOriginal contains 'curl' or UrlOriginal contains '%63%75%72%6c' or UrlOriginal contains '&dir' or UrlOriginal contains '%26%64%69%72' or UrlOriginal contains '& dir' or UrlOriginal =~ '%26%20%64%69%72' or UrlOriginal contains '<script>' or UrlOriginal  contains '%3c%73%63%72%69%70%74%3e' or UrlOriginal contains 'eval(' or UrlOriginal contains '%65%76%61%6c%28' or UrlOriginal contains 'exec(' or UrlOriginal contains '%65%78%65%63%28' or UrlOriginal contains 'whoami' or UrlOriginal contains '%77%68%6f%61%6d%69' or UrlOriginal contains 'wget' or UrlOriginal contains 'python' or UrlOriginal contains 'gcc' or UrlOriginal contains 'uname' or UrlOriginal contains 'systeminfo' or UrlOriginal contains '%77%67%65%74' or UrlOriginal contains '%70%79%74%68%6f%6e' or UrlOriginal contains '%75%6e%61%6d%65' or UrlOriginal =~ '%73%79%73%74%65%6d%69%6e%66%6f' \n| extend UrlCustomEntity = UrlOriginal\n", "attributes": {"description": "'Detects commands in Url.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOneDvcAccessPermissionWasChanged.yaml", "query_name": "ApexOne - Device access permissions was changed", "query": "let threshold = 1;\nTMApexOneEvent\n| where EventMessage has \"Device access\"\n| extend DeviceCustomNumber3 = coalesce(\n                                  column_ifexists(\"FieldDeviceCustomNumber3\", long(null)),\n                                  DeviceCustomNumber3,\n                                  long(null)\n                              )\n| extend Permission = case(\n                            DeviceCustomNumber3 == \"0\", \"Modify\", \n                            DeviceCustomNumber3 == \"1\", \"Read and execute\",\n                            DeviceCustomNumber3 == \"2\", \"Read\",\n                            DeviceCustomNumber3 == \"3\", \"List device content only\", \n                            DeviceCustomNumber3 == \"4\", \"Block\",\n                            \"unknown\"\n                      )\n| summarize Permissions = make_set(Permission) by DstUserName\n| extend PermissionCount = array_length(Permissions)\n| where PermissionCount > threshold\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query shows device access permissions was changed.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOneInboundRemoteAccess.yaml", "query_name": "ApexOne - Inbound remote access connection", "query": "TMApexOneEvent\n| where EventSubType has \"WB\"\n| where NetworkDirection == 1\n| where ApplicationProtocol in ('15', '17', '20', '22', '23', '27', '36', '37')\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects inbound remote access connection.'\n", "techniques": ["T1021"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOneMultipleDenyOrTerminateActionOnSingleIp.yaml", "query_name": "ApexOne - Multiple deny or terminate actions on single IP", "query": "let threshold = 5;\nTMApexOneEvent\n| where EventMessage has \"Behavior Monitoring\"\n| where DvcAction == 2 or DvcAction == 3\n| summarize count() by SrcIpAddr, bin(TimeGenerated, 10m)\n| where count_ > threshold\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects multiple deny or terminate actions on single IP.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOnePossibleExploitOrExecuteOperation.yaml", "query_name": "ApexOne - Possible exploit or execute operation", "query": "TMApexOneEvent\n| where EventMessage has \"Behavior Monitoring\"\n| extend DeviceCustomNumber3 = coalesce(column_ifexists(\"FieldDeviceCustomNumber3\", int(null)),DeviceCustomNumber3)\n| where Event_Type == 2048 or DeviceCustomNumber3 == 403 or DeviceCustomNumber3 == 601\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects possible exploit or execute operation.'\n", "techniques": ["T1546"], "tactics": ["PrivilegeEscalation", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOneRiskCnCEvents.yaml", "query_name": "ApexOne - C&C callback events", "query": "TMApexOneEvent\n| where EventMessage has \"CnC Callback\"\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects C&C callback events.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOneSpywareWithFailedResponse.yaml", "query_name": "ApexOne - Spyware with failed response", "query": "TMApexOneEvent\n| where EventMessage has \"Spyware Detected\"\n| where ActionResult has_any (\"No action\", \"Unable to\")\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects spyware with failed response.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Analytic%20Rules/TMApexOneSuspiciousConnections.yaml", "query_name": "ApexOne - Suspicious connections", "query": "TMApexOneEvent\n| where EventMessage has \"Suspicious Connection\"\n| where NetworkDirection == 1 \n| where DvcAction in ('1', '3')\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects suspicious connections.'\n", "techniques": ["T1102"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneBehaviorMonitoringTranslatedAction.yaml", "query_name": "ApexOne - Behavior monitoring actions by files", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where EventMessage has \"Behavior Monitoring\"\n| where isnotempty(DvcAction)\n| extend TranslatedAction = case(\nDvcAction == \"0\", \"Allow\", \nDvcAction == \"1\", \"Ask\",\nDvcAction == \"2\", \"Deny\",\nDvcAction == \"3\", \"Terminate\", \nDvcAction == \"4\", \"Read Only\",\nDvcAction == \"5\", \"Read/Write Only\",\nDvcAction == \"6\", \"Read/Execute Only\", \nDvcAction == \"7\", \"Feedback\",\nDvcAction == \"8\", \"Clean\",\nDvcAction == \"1002\", \"Unknown\", \nDvcAction == \"1003\", \"Assess\",\nDvcAction == \"1004\", \"Terminated. Files were recovered.\",\nDvcAction == \"1005\", \"Terminated. Some files were not recovered.\", \nDvcAction == \"1006\", \"Terminated. Files were not recovered.\",\nDvcAction == \"1007\", \"Terminated. Restart result: Files were recovered.\",\nDvcAction == \"1008\", \"Terminated: Restart result: Some files were not recovered.\", \nDvcAction == \"1009\", \"Terminated: Restart result: Riles were not recovered.\",\n\"unknown\")\n| summarize ActionByFiles = count() by TranslatedAction, FileName\n| top 20 by ActionByFiles asc\n| extend FileCustomEntity = FileName\n", "attributes": {"description": "'Shows behavior monitoring actions taken for files.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneBehaviorMonitoringTranslatedOperation.yaml", "query_name": "ApexOne - Behavior monitoring operations by users", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where EventMessage has \"Behavior Monitoring\"\n| extend DeviceCustomNumber3 = coalesce(\n                                  column_ifexists(\"FieldDeviceCustomNumber3\", long(null)),\n                                  DeviceCustomNumber3,\n                                  long(null)\n                              )\n| where isnotempty(DeviceCustomNumber3)\n| extend Translatedoperation = case(\nDeviceCustomNumber3 == \"101\", \"Create Process\", \nDeviceCustomNumber3 == \"102\", \"Open\",\nDeviceCustomNumber3 == \"103\", \"Terminate\",\nDeviceCustomNumber3 == \"104\", \"Terminate\", \nDeviceCustomNumber3 == \"301\", \"Delete\",\nDeviceCustomNumber3 == \"302\", \"Write\",\nDeviceCustomNumber3 == \"303\", \"Access\", \nDeviceCustomNumber3 == \"401\", \"Create File\",\nDeviceCustomNumber3 == \"402\", \"Close\",\nDeviceCustomNumber3 == \"403\", \"Execute\", \nDeviceCustomNumber3 == \"501\", \"Invoke\",\nDeviceCustomNumber3 == \"601\", \"Exploit\",\nDeviceCustomNumber3 == \"9999\", \"Unhandled Operation\",\n\"unknown\")\n| summarize OperationCount = count() by Translatedoperation, DstUserName\n| sort by OperationCount desc \n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Shows behavior monitoring operations by users.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneBehaviorMonitoringTriggeredPolicy.yaml", "query_name": "ApexOne - Behavior monitoring triggered policy by command line", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where EventMessage has \"Behavior Monitoring\"\n| where isnotempty(Policy)\n| extend TriggeredPolicy = case(\nPolicy == \"0\", \"Compromised executable file\", \nPolicy == \"1\", \"New startup program\",\nPolicy == \"2\", \"Host file modification\",\nPolicy == \"3\", \"Program library injection\", \nPolicy == \"4\", \"New Internet Explorer plugin\",\nPolicy == \"5\", \"Internet Explorer setting modification\",\nPolicy == \"6\", \"Shell modification\", \nPolicy == \"7\", \"New service\",\nPolicy == \"8\", \"Security policy modification\",\nPolicy == \"9\", \"Firewall policy modification\", \nPolicy == \"10\", \"System file modification\",\nPolicy == \"11\", \"Duplicated system file\",\nPolicy == \"13\", \"Layered service provider\", \nPolicy == \"14\", \"System process modification\",\nPolicy == \"16\", \"Suspicious behavior\",\nPolicy == \"100\", \"Newly encountered programs\", \nPolicy == \"200\", \"Unauthorized file encryption\",\nPolicy == \"1000\", \"Threat behavior analysis\",\nPolicy == \"9999\", \"User-defined policy\",\n\"unknown\")\n| summarize PolicyCount = count() by TriggeredPolicy, ProcessCommandLine\n| extend ProcessCustomEntity = ProcessCommandLine\n", "attributes": {"description": "'Shows behavior monitoring triggered policy by command line.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneBehaviorMonitoringTypesOfEvent.yaml", "query_name": "ApexOne - Behavior monitoring event types by users", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where EventMessage has \"Behavior Monitoring\"\n| where isnotempty(Event_Type)\n| extend TypeOfEvent= case(\nEvent_Type == \"1\", \"Process\",\nEvent_Type == \"2\", \"Process image\",\nEvent_Type == \"4\", \"Registry\",\nEvent_Type == \"8\", \"File system\",\nEvent_Type == \"16\", \"Driver\",\nEvent_Type == \"32\", \"SDT\", \nEvent_Type == \"64\", \"System API\",\nEvent_Type == \"128\", \"User Mode\",\nEvent_Type == \"2048\", \"Exploit\",\nEvent_Type == \"65535\", \"All\",\n\"unknown\")\n| summarize EventTypeCount = count() by TypeOfEvent, DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Shows behavior monitoring event types.'\n", "techniques": ["T1546"], "tactics": ["Privilege Escalation", "Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneChannelType.yaml", "query_name": "ApexOne - Channel type by users", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where EventMessage has \"Data Loss Prevention\"\n| extend DeviceCustomNumber3 = coalesce(\n                                  column_ifexists(\"FieldDeviceCustomNumber3\", long(null)),\n                                  DeviceCustomNumber3,\n                                  long(null)\n                              )\n| where isnotempty(DeviceCustomNumber3)\n| extend DlpAction = case(\nDeviceCustomNumber3 == \"65535\", \"Not available\",\nDeviceCustomNumber3 == \"0\", \"Removable storage\", \nDeviceCustomNumber3 == \"1\", \"SMB\",\nDeviceCustomNumber3 == \"2\", \"Email\",\nDeviceCustomNumber3 == \"3\", \"IM\", \nDeviceCustomNumber3 == \"4\", \"FTP\",\nDeviceCustomNumber3 == \"5\", \"HTTP\",\nDeviceCustomNumber3 == \"6\", \"HTTPS\", \nDeviceCustomNumber3 == \"7\", \"PGP\",\nDeviceCustomNumber3 == \"8\", \"Data recorders\",\nDeviceCustomNumber3 == \"9\", \"Printer\", \nDeviceCustomNumber3 == \"10\", \"Clipboard\",\nDeviceCustomNumber3 == \"11\", \"Sync\",\nDeviceCustomNumber3 == \"12\", \"P2P\",\nDeviceCustomNumber3 == \"13\", \"Webmail\", \nDeviceCustomNumber3 == \"14\", \"Document management\",\nDeviceCustomNumber3 == \"15\", \"Cloud storage\",\nDeviceCustomNumber3 == \"121\", \"SMTP email\",\nDeviceCustomNumber3 == \"122\", \"Exchange Client Mail\", \nDeviceCustomNumber3 == \"123\", \"Lotus Note Email\",\nDeviceCustomNumber3 == \"130\", \"Webmail (Yahoo! Mail)\",\nDeviceCustomNumber3 == \"131\", \"Webmail (Hotmail)\",\nDeviceCustomNumber3 == \"132\", \"Webmail (Gmail)\",\nDeviceCustomNumber3 == \"133\", \"Webmail (AOL Mail)\",\nDeviceCustomNumber3 == \"140\", \"IM (MSN)\",\nDeviceCustomNumber3 == \"141\", \"IM (AIM)\",\nDeviceCustomNumber3 == \"142\", \"IM (Yahoo Messenger)\",\nDeviceCustomNumber3 == \"143\", \"IM (Skype)\",\nDeviceCustomNumber3 == \"191\", \"P2P (BitTorrent)\",\nDeviceCustomNumber3 == \"192\", \"P2P (EMule)\",\nDeviceCustomNumber3 == \"193\", \"P2P (Winny)\",\nDeviceCustomNumber3 == \"194\", \"P2P (HTCSYN)\",\nDeviceCustomNumber3 == \"195\", \"P2P (iTunes)\",\nDeviceCustomNumber3 == \"196\", \"Cloud storage (DropBox)\",\nDeviceCustomNumber3 == \"197\", \"Cloud storage (Box)\",\nDeviceCustomNumber3 == \"198\", \"Cloud storage (Google Drive)\",\nDeviceCustomNumber3 == \"199\", \"Cloud storage (OneDrive)\",\nDeviceCustomNumber3 == \"200\", \"Cloud storage (SugarSync)\",\nDeviceCustomNumber3 == \"201\", \"Cloud storage (Hightail)\",\nDeviceCustomNumber3 == \"202\", \"IM (QQ)\",\nDeviceCustomNumber3 == \"203\", \"Webmail (other)\",\nDeviceCustomNumber3 == \"204\", \"Cloud storage (Evernote)\",\nDeviceCustomNumber3 == \"211\", \"Document management (SharePoint)\",\n\"unknown\")\n| summarize ChannelType = count() by DlpAction, DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Shows channel type.'\n", "techniques": ["T1071"], "tactics": ["CommandandControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneDataLossPreventionAction.yaml", "query_name": "ApexOne - Data loss prevention action by IP", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where EventMessage has \"Data Loss Prevention\"\n| extend DlpAction = case(\nAction == \"-1\", \"Not available\",\nAction == \"0\", \"Blocked\", \nAction == \"1\", \"Deleted\",\nAction == \"2\", \"Delivered\",\nAction == \"3\", \"Logged\", \nAction == \"4\", \"Passed\",\nAction == \"5\", \"Quarantined\",\nAction == \"6\", \"Replaced\", \nAction == \"7\", \"Archived\",\nAction == \"8\", \"Archived (message body only)\",\nAction == \"9\", \"Quarantined (message body only)\", \nAction == \"10\", \"Passed (message body only)\",\nAction == \"11\", \"Encrypted\",\nAction == \"12\", \"Alerted (endpoint)\",\nAction == \"13\", \"Alerted (server)\", \nAction == \"14\", \"Data recorded\",\nAction == \"15\", \"User justified\",\nAction == \"16\", \"Handed off\",\nAction == \"17\", \"Recipient altered\", \nAction == \"18\", \"Blind carbon copied\",\nAction == \"19\", \"Delivery postponed\",\nAction == \"20\", \"Stamped\",\nAction == \"21\", \"Attachment deleted\",\nAction == \"22\", \"Subject tagged\",\nAction == \"23\", \"X-header tagged\",\nAction == \"24\", \"Decrypted\",\nAction == \"25\", \"Re-encrypted\",\nAction == \"26\", \"Tagged (mail)\",\nAction == \"27\", \"Encrypted (user key)\",\nAction == \"28\", \"Encrypted (group key)\",\nAction == \"29\", \"Moved\",\nAction == \"30\", \"Passed (encrypted)\",\nAction == \"31\", \"Passed (user justified)\",\nAction == \"32\", \"Blocked (Endpoint Encryption not installed)\",\nAction == \"33\", \"Blocked (user justified)\",\nAction == \"34\", \"Blocked (Endpoint Encryption logged off)\",\nAction == \"35\", \"Blocked (Endpoint Encryption error)\",\nAction == \"36\", \"web upload\",\n\"unknown\")\n| summarize ActionCount = count() by DlpAction, SrcIpAddr, FileName\n| sort by ActionCount desc \n| extend IPCustomEntity = SrcIpAddr, FileCustomEntity = FileName\n", "attributes": {"description": "'Shows data loss prevention action by IP address.'\n", "techniques": ["T1213"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneRareAppProtocolByIP.yaml", "query_name": "ApexOne - Rare application protocols by Ip address", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(ApplicationProtocol)\n| extend AppProtocol = case(\nApplicationProtocol == \"0\", \"Unknown\", \nApplicationProtocol == \"1\", \"SMTP\",\nApplicationProtocol == \"2\", \"POP3\",\nApplicationProtocol == \"3\", \"IRC\", \nApplicationProtocol == \"4\", \"DNS Response\",\nApplicationProtocol == \"5\", \"HTTP\",\nApplicationProtocol == \"6\", \"FTP\", \nApplicationProtocol == \"7\", \"TFTP\",\nApplicationProtocol == \"8\", \"SMB\",\nApplicationProtocol == \"9\", \"Windows Live Messenger (MSN)\", \nApplicationProtocol == \"10\", \"AIM\",\nApplicationProtocol == \"11\", \"Yahoo! Messenger\",\nApplicationProtocol == \"12\", \"Gmail\",\nApplicationProtocol == \"13\", \"Yahoo! Mail\", \nApplicationProtocol == \"14\", \"Windows Live Hotmail\",\nApplicationProtocol == \"15\", \"RDP\",\nApplicationProtocol == \"16\", \"DHCP\",\nApplicationProtocol == \"17\", \"Telnet\", \nApplicationProtocol == \"18\", \"LDAP\",\nApplicationProtocol == \"19\", \"File transfer\",\nApplicationProtocol == \"20\", \"SSH\",\nApplicationProtocol == \"21\", \"Dameware\", \nApplicationProtocol == \"22\", \"VNC\",\nApplicationProtocol == \"23\", \"Cisco Telnet\",\nApplicationProtocol == \"24\", \"Kerberos\", \nApplicationProtocol == \"25\", \"DCE RPC\",\nApplicationProtocol == \"26\", \"SQL\",\nApplicationProtocol == \"27\", \"pcAnywhere\", \nApplicationProtocol == \"28\", \"ICMP\",\nApplicationProtocol == \"29\", \"SNMP\",\nApplicationProtocol == \"30\", \"Virus pattern TCP\", \nApplicationProtocol == \"31\", \"Virus pattern UDP\",\nApplicationProtocol == \"32\", \"HTTPS\",\nApplicationProtocol == \"33\", \"SMB2\",\nApplicationProtocol == \"34\", \"MMS\", \nApplicationProtocol == \"35\", \"IMAP4\",\nApplicationProtocol == \"36\", \"RADIUS\",\nApplicationProtocol == \"37\", \"Radmin\",\nApplicationProtocol == \"38\", \"FTP_Response\", \nApplicationProtocol == \"48\", \"RTSP/RTP-UDP\",\nApplicationProtocol == \"49\", \"RTSP/RTP-TCP\",\nApplicationProtocol == \"50\", \"RTSP/RDT-UDP\",\nApplicationProtocol == \"51\", \"RTSP/RDT-TCP\",\nApplicationProtocol == \"52\", \"WMSP\",\nApplicationProtocol == \"53\", \"SHOUTCast\", \nApplicationProtocol == \"54\", \"RTMP\",\nApplicationProtocol == \"68\", \"DNS Request\",\nApplicationProtocol == \"256\", \"BitTorrent\", \nApplicationProtocol == \"257\", \"Kazaa\",\nApplicationProtocol == \"258\", \"Limewire\",\nApplicationProtocol == \"259\", \"Bearshare\", \nApplicationProtocol == \"260\", \"Bluester\",\nApplicationProtocol == \"261\", \"Edonkey emule\",\nApplicationProtocol == \"262\", \"Edonkey2000\",\nApplicationProtocol == \"263\", \"Filezilla\", \nApplicationProtocol == \"264\", \"Guncleus\",\nApplicationProtocol == \"265\", \"Gnutella\",\nApplicationProtocol == \"266\", \"Winny\",\nApplicationProtocol == \"267\", \"Napster\", \nApplicationProtocol == \"268\", \"Morpheus\",\nApplicationProtocol == \"269\", \"Napster\",\nApplicationProtocol == \"270\", \"Shareaza\",\nApplicationProtocol == \"271\", \"WinMX\", \nApplicationProtocol == \"272\", \"Mldonkey\",\nApplicationProtocol == \"273\", \"Direct Connect\",\nApplicationProtocol == \"274\", \"Soulseek\", \nApplicationProtocol == \"275\", \"OpenAP\",\nApplicationProtocol == \"276\", \"Kuro\",\nApplicationProtocol == \"277\", \"Imesh\", \nApplicationProtocol == \"278\", \"Skype\",\nApplicationProtocol == \"279\", \"Google Talk\",\nApplicationProtocol == \"317\", \"Cabos\", \nApplicationProtocol == \"318\", \"Zultrax\",\nApplicationProtocol == \"319\", \"Foxy\",\nApplicationProtocol == \"320\", \"eDonkey\",\nApplicationProtocol == \"321\", \"Ares\", \nApplicationProtocol == \"322\", \"Miranda\",\nApplicationProtocol == \"323\", \"Kceasy\",\nApplicationProtocol == \"324\", \"MoodAmp\",\nApplicationProtocol == \"325\", \"Deepnet Explorer\", \nApplicationProtocol == \"326\", \"FreeWire\",\nApplicationProtocol == \"327\", \"Gimme\",\nApplicationProtocol == \"328\", \"GnucDNA GWebCache\",\nApplicationProtocol == \"329\", \"Jubster\",\nApplicationProtocol == \"330\", \"MyNapster\", \nApplicationProtocol == \"331\", \"Nova GWebCache\",\nApplicationProtocol == \"332\", \"Swapper GWebCache\",\nApplicationProtocol == \"333\", \"Xnap\",\nApplicationProtocol == \"334\", \"Xolox\", \nApplicationProtocol == \"335\", \"Ppstream\",\nApplicationProtocol == \"640\", \"AIM Express\",\nApplicationProtocol == \"641\", \"Chikka SMS Messenger\",\nApplicationProtocol == \"642\", \"eBuddy\", \nApplicationProtocol == \"643\", \"ICQ2Go\",\nApplicationProtocol == \"644\", \"ILoveIM Web Messenger\",\nApplicationProtocol == \"645\", \"IMUnitive\",\nApplicationProtocol == \"646\", \"Mabber\",\nApplicationProtocol == \"647\", \"Meebo\",\nApplicationProtocol == \"648\", \"Yahoo! Web Messenger\", \nApplicationProtocol == \"848\", \"SIP2\",\nApplicationProtocol == \"1024\", \"GPass\",\nApplicationProtocol == \"10001\", \"IP\",\nApplicationProtocol == \"10002\", \"ARP\",\nApplicationProtocol == \"10003\", \"TCP\", \nApplicationProtocol == \"10004\", \"UDP\",\nApplicationProtocol == \"10005\", \"IGMP\",\nApplicationProtocol == \"60\", \"ORACLE\", \nApplicationProtocol == \"44\", \"MySQL\",\nApplicationProtocol == \"520\", \"MSSQL\",\nApplicationProtocol == \"337\", \"Postgres\", \nApplicationProtocol == \"41\", \"ICMPv6\",\nApplicationProtocol == \"10006\", \"GGP\",\nApplicationProtocol == \"10007\", \"PUP\",\nApplicationProtocol == \"10008\", \"IDP\", \nApplicationProtocol == \"10009\", \"ND\",\nApplicationProtocol == \"10010\", \"RAW\",\n\"unknown\")\n| summarize ProtocolCount = count() by AppProtocol, SrcIpAddr, DstUserName\n| top 20 by ProtocolCount asc \n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches rare application protocols by Ip address.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneSpywareDetection.yaml", "query_name": "ApexOne - Spyware detection", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where EventMessage has \"Spyware\"\n| extend MalwareCustomEntity = VirusName, FileCustomEntity = FileName\n", "attributes": {"description": "'Query searches spyware detection events.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneSuspiciousFiles.yaml", "query_name": "ApexOne - Suspicious files events", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where EventMessage has \"Suspicious File\"\n| extend AccountCustomEntity = DstUserName, FileCustomEntity = FileName\n", "attributes": {"description": "'Query searches suspicious files events.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Apex%20One/Hunting%20Queries/TMApexOneTopSources.yaml", "query_name": "ApexOne - Top sources with alerts", "query": "TMApexOneEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(SrcIpAddr)\n| summarize IpCount = count() by SrcIpAddr\n| top 20 by IpCount desc \n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query shows list of top sources with alerts.'\n", "techniques": ["T1204", "T1189", "T1068", "T1202", "T1112", "T1055", "T1071", "T1095", "T1537", "T1567"], "tactics": ["Execution", "InitialAccess", "PrivilegeEscalation", "DefenseEvasion", "CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASDLPViolation.yaml", "query_name": "Trend Micro CAS - DLP violation", "query": "TrendMicroCAS\n| where isnotempty(TriggeredDlpTemplate)\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when DLP policy violation occurs.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASPossiblePhishingMail.yaml", "query_name": "Trend Micro CAS - Possible phishing mail", "query": "let threshold = 5;\nTrendMicroCAS\n| where EventCategoryType in~ ('exchange', 'gmail', 'exchangeserver')\n| where isnotempty(SrcFileName)\n| where isnotempty(SecurityRiskName)\n| summarize r_users = makeset(DstUserName) by SrcFileName, bin(TimeGenerated, 30m)\n| where array_length(r_users) > threshold\n| extend AccountCustomEntity = r_users\n", "attributes": {"description": "'Detects possible phishing mail.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASRansomwareOnHost.yaml", "query_name": "Trend Micro CAS - Ransomware infection", "query": "TrendMicroCAS\n| where EventType =~ 'ransomware'\n| extend AccountCustomEntity = DstUserName, MalwareCustomEntity = RansomwareName\n", "attributes": {"description": "'Triggeres when ransomware was detected.'\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASRansomwareOutbreak.yaml", "query_name": "Trend Micro CAS - Ransomware outbreak", "query": "TrendMicroCAS\n| where EventType =~ 'ransomware'\n| summarize count() by DstUserName, bin(TimeGenerated, 2m)\n| where count_ >= 2\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Triggeres when ransomware was detected on several accounts.'\n", "techniques": ["T1486"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASSuspiciousFilename.yaml", "query_name": "Trend Micro CAS - Suspicious filename", "query": "TrendMicroCAS\n| where isnotempty(SrcFileName)\n| where SrcFileName matches regex @'\\A[a-zA-Z0-9_\\-.]{1,3}\\.\\w+$'\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects unexpected filename.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASThreatNotBlocked.yaml", "query_name": "Trend Micro CAS - Threat detected and not blocked", "query": "TrendMicroCAS\n| where isnotempty(SecurityRiskName)\n| where EventOriginalResultDetails !has 'Blocked' or EventOriginalResultDetails !has 'Block' or EventOriginalResultDetails !has 'Quarantine' or TriggeredPolicyName has 'Monitor Only'\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when threat was not blocked by CAS solution.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASUnexpectedFileInMail.yaml", "query_name": "Trend Micro CAS - Unexpected file via mail", "query": "let f_types = dynamic(['ps1', 'bat', 'scr', 'sh', 'exe', 'js', 'lnk']);\nTrendMicroCAS\n| where EventCategoryType in~ ('exchange', 'gmail', 'exchangeserver')\n| where isnotempty(SrcFileName)\n| extend file_type = extract(@'\\.(\\w+)$', 1, SrcFileName)\n| where file_type in~ (f_types)\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects when unexpected file recieved via mail.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASUnexpectedFileOnFileShare.yaml", "query_name": "Trend Micro CAS - Unexpected file on file share", "query": "let f_types = dynamic(['ps1', 'bat', 'scr', 'sh', 'exe', 'js', 'lnk']);\nTrendMicroCAS\n| where EventCategoryType in~ ('sharepoint', 'onedrive', 'dropbox', 'box', 'googledrive')\n| where isnotempty(SrcFileName)\n| extend file_type = extract(@'\\.(\\w+)$', 1, SrcFileName)\n| where file_type in~ (f_types) or SrcFileName !contains @'.'\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects unexpected files on file share.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASVAInfectedUser.yaml", "query_name": "Trend Micro CAS - Infected user", "query": "TrendMicroCAS\n| where EventType has_all ('virtual', 'analyzer')\n| where isnotempty(VirusName)\n| extend AccountCustomEntity = DstUserName, MalwareCustomEntity = VirusName\n", "attributes": {"description": "'Detects when malware was detected for user account.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Analytic%20Rules/TrendMicroCASVAOutbreak.yaml", "query_name": "Trend Micro CAS - Multiple infected users", "query": "TrendMicroCAS\n| where EventType has_all ('virtual', 'analyzer')\n| where isnotempty(VirusName)\n| summarize count() by DstUserName, VirusName, bin(TimeGenerated, 15m)\n| where count_ >= 2\n| extend AccountCustomEntity = DstUserName, MalwareCustomEntity = VirusName\n", "attributes": {"description": "'Detects when same malware was detected for multiple user account.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASFilesOnShares.yaml", "query_name": "Trend Micro CAS - Files stored on cloud fileshare services", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where EventCategoryType in~ ('sharepoint', 'onedrive', 'dropbox', 'box', 'googledrive')\n| where isnotempty(SrcFileName)\n| project DetectionTime, DstUserName, SrcFileName, EventOriginalResultDetails, SecurityRiskName, VirusName\n| extend FileCustomEntity = SrcFileName, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for stored on cloud fileshare services.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASInfectedFilesInEmails.yaml", "query_name": "Trend Micro CAS - Infected files received via email", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where EventCategoryType in~ ('exchange', 'gmail', 'exchangeserver')\n| where isnotempty(SecurityRiskName)\n| where EventOriginalResultDetails =~ 'Quarantine'\n| project DetectionTime, DstUserName, MailMessageFileName, SecurityRiskName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for infected files received via email.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASRansomwareThreats.yaml", "query_name": "Trend Micro CAS - Ransomware threats", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where isnotempty(RansomwareName)\n| project DetectionTime, DstUserName, SrcFileName, RansomwareName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for ransomware threats.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASRareFilesRecievedViaEmail.yaml", "query_name": "Trend Micro CAS - Rare files received via email services", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where EventCategoryType in~ ('exchange', 'gmail', 'exchangeserver')\n| where isnotempty(MailMessageFileName)\n| summarize count() by MailMessageFileName, EventOriginalResultDetails\n| order by count_ asc\n| extend FileCustomEntity = MailMessageFileName\n", "attributes": {"description": "'Query searches for rare files recieved via email services.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASRiskyUsers.yaml", "query_name": "Trend Micro CAS - Risky users", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where isnotempty(SecurityRiskName)\n| summarize threats = makeset(SecurityRiskName) by DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for users with high number of threats.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASScanDiscoveredThreats.yaml", "query_name": "Trend Micro CAS - Security risk scan threats", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where EventType =~ 'security_risk_scan'\n| where isnotempty(SecurityRiskName)\n| project DetectionTime, DstUserName, SrcFileName, SecurityRiskName\n| extend AccountCustomEntity = DstUserName, FileCustomEntity = SrcFileName\n", "attributes": {"description": "'Query searches for threats discovered via security risk scans.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASSuspiciousFilesSharepoint.yaml", "query_name": "Trend Micro CAS - Suspicious files on sharepoint", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where EventCategoryType =~ 'sharepoint'\n| where EventOriginalResultDetails =~ 'Quarantine'\n| project DetectionTime, DstUserName, SrcFileName, SrcFileSHA1, SrcFileSHA256, SecurityRiskName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for suspicious files on sharepoint.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASTopFilesRecievedViaEmail.yaml", "query_name": "Trend Micro CAS - Files received via email services", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where EventCategoryType in~ ('exchange', 'gmail', 'exchangeserver')\n| where isnotempty(MailMessageFileName)\n| summarize count() by MailMessageFileName, EventOriginalResultDetails\n| extend FileCustomEntity = MailMessageFileName\n", "attributes": {"description": "'Query searches for top files recieved via email services.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASUserDLPViolations.yaml", "query_name": "Trend Micro CAS - DLP violations", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where isnotempty(TriggeredDlpTemplate)\n| project DetectionTime, DstUserName, SrcFileName, TriggeredDlpTemplate\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for DLP violations by users.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Cloud%20App%20Security/Hunting%20Queries/TrendMicroCASVAThreats.yaml", "query_name": "Trend Micro CAS - Virtual Analyzer threats", "query": "TrendMicroCAS\n| where TimeGenerated > ago(24h)\n| where EventType has 'virtual_analyzer'\n| where isnotempty(VirusName)\n| project DetectionTime, DstUserName, SrcFileName, RansomwareName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query searches for Virtual Analyzer threats.'\n", "techniques": ["T1566"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Trend%20Micro%20Vision%20One/Analytic%20Rules/Create%20Incident%20for%20XDR%20Alerts.yaml", "query_name": "Create Incident for XDR Alerts", "query": "TrendMicro_XDR_WORKBENCH_CL\n| extend Severity = case(severity_s == \"low\", \"Informational\",\n                        severity_s == \"medium\", \"Low\",\n                        severity_s == \"high\", \"Medium\",\n                        \"High\"\n                        )\n| extend \n    UserAccountName_s = todynamic(UserAccountName_s)[0],\n    UserAccountNTDomain_s = todynamic(UserAccountNTDomain_s)[0],\n    FileName_s = todynamic(FileName_s)[0],\n    FileDirectory_s = todynamic(FileDirectory_s)[0],\n    ProcessCommandLine_s = todynamic(ProcessCommandLine_s)[0],\n    RegistryKey_s = todynamic(RegistryKey_s)[0],\n    RegistryValue_s = todynamic(RegistryValue_s)[0],\n    RegistryValueName_s = todynamic(RegistryValueName_s)[0]\n", "attributes": {"description": "'This Query creates an incident based on Trend Micro Vision One Workbench Alerts and maps the impacted entities for Microsoft Sentinel usage.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiCryptominer.yaml", "query_name": "Ubiquiti - Possible connection to cryptominning pool", "query": "let susp_dst_ports = dynamic(['14433', '14444', '3333', '3334', '3335', '3336', '4444', '45560', '45700', '5555', '5556', '6666', '7777', '8788', '8888', '8899', '9999', '10034']);\nUbiquitiAuditEvent\n| where ipv4_is_private(SrcIpAddr)\n| where ipv4_is_private(DstIpAddr) == 'False'\n| where DstPortNumber in (susp_dst_ports)  or (DnsQuery contains 'pool' and DnsQuery contains 'xmr')\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects connections which may indicate that device is infected with cryptominer.'\n", "techniques": ["T1071", "T1095", "T1571"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiDestinationInTiList.yaml", "query_name": "Ubiquiti - Connection to known malicious IP or C2", "query": "let malicious_ips =\nThreatIntelligenceIndicator\n| where isnotempty(NetworkIP)\n| summarize make_list(NetworkIP);\nUbiquitiAuditEvent\n| where EventCategory =~ 'firewall'\n| where ipv4_is_private(SrcIpAddr)\n| where ipv4_is_private(DstIpAddr) == 'False'\n| where DstIpAddr in (malicious_ips)\n| where DvcAction =~ 'Accepted' or DvcAction =~ 'Other'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects allowed connections to IP addresses which are in TI list and are known to be malicious.'\n", "techniques": ["T1071", "T1571", "T1572"], "tactics": ["Exfiltration", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiL2RFTP.yaml", "query_name": "Ubiquiti - Unusual FTP connection to external server", "query": "let allowed_ftp = dynamic(['127.0.0.2']);\nUbiquitiAuditEvent\n| where EventCategory == 'firewall'\n| where ipv4_is_private(SrcIpAddr)\n| where ipv4_is_private(DstIpAddr) == 'False'\n| where DstPortNumber in ('20', '21')\n| where DstIpAddr !in (allowed_ftp)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects local to remote (L2R) FTP connections.'\n", "techniques": NaN, "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiL2RLargeIcmp.yaml", "query_name": "Ubiquiti - Large ICMP to external server", "query": "UbiquitiAuditEvent\n| where EventCategory =~ 'firewall'\n| where ipv4_is_private(SrcIpAddr)\n| where ipv4_is_private(DstIpAddr) == 'False'\n| where NetworkProtocol =~ 'ICMP'\n| summarize avg_packet_length = avg(toint(NetworkBytes))\n| extend a = 1\n| join (UbiquitiAuditEvent\n  | where EventCategory =~ 'firewall'\n  | where ipv4_is_private(SrcIpAddr)\n  | where ipv4_is_private(DstIpAddr) == 'False'\n  | where NetworkProtocol =~ 'ICMP'\n  | extend a = 1) on a\n| where toint(NetworkBytes) > 2*avg_packet_length\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects large ICMP packets to external host.'\n", "techniques": ["T1041", "T1572"], "tactics": ["Exfiltration", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiNonCorpDns.yaml", "query_name": "Ubiquiti - connection to non-corporate DNS server", "query": "let corp_dns = dynamic(['127.0.0.2']);\nUbiquitiAuditEvent\n| where DstPortNumber == '53'\n| where DstIpAddr !in (corp_dns)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects connections to non-corporate DNS servers.'\n", "techniques": ["T1572", "T1041"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiR2LDns.yaml", "query_name": "Ubiquiti - Unusual DNS connection", "query": "let threshold = 50;\nUbiquitiAuditEvent\n| where EventCategory =~ 'firewall'\n| where ipv4_is_private(SrcIpAddr) == 'False'\n| where ipv4_is_private(DstIpAddr)\n| where DstPortNumber == '53'\n| summarize count() by SrcIpAddr, DstIpAddr\n| where count_ > threshold\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects unusual remote to local (R2L) DNS connections.'\n", "techniques": ["T1090", "T1572"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiR2LRDP.yaml", "query_name": "Ubiquiti - RDP from external source", "query": "UbiquitiAuditEvent\n| where EventCategory =~ 'firewall'\n| where ipv4_is_private(SrcIpAddr) == 'False'\n| where ipv4_is_private(DstIpAddr)\n| where DstPortNumber == '3389'\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects remote to local (R2L) RDP connection.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiR2LSSH.yaml", "query_name": "Ubiquiti - SSH from external source", "query": "UbiquitiAuditEvent\n| where EventCategory =~ 'firewall'\n| where ipv4_is_private(SrcIpAddr) == 'False'\n| where ipv4_is_private(DstIpAddr)\n| where DstPortNumber == '22'\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Detects remote to local (R2L) SSH connection to internal host.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiUnknownMacJoined.yaml", "query_name": "Ubiquiti - Unknown MAC Joined AP", "query": "let lbperiod = 14d;\nlet lbperiod_24h = 24h;\nlet known_macs = UbiquitiAuditEvent\n| where TimeGenerated between (ago(lbperiod) .. ago(lbperiod_24h))\n| where DvcAction =~ 'JOIN'\n| summarize makeset(SrcMacAddr);\nUbiquitiAuditEvent\n| where DvcAction =~ 'JOIN'\n| where SrcMacAddr !in (known_macs)\n| extend Device = SrcMacAddr\n| extend HostCustomEntity = Device\n", "attributes": {"description": "'Detects when device with unseen MAC Address joined AP.'\n", "techniques": ["T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Analytic%20Rules/UbiquitiUnusualTraffic.yaml", "query_name": "Ubiquiti - Unusual traffic", "query": "UbiquitiAuditEvent\n| where EventCategory =~ 'firewall'\n| where DstPortNumber in ('80', '443')\n| where NetworkProtocol !~ 'TCP'\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects unusual traffic masking as HTTP(S).'\n", "techniques": NaN, "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiDnsTimeOut.yaml", "query_name": "Ubiquiti - DNS requests timed out", "query": "UbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(DnsQuery)\n| where EventMessage =~ 'DNS request timed out'\n| extend Name = DnsQuery\n", "attributes": {"description": "'Query shows failed DNS requests due to timeout.'\n", "techniques": ["T1572", "T1041", "T1071"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiInternalDnsServer.yaml", "query_name": "Ubiquiti - Hidden internal DNS server", "query": "let threshold = 100;\nUbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where EventCategory =~ 'firewall'\n| where ipv4_is_private(DstIpAddr)\n| where DvcAction =~ 'Accepted'\n| where DstPortNumber == '53'\n| summarize count() by DstIpAddr\n| where count_ > threshold\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query shows list of unaccounted internal DNS servers.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiRareInternalPorts.yaml", "query_name": "Ubiquiti - Rare internal ports", "query": "UbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where EventCategory =~ 'firewall'\n| where ipv4_is_private(DstIpAddr)\n| where DvcAction =~ 'Accepted'\n| where isnotempty(DstPortNumber)\n| summarize count() by DstPortNumber, DstIpAddr\n| top 10 by count_ asc\n  | extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query shows list of least used internal destination ports.'\n", "techniques": ["T1571"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiTopBlockedDst.yaml", "query_name": "Ubiquiti - Top blocked destinations", "query": "UbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where EventCategory =~ 'firewall'\n| where DvcAction =~ 'Blocked'\n| summarize count() by DstIpAddr\n| top 10 by count_\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query shows list of top destinations connections to which were blocked by firewall.'\n", "techniques": ["T1090", "T1041"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiTopBlockedExternalServices.yaml", "query_name": "Ubiquiti - Top blocked external services", "query": "UbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where EventCategory =~ 'firewall'\n| where DvcAction =~ 'Blocked'\n| where isnotempty(DstPortNumber)\n| where ipv4_is_private(DstIpAddr) == 'False'\n| extend svc_name = case(DstPortNumber in ('20', '21'), 'FTP',\n                        DstPortNumber == '22', 'SSH',\n                        DstPortNumber == '23', 'Telnet',\n                        DstPortNumber == '25', 'SMTP',\n                        DstPortNumber == '53', 'DNS',\n                        DstPortNumber in ('67', '68'), 'DHCP',\n                        DstPortNumber == '110', 'POP3',\n                        DstPortNumber == '123', 'NTP',\n                        DstPortNumber in ('137', '138', '139'), 'NeTBIOS',\n                        DstPortNumber == '143', 'IMAP',\n                        DstPortNumber == '220', 'IMAPv3',\n                        DstPortNumber == '389', 'LDAP',\n                        DstPortNumber == '3389', 'RDP',\n                        DstPortNumber == '514', 'Syslog',\n                        DstPortNumber == '80', 'HTTP',\n                        DstPortNumber == '443', 'HTTPS',\n                        DstPortNumber )\n| summarize count() by svc_name, SrcIpAddr\n| top 10 by count_\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query shows list of top blocked connections to external services.'\n", "techniques": ["T1041", "T1071"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiTopBlockedInternalServices.yaml", "query_name": "Ubiquiti - Top blocked internal services", "query": "UbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where EventCategory =~ 'firewall'\n| where DvcAction =~ 'Blocked'\n| where isnotempty(DstPortNumber)\n| where ipv4_is_private(DstIpAddr)\n| extend svc_name = case(DstPortNumber in ('20', '21'), 'FTP',\n                        DstPortNumber == '22', 'SSH',\n                        DstPortNumber == '23', 'Telnet',\n                        DstPortNumber == '25', 'SMTP',\n                        DstPortNumber == '53', 'DNS',\n                        DstPortNumber in ('67', '68'), 'DHCP',\n                        DstPortNumber == '110', 'POP3',\n                        DstPortNumber == '123', 'NTP',\n                        DstPortNumber in ('137', '138', '139'), 'NeTBIOS',\n                        DstPortNumber == '143', 'IMAP',\n                        DstPortNumber == '220', 'IMAPv3',\n                        DstPortNumber == '389', 'LDAP',\n                        DstPortNumber == '3389', 'RDP',\n                        DstPortNumber == '514', 'Syslog',\n                        DstPortNumber == '80', 'HTTP',\n                        DstPortNumber == '443', 'HTTPS',\n                        DstPortNumber )\n| summarize count() by svc_name, SrcIpAddr\n| top 10 by count_\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query shows list of top blocked connections to internal services.'\n", "techniques": ["T1595", "T1572", "T1571", "T1071"], "tactics": ["InitialAccess", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiTopBlockedSrc.yaml", "query_name": "Ubiquiti - Top blocked sources", "query": "UbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where EventCategory =~ 'firewall'\n| where DvcAction =~ 'Blocked'\n| summarize count() by SrcIpAddr\n| top 10 by count_\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query shows list of top sources with blocked connections.'\n", "techniques": ["T1572", "T1571", "T1071"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiTopFirewallRules.yaml", "query_name": "Ubiquiti - Top firewall rules", "query": "UbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where EventCategory =~ 'firewall'\n| summarize count() by NetworkRuleName\n| top 10 by count_\n", "attributes": {"description": "'Query shows list of top triggered firewall rules.'\n", "techniques": ["T1572", "T1571", "T1071"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiUnusualSubdomains.yaml", "query_name": "Ubiquiti - Unusual number of subdomains for top level domain (TLD)", "query": "let threshold = 100;\nUbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where isnotempty(DnsQuery)\n| extend replaced = replace(@'\\.$', @'', DnsQueryName)\n| extend Domain = extract(@'.*\\.(.*\\.[a-z]+)', 1, replaced)\n| extend fqdn = extract(@'(.*)\\..*\\.[a-z]+', 1, replaced)\n| summarize FQDNs = dcount(fqdn) by Domain\n| where FQDNs > threshold\n| extend HostCustomEntity = Domain\n", "attributes": {"description": "'Query counts the number of unique subdomains for each TLD.'\n", "techniques": ["T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Ubiquiti%20UniFi/Hunting%20Queries/UbiquitiVulnerableDevices.yaml", "query_name": "Ubiquiti - Vulnerable devices", "query": "let latest_firmware = '4.0.80.10875';\nUbiquitiAuditEvent\n| where TimeGenerated > ago(24h)\n| where FirmwareVersion != latest_firmware\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query shows list of devices (APs) which do not have the latest version of firmware installed.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/anomaliesOnVIPUsers.yaml", "query_name": "Anomalies on users tagged as VIP", "query": "BehaviorAnalytics\n| where UsersInsights.IsVIPUser == True\n| where InvestigationPriority > 0\n| extend AadUserId = UsersInsights.AccountObjectID\n", "attributes": {"description": "'Shows all users tagged as VIP in the VIP users watchlist that had anomalies with a score greater than 0.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20AAD%20Account%20Manipulation.yaml", "query_name": "Anomalous AAD Account Manipulation", "query": "\n//Critical Roles can impersonate any user or app, can update passwords for users or service principals (if the role can let a user update passwords for privileged users, if an attacker compromises this user then attacker can update passwords for privileged users hence gaining more privileges so users with this role are equally critical)\n//High Roles are Administrators that can manage all aspects or permissions of important products but can't update credentials and impersonate another user/app\nlet critical = dynamic(['9b895d92-2cd3-44c7-9d02-a6ac2d5ea5c3','c4e39bd9-1100-46d3-8c65-fb160da0071f','158c047a-c907-4556-b7ef-446551a6b5f7','62e90394-69f5-4237-9190-012177145e10',\n'd29b2b05-8046-44ba-8758-1e26182fcf32','729827e3-9c14-49f7-bb1b-9608f156bbb8','966707d0-3269-4727-9be2-8c3a10f19b9d','194ae4cb-b126-40b2-bd5b-6091b380977d','fe930be7-5e62-47db-91af-98c3a49a38b1']);\nlet high = dynamic(['cf1c38e5-3621-4004-a7cb-879624dced7c','7495fdc4-34c4-4d15-a289-98788ce399fd','aaf43236-0c0d-4d5f-883a-6955382ac081','3edaf663-341e-4475-9f94-5c398ef6c070',\n'7698a772-787b-4ac8-901f-60d6b08affd2','b1be1c3e-b65d-4f19-8427-f6fa0d97feb9','9f06204d-73c1-4d4c-880a-6edb90606fd8','29232cdf-9323-42fd-ade2-1d097af3e4de','be2f45a1-457d-42af-a067-6ec1fa63bc45',\n'7be44c8a-adaf-4e2a-84d6-ab2649e08a13','e8611ab8-c189-46e8-94e1-60213ab1f814']);\nAuditLogs\n| where OperationName == \"Update user\"\n| mv-expand AdditionalDetails\n| mv-expand TargetResources\n| where AdditionalDetails.key == \"UserPrincipalName\"\n| mv-expand TargetResources\n| extend RoleId = tostring(TargetResources.modifiedProperties[0].newValue)\n| extend RoleName = tostring(TargetResources.modifiedProperties[1].newValue)\n| where RoleId in (critical,high)\n| where isnotempty(RoleId) or isnotempty(RoleName)\n| extend TargetId = tostring(TargetResources.id)\n| extend Target =  iff(tostring(TargetResources.userPrincipalName) has \"#EXT#\",replace(\"_\",\"@\",tostring(split(TargetResources.userPrincipalName, \"#\")[0])),TargetResources.userPrincipalName),tostring(TargetResources.userPrincipalName)\n| join kind=inner ( BehaviorAnalytics\n) on $left._ItemId == $right.SourceRecordId\n| where UsersInsights.BlastRadius == \"High\" or ActivityInsights has \"True\"\n| extend UserPrincipalName = iff(UserPrincipalName has \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserPrincipalName), UserName = iff(UserName has \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserName) \n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [\"TargetUser\"]=Target, RoleName, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights, ResourceId\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress, ResourceCustomEntity = ResourceId\n", "attributes": {"description": "'Adversaries may manipulate accounts to maintain access to victim systems. These actions include adding new accounts to high privilleged groups. \n Dragonfly 2.0, for example, added newly created accounts to the administrators group to maintain elevated access. The query below generates an \n output of all high Blast Radius users performing \"Update user\" (name change) to priveleged role, or where one or more features of the activitiy \n deviates from the user, his peers or the tenant profile.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Account%20Creation.yaml", "query_name": "Anomalous AAD Account Creation", "query": "\nBehaviorAnalytics\n| where ActionType == \"Add user\"\n| where ActivityInsights has \"True\"\n| join(\nAuditLogs\n) on $left.SourceRecordId == $right._ItemId\n| mv-expand TargetResources\n| extend Target =  iff(tostring(TargetResources.userPrincipalName) has \"#EXT#\",replace(\"_\",\"@\",tostring(split(TargetResources.userPrincipalName, \"#\")[0])),TargetResources.userPrincipalName),tostring(TargetResources.userPrincipalName)\n| extend DisplayName = tostring(UsersInsights.AccountDisplayName),\nUserPrincipalName = iff(UserPrincipalName has \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserPrincipalName),\nUserName = iff(UserName has \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserName)\n| sort by TimeGenerated desc\t\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [\"TargetUser\"]=Target, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights, ResourceId\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress, ResourceCustomEntity = ResourceId\n", "attributes": {"description": "'Adversaries may create a cloud account to maintain access to victim systems. With a sufficient level of access, such accounts may be used to establish secondary credentialed access that does not require persistent remote access tools to be deployed on the system. The query below generates an output of all the users performing user creation where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'\n", "techniques": ["T1136"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Activity%20Role%20Assignment.yaml", "query_name": "Anomalous Activity Role Assignment", "query": "let operations = dynamic(['Create role assignment']);\nBehaviorAnalytics\n| where ActionType in(operations)\n| where ActivityInsights contains \"True\"\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress\n", "attributes": {"description": "'Adversaries may circumvent mechanisms designed to control elevate privileges to gain higher-level permissions. The query below generates an output \nof all users performing an \"action\" operation regarding a access elevation, where one or more features of the activitiy deviates from the user, \nhis peers or the tenant profile.'\n", "techniques": ["T1548"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Code%20Execution.yaml", "query_name": "Anomalous Code Execution", "query": "let operations = dynamic(['Run Command on Virtual Machine']);\nBehaviorAnalytics\n| where ActionType in(operations)\n| where ActivityInsights has \"True\"\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress\n", "attributes": {"description": "'Adversaries may abuse command and script interpreters to execute commands, scripts, or binaries. These interfaces and languages provide ways of interacting with computer systems and are a common feature across many different platforms. APT19, for example, used PowerShell commands to execute payloads. The query below generates an output of all users performing an \"action\" operation regarding \"runCommand\" in virtual machines, where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'\n", "techniques": ["T1059"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Data%20Access.yaml", "query_name": "Anomalous Data Access", "query": "let operations = dynamic(['Export an existing database']);\nBehaviorAnalytics\n| where ActionType in(operations)\n| where ActivityInsights has \"True\"\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress\n", "attributes": {"description": "'Adversaries may access data objects from cloud storage.  The query below generates an output of all users performing a \"read\" operation regarding data or files, where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'\n", "techniques": ["T1530"], "tactics": ["Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Defensive%20Mechanism%20Modification.yaml", "query_name": "Anomalous Defensive Mechanism Modification", "query": "let operations = dynamic(['Remove database vulnerability assessment rule baseline']);\nBehaviorAnalytics\n| where ActionType in(operations)\n| where ActivityInsights has \"True\"\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress\n", "attributes": {"description": "'Adversaries may disable security tools to avoid possible detection of their tools and activities. DarkComet, for example, can disable Security Center functions like anti-virus. The query below generates an output of all users performing a \"delete\" operation regarding a security policy, where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Failed%20Logon.yaml", "query_name": "Anomalous Failed Logon", "query": "\nBehaviorAnalytics\n| where ActivityType == \"LogOn\"\n| where UsersInsights.BlastRadius == \"High\"\n| join (\nSigninLogs  | where Status.errorCode == 50126\n) on $left.SourceRecordId == $right._ItemId\n| extend UserPrincipalName = iff(UserPrincipalName contains \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserPrincipalName),\nUserName = iff(UserName contains \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserName)\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType,[\"Evidence\"]=ActivityInsights, ResourceDisplayName, AppDisplayName, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights, ResourceId\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress, ResourceCustomEntity = ResourceId\n", "attributes": {"description": "'Adversaries with no prior knowledge of legitimate credentials within the system or environment may guess passwords to attempt access to accounts. Emotet, for example, has been observed using a hard coded list of passwords to brute force user accounts. The query below generates an output of all users with 'High' BlastRadius that perform failed Sign-in:Invalid username or password.'\n", "techniques": ["T1110.001"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Geo%20Location%20Logon.yaml", "query_name": "Anomalous Geo Location Logon", "query": "\nBehaviorAnalytics\n| where ActionType == \"Sign-in\"\n| where ActivityInsights.FirstTimeConnectionFromCountryObservedInTenant == True and ActivityInsights.CountryUncommonlyConnectedFromAmongPeers == True\n    | join (\nSigninLogs\n) on $left.SourceRecordId == $right._ItemId\n| extend UserPrincipalName = iff(UserPrincipalName contains \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserPrincipalName),\nUserName = iff(UserName contains \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserName)\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [\"Evidence\"]=ActivityInsights, ResourceDisplayName, AppDisplayName, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights, ResourceId\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress, ResourceCustomEntity = ResourceId\n", "attributes": {"description": "'Adversaries may steal the credentials of a specific user or service account using Credential Access techniques or capture credentials earlier in their reconnaissance process through social engineering for means of gaining Initial Access. APT33, for example, has used valid accounts for initial access. The query below generates an output of successful Sign-in performed by a user from a new geo location he has never connected from before, and none of his peers as well.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Login%20to%20Devices.yaml", "query_name": "Anomalous Login to Devices", "query": "\nBehaviorAnalytics\n| where UsersInsights.IsDormantAccount == true\n| where DevicesInsights.IsLocalAdmin == true\n| where ActivityType == \"LogOn\"\n| where ActionType == \"InteractiveLogon\"\n| where ActivityInsights contains \"True\"\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress\n", "attributes": {"description": "'Adversaries may steal the credentials of a specific user or service account using Credential Access techniques or capture credentials earlier in their reconnaissance process through social engineering for means of gaining Initial Access. APT33, for example, has used valid accounts for initial access and privilege escalation. The query below generates an output of all administator users performing an interactive logon (4624:2) where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Password%20Reset.yaml", "query_name": "Anomalous Password Reset", "query": "\nBehaviorAnalytics\n| where ActionType == \"Reset user password\"\n| where ActivityInsights has \"True\"\n| join (\nAuditLogs\n) on $left.SourceRecordId == $right._ItemId\n| mv-expand TargetResources\n| extend Target =  iff(tostring(TargetResources.userPrincipalName) has \"#EXT#\",replace(\"_\",\"@\",tostring(split(TargetResources.userPrincipalName, \"#\")[0])),TargetResources.userPrincipalName),tostring(TargetResources.userPrincipalName)\n| extend UserPrincipalName = iff(UserPrincipalName has \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserPrincipalName),\nUserName = iff(UserName has \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserName)\n| sort by TimeGenerated desc\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [\"TargetUser\"]=Target, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights, ResourceId\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress, ResourceCustomEntity = ResourceId\n", "attributes": {"description": "'Adversaries may interrupt availability of system and network resources by inhibiting access to accounts utilized by legitimate users. Accounts may be deleted, locked, or manipulated (ex: changed credentials) to remove access to accounts. LockerGoga, for example, has been observed changing account passwords and logging off current users. The query below generates an output of all users performing Reset user password where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'\n", "techniques": ["T1531"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20RDP%20Activity.yaml", "query_name": "Anomalous RDP Activity", "query": "\nBehaviorAnalytics\n| where ActivityType == \"LogOn\"\n| where ActionType == \"RemoteInteractiveLogon\"\n| where ActivityInsights has \"True\"\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress\n", "attributes": {"description": "'Adversaries may use Valid Accounts to log into a computer using the Remote Desktop Protocol (RDP). \nThe adversary may then perform actions as the logged-on user. FIN10, for example, has used RDP to move laterally to systems in the victim environment.'\n", "techniques": [null], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Resource%20Access.yaml", "query_name": "Anomalous Resource Access", "query": "\nBehaviorAnalytics\n| where ActivityType == \"LogOn\"\n| where ActionType == \"ResourceAccess\"\n| where ActivityInsights has \"True\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by bin(TimeGenerated,1d), UserName, UserPrincipalName, tostring(UsersInsights), ActivityType, ActionType, tostring(ActivityInsights), SourceIPAddress, SourceIPLocation, SourceDevice, tostring(DevicesInsights)\n| extend timestamp = StartTime, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress\n", "attributes": {"description": "'Adversary may be trying to move through the environment. APT29 and APT32, for example, has used PtH & PtT techniques to lateral move around the network. The query below generates an output of all users performing an resource access (4624:3) to devices for the first time.'\n", "techniques": [null], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Role%20Assignment.yaml", "query_name": "Anomalous Role Assignment", "query": "\nlet critical = dynamic(['9b895d92-2cd3-44c7-9d02-a6ac2d5ea5c3','c4e39bd9-1100-46d3-8c65-fb160da0071f','158c047a-c907-4556-b7ef-446551a6b5f7','62e90394-69f5-4237-9190-012177145e10','d29b2b05-8046-44ba-8758-1e26182fcf32','729827e3-9c14-49f7-bb1b-9608f156bbb8','966707d0-3269-4727-9be2-8c3a10f19b9d','194ae4cb-b126-40b2-bd5b-6091b380977d','fe930be7-5e62-47db-91af-98c3a49a38b1']);\nlet high = dynamic(['cf1c38e5-3621-4004-a7cb-879624dced7c','7495fdc4-34c4-4d15-a289-98788ce399fd','aaf43236-0c0d-4d5f-883a-6955382ac081','3edaf663-341e-4475-9f94-5c398ef6c070','7698a772-787b-4ac8-901f-60d6b08affd2','b1be1c3e-b65d-4f19-8427-f6fa0d97feb9','9f06204d-73c1-4d4c-880a-6edb90606fd8','29232cdf-9323-42fd-ade2-1d097af3e4de','be2f45a1-457d-42af-a067-6ec1fa63bc45','7be44c8a-adaf-4e2a-84d6-ab2649e08a13','e8611ab8-c189-46e8-94e1-60213ab1f814']);\nAuditLogs\n| where OperationName == \"Add member to role\"\n| mv-expand TargetResources\n| extend RoleId = tostring(TargetResources.modifiedProperties[0].newValue)\n| extend RoleName = tostring(TargetResources.modifiedProperties[1].newValue)\n| where RoleId in (critical,high)\n| extend TargetId = tostring(TargetResources.id)\n| extend Target = tostring(TargetResources.userPrincipalName)\n| where isnotempty(RoleId) or isnotempty(RoleName)\n| join kind=inner ( BehaviorAnalytics\n) on $left._ItemId == $right.SourceRecordId\n| where UsersInsights.BlasrRadius == \"High\" or ActivityInsights has \"True\"\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [\"TargetUser\"]=Target, RoleName, ActivityInsights, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights, ResourceId\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress, ResourceCustomEntity = ResourceId\n", "attributes": {"description": "'Adversaries may manipulate accounts to maintain access to victim systems. These actions include adding new accounts to high privilleged groups. Dragonfly 2.0, for example, added newly created accounts to the administrators group to maintain elevated access.  The query below generates an output of all high Blast Radius users performing Add member to priveleged role, or where one or more features of the activitiy deviates from the user, his peers or the tenant profile.'\n", "techniques": ["T1098"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/Anomalous%20Sign-in%20Activity.yaml", "query_name": "Anomalous Sign-in Activity", "query": "\nBehaviorAnalytics\n| where ActionType == \"Sign-in\"\n| where UsersInsights.IsNewAccount == True or UsersInsights.IsDormantAccount == True or ActivityInsights has \"True\"\n| join (\nSigninLogs | where Status.errorCode == 0 or Status.errorCode == 0 and RiskDetail != \"none\"\n) on $left.SourceRecordId == $right._ItemId\n| extend UserPrincipalName = iff(UserPrincipalName has \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserPrincipalName),\nUserName = iff(UserName has \"#EXT#\",replace(\"_\",\"@\",tostring(split(UserPrincipalName, \"#\")[0])),UserName)\n| project TimeGenerated, UserName, UserPrincipalName, UsersInsights, ActivityType, ActionType, [\"Evidence\"]=ActivityInsights, ResourceDisplayName, AppDisplayName, SourceIPAddress, SourceIPLocation, SourceDevice, DevicesInsights, ResourceId\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName, IPCustomEntity = SourceIPAddress, ResourceCustomEntity = ResourceId\n", "attributes": {"description": "'Adversaries may steal the credentials of a specific user or service account using Credential Access techniques or capture credentials earlier in their reconnaissance process through social engineering for means of gaining Persistence. Umbreon, for example, creates valid users to provide access to the system.\nThe query below generates an output of successful Sign-in with one or more of the following indications:\n- performed by new or recently dormant accounts\n- where one or more features of the activitiy deviates from the user, his peers or the tenant profile\n- performed by a user with Risk indicaiton from AAD'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/anomalousActionInTenant.yaml", "query_name": "Anomalous action performed in tenant by privileged user", "query": "BehaviorAnalytics\n| where ActivityInsights.FirstTimeActionPerformedInTenant == True\n| where UsersInsights.BlastRadius == 'High'\n| extend AadUserId = UsersInsights.AccountObjectID\n", "attributes": {"description": "'Shows activties that have never been executed in the tenant, performed by a user with high privileges.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/dormantAccountActivityFromUncommonCountry.yaml", "query_name": "Dormant account activity from uncommon country", "query": "BehaviorAnalytics\n| where UsersInsights.IsDormantAccount == True\n| where ActivityInsights.FirstTimeUserConnectedFromCountry == True\n| where ActivityInsights.CountryUncommonlyConnectedFromInTenant == True \n  or ActivityInsights.FirstTimeConnectionViaISPInTenant == True\n| extend AadUserId = UsersInsights.AccountObjectID\n", "attributes": {"description": "'Shows dormant accounts (not active in last 180 days), that connect from a country for the first time and the country is uncommon in the tenant or is the first time the ISP is used.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/firstConnectionFromGroup.yaml", "query_name": "Anomalous connection from highly privileged user", "query": "let Group = 'Helpdesk';\nIdentityInfo \n| summarize arg_max(TimeGenerated, *) by AccountObjectId //get latest information\n| where Department == Group\n| where BlastRadius == 'High'\n| join ( BehaviorAnalytics\n         | where ActivityType == 'LogOn'\n         | where ActionType == 'ResourceAccess' //filter for specific activties\n         | where ActivityInsights.FirstTimeUserAccessedResource == True\n         | where ActivityInsights.ResourceUncommonlyAccessedAmongPeers == True )\non $left.AccountUPN == $right.UserPrincipalName\n| extend AadUserId = UsersInsights.AccountObjectID\n", "attributes": {"description": "'Shows all users from a given department, which have high impact on the organization, who connected to a resource for the first time, and none of their peers accessed it'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/loginActivityFromBotnet.yaml", "query_name": "Anomalous login activity originated from Botnet, Tor proxy or C2", "query": "BehaviorAnalytics\n| where ActivityType == 'LogOn' or ActivityType == 'FailedLogOn'\n| where DevicesInsights.ThreatIntelIndicatorType == 'Botnet' \n  or DevicesInsights.ThreatIntelIndicatorType == 'C2' \n  or DevicesInsights.ThreatIntelIndicatorType == 'Proxy'\n| where ActivityInsights contains 'True'\n| extend AadUserId = UsersInsights.AccountObjectID\n", "attributes": {"description": "'Shows login activity (successful or failed) originated from botnet, Tor proxy or C2, with at least one 'True' activity insight.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/newAccountAddedToAdminGroup.yaml", "query_name": "New account added to admin group", "query": "let adminGroup = 'Administrators';\nIdentityInfo\n| where AccountCreationTime < ago(7d)\n| where GroupMembership contains adminGroup\n", "attributes": {"description": "'Account created in the last 7 days that is added to administrators group'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/terminatedEmployeeAccessHVA.yaml", "query_name": "Terminated employee accessing High Value Asset", "query": "_GetWatchlist('HighValueAssets')\n| join ( BehaviorAnalytics \n        | where ActionType contains \"ResourceAccess\") \n        on $left.['Asset Name'] == $right.DestinationDevice\n| join _GetWatchlist('TerminatedEmployees')\n  on $left.UserPrincipalName == $right.['User Principal Name']\n| extend AadUserId = UsersInsights.AccountObjectID\n", "attributes": {"description": "'Shows all users tagged as terminated employees in the Terminated Employees watchlist that had activities after their termination date.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/terminatedEmployeeActivity.yaml", "query_name": "Activity from terminated employees after their termination date", "query": "_GetWatchlist('TerminatedEmployees') \n| join (BehaviorAnalytics) \n  on $left.['User Principal Name'] == $right.UserPrincipalName\n| where TimeGenerated > todatetime(['Termination date'])\n| extend AadUserId = UsersInsights.AccountObjectID\n", "attributes": {"description": "'Shows all users tagged as terminated employees in the Terminated Employees watchlist that had activities after their termination date.'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/UEBA%20Essentials/Hunting%20Queries/updateKeyVaultActivity.yaml", "query_name": "Anomalous update Key Vault activity by high blast radius user", "query": "BehaviorAnalytics\n| where ActivityType == \"Administrative\"\n| where ActionType == \"Update Key Vault\"\n| where UsersInsights.BlastRadius == \"High\"\n| where ActivityInsights.FirstTimeActionPerformedInTenant == true or\n  ActivityInsights.FirstTimeUserPerformedAction == true or\n  ActivityInsights.FirstTimeConnectionFromCountryObservedInTenant == true\n| extend AadUserId = UsersInsights.AccountObjectID\n", "attributes": {"description": "'Shows all update Key Vault activities done by a user with a High blast radius. If the activity is performed for the first time (by the user or in the tenant) or if the activity originated in a never seen before country'\n", "techniques": null, "tactics": null}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/vArmour%20Application%20Controller/Analytic%20Rules/vArmourApplicationControllerSMBRealmTraversal.yaml", "query_name": "vArmour AppController - SMB Realm Traversal", "query": "CommonSecurityLog\n| where DeviceVendor == \"vArmour\"\n| where DeviceProduct == \"AC\"\n| where Activity == \"POLICY_VIOLATION\"\n| extend PolicyName = extract(\"(SMB_REALM_TRAVERSAL\\\\w+{.*})\", 1, DeviceCustomString1)\n", "attributes": {"description": "'Detects when SMB traffic crosses Production and Non-Production Realms. Possible network share discovery or lateral tool transfer across realms'\n", "techniques": ["T1135", "T1570"], "tactics": ["Discovery", "LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Detect/Analytic%20Rules/VectraDetect-Account-by-Severity.yaml", "query_name": "Vectra AI Detect - Suspected Compromised Account", "query": "// Edit this variable to only keep the Severity level where an incident needs to be created (Defaults are: \"Low\", \"Medium\", \"High\", \"Critical\" )   \nlet configured_level = dynamic([\"Low\", \"Medium\", \"High\", \"Critical\"]);\nlet upn_has_prefix = \":\";\nCommonSecurityLog\n| where DeviceVendor == \"Vectra Networks\"\n| where DeviceProduct == \"X Series\"\n| where DeviceEventClassID == \"asc\"\n| extend saccount = extract(\"saccount=(.+?);\", 1, AdditionalExtensions)\n| extend type = iff(saccount matches regex upn_has_prefix, tostring(split(saccount,\":\")[0]) ,\"network\" ) \n| extend upn = iff(saccount matches regex upn_has_prefix, tostring(split(saccount,\":\")[1]) , saccount )\n| project-rename threat_score = FlexNumber1\n| project-rename certainty_score = FlexNumber2\n| project-rename vectra_URL = DeviceCustomString4\n| project-rename detection_name = DeviceEventClassID\n| project-rename score_decreases = DeviceCustomString3\n| extend level = case( threat_score <  50 and certainty_score < 50, \"Low\",\n                       threat_score < 50 and certainty_score >= 50 , \"Medium\", \n                       threat_score >= 50 and certainty_score <= 50, \"High\", \n                       threat_score >= 50 and certainty_score >= 50, \"Critical\",\n                       \"UNKNOWN\")\n| extend Severity = case( level == \"Low\", \"Low\",\n                          level == \"Medium\", \"Medium\",\n                          level == \"High\", \"Medium\",\n                          level == \"Critical\", \"High\",\n                          \"UNKNOWN\")\n| where level in (configured_level) \n//keep only the event with the highest threat score per Host\n| summarize arg_max(threat_score, *) by saccount\n| project TimeGenerated, saccount, level, Severity, upn, type, threat_score, certainty_score, vectra_URL\n| extend AccountCustomEntity = upn, URLCustomEntity = vectra_URL, timestamp = TimeGenerated\n", "attributes": {"description": "'Create an incident when an Account is suspected to be compromised. \nThe higher the severity level is, the more immediate attention it requires as Vectra AI engine is more confident that this is a real threat. \nLevel of severity are: Low, Medium, High, Critical). Recommended configuration is to trigger an alert for at least High and Critical.'\n", "techniques": null, "tactics": ["CredentialAccess", "Discovery", "LateralMovement", "Collection", "CommandAndControl", "Exfiltration", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Detect/Analytic%20Rules/VectraDetect-HighSeverityDetection-by-Tactics.yaml", "query_name": "Vectra AI Detect - Detections with High Severity", "query": "// Edit this variable to only keep the tactics where an incident needs to be created (Defaults are: \"COMMAND & CONTROL\", \"BOTNET ACTIVITY\", \"EXFILTRATION\", \"LATERAL MOVEMENT\", \"RECONNAISSANCE\")   \nlet configured_tactics = dynamic([\"COMMAND & CONTROL\", \"BOTNET ACTIVITY\", \"EXFILTRATION\", \"LATERAL MOVEMENT\", \"RECONNAISSANCE\"]);\n//default threshold is 7 (meaning a threat score of 70)\nlet severity_threshold = 7.0;\n//Map by default to High Severity in Sentinel\nlet Severity = \"High\";\nCommonSecurityLog\n| where DeviceVendor == \"Vectra Networks\"\n| where DeviceProduct == \"X Series\"\n| where DeviceEventClassID != \"campaigns\" and DeviceEventClassID != \"hsc\" and DeviceEventClassID != \"audit\" and DeviceEventClassID != \"health\" and DeviceEventClassID != \"asc\"\n| extend Category = coalesce(\n                          column_ifexists(\"DeviceEventCategory\", \"\"), \n                          extract(\"cat=(.+?)(;|$)\", 1, AdditionalExtensions), \n                          \"\"\n                      )\n| project-rename threat_score = FlexNumber1\n| project-rename certainty_score = FlexNumber2\n| project-rename vectra_URL = DeviceCustomString4\n| project-rename detection_name = DeviceEventClassID\n| where todecimal(LogSeverity) >= severity_threshold\n| extend Tactic = case( Category == \"COMMAND & CONTROL\", \"CommandAndControl\",\n                        Category == \"BOTNET ACTIVITY\" , \"Impact\",\n                        Category == \"EXFILTRATION\", \"Exfiltration\",\n                        Category == \"LATERAL MOVEMENT\", \"LateralMovement\",\n                        Category == \"RECONNAISSANCE\", \"Discovery\",\n                        \"UNKNOWN\")\n| extend account = extract(\"account=(.+?);\", 1, AdditionalExtensions)\n| extend upn = iff(account matches regex \":\", tostring(split(account,\":\")[1]) ,tostring(split(account,\":\")[0])) \n| extend source_entity = case( isnotempty(upn), upn,\n                               isnotempty(SourceHostName), SourceHostName,\n                               \"UNKNWON\") \n| where Category in (configured_tactics) \n| summarize arg_max(threat_score, *) by source_entity, Activity\n| sort by TimeGenerated\n| project TimeGenerated, source_entity, SourceHostName, SourceIP, upn, Tactic, Activity, LogSeverity, Severity, vectra_URL\n| extend AccountCustomEntity = upn, HostCustomEntity = SourceHostName, IPCustomEntity = SourceIP, URLCustomEntity = vectra_URL, timestamp = TimeGenerated\n", "attributes": {"description": "'Create an incident for high severity malicious behavior detected by Vectra AI (Threat score superior to 7.0). \nThe Severity is a mapping with the Threat score assigned to a detection. It ranges between 0 and 10. \nThe severity_threshold variable can be adjusted as desired.' \n", "techniques": null, "tactics": ["CredentialAccess", "Discovery", "LateralMovement", "Collection", "CommandAndControl", "Exfiltration", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Detect/Analytic%20Rules/VectraDetect-Host-by-Severity.yaml", "query_name": "Vectra AI Detect - Suspected Compromised Host", "query": "// Edit this variable to only keep the Severity level where an incident needs to be created (Defaults are: \"Low\", \"Medium\", \"High\", \"Critical\" )   \nlet configured_level = dynamic([\"Low\", \"Medium\", \"High\", \"Critical\"]);\nCommonSecurityLog\n| where DeviceVendor == \"Vectra Networks\"\n| where DeviceProduct == \"X Series\"\n| where DeviceEventClassID == \"hsc\"\n| project-rename threat_score = FlexNumber1\n| project-rename certainty_score = FlexNumber2\n| project-rename vectra_URL = DeviceCustomString4\n| project-rename detection_name = DeviceEventClassID\n| project-rename score_decreases = DeviceCustomString3\n| extend level = case( threat_score <  50 and certainty_score < 50, \"Low\",\n                       threat_score < 50 and certainty_score >= 50 , \"Medium\", \n                       threat_score >= 50 and certainty_score <= 50, \"High\", \n                       threat_score >= 50 and certainty_score >= 50, \"Critical\",\n                       \"UNKNOWN\")\n| extend Severity = case( level == \"Low\", \"Low\",\n                          level == \"Medium\", \"Medium\",\n                          level == \"High\", \"Medium\",\n                          level == \"Critical\", \"High\",\n                          \"UNKNOWN\")\n| where level in (configured_level) \n//keep only the event with the highest threat score per Host\n| summarize arg_max(threat_score, *) by SourceHostName\n| project SourceHostName, level, Severity, TimeGenerated, SourceIP, threat_score, certainty_score, vectra_URL\n| extend HostCustomEntity = SourceHostName, IPCustomEntity = SourceIP, URLCustomEntity = vectra_URL, timestamp = TimeGenerated\n", "attributes": {"description": "'Create an incident when a Host is suspected to be compromised. \nThe higher the severity level is, the more immediate attention it requires as Vectra AI engine is more confident that this is a real threat. \nLevel of severity are: Low, Medium, High, Critical). Recommended configuration is to trigger an alert for at least High and Critical.'\n", "techniques": null, "tactics": ["CredentialAccess", "Discovery", "LateralMovement", "Collection", "CommandAndControl", "Exfiltration", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Detect/Analytic%20Rules/VectraDetect-NewCampaign.yaml", "query_name": "Vectra AI Detect - New Campaign Detected", "query": "CommonSecurityLog\n| where DeviceVendor == \"Vectra Networks\"\n| where DeviceProduct == \"X Series\"\n| where DeviceEventClassID contains \"campaign\"\n| where DeviceAction == \"START\"\n| extend reason = coalesce(\n                          column_ifexists(\"Reason\", \"\"), \n                          extract(\"reason=(.+?)($|;)\", 1, AdditionalExtensions),\n                          \"\"\n                      )\n| project-rename vectra_URL = DeviceCustomString4\n| project Activity,SourceHostName, reason, vectra_URL\n| extend HostCustomEntity = SourceHostName, URLCustomEntity = vectra_URL\n", "attributes": {"description": "'Identifies when a new Campaign has been detected.  This occurs when multiple Detections accross different Hosts are suspected to be part of the same Attack Campaign.'\n", "techniques": null, "tactics": ["LateralMovement", "CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Detect/Analytic%20Rules/VectraDetect-Suspected-Behavior-by-Tactics.yaml", "query_name": "Vectra AI Detect - Suspicious Behaviors", "query": "// Edit this variable to only keep the tactics where an incident needs to be created (Defaults are: \"COMMAND & CONTROL\", \"BOTNET ACTIVITY\", \"EXFILTRATION\", \"LATERAL MOVEMENT\", \"RECONNAISSANCE\")   \nlet configured_tactics = dynamic([\"COMMAND & CONTROL\", \"BOTNET ACTIVITY\", \"EXFILTRATION\", \"LATERAL MOVEMENT\", \"RECONNAISSANCE\"]);\nCommonSecurityLog\n| where DeviceVendor == \"Vectra Networks\"\n| where DeviceProduct == \"X Series\"\n| where DeviceEventClassID != \"campaigns\" and DeviceEventClassID != \"hsc\" and DeviceEventClassID != \"audit\" and DeviceEventClassID != \"health\" and DeviceEventClassID != \"asc\" \n| extend Category = coalesce(\n                          column_ifexists(\"DeviceEventCategory\", \"\"), \n                          extract(\"cat=(.+?)(;|$)\", 1, AdditionalExtensions), \n                          \"\"\n                      )\n| project-rename threat_score = FlexNumber1\n| project-rename certainty_score = FlexNumber2\n| project-rename triaged = DeviceCustomString5\n| project-rename vectra_URL = DeviceCustomString4\n| project-rename detection_name = DeviceEventClassID\n| extend Tactic = case( Category == \"COMMAND & CONTROL\", \"CommandAndControl\",\n                        Category == \"BOTNET ACTIVITY\" , \"Impact\",\n                        Category == \"EXFILTRATION\", \"Exfiltration\",\n                        Category == \"LATERAL MOVEMENT\", \"LateralMovement\",\n                        Category == \"RECONNAISSANCE\", \"Discovery\",\n                        \"UNKNOWN\")\n| extend level = case( threat_score <  50 and certainty_score < 50, \"Low\",\n                       threat_score < 50 and certainty_score >= 50 , \"Medium\", \n                       threat_score >= 50 and certainty_score <= 50, \"High\", \n                       threat_score >= 50 and certainty_score >= 50, \"Critical\",\n                       \"UNKNOWN\")\n| extend Severity = case( level == \"Low\", \"Low\",\n                          level == \"Medium\", \"Medium\",\n                          level == \"High\", \"Medium\",\n                          level == \"Critical\", \"High\",\n                          \"UNKNOWN\")\n| extend account = extract(\"account=(.+?);\", 1, AdditionalExtensions)\n| extend upn = iff(account matches regex \":\", tostring(split(account,\":\")[1]) ,tostring(split(account,\":\")[0])) \n| extend source_entity = case( isnotempty(upn), upn,\n                               isnotempty(SourceHostName), SourceHostName,\n                               \"UNKNWON\") \n| where Category in (configured_tactics) \n| summarize arg_max(threat_score, *) by source_entity , Activity\n| project  TimeGenerated, source_entity, SourceHostName, SourceIP, upn, Activity, Tactic, Severity, threat_score, certainty_score, triaged, vectra_URL\n| extend AccountCustomEntity = upn, HostCustomEntity = SourceHostName, IPCustomEntity = SourceIP, URLCustomEntity = vectra_URL, timestamp = TimeGenerated\n", "attributes": {"description": "'Create an incident for each new malicious behavior detected by Vectra Detect. \nBy default, it looks through all tactics. This can be modified to create incident only for a subset of tactics.'\n", "techniques": null, "tactics": ["CredentialAccess", "Discovery", "LateralMovement", "Collection", "CommandAndControl", "Exfiltration", "Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraHighVolumeOfNXDOMAIN.yaml", "query_name": "Vectra AI - Potential Exfiltration over DNS", "query": "//Adjust the threshold as desired (default is 500)\nlet min_fail_query = 500;\nVectraStream\n| where metadata_type == \"metadata_dns\"\n| where rcode_name in~ ('NXDOMAIN', 'SERVFAIL')\n| summarize count() by orig_hostname, id_orig_h, bin(TimeGenerated, 1h)\n| where count_ > min_fail_query\n| extend HostCustomEntity = orig_hostname, IPCustomEntity = id_orig_h\n", "attributes": {"description": "'Query searches for high volume of DNS resolutions which return non existent domain. \nMetadata required = metadata_dns'\n", "techniques": ["T1048.003", "T1071.004"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraMaliciousToolFileCopy.yaml", "query_name": "Vectra AI - Malicious Tools File Copy", "query": "let suspicious_names = dynamic([\"bloodhound.py\",\"BloodHound.py\",\"ADRecon.ps1\",\"ADRecon\",\"CrackMapExec\",\"crackmapexec\",\"Invoke-HoneypotBuster.ps1\",\"HoneypotBuster\",\"impacket\",\"impacket-maste\",\"Inveigh\",\"Inveigh-master\",\"Inveigh.ps1\",\"Inveigh-relay.ps1\",\"LaZagne\",\"laZagne.py\",\"laZagne-master\",\"mimipenguin-maste\",\"mimipenguin.py\",\"mimikatz.exe\",\"mimidrv.sys\",\"mimilib.dll\",\"nishang\",\"Nishang.psm1\",\"nishang.psm1\",\"PowerLessShell\",\"csproj.bat\",\"PowerSploit\",\"PowerUpSQL\",\"PsExec.exe\",\"PsExec64.exe\",\"procdump.exe\",\"Procdump.exe\",\"lsass.dmp\",\"lsass.DMP\",\"ReflectiveDLLInjection\",\"inject.exe\",\"inject.arm.exe\",\"inject.x64.exe\",\"reflective_dll.x64.dll\",\"reflective_dll.dll\",\"fingerprint.py\",\"packets.py\",\"Responder.py\",\"Responder-master\",\"BrowserListener.py\",\"DHCP.py\",\"DHCP_Auto.sh\",\"FindSMB2UPTime.py\",\"FindSQLSrv.py\",\"Icmp-Redirect.py\",\"RelayPackets.py\",\"SMBRelay.py\",\"Export-PotentiallyCrackableAccounts.ps1\",\"Find-PotentiallyCrackableAccounts.ps1\",\"Get-TGSCipher.ps1\",\"RiskySPNs.psd1\",\"RiskySPNs.psm\",\"RiskySPNs-master\",\"SessionGopher.ps1\",\"BloodHound.zip\",\"WorsePDF\"]);\nVectraStream\n| where metadata_type == \"metadata_smbfiles\"\n| where name has_any (suspicious_names)\n| extend HostCustomEntity = orig_hostname, IPCustomEntity = id_orig_h, timestamp = TimeGenerated\n", "attributes": {"description": "'Query searches for suspicious malicious file names copy over SMB.\nMetadata required = metadata_smbfiles'\n", "techniques": ["T1570"], "tactics": ["CredentialAccess", "LateralMovement", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraNetbiosLLMNRUsage.yaml", "query_name": "Vectra AI - Potential LLMNR/NBT-NS Poisoning and SMB Relay", "query": "//whitelist IP addresses from the result  (default is empty)\nlet whitelist = dynamic([\"\"]);\nVectraStream\n| where metadata_type == \"metadata_isession\"\n| where id_resp_p == \"137\" or id_resp_p == \"5535\"\n| where protoName == \"UDP\"\n| where id_resp_h !in (whitelist)\n| extend HostCustomEntity = resp_hostname, IPCustomEntity = id_resp_h, timestamp = TimeGenerated\n", "attributes": {"description": "'Query searches for potential LLMNR/NBT-NS Poisoning and SMB Relay. The host of interest is the one responding to such request.\nBy responding to LLMNR/NBT-NS network traffic, adversaries may spoof an authoritative source for name resolution to force communication with an adversary controlled system. This activity may be used to collect or relay authentication materials.\nMetadata required = metadata_isession'\n", "techniques": ["T1557.001"], "tactics": ["CredentialAccess", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraPoshC2.yaml", "query_name": "Vectra AI - Possible PoshC2 Tunnel", "query": "VectraStream\n| where metadata_type == \"metadata_ssl\"\n| where ja3 == \"e84d3d1743f1da2f03fe6296bd97b7d6\"\n| project TimeGenerated, orig_hostname, id_orig_h, id_resp_h, id_resp_p, service, version, server_name, ja3\n| extend HostCustomEntity = orig_hostname, IPCustomEntity = id_orig_h, timestamp = TimeGenerated\n", "attributes": {"description": "'Query searches PoshC2 Tunnel.\nPoshC2 can use protocols like HTTPS for command and control traffic\nMetadata required = metadata_ssl'\n", "techniques": ["T1071.001"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraPotentialDCSync.yaml", "query_name": "Vectra AI - Potential DCSync Attack", "query": "//Add IP addresses of your Domain Dontrollers (default is empty)\nlet IpDC = dynamic([\"\"]);\n//Add hostnames of your Domain Dontrollers (default is empty)\nlet NameDC = dynamic([\"\"]);\nVectraStream\n| where metadata_type == \"metadata_dcerpc\"\n| where endpoint == \"drsuapi\" and operation == \"DRSGetNCChanges\"\n| where id_orig_h !in (IpDC) or orig_hostname !in (NameDC)\n| extend AccountCustomEntity = username, HostCustomEntity = orig_hostname, IPCustomEntity = id_orig_h, timestamp = TimeGenerated\n", "attributes": {"description": "'Query searches for potential DCSync Attack. \nIn this attack, an adversary attempt to access credentials and other sensitive information by abusing a Windows Domain Controller's application programming interface (API)\nMetadata required = metadata_dcerpc'\n", "techniques": ["T1003.006"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraSuspectedKali.yaml", "query_name": "Vectra AI - Possible Kali Linux Detected", "query": "VectraStream\n| where metadata_type == \"metadata_httpsessioninfo\"\n| where user_agent matches regex \".*[lL]inux.*[kK]ali.*\"\n| extend HostCustomEntity = orig_hostname, IPCustomEntity = id_orig_h, timestamp = TimeGenerated\n", "attributes": {"description": "'Query searches Kali Linux machine in your environment. \nMetadata required = metadata_httpsessioninfo'\n", "techniques": ["T1048.003"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraSuspiciousBeacon.yaml", "query_name": "Vectra AI - Beaconing Behaviors", "query": "//Whitelist source IP (default is empty)\nlet whitelist_src_ip = dynamic([\"\"]);\n//Whitelist domain names (default is empty)\nlet whitelist_domain = dynamic([\"\"]);\nVectraStream\n| where metadata_type == \"metadata_beacon\"\n| where id_orig_h !in (whitelist_src_ip) or orig_hostname !in (whitelist_domain)\n| summarize  arg_max(session_count, *) by orig_hostname, id_resp_h\n| project ts, orig_hostname, id_orig_h, id_resp_h, id_resp_p, beacon_type, resp_domains, session_count\n| extend HostCustomEntity = orig_hostname, IPCustomEntity = id_orig_h\n", "attributes": {"description": "'Query searches for beaconing behavior. \nVectra uses its AI to enrich metadata and detect beaconing behaviors within your environment.\nMetadata required = metadata_beacon'\n", "techniques": ["T1095", "T1071", "T1573", "T1008", "T1095", "T1571", "T1219"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraSuspiciousLongDNSQueries.yaml", "query_name": "Vectra AI - Suspicious Long DNS Queries", "query": "VectraStream\n| where metadata_type == \"metadata_dns\"\n| extend querylength = strlen(['query'])\n| summarize count() by querylength, orig_hostname, id_orig_h\n| sort by querylength desc \n| extend HostCustomEntity = orig_hostname, IPCustomEntity = id_orig_h\n", "attributes": {"description": "'Query searches long DNS queries.\nA high volume of long DNS queries may indicate the usage of DNS Tunneling.\nMetadata required = metadata_dns'\n", "techniques": ["T1071.004", "T1048.003"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraSuspiciousNbOfSubDomains.yaml", "query_name": "Vectra AI - Suspicious number of sub-domains", "query": "//Adjust the threshold as desired (default is 500)\nlet min_sub_domains = 500;\nVectraStream\n| where metadata_type == \"metadata_dns\"\n| extend top_domain = extract(@\"(?:(?P<rex_sub_domain>[^\\.\\s]+)\\.)??(?P<rex_domain>(?:(?P<rex_domain_no_tld>[^\\.\\s]+)\\.)?(?P<rex_tld>[^\\.\\s]{2,}))$\",2,['query'])\n| summarize sub_domains=dcount(['query']) by top_domain, orig_hostname, id_orig_h\n| where sub_domains > min_sub_domains\n| extend HostCustomEntity = orig_hostname, IPCustomEntity = id_orig_h\n", "attributes": {"description": "'Query searches for number of sub-domains attached per domain\nA high volume of sub-domains may indicate the usage of DNS Tunneling.\nMetadata required = metadata_dns'\n", "techniques": ["T1071.004", "T1048.003"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Vectra%20AI%20Stream/Hunting%20Queries/VectraUnsecuredCredsGPP.yaml", "query_name": "Vectra AI - Suspicious Unsecured Credentials Group Policy Preferences", "query": "//List of suspicipous name in SYSVOL share\nlet filenames = dynamic([\"scheduledTasks.xml\",\"groups.xml\",\"services.xml\",\"datasources.xml\",\"printers.xml\",\"drives.xml\"]);\nVectraStream\n| where metadata_type == \"metadata_smbfiles\"\n| where name contains (filenames)\n| where path matches regex \".*sysvol.*\"\n| where action == \"SMB::FILE_READ\" or action == \"SMB::FILE_OPEN\"\n| extend HostCustomEntity = orig_hostname, IPCustomEntity = id_orig_h, timestamp = TimeGenerated\n", "attributes": {"description": "'Query searches for suspicious Unsecured Credential using GPP Attack. \nAn adversary may look for legacy GPPs containing credentials, stored in an insecure manner. GPPs files are all stored on the domain controller in the SYSVOL share.\nMetadata required = metadata_smbfiles'\n", "techniques": ["T1552.006"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMware%20Carbon%20Black%20Cloud/Analytic%20Rules/CriticalThreatDetected.yaml", "query_name": "Critical Threat Detected", "query": "\nlet threshold = 8;\nCarbonBlackNotifications_CL\n| where threatHunterInfo_score_d >= threshold\n| extend eventTime = datetime(1970-01-01) + tolong(threatHunterInfo_time_d/1000) * 1sec\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by eventTime, Threat_Name = threatHunterInfo_reportName_s, Device_Name = deviceInfo_deviceName_s,  Internal_IP = deviceInfo_internalIpAddress_s, External_IP = deviceInfo_externalIpAddress_s, Threat_Score = threatHunterInfo_score_d\n| project-away count_\n| extend timestamp = StartTime, HostCustomEntity = Device_Name, IPCustomEntity = Internal_IP\n", "attributes": {"description": "'This creates an incident in the event a critical threat was identified on a Carbon Black managed endpoint.'\n", "techniques": ["T1210"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMware%20Carbon%20Black%20Cloud/Analytic%20Rules/KnownMalwareDetected.yaml", "query_name": "Known Malware Detected", "query": "\nCarbonBlackEvents_CL\n| extend eventTime = datetime(1970-01-01) + tolong(eventTime_d/1000) * 1sec\n| where targetApp_effectiveReputation_s =~ \"KNOWN_MALWARE\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by eventTime, deviceDetails_deviceName_s, deviceDetails_deviceIpAddress_s, processDetails_fullUserName_s, processDetails_targetName_s\n| extend timestamp = StartTime, AccountCustomEntity = processDetails_fullUserName_s, HostCustomEntity = deviceDetails_deviceName_s, IPCustomEntity = deviceDetails_deviceIpAddress_s\n", "attributes": {"description": "'This creates an incident when a known Malware is detected on a endpoint managed by a Carbon Black.'\n", "techniques": ["T1204"], "tactics": ["Execution"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMware%20vCenter/Analytic%20Rules/vCenter-Root%20impersonation.yaml", "query_name": "vCenter - Root impersonation", "query": "vCenter\n | where Message has_all ('ImpersonateUser', 'VcIntegrity', 'root')\n | extend user = 'root'\n", "attributes": {"description": "'Detects when root impersonation occurs.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMware%20vCenter/Analytic%20Rules/vCenterRootLogin.yaml", "query_name": "VMware vCenter - Root login", "query": "let p_lookback = 14d;\nlet t_lookback = 1h;\nlet root_ips = vCenter\n| where TimeGenerated between (ago(p_lookback) .. ago(t_lookback))\n| where EventType has_all ('UserLoginSessionEvent', 'root', 'logged in')\n| summarize make_set(SourceIP,128);\nvCenter\n| where TimeGenerated > ago(t_lookback)\n| where EventType   has_all ('UserLoginSessionEvent', 'root', 'logged in')\n| where SourceIP   !in (root_ips)\n", "attributes": {"description": "'Detects when root user login from uncommon IP address.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiDormantVMStarted.yaml", "query_name": "VMware ESXi - Dormant VM started", "query": "let vm_p_off =\nVMwareESXi\n| where TimeGenerated > ago(14d)\n| where SyslogMessage has ('VmPoweredOffEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| summarize LastPowerOffTime=max(TimeGenerated) by DstHostname\n| where datetime_diff('day',datetime(now),LastPowerOffTime) >= 20; \nlet vm_p_on =\nVMwareESXi\n| where TimeGenerated > ago(14d)\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| summarize LastPowerOnTime=max(TimeGenerated) by DstHostname\n| where datetime_diff('day',datetime(now),LastPowerOnTime) >= 20;\nlet off_vms =\nvm_p_on\n| join (vm_p_off) on DstHostname\n| where LastPowerOffTime > LastPowerOnTime\n| summarize p_off_vm = makeset(DstHostname)\n| extend k=1;\nVMwareESXi\n| where TimeGenerated between (ago(24h) .. datetime(now))\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| extend k=1\n| join (off_vms) on k\n| where p_off_vm !has DstHostname\n| summarize rec_p_on = makeset(DstHostname)\n| extend HostCustomEntity = rec_p_on\n", "attributes": {"description": "'Detects when dormant VM was started.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiLowPatchDiskSpace.yaml", "query_name": "VMware ESXi - Low patch disk space", "query": "let threshold = 100;\nVMwareESXi\n| where SyslogMessage has ('Patch store disk')\n| extend sp = toreal(extract(@'free space is:\\s(\\d+)', 1, SyslogMessage)) / 1000000000\n| where sp < threshold\n| extend h = 'Hypervisor'\n| extend HostCustomEntity = h\n", "attributes": {"description": "'This rule is triggered when low patch disk store space is detected.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiLowTempDirSpace.yaml", "query_name": "VMware ESXi - Low temp directory space", "query": "let threshold = 10;\nVMwareESXi\n| where SyslogMessage has_all ('Temp directory', 'free space')\n| extend sp = toreal(extract(@'free space is:\\s(\\d+)', 1, SyslogMessage)) / 1000000000\n| where sp < threshold\n| extend h = 'Hypervisor'\n| extend HostCustomEntity = h\n", "attributes": {"description": "'This rule is triggered when temp directory space is detected.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiMultipleNewVM.yaml", "query_name": "VMware ESXi - Multiple new VMs started", "query": "let threshold = 5;\nlet a_vm = \nVMwareESXi\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| summarize vm_l = makeset(DstHostname)\n| extend k=1;\nVMwareESXi\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| extend SrcUsername = extract(@'\\[info\\]\\s+\\[(.*?)\\]', 1, SyslogMessage)\n| extend k = 1\n| join (a_vm) on k\n| where vm_l !has DstHostname\n| summarize n_vm = makeset(DstHostname) by SrcUsername, bin(TimeGenerated, 10m)\n| where array_length(n_vm) >= threshold\n| extend HostCustomEntity = n_vm\n", "attributes": {"description": "'Detects when multiple new VMs were started.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiMultipleVMStopped.yaml", "query_name": "VMware ESXi - Multiple VMs stopped", "query": "let threshold = 5;\nVMwareESXi\n| where SyslogMessage has ('VmPoweredOffEvent')\n| extend SrcUsername = extract(@'\\[info\\]\\s+\\[(.*?)\\]', 1, SyslogMessage)\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| summarize st_vm = makeset(DstHostname) by SrcUsername, bin(TimeGenerated, 5m)\n| where array_length(st_vm) > threshold\n| extend HostCustomEntity = st_vm, AccountCustomEntity = SrcUsername\n", "attributes": {"description": "'Detects when multiple VMs ware stopped by user.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiNewVM.yaml", "query_name": "VMware ESXi - New VM started", "query": "let a_vm = \nVMwareESXi\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| summarize vm_l = makeset(DstHostname)\n| extend k=1;\nVMwareESXi\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| extend k = 1\n| join (a_vm) on k\n| where vm_l !has DstHostname\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Detects when new VM was started.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiRootImpersonation.yaml", "query_name": "VMware ESXi - Root impersonation", "query": "VMwareESXi\n| where SyslogMessage has_all ('ImpersonateUser', 'VcIntegrity', 'root')\n| extend user = 'root'\n| extend AccountCustomEntity = user\n", "attributes": {"description": "'Detects when root impersonation occurs.'\n", "techniques": ["T1078"], "tactics": ["PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiRootLogin.yaml", "query_name": "VMware ESXi - Root login", "query": "let p_lookback = 14d;\nlet t_lookback = 1h;\nlet root_ips = VMwareESXi\n| where TimeGenerated between (ago(p_lookback) .. ago(t_lookback))\n| where SyslogMessage has_all ('UserLoginSessionEvent', 'root', 'logged in')\n| extend SrcIpAddr = extract(@'root@(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})', 1, SyslogMessage)\n| summarize makeset(SrcIpAddr);\nVMwareESXi\n| where TimeGenerated > ago(t_lookback)\n| where SyslogMessage has_all ('UserLoginSessionEvent', 'root', 'logged in')\n| extend SrcIpAddr = extract(@'root@(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})', 1, SyslogMessage)\n| where SrcIpAddr !in (root_ips)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when root user login from uncommon IP address.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiSharedOrStolenRootAccount.yaml", "query_name": "VMware ESXi - Shared or stolen root account", "query": "VMwareESXi\n| where SyslogMessage has_all ('UserLoginSessionEvent', 'root', 'logged in')\n| extend SrcIpAddr = extract(@'root@(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})', 1, SyslogMessage)\n| summarize count() by SrcIpAddr, bin(TimeGenerated, 15m)\n| where count_ > 1\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Detects when shared or stolen root account.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiUnexpectedDiskImage.yaml", "query_name": "VMware ESXi - Unexpected disk image", "query": "let img_ =\nVMwareESXi\n| where SyslogMessage has ('Matched discovered VM')\n| extend DstHostname = extract(@'vim.VirtualMachine\\S+,(.*?)\\]', 1, SyslogMessage)\n| extend kImageName = extract(@'ds:///vmfs/volumes/(.*)/(.*?),', 2, SyslogMessage)\n| summarize img_lst = makeset(kImageName) by DstHostname;\nVMwareESXi\n| where SyslogMessage has ('Matched discovered VM')\n| extend DstHostname = extract(@'vim.VirtualMachine\\S+,(.*?)\\]', 1, SyslogMessage)\n| extend ImageName = extract(@'ds:///vmfs/volumes/(.*)/(.*?),', 2, SyslogMessage)\n| join (img_) on DstHostname\n| where img_lst !has ImageName\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Detects unexpected disk image for VM.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Analytic%20Rules/ESXiVMStopped.yaml", "query_name": "VMware ESXi - VM stopped", "query": "VMwareESXi\n| where SyslogMessage has ('VmPoweredOffEvent')\n| extend SrcUsername = extract(@'\\[info\\]\\s+\\[(.*?)\\]', 1, SyslogMessage)\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| extend HostCustomEntity = DstHostname, AccountCustomEntity = SrcUsername\n", "attributes": {"description": "'Detects when VM was stopped.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiDormantUsers.yaml", "query_name": "VMware ESXi - List of dormant users.", "query": "VMwareESXi\n| where TimeGenerated > ago(30d)\n| where SyslogMessage has_all ('UserLoginSessionEvent', 'logged in')\n| extend SrcUsername = extract(@'User\\s(.*?)@\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}', 1, SyslogMessage)\n| summarize LastLoginTime=max(TimeGenerated) by SrcUsername\n| extend AccountCustomEntity = SrcUsername\n", "attributes": {"description": "'Query searches for dormant user dormant.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiDownloadErrors.yaml", "query_name": "VMware ESXi - Download errors", "query": "VMwareESXi\n| where TimeGenerated > ago(24h)\n| where SyslogMessage has_any ('Download failed', 'Failed to download file', 'File download error')\n| extend URLCustomEntity = SyslogMessage\n", "attributes": {"description": "'Query searches for download errors.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiNFCDownloadActivities.yaml", "query_name": "VMware ESXi - NFC download activities", "query": "VMwareESXi\n| where TimeGenerated > ago(24h)\n| where SyslogMessage has_all ('NFC', 'operation', 'Download')\n| extend SrcUsername = extract(@'\\[info\\]\\s+\\[(.*?)\\]', 1, SyslogMessage)\n| extend path = extract(@\"for path '(.*?)'\\swas\", 1, SyslogMessage)\n| extend SrcIpAddr = extract(@\"initiated from '(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\", 1, SyslogMessage)\n| extend Result = extract(@\"status\\s'(\\w+)'\", 1, SyslogMessage)\n| extend HostCustomEntity = Computer\n", "attributes": {"description": "'Query searches for download activities.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiRootLoginFailure.yaml", "query_name": "VMware ESXi - Root logins failures", "query": "VMwareESXi\n| where TimeGenerated > ago(24h)\n| where SyslogMessage has_all ('UserLoginSessionEvent', 'root', 'fail')\n| extend SrcIpAddr = extract(@'root@(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})', 1, SyslogMessage)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for failed root logins.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiRootLogins.yaml", "query_name": "VMware ESXi - Root logins", "query": "VMwareESXi\n| where TimeGenerated > ago(24h)\n| where SyslogMessage has_all ('UserLoginSessionEvent', 'root', 'logged in')\n| extend SrcIpAddr = extract(@'root@(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})', 1, SyslogMessage)\n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query searches for root logins.'\n", "techniques": ["T1078"], "tactics": ["InitialAccess", "PrivilegeEscalation"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiUnusedVMs.yaml", "query_name": "VMware ESXi - List of unused VMs", "query": "let vm_p_off =\nVMwareESXi\n| where TimeGenerated > ago(30d)\n| where SyslogMessage has ('VmPoweredOffEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| summarize LastPowerOffTime=max(TimeGenerated) by DstHostname\n| where datetime_diff('day', datetime(now), LastPowerOffTime) >= 20; \nlet vm_p_on =\nVMwareESXi\n| where TimeGenerated > ago(30d)\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| summarize LastPowerOnTime=max(TimeGenerated) by DstHostname\n| where datetime_diff('day',datetime(now),LastPowerOnTime) >= 20;\nlet off_vms =\nvm_p_on\n| join (vm_p_off) on DstHostname\n| where LastPowerOffTime > LastPowerOnTime\n| summarize p_off_vm = makeset(DstHostname)\n| extend k=1;\nlet p_on_vms =\nVMwareESXi\n| where TimeGenerated between (ago(24h) .. datetime(now))\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| extend k=1\n| join (off_vms) on k\n| where p_off_vm !has DstHostname\n| summarize rec_p_on = makeset(DstHostname)\n| extend k=1;\nVMwareESXi\n| where TimeGenerated between (ago(24h) .. datetime(now))\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| extend k=1\n| join (p_on_vms) on k\n| where  rec_p_on !has DstHostname\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for unused VMs.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiVirtualImagesList.yaml", "query_name": "VMware ESXi - List of virtual disks (images)", "query": "VMwareESXi\n| where TimeGenerated > ago(24h)\n| where SyslogMessage has ('Matched discovered VM')\n| extend DstHostname = extract(@'vim.VirtualMachine\\S+,(.*?)\\]', 1, SyslogMessage)\n| extend ImageName = extract(@'ds:///vmfs/volumes/(.*)/(.*?),', 2, SyslogMessage)\n| summarize makeset(ImageName) by DstHostname\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for virtual disks (images) seen for VM.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiVMHighLoad.yaml", "query_name": "VMware ESXi - VM high resource load", "query": "let threshold = 50;\nVMwareESXi\n| where TimeGenerated > ago(24h)\n| where SyslogMessage has_any ('Virtual machine CPU usage', 'Virtual machine memory usage')\n| where SyslogMessage has_all ('AlarmStatusChangedEvent', 'Red')\n| extend DstHostname = extract(@\"usage'\\son\\s(.*?)\\schanged\", 1, SyslogMessage)\n| summarize count() by DstHostname, bin(TimeGenerated, 1h)\n| where count_ >= threshold\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for VMs with high resource consumption.'\n", "techniques": ["T1499"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiVMPoweredOff.yaml", "query_name": "VMware ESXi - List of powered off VMs", "query": "VMwareESXi\n| where TimeGenerated > ago(24h)\n| where SyslogMessage has ('VmPoweredOffEvent')\n| extend SrcUsername = extract(@'\\[info\\]\\s+\\[(.*?)\\]', 1, SyslogMessage)\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| project TimeGenerated, SrcUsername, DstHostname\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for powered off VMs.'\n", "techniques": ["T1529"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/VMWareESXi/Hunting%20Queries/ESXiVMPoweredOn.yaml", "query_name": "VMware ESXi - List of powered on VMs", "query": "VMwareESXi\n| where TimeGenerated > ago(24h)\n| where SyslogMessage has ('VmPoweredOnEvent')\n| extend SrcUsername = extract(@'\\[info\\]\\s+\\[(.*?)\\]', 1, SyslogMessage)\n| extend DstHostname = extract(@'\\[\\d+\\]\\s+\\[(.*?)\\s+on', 1, SyslogMessage)\n| project TimeGenerated, SrcUsername, DstHostname\n| extend HostCustomEntity = DstHostname\n", "attributes": {"description": "'Query searches for powered on VMs.'\n", "techniques": ["T1190"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Forwarded%20Events/Analytic%20Rules/ChiaCryptoMining_WindowsEvent.yaml", "query_name": "Chia_Crypto_Mining - Domain, Process, Hash and IP IOCs - June 2021", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/ChiaCryptoIOC.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet process = (iocs | where Type =~ \"process\" | project IoC);\n//This query uses sysmon data, sections that have - | where Source == \"Microsoft-Windows-Sysmon\" - may need to be updated with latest\nWindowsEvent\n| where EventID == '4688' and EventData has_any (process)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| where NewProcessName  has_any (process)\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n  , Account =  strcat(tostring(EventData.SubjectDomainName),\"\\\\\", tostring(EventData.SubjectUserName))\n  , NewProcessId = tostring(EventData.NewProcessId)\n| extend timestamp = TimeGenerated, Computer, Account, File = tostring(split(NewProcessName, '\\\\', -1)[-1]), AlertDetail = 'Chia crypto IOC detected'\n| extend FilePath = replace_string(NewProcessName, File, '')\n| project TimeGenerated, timestamp, File, AlertDetail, FilePath,Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type\n", "attributes": {"description": "'Identifies a match across various data feeds for domains, process, hashes and IP IOC related to Chia cryptocurrency farming/plotting activity.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Forwarded%20Events/Analytic%20Rules/SOURGUM_IOC_WindowsEvent.yaml", "query_name": "SOURGUM Actor IOC - July 2021", "query": "let iocs = externaldata(DateAdded:string,IoC:string,Type:string,TLP:string) [@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/SOURGUM.csv\"] with (format=\"csv\", ignoreFirstRecord=True);\nlet domains = (iocs | where Type =~ \"domainname\"| project IoC);\nlet sha256Hashes = (iocs | where Type =~ \"sha256\" | project IoC);\nlet file_path1 = (iocs | where Type =~ \"filepath1\" | project IoC);\nlet file_path2 = (iocs | where Type =~ \"filepath2\" | project IoC);\nlet file_path3 = (iocs | where Type =~ \"filepath3\" | project IoC);\nlet reg_key = (iocs | where Type =~ \"regkey\" | project IoC);\nWindowsEvent\n| where EventID == 4688 and (EventData has_any (file_path1) or EventData has_any (file_path2) or  EventData has_any (file_path3) or EventData has_any ('reg add') or EventData has_any (reg_key) )\n| extend CommandLine = tostring(EventData.CommandLine)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| where (CommandLine has_any (file_path1)) or\n  (CommandLine has_any (file_path3)) or\n  (CommandLine has 'reg add' and CommandLine has_any (reg_key) and CommandLine has_any (file_path2)) or \n  (NewProcessName has_any (file_path1)) or\n  (NewProcessName has_any (file_path3)) or\n  (ParentProcessName has_any (file_path1)) or \n  (ParentProcessName has_any (file_path3)) \n| extend Account = strcat(EventData.SubjectDomainName,\"\\\\\", EventData.SubjectUserName)\n| extend NewProcessId = tostring(EventData.NewProcessId)\n| extend IPCustomEntity = tostring(EventData.IpAddress)\n| project TimeGenerated, Computer, NewProcessName, ParentProcessName, Account, NewProcessId, Type, IPCustomEntity\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = Account, ProcessCustomEntity = NewProcessName, Alert = 'SOURGUM IOC detected'\n", "attributes": {"description": "'Identifies a match across IOC's related to an actor tracked by Microsoft as SOURGUM'\n", "techniques": ["T1546"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Analytic%20Rules/DNS_HighNXDomainCount_detection.yaml", "query_name": "Potential DGA detected", "query": "\nlet starttime = 10d;\nlet endtime = 1d;\nlet threshold = 100;\nlet nxDomainDnsEvents = DnsEvents \n| where ResultCode == 3 \n| where QueryType in (\"A\", \"AAAA\")\n| where ipv4_is_match(\"127.0.0.1\", ClientIP) == False\n| where Name !contains \"/\"\n| where Name contains \".\";\nnxDomainDnsEvents\n| where TimeGenerated > ago(endtime)\n| extend sld = tostring(split(Name, \".\")[-2])\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), dcount(sld) by ClientIP\n| where dcount_sld > threshold\n// Filter out previously seen IPs\n| join kind=leftanti (nxDomainDnsEvents\n    | where TimeGenerated between(ago(starttime)..ago(endtime))\n    | extend sld = tostring(split(Name, \".\")[-2])\n    | summarize dcount(sld) by ClientIP\n    | where dcount_sld > threshold ) on ClientIP\n// Pull out sample NXDomain responses for those remaining potentially infected IPs\n| join kind = inner (nxDomainDnsEvents | summarize by Name, ClientIP) on ClientIP\n| summarize StartTimeUtc = min(StartTimeUtc), EndTimeUtc = max(EndTimeUtc), sampleNXDomainList=make_list(Name, 100)  by ClientIP, dcount_sld\n| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP\n", "attributes": {"description": "'Identifies clients with a high NXDomain count which could be indicative of a DGA (cycling through possible C2 domains\nwhere most C2s are not live). Alert is generated when a new IP address is seen (based on not being seen associated with \nNXDomain records in prior 10-day baseline period).'\n", "techniques": ["T1568", "T1008"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Analytic%20Rules/DNS_HighReverseDNSCount_detection.yaml", "query_name": "Rare client observed with high reverse DNS lookup count", "query": "\nlet starttime = 8d;\nlet endtime = 1d;\nlet threshold = 10;\nDnsEvents \n| where TimeGenerated > ago(endtime)\n| where Name contains \"in-addr.arpa\" \n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), dcount(Name) by ClientIP\n| where dcount_Name > threshold\n| project StartTimeUtc, EndTimeUtc, ClientIP , dcount_Name \n| join kind=leftanti (DnsEvents \n    | where TimeGenerated between(ago(starttime)..ago(endtime))\n    | where Name contains \"in-addr.arpa\" \n    | summarize dcount(Name) by ClientIP, bin(TimeGenerated, 1d)\n    | where dcount_Name > threshold\n    | project ClientIP , dcount_Name \n) on ClientIP\n| extend timestamp = StartTimeUtc, IPCustomEntity = ClientIP\n", "attributes": {"description": "'Identifies clients with a high reverse DNS counts which could be carrying out reconnaissance or discovery activity.\nAlert is generated if the IP performing such reverse DNS lookups was not seen doing so in the preceding 7-day period.'\n", "techniques": ["T1046"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Analytic%20Rules/DNS_Miners.yaml", "query_name": "DNS events related to mining pools", "query": "\nDnsEvents\n| where Name contains \".\"\n| where Name has_any (\"monerohash.com\", \"do-dear.com\", \"xmrminerpro.com\", \"secumine.net\", \"xmrpool.com\", \"minexmr.org\", \"hashanywhere.com\", \n\"xmrget.com\", \"mininglottery.eu\", \"minergate.com\", \"moriaxmr.com\", \"multipooler.com\", \"moneropools.com\", \"xmrpool.eu\", \"coolmining.club\", \n\"supportxmr.com\", \"minexmr.com\", \"hashvault.pro\", \"xmrpool.net\", \"crypto-pool.fr\", \"xmr.pt\", \"miner.rocks\", \"walpool.com\", \"herominers.com\", \n\"gntl.co.uk\", \"semipool.com\", \"coinfoundry.org\", \"cryptoknight.cc\", \"fairhash.org\", \"baikalmine.com\", \"tubepool.xyz\", \"fairpool.xyz\", \"asiapool.io\", \n\"coinpoolit.webhop.me\", \"nanopool.org\", \"moneropool.com\", \"miner.center\", \"prohash.net\", \"poolto.be\", \"cryptoescrow.eu\", \"monerominers.net\", \"cryptonotepool.org\", \n\"extrmepool.org\", \"webcoin.me\", \"kippo.eu\", \"hashinvest.ws\", \"monero.farm\", \"supportxmr.com\", \"xmrpool.eu\", \"linux-repository-updates.com\", \"1gh.com\", \n\"dwarfpool.com\", \"hash-to-coins.com\", \"hashvault.pro\", \"pool-proxy.com\", \"hashfor.cash\", \"fairpool.cloud\", \"litecoinpool.org\", \"mineshaft.ml\", \"abcxyz.stream\", \n\"moneropool.ru\", \"cryptonotepool.org.uk\", \"extremepool.org\", \"extremehash.com\", \"hashinvest.net\", \"unipool.pro\", \"crypto-pools.org\", \"monero.net\", \n\"backup-pool.com\", \"mooo.com\", \"freeyy.me\", \"cryptonight.net\", \"shscrypto.net\")\n| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies IP addresses that may be performing DNS lookups associated with common currency mining pools.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Analytic%20Rules/DNS_TorProxies.yaml", "query_name": "DNS events related to ToR proxies", "query": "\nDnsEvents\n| where Name contains \".\"\n| where Name has_any (\"tor2web.org\", \"tor2web.com\", \"torlink.co\", \"onion.to\", \"onion.ink\", \"onion.cab\", \"onion.nu\", \"onion.link\", \n\"onion.it\", \"onion.city\", \"onion.direct\", \"onion.top\", \"onion.casa\", \"onion.plus\", \"onion.rip\", \"onion.dog\", \"tor2web.fi\", \n\"tor2web.blutmagie.de\", \"onion.sh\", \"onion.lu\", \"onion.pet\", \"t2w.pw\", \"tor2web.ae.org\", \"tor2web.io\", \"tor2web.xyz\", \"onion.lt\", \n\"s1.tor-gateways.de\", \"s2.tor-gateways.de\", \"s3.tor-gateways.de\", \"s4.tor-gateways.de\", \"s5.tor-gateways.de\", \"hiddenservice.net\")\n| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer\n", "attributes": {"description": "'Identifies IP addresses performing DNS lookups associated with common ToR proxies.'\n", "techniques": ["T1048"], "tactics": ["Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Analytic%20Rules/NRT_DNS_Related_To_Mining_Pools.yaml", "query_name": "NRT DNS events related to mining pools", "query": "DnsEvents\n| where Name contains \".\"\n| where Name has_any (\"monerohash.com\", \"do-dear.com\", \"xmrminerpro.com\", \"secumine.net\", \"xmrpool.com\", \"minexmr.org\", \"hashanywhere.com\",\n\"xmrget.com\", \"mininglottery.eu\", \"minergate.com\", \"moriaxmr.com\", \"multipooler.com\", \"moneropools.com\", \"xmrpool.eu\", \"coolmining.club\",\n\"supportxmr.com\", \"minexmr.com\", \"hashvault.pro\", \"xmrpool.net\", \"crypto-pool.fr\", \"xmr.pt\", \"miner.rocks\", \"walpool.com\", \"herominers.com\",\n\"gntl.co.uk\", \"semipool.com\", \"coinfoundry.org\", \"cryptoknight.cc\", \"fairhash.org\", \"baikalmine.com\", \"tubepool.xyz\", \"fairpool.xyz\", \"asiapool.io\",\n\"coinpoolit.webhop.me\", \"nanopool.org\", \"moneropool.com\", \"miner.center\", \"prohash.net\", \"poolto.be\", \"cryptoescrow.eu\", \"monerominers.net\", \"cryptonotepool.org\",\n\"extrmepool.org\", \"webcoin.me\", \"kippo.eu\", \"hashinvest.ws\", \"monero.farm\", \"supportxmr.com\", \"xmrpool.eu\", \"linux-repository-updates.com\", \"1gh.com\",\n\"dwarfpool.com\", \"hash-to-coins.com\", \"hashvault.pro\", \"pool-proxy.com\", \"hashfor.cash\", \"fairpool.cloud\", \"litecoinpool.org\", \"mineshaft.ml\", \"abcxyz.stream\",\n\"moneropool.ru\", \"cryptonotepool.org.uk\", \"extremepool.org\", \"extremehash.com\", \"hashinvest.net\", \"unipool.pro\", \"crypto-pools.org\", \"monero.net\",\n\"backup-pool.com\", \"mooo.com\", \"freeyy.me\", \"cryptonight.net\", \"shscrypto.net\")\n", "attributes": {"description": "'Identifies IP addresses that may be performing DNS lookups associated with common currency mining pools.'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Hunting%20Queries/DNS_CommonlyAbusedTLDs.yaml", "query_name": "DNS lookups for commonly abused TLDs", "query": "\n// Add additional TLDs to this list are required.\nlet abusedTLD = dynamic([\"click\", \"club\", \"download\",  \"xxx\", \"xyz\"]);\nDnsEvents\n| where Name has \".\" \n| extend tld = tostring(split(Name, \".\")[-1])\n| where tld in~ (abusedTLD)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), NameCount = count() by Name, ClientIP, tld\n| order by NameCount desc\n| extend timestamp = StartTime, IPCustomEntity = ClientIP, DomainCustomEntity = Name\n", "attributes": {"description": "'Some top level domains (TLDs) are more commonly associated with malware for a range of \nreasons - including how easy domains on these TLDs are to obtain. Many of these may be undesirable \nfrom an enterprise policy perspective. You can update and extend the list of TLD's  you wish to search for.\nThe NameCount column provides an initial insight into how widespread the domain usage is across the environment.'\n", "techniques": ["T1568", "T1008", "T1048"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Hunting%20Queries/DNS_DomainAnomalousLookupIncrease.yaml", "query_name": "DNS - domain anomalous lookup increase", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 7d;\n//example of excluding Saturday and Sunday in Average as those are potentially low volume and decrease the average, feel free to change\nlet excludedDays = dynamic([\"Saturday\", \"Sunday\"]);\n// average is across 5 days as we are dropping weekends, change as needed\nlet numDays = 5;\n// limit to over 1000 lookups somewhat random but helps focus in on higher lookups, change as needed\nlet avglookupThreshold = 3;\nlet lookupThreshold = 1000;\nDnsEvents\n//Setting to startofday so we get 7 days prior to start\n| where TimeGenerated >= startofday(lookback) and TimeGenerated <= startofday(starttime)\n| where SubType =~ \"LookupQuery\"\n//getting the associated number of the day of the week so we can map to a given day for later parsing if needed\n| extend DayNumberofWeek = tostring(dayofweek(TimeGenerated))\n//Setting the Day of the week value so that certain days could be excluded if needed\n| extend DayofWeek = iff(DayNumberofWeek == \"00:00:00\", \"Sunday\",\n(iff(DayNumberofWeek == \"1.00:00:00\", \"Monday\",\n(iff(DayNumberofWeek == \"2.00:00:00\", \"Tuesday\",\n(iff(DayNumberofWeek == \"3.00:00:00\", \"Wednesday\",\n(iff(DayNumberofWeek == \"4.00:00:00\", \"Thursday\",\n(iff(DayNumberofWeek == \"5.00:00:00\", \"Friday\",\n(iff(DayNumberofWeek == \"6.00:00:00\", \"Saturday\", DayNumberofWeek)))))))))))))\n| where DayofWeek !in~ (excludedDays)\n| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by ClientIP, Domain, IPAddresses\n| project StartTime, EndTime, ClientIP, Domain, IPAddresses, DailyAvgLookupCountOverLastWeek = count_/numDays\n| join ( DnsEvents\n| where TimeGenerated between(startofday(starttime)..endofday(endtime))\n| where SubType =~ \"LookupQuery\"\n| extend Domain = iff(countof(Name,'.') >= 2, strcat(split(Name,'.')[-2], '.',split(Name,'.')[-1]), Name)\n| summarize count() by ClientIP, Domain, IPAddresses\n| project ClientIP, LookupCountToday = count_, Domain, IPAddresses\n)\non ClientIP, Domain, IPAddresses\n| where LookupCountToday > ( DailyAvgLookupCountOverLastWeek * avglookupThreshold) and LookupCountToday > lookupThreshold\n| project StartTime, EndTime, ClientIP, SecondLevelDomain = Domain , LookupCountToday , DailyAvgLookupCountOverLastWeek, IPAddresses\n| order by LookupCountToday desc nulls last\n| extend timestamp = StartTime, IPCustomEntity = ClientIP, DomainCustomEntity = SecondLevelDomain\n", "attributes": {"description": "'Checking for a threefold increase or more of domain lookups per client IP address for the current day vs daily average for the previous week.\nThis can potentially identify excessive traffic to a given location that could be indicative of data transfer out of your network to a group of systems based on the same second level domain.\nFor example, if one client is sending requests for test1.badguy.com and another client is sending requests for test2.badguy.com, you may not see a high enough count to be interesting.\nHowever, a combination of the requests to badguy.com could have a high enough count to be interesting.\nThis is only Name lookups, so it would be recommended to review the Firewall\\Webproxy logs in relation to the client IP address making the interesting requests.'\n", "techniques": ["T1568", "T1008", "T1048"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Hunting%20Queries/DNS_FullNameAnomalousLookupIncrease.yaml", "query_name": "DNS Full Name anomalous lookup increase", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet lookback = starttime - 7d;\n//example of excluding Saturday and Sunday in Average as those are potentially low volume and decrease the average, feel free to change\nlet excludedDays = dynamic([\"Saturday\", \"Sunday\"]);\n// average is across 5 days as we are dropping weekends, change as needed\nlet numDays = 5;\n// limit to over 1000 lookups somewhat random but helps focus in on higher lookups, change as needed\nlet avglookupThreshold = 3;\nlet lookupThreshold = 1000;\nDnsEvents\n//Setting to startofday so we get 7 days prior to today\n| where TimeGenerated >= startofday(lookback) and TimeGenerated <= startofday(starttime)\n| where SubType =~ \"LookupQuery\"\n//getting the associated number of the day of the week so we can map to a given day for later parsing if needed\n| extend DayNumberofWeek = tostring(dayofweek(TimeGenerated))\n//Setting the Day of the week value so that certain days could be excluded if needed\n| extend DayofWeek = iff(DayNumberofWeek == \"00:00:00\", \"Sunday\",\n(iff(DayNumberofWeek == \"1.00:00:00\", \"Monday\",\n(iff(DayNumberofWeek == \"2.00:00:00\", \"Tuesday\",\n(iff(DayNumberofWeek == \"3.00:00:00\", \"Wednesday\",\n(iff(DayNumberofWeek == \"4.00:00:00\", \"Thursday\",\n(iff(DayNumberofWeek == \"5.00:00:00\", \"Friday\",\n(iff(DayNumberofWeek == \"6.00:00:00\", \"Saturday\", DayNumberofWeek)))))))))))))\n| where DayofWeek !in~ (excludedDays)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by ClientIP, Name, IPAddresses\n| project StartTime, EndTime, ClientIP, FullNameLookup = Name, IPAddresses, DailyAvgLookupCountOverLastWeek = count_/numDays\n| join ( DnsEvents\n| where TimeGenerated between(startofday(starttime)..endofday(endtime))\n| where SubType =~ \"LookupQuery\"\n| summarize count() by ClientIP, FullNameLookup = Name, IPAddresses\n| project ClientIP, LookupCountToday = count_, FullNameLookup, IPAddresses\n)\non ClientIP, FullNameLookup, IPAddresses\n| where LookupCountToday > (DailyAvgLookupCountOverLastWeek * avglookupThreshold) and LookupCountToday >= lookupThreshold\n| project StartTime, EndTime, ClientIP, LookupCountToday, DailyAvgLookupCountOverLastWeek, FullNameLookup, IPAddresses\n| order by LookupCountToday desc nulls last\n| extend timestamp = StartTime, IPCustomEntity = ClientIP, DomainCustomEntity = FullNameLookup\n", "attributes": {"description": "'Checking for a threefold increase or more of Full Name lookup per Client IP for the current day for today vs the daily average for the previous week.\nThis can potentially identify excessive traffic to a given location that could be indicative of data transfer out of your network.\nThis is only Name lookups, so it would be recommended to review the Firewall\\Webproxy logs in relation to the ClientIP making the interesting requests.'\n", "techniques": ["T1568", "T1008", "T1048"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Hunting%20Queries/DNS_HighPercentNXDomainCount.yaml", "query_name": "Potential DGA detected", "query": "\nlet starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nlet timeframe = 1d;\nlet excludeTLD = dynamic([\"arris\",\"ati\",\"virtusa\",\"unknowndomain\",\"onion\",\"corp\",\"domain\",\"local\",\"localdomain\",\"host\",\"home\",\"gateway\",\"lan\",\n\"services\",\"hub\",\"domain.name\",\"WirelessAP\",\"Digicom-ADSL\",\"OpenDNS\",\"dlinkrouter\",\"Dlink\",\"ASUS\",\"device\",\"router\",\"Belkin\",\"DHCP\",\"Cisco\"]);\nlet nxDomainDnsEvents = DnsEvents\n| where TimeGenerated between(starttime..endtime)\n| where ResultCode == 3 \n| where QueryType in (\"A\", \"AAAA\")\n| where ipv4_is_match(\"127.0.0.1\", ClientIP) == False\n| where Name !contains \"/\"\n| where Name contains \".\"\n| extend mytld = tostring(split(Name, '.')[-1])\n| where mytld !in~ (excludeTLD)\n| extend truncatedDomain = iff((strlen(Name) - indexof(Name, tostring(split(Name, \".\")[-2])) ) >= 7, \nstrcat(tostring(split(Name, \".\")[-2]), \".\", tostring(split(Name, \".\")[-1])) , \nstrcat(tostring(split(Name, \".\")[-3]), \".\", tostring(split(Name, \".\")[-2]), \".\", tostring(split(Name, \".\")[-1])));\nlet quartileFunctionForIPThreshold = view (mypercentile:long, startTimeSpan:timespan, endTimeSpan:timespan) {\n(nxDomainDnsEvents\n| where TimeGenerated between (ago(startTimeSpan)..ago(endTimeSpan))\n| summarize domainCount = dcount(truncatedDomain) by ClientIP, bin(TimeGenerated, 1d)\n| project SearchList = (domainCount), ClientIP\n| summarize qPercentiles = percentiles(SearchList, mypercentile) by ClientIP);\n};\nlet firstQT = quartileFunctionForIPThreshold(25, 7d, 2d) | project-rename percentile_SearchList_25 = qPercentiles;\nlet thirdQT = quartileFunctionForIPThreshold(75, 7d, 2d) | project-rename percentile_SearchList_75 = qPercentiles;\n// The IP threshold could be adjusted for based on the skewness of the IPthreshold distribution per IP - https://wis.kuleuven.be/stat/robust/papers/2008/outlierdetectionskeweddata-revision.pdf\nlet threshold = (firstQT\n| join thirdQT on ClientIP\n| extend IPthreshold = percentile_SearchList_75 + (1.5*exp(3)*(percentile_SearchList_75 - percentile_SearchList_25))\n| project ClientIP, IPthreshold);\nlet FilterOnIPThreshold_MainTable = (\nnxDomainDnsEvents\n| summarize TotalNXLookups=dcount(truncatedDomain) by ClientIP\n| sort by TotalNXLookups desc\n| join ['threshold'] on ClientIP\n// Comment the line below in order to view results filtered by Global Threshold only. \n| where TotalNXLookups > IPthreshold \n| join kind = leftouter (nxDomainDnsEvents\n    | where TimeGenerated > ago(timeframe)\n    | summarize domainCount = dcount(Name) by truncatedDomain, ClientIP\n    | project SearchList = strcat(truncatedDomain,\" (\",tostring(domainCount),\")\"), ClientIP\n    ) on ClientIP\n| summarize SLDs_DistinctLookups = make_list(SearchList) by ClientIP, TotalNXLookups, IPthreshold\n| sort by TotalNXLookups desc);\n//\nlet quartileFunctionForGlobalThreshold = view (mypercentile:long, startTimeSpan:timespan) {\n(nxDomainDnsEvents\n| where TimeGenerated > ago(startTimeSpan)\n| summarize domainCount = dcount(truncatedDomain) by ClientIP\n| summarize event_count = count() by domainCount\n| summarize perc2 = percentilesw(domainCount, event_count, mypercentile));\n};\nlet firstQ = toscalar(quartileFunctionForGlobalThreshold(25, 1d));\nlet thirdQ = toscalar(quartileFunctionForGlobalThreshold(75, 1d));\n// The Global threshold could be adjusted for based on the skewness of the GlobalThreshold distribution per IP - https://wis.kuleuven.be/stat/robust/papers/2008/outlierdetectionskeweddata-revision.pdf\nlet GlobalThreshold = toscalar(thirdQ + (1.5*exp(3)*(thirdQ - firstQ)));\nlet FilterOnGlobalThreshold_MainTable = (\nnxDomainDnsEvents\n| where TimeGenerated > ago(timeframe)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), TotalNXLookups = dcount(truncatedDomain) by ClientIP\n| sort by TotalNXLookups desc\n// Comment the line below in order to view results filtered by IPThreshold only. \n| where TotalNXLookups > GlobalThreshold \n| join kind = leftouter (nxDomainDnsEvents\n    | where TimeGenerated > ago(timeframe)\n    | summarize domainCount = dcount(Name) by truncatedDomain, ClientIP\n    | project truncatedDomain = strcat(truncatedDomain,\" (\",tostring(domainCount),\")\"), ClientIP\n    ) on ClientIP\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), SLDs_DistinctLookups = make_list(truncatedDomain), UniqueSLDsCount=count(truncatedDomain) by ClientIP, TotalNXLookups, GlobalThreshold\n| sort by TotalNXLookups desc);\nFilterOnIPThreshold_MainTable\n| join FilterOnGlobalThreshold_MainTable on ClientIP\n| project StartTime, EndTime, ClientIP, TotalNXLookups, IPthreshold, GlobalThreshold, SLDs_DistinctLookups, UniqueSLDsCount\n| extend timestamp = StartTime, IPCustomEntity = ClientIP\n", "attributes": {"description": "'Clients with a high NXDomain count could be indicative of a DGA (cycling through possible C2 domains\nwhere most C2s are not live). Based on quartile precent analysis aglorithm.'\n", "techniques": ["T1568", "T1008"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Hunting%20Queries/DNS_HighReverseDNSCount.yaml", "query_name": "High reverse DNS count by host", "query": "\nlet threshold = 10;\nDnsEvents \n| where Name has \"in-addr.arpa\" \n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), NameCount = dcount(Name), Names = make_set(Name), ClientIPCount = count() by ClientIP\n| where NameCount > threshold\n| extend timestamp = StartTime, IPCustomEntity = ClientIP\n", "attributes": {"description": "'Clients with a high reverse DNS count could be carrying out reconnaissance or discovery activity.'\n", "techniques": ["T1046"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Hunting%20Queries/DNS_LongURILookup.yaml", "query_name": "Abnormally long DNS URI queries", "query": "\n// Setting URI length threshold count, shorter URI's may cause noise, change as needed\nlet uriThreshold = 150;\nlet LocalDomains = \n(\nDnsEvents\n| summarize count() by Computer \n| extend SubDomain = tolower(strcat(tostring(split(Computer, \".\")[-2]),\".\", tostring(split(Computer, \".\")[-1])))\n| distinct SubDomain\n);\nlet DomainLookups =\n(\nDnsEvents\n| where SubType =~ \"LookupQuery\"\n| where ipv4_is_match(\"127.0.0.1\", ClientIP) == False \n| where Name !endswith \".local\" and Name !startswith \"_\" and Name !startswith \"#\"\n| where Name !contains \"::1\"\n| where Name !has \"cnr.io\" and Name !has \"kr0.io\" and Name !has \"arcticwolf.net\" and Name !has \"webcfs00.com\" and Name !has \"barracudabrts.com\"and Name !has \"trendmicro.com\" \nand Name !has \"sophosxl.net\" and Name !has \"spotify.com\" and Name !has \"e5.sk\" and Name !has \"mcafee.com\" and Name !has \"opendns.com\"  and Name !has \"spameatingmonkey.net\" \nand Name !has \"_ldap\" and Name !has \"_kerberos\" and Name !has \"modsecurity.org\" and Name !has \"fdmarc.net\" and Name !has \"ipass.com\" and Name !has \"wpad\"\nand Name !has \"cnr.io\" and Name !has \"trendmicro.com\" and Name !has \"sophosxl.net\" and Name !has \"spotify.com\" and Name !has \"e5.sk\" and Name !has \"mcafee.com\" \nand Name !has \"opendns.com\"  and Name !has \"spameatingmonkey.net\" and Name !has \"_ldap\" and Name !has \"_kerberos\" and Name !has \"modsecurity.org\" and Name !has \"fdmarc.net\" \nand Name !has \"ipass.com\"\n| extend Name = tolower(Name), Urilength = strlen(Name) \n| where Urilength >= uriThreshold\n| extend SubDomain = case(\nisempty(Name), Name,\narray_length(split(Name, \".\")) <= 2, Name,\ntostring(split(Name, \".\")[-2]) == \"corp\", strcat(tostring(split(Name, \".\")[-3]),\".\",tostring(split(Name, \".\")[-2]),\".\", tostring(split(Name, \".\")[-1])),\nstrlen(tostring(split(Name, \".\")[-1])) == 2, strcat(tostring(split(Name, \".\")[-3]),\".\",tostring(split(Name, \".\")[-2]),\".\", tostring(split(Name, \".\")[-1])),\nstrlen(tostring(split(Name, \".\")[-2])) != \"corp\", strcat(tostring(split(Name, \".\")[-2]),\".\", tostring(split(Name, \".\")[-1])),\nName))\n;\nDomainLookups\n| join kind= leftanti (\n    LocalDomains\n) on SubDomain \n| summarize by TimeGenerated, Computer, ClientIP, Name, Urilength\n| extend timestamp = TimeGenerated, IPCustomEntity = ClientIP, HostCustomEntity = Computer, DomainCustomEntity = Name\n", "attributes": {"description": "'Length of DNS query can often be an indicator of suspicious activity. Typical domain name lengths are short whereas domain name query used \nfor data exfiltration or tunneling can often be very large in size. This is because they could be encoded using base 64/32 etc. The hunting query looks \nfor Names that are more than 150 characters in length. Due to a lot of services using long DNS to communicate via prcodurally generated long domain names\nthis can be prone, so a number of known services are excluded from this query. Additional items might need to be added to this exclusion dependent on your\nenvironment.'\n", "techniques": ["T1568", "T1008", "T1048"], "tactics": ["CommandAndControl", "Exfiltration"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Hunting%20Queries/DNS_WannaCry.yaml", "query_name": "DNS Domains linked to WannaCry ransomware campaign", "query": "\nlet badDomains = dynamic([\"agrdwrtj.us\", \"bctxawdt.us\", \"cokfqwjmferc.us\", \"cxbenjiikmhjcerbj.us\", \"depuisgef.us\", \"edoknehyvbl.us\", \n\"enyeikruptiukjorq.com\", \"frullndjtkojlu.us\", \"gcidpiuvamynj.us\", \"gxrytjoclpvv.us\", \"hanoluexjqcf.us\", \"iarirjjrnuornts.us\", \n\"ifbjoosjqhaeqjjwaerri.us\", \"iouenviwrc.us\", \"kuuelejkfwk.us\", \"lkbsxkitgxttgaobxu.us\", \"nnnlafqfnrbynwor.us\", \"ns768.com\", \n\"ofdwcjnko.us\", \"peuwdchnvn.us\", \"pvbeqjbqrslnkmashlsxb.us\", \"pxyhybnyv.us\", \"qkkftmpy.us\", \"rkhlkmpfpoqxmlqmkf.us\", \n\"ryitsfeogisr.us\", \"srwcjdfrtnhnjekjerl.us\", \"thstlufnunxaksr.us\", \"udrgtaxgdyv.us\", \"w5q7spejg96n.com\", \"xmqlcikldft.us\", \n\"yobvyjmjbsgdfqnh.us\", \"yrwgugricfklb.us\", \"ywpvqhlqnssecpdemq.us\"]);\nDnsEvents\n| where Name in~ (badDomains)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), count() by Computer, ClientIP, WannaCrypt_Related_Domain = Name\n| extend timestamp = StartTime, HostCustomEntity = Computer, IPCustomEntity = ClientIP, DomainCustomEntity = WannaCrypt_Related_Domain\n", "attributes": {"description": "'Displays client DNS request for any of the known domains linked to WannaCry.\nThese results may indicate Wannacry/Wannacrypt ransomware infection.\nReference: Domain listing from https://pastebin.com/cRUii32E'\n", "techniques": ["T1496"], "tactics": ["Impact"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Hunting%20Queries/Solorigate-DNS-Pattern.yaml", "query_name": "Solorigate DNS Pattern", "query": "\nlet cloudApiTerms = dynamic([\"api\", \"east\", \"west\"]);\nDnsEvents\n| where IPAddresses != \"\" and IPAddresses != \"127.0.0.1\"\n| where Name endswith \".com\" or Name endswith \".org\" or Name endswith \".net\"\n| extend domain_split = split(Name, \".\")\n| where tostring(domain_split[-5]) != \"\" and tostring(domain_split[-6]) == \"\"\n| extend sub_domain = tostring(domain_split[0])\n| where sub_domain !contains \"-\"\n| extend sub_directories = strcat(domain_split[-3], \" \", domain_split[-4])\n| where sub_directories has_any(cloudApiTerms)\n//Based on sample communications the subdomain is always between 20 and 30 bytes\n| where strlen(sub_domain) < 32 and strlen(sub_domain) > 20\n| extend domain = strcat(tostring(domain_split[-2]), \".\", tostring(domain_split[-1])) \n| extend subdomain_no = countof(sub_domain, @\"(\\d)\", \"regex\")\n| extend subdomain_ch = countof(sub_domain, @\"([a-z])\", \"regex\")\n| where subdomain_no > 1\n| extend percentage_numerical = toreal(subdomain_no) / toreal(strlen(sub_domain)) * 100\n| where percentage_numerical < 50 and percentage_numerical > 5\n| summarize count(), FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated) by Name, IPAddresses\n| order by count_ asc\n| extend timestamp = FirstSeen, IPCustomEntity = IPAddresses, DomainCustomEntity = Name\n", "attributes": {"description": "'Looks for DGA pattern of the domain associated with Solorigate in order to find other domains with the same activity pattern.'\n", "techniques": ["T1568"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Windows%20Server%20DNS/Hunting%20Queries/Solorigate-Encoded-Domain-URL.yaml", "query_name": "Solorigate Encoded Domain in URL", "query": "\nlet dictionary = dynamic([\"r\",\"q\",\"3\",\"g\",\"s\",\"a\",\"l\",\"t\",\"6\",\"u\",\"1\",\"i\",\"y\",\"f\",\"z\",\"o\",\"p\",\"5\",\"7\",\"2\",\"d\",\"4\",\"9\",\"b\",\"n\",\"x\",\"8\",\"c\",\"v\",\"m\",\"k\",\"e\",\"w\",\"h\",\"j\"]);\nlet regex_bad_domains = SigninLogs\n//Collect domains from tenant from signin logs\n| extend domain = tostring(split(UserPrincipalName, \"@\", 1)[0])\n| where domain != \"\"\n| summarize by domain\n| extend split_domain = split(domain, \".\")\n//This cuts back on domains such as na.contoso.com by electing not to match on the \"na\" portion\n| extend target_string = iff(strlen(split_domain[0]) <= 2, split_domain[1], split_domain[0])\n| extend target_string = split(target_string, \"-\")\n| mv-expand target_string\n//Rip all of the alphanumeric out of the domain name\n| extend string_chars = extract_all(@\"([a-z0-9])\", tostring(target_string))\n//Guid for tracking our data\n| extend guid = new_guid()\n//Expand to get all of the individual chars from the domain\n| mv-expand string_chars\n| extend chars = tostring(string_chars)\n//Conduct computation to encode the domain as per actor spec\n| extend computed_char = array_index_of(dictionary, chars)\n| extend computed_char = dictionary[(computed_char + 4) % array_length(dictionary)] \n| summarize make_list(computed_char) by guid, domain\n| extend target_encoded = tostring(strcat_array(list_computed_char, \"\"))\n//These are probably too small, but can be edited (expect FP's when going too small)\n| where strlen(target_encoded) > 5\n| distinct target_encoded\n| summarize make_set(target_encoded)\n//Key to join to DNS\n| extend key = 1;\nDnsEvents\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by Name\n| extend key = 1\n//For each DNS query join the malicious domain list\n| join kind=inner ( \n    regex_bad_domains\n) on key\n| project-away key\n//Expand each malicious key for each DNS query observed\n| mv-expand set_target_encoded\n//IndexOf allows us to fuzzy match on the substring\n| extend match = indexof(Name, set_target_encoded)\n| where match > -1\n| extend timestamp = StartTime, DomainCustomEntity = Name\n", "attributes": {"description": "'Looks for a logon domain seen in Azure AD logs appearing in a DNS query encoded with the DGA encoding used in the Solorigate incident.\nReference: https://blogs.microsoft.com/on-the-issues/2020/12/13/customers-protect-nation-state-cyberattacks/'\n", "techniques": ["T1568"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ZeroNetworks/Analytics%20Rules/ZNAccessOrchestratorMachineRemovedfromProtection.yaml", "query_name": "ZN Access Orchestrator - Machine Removed from protection", "query": "ZNAccessOrchestratorAudit\n| where AuditTypeId == 4\n", "attributes": {"description": "'Detects when a machine is removed from protection.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ZeroNetworks/Analytics%20Rules/ZNAccessOrchestratorNewAPIToken.yaml", "query_name": "ZN Access Orchestrator - New API Token created", "query": "ZNAccessOrchestratorAudit\n| where AuditTypeId == 25\n", "attributes": {"description": "'Detects when a api token has been created.'\n", "techniques": ["T1528"], "tactics": ["CredentialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ZeroNetworks/Analytics%20Rules/ZNAccessOrchestratorRareJITRuleCreation.yaml", "query_name": "ZN Access Orchestrator - Rare JIT Rule Creation", "query": "\nlet starttime = 14d;\nlet endtime = 1d;\nZNAccessOrchestratorAudit\n| where TimeGenerated >= ago(endtime)\n| where AuditTypeId == 20\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ConnectionCount = count()\nby PerformedByName, tostring(DestinationEntityName)\n  // use left anti to exclude anything from the previous 14 days that is not rare\n| join kind=leftanti (\nZNAccessOrchestratorAudit\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where AuditTypeId == 20\n| summarize by tostring(DestinationEntityName)\n) on DestinationEntityName\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), ConnectionCount = sum(ConnectionCount)\nby PerformedByName, DestinationEntityName\n| extend TimeGenerated = StartTime\n", "attributes": {"description": "'Identifies when a JIT Rule connection is new or rare by a given account today based on comparison with the previous 14 days.\nJIT Rule creations are indicated by the Activity Type Id 20'\n", "techniques": ["T1021"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ZeroNetworks/Hunting%20Queries/ZNAccessOrchestratorExcessiveAccessbyUser.yaml", "query_name": "ZN Access Orchestrator - Excessive access by user", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nZNAccessOrchestratorAudit\n| where TimeGenerated > ago(endtime-starttime)\n| where AuditTypeId in (9,12,20,22,23,24)\n| where DestinationEntityId !startswith \"b:\"\n| summarize AffectedEntities=make_set(DestinationEntityName) by PerformedByName\n| extend numOfTargetEntities=array_length(AffectedEntities)\n| order by numOfTargetEntities desc\n| extend Account_0_FullName = PerformedByName\n| extend Host_0_NetBiosName = AffectedEntities\n", "attributes": {"description": "'Find users who gained access to the largest number of target assets in the selected time range'\n", "techniques": ["T1210", "T1570", "T0866"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ZeroNetworks/Hunting%20Queries/ZNAccessOrchestratorExcessiveAccesstoBuiltinGroupbyUser.yaml", "query_name": "ZN Access Orchestrator - Excessive access to a built-in group by user", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nZNAccessOrchestratorAudit\n| where TimeGenerated > ago(endtime-starttime)\n| where AuditTypeId  in (9,12,20,22,23,24)\n| where DestinationEntityId startswith \"b:\"\n| summarize affectedEntities=make_set(DestinationEntityId) by PerformedByName\n| extend numOfTargetEntities=array_length(affectedEntities)\n| order by numOfTargetEntities desc\n| extend Account_0_Name = PerformedByName\n| extend Host_0_NetBiosName = affectedEntities\n", "attributes": {"description": "'A rule was created which granted a user access to a large, built-in, group of assets.'\n", "techniques": ["T1210", "T1570", "T0866"], "tactics": ["LateralMovement"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ZeroNetworks/Hunting%20Queries/ZNAccessOrchestratorInboundBlockRulesDeleted.yaml", "query_name": "ZN Access Orchestrator - Inbound Block Rules Deleted", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nZNAccessOrchestratorAudit\n| where TimeGenerated > ago(endtime-starttime)\n| where AuditTypeId == 34\n| where EnforcementSource != \"AI\"\n| extend Account_0_FullName = PerformedByName\n| extend Host_0_NetBiosName = DestinationEntityName\n", "attributes": {"description": "'Query searches for inbound block rules deleted by non AI.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ZeroNetworks/Hunting%20Queries/ZNAccessOrchestratorOutboundBlockRulesDeleted.yaml", "query_name": "ZN Access Orchestrator - Outbound Block Rules Deleted", "query": "let starttime = todatetime('{{StartTimeISO}}');\nlet endtime = todatetime('{{EndTimeISO}}');\nZNAccessOrchestratorAudit\n| where TimeGenerated > ago(endtime-starttime)\n| where AuditTypeId == 30\n| where EnforcementSource != \"AI\"\n| extend Account_0_FullName = PerformedByName\n| extend Host_0_NetBiosName = DestinationEntityName\n", "attributes": {"description": "'Query searches for outbound block rules deleted by non AI.'\n", "techniques": ["T1562"], "tactics": ["DefenseEvasion"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/ZeroTrust%28TIC3.0%29/Analytic%20Rules/Zero_Trust_TIC3.0_ControlAssessmentPostureChange.yaml", "query_name": "ZeroTrust(TIC3.0) Control Assessment Posture Change", "query": "SecurityRecommendation\n| where RecommendationDisplayName <> \"\"\n| extend ControlFamily=iff(RecommendationDisplayName has_any(\"email\"), \"Email\",\n    iff(RecommendationDisplayName has_any(\"apps\", \"teams\", \"meeting\", \"call\"), \"Unified Communications & Collaboration\",\n    iff(RecommendationDisplayName has_any(\"dns\", \"domain\"), \"DNS\",\n    iff(RecommendationDisplayName has_any(\"endpoint protection\", \"malware\", \"file\", \"files\", \"IaaSAntimalware\"), \"Files\",\n    iff(RecommendationDisplayName has_any(\"Security Center\", \"defender\", \"adaptive\", \"HoneyTokens\", \"honey\", \"deception\", \"intrusion\", \"incident\", \"incidents\"), \"Intrusion Detection\",\n    iff(RecommendationDisplayName has_any(\"firewall\", \"watcher\", \"proxy\", \"certificate\", \"url\", \"web\"), \"Web\",\n    iff(RecommendationDisplayName has_any(\"network\", \"segment\", \"network security groups\", \"subnet\", \"application gateway\", \"security groups\", \"IP forwarding\", \"port\", \"ports\", \"networks\"), \"Networking\",\n    iff(RecommendationDisplayName has_any(\"backup\", \"denial\", \"DDoS\", \"load\", \"scale\", \"front\", \"traffic manager\", \"pool\", \"disaster\", \"region\", \"redundant\", \"geo\"), \"Resiliency\",\n    iff(RecommendationDisplayName has_any(\"encrypt\", \"rest\", \"transit\", \"data\", \"http\", \"https\", \"TLS\", \"transfer\", \"transit\", \"Secure Socket\", \"SSH\", \"just\", \"FTP\", \"server-side\", \"storage\", \"database\", \"databases\", \"SQL\", \"disk\", \"disks\"), \"Data Protection\",\n    iff(RecommendationDisplayName has_any(\"private\", \"vpn\", \"automation\", \"playbook\", \"logic\", \"notification\", \"authorized\", \"safe\", \"network gateway\", \"express\", \"VPC\"), \"Enterprise\",\n    iff(RecommendationDisplayName has_any(\"recover\", \"log\", \"configured\", \"configuration\", \"identity\", \"privilege\", \"admin\", \"authentication\", \"JIT\", \"just\", \"password\", \"time\", \"sync\", \"vulnerability\", \"Vulnerabilities\", \"updates\", \"update\", \"upgrade\", \"audit\", \"account\", \"guest\", \"shared\", \"access\", \"machines\", \"rights\", \"VM\", \"key\", \"keys\", \"IAM\", \"EC2\", \"GuardDuty\", \"logs\", \"CloudTrail\", \"MFA\", \"External accounts\", \"accounts\", \"config\", \"credentials\", \"privileged\", \"owner\", \"owners\", \"login\", \"logon\", \"virtual machine\", \"container\", \"containers\", \"Kubernetes\"), \"Universal Security Capabilities\", \"Other\")))))))))))\n| summarize arg_max(TimeGenerated, *) by AssessedResourceId, RecommendationDisplayName\n| summarize\n    Failed=countif(RecommendationState == \"Unhealthy\"),\n    Passed=countif(RecommendationState == \"Healthy\"),\n    Total=countif(RecommendationState == \"Unhealthy\" or RecommendationState == \"Healthy\")\n    by ControlFamily\n| extend PassedControlsPercentage = (Passed / todouble(Total)) * 100\n| extend RemediationLink = strcat('https://portal.azure.com/#blade/Microsoft_Azure_Security/SecurityMenuBlade/5')\n| extend URLCustomEntity = RemediationLink\n| project ControlFamily, Total, PassedControlsPercentage, Passed, Failed, RemediationLink, URLCustomEntity\n| where PassedControlsPercentage < 70 //Adjust PassedRatePercentage Thresholds within Organizational Needs\n| sort by PassedControlsPercentage asc\n", "attributes": {"description": "'Zero Trust(TIC3.0) Control Assessments have Deviated from Configured Threshold Baselines'\n", "techniques": ["T1082"], "tactics": ["Discovery"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Internet%20Access/Analytic%20Rules/DiscordCDNRiskyDownload.yaml", "query_name": "Discord CDN Risky File Download", "query": "let connectionThreshold = 1;\nlet riskyExtensions = dynamic([\".bin\",\".exe\",\".dll\",\".bin\",\".msi\"]);\nCommonSecurityLog\n| where DeviceVendor =~ \"ZScaler\"\n| where RequestURL has_any(\"media.discordapp.net\", \"cdn.discordapp.com\")\n| where RequestURL has \"attachments\"\n| where DeviceAction !~ \"blocked\"\n| extend DiscordServerId = extract(@\"\\/attachments\\/([0-9]+)\\/\", 1, RequestURL)\n| summarize dcount(RequestURL), make_set(SourceUserName), make_set(SourceIP), make_set(RequestURL), min(TimeGenerated), max(TimeGenerated), make_set(DeviceAction) by DiscordServerId, DeviceProduct\n| where dcount_RequestURL <= connectionThreshold\n| mv-expand set_SourceUserName to typeof(string), set_RequestURL to typeof(string), set_DeviceAction to typeof(string), set_SourceIP to typeof(string)\n| summarize by DiscordServerId, DeviceProduct, dcount_RequestURL, set_SourceUserName, min_TimeGenerated, max_TimeGenerated, set_DeviceAction, set_SourceIP, set_RequestURL\n| project StartTime=min_TimeGenerated, EndTime=max_TimeGenerated, DeviceActionTaken=set_DeviceAction, DeviceProduct, SourceUser=set_SourceUserName, SourceIP=set_SourceIP, RequestURL=set_RequestURL\n| where RequestURL has_any (riskyExtensions)\n", "attributes": {"description": "'Identifies callouts to Discord CDN addresses for risky file extensions. This detection will trigger when a callout for a risky file\nis made to a discord server that has only been seen once in your environment. Unique discord servers are identified using the server ID\nthat is included in the request URL (DiscordServerId in query). Discord CDN has been used in multiple campaigns to download additional payloads'\n", "techniques": ["T1071.001"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Internet%20Access/Analytic%20Rules/Zscaler-LowVolumeDomainRequests.yaml", "query_name": "Request for single resource on domain", "query": "\nlet scriptExtensions = dynamic([\".php\", \".aspx\", \".asp\", \".cfml\"]);\n//The number of URI's seen to be suspicious, higher = less likely to be suspicious\nlet uriThreshold = 1;\nCommonSecurityLog\n// Only look at connections that were allowed through the web proxy\n| where DeviceVendor =~ \"Zscaler\" and DeviceAction =~ \"Allowed\"\n// Only look where some data was exchanged.\n| where SentBytes > 0 and ReceivedBytes > 0\n// Extract the Domain\n| extend Domain = iff(countof(DestinationHostName,'.') >= 2, strcat(split(DestinationHostName,'.')[-2], '.',split(DestinationHostName,'.')[-1]), DestinationHostName)\n| extend GetData=iff(RequestURL == \"?\", 1, 0)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), makelist(RequestURL), makelist(DestinationIP), makelist(SourceIP), numOfConnections = count(), make_set(RequestMethod), max(GetData), max(RequestContext) by Domain\n// Determine the number of URIs that have been visited for the domain\n| extend destinationURI = arraylength(list_RequestURL)\n| where destinationURI <= uriThreshold\n| where tostring(list_RequestURL) has_any(scriptExtensions)\n//Remove matches with referer\n| where max_RequestContext == \"\"\n//Keep requests where data was trasferred either in a GET with parameters or a POST\n| where set_RequestMethod in~ (\"POST\") or max_GetData == 1\n//Defeat email click tracking, may increase FN's while decreasing FP's\n| where list_RequestURL !has \"click\" and set_RequestMethod !has \"GET\"\n| mvexpand list_RequestURL, list_DestinationIP\n| extend RequestURL = tostring(list_RequestURL), DestinationIP = tostring(list_DestinationIP), ClientIP = tostring(list_SourceIP)\n//Extend custom entitites for incidents\n| extend timestamp = StartTimeUtc, IPCustomEntity = DestinationIP\n| project-away list_RequestURL, list_DestinationIP, list_SourceIP, destinationURI, Domain, StartTimeUtc, EndTimeUtc, max_GetData, max_RequestContext\n", "attributes": {"description": "'This will look for connections to a domain where only a single file is requested, this is unusual as most modern web applications require additional recources. This type of activity is often assocaited with malware beaconing or tracking URL's delivered in emails. Developed for Zscaler but applicable to any outbound web logging.'\n", "techniques": ["T1102", "T1071"], "tactics": ["CommandAndControl"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerSharedZPASession.yaml", "query_name": "Zscaler - Shared ZPA session", "query": "let open_sessions =\nZPAEvent\n| where DvcAction == 'open'\n| summarize timestampstart = min(TimeGenerated) by DstUserName, SrcIpAddr, NetworkSessionId\n| sort by timestampstart asc;\nlet closed_sessions =\nZPAEvent\n| where TimeGenerated > ago(1h)\n| where DvcAction == 'close'\n| summarize timestampend = max(TimeGenerated) by DstUserName, SrcIpAddr, NetworkSessionId\n| sort by timestampend asc;\nopen_sessions\n| join (closed_sessions) on DstUserName\n| sort by DstUserName, timestampstart\n| extend prev_session_closetime = prev(timestampend,1)\n| extend prev_session_starttime = prev(timestampstart,1)\n| extend PreviousSrcIpAddr = prev(SrcIpAddr, 1)\n| extend prev_sessionuser = prev(DstUserName, 1) \n| where DstUserName == prev_sessionuser\n| where SrcIpAddr != PreviousSrcIpAddr\n| where prev_session_closetime > timestampstart\n| project DstUserName, SrcIpAddr, PreviousSrcIpAddr\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects shared ZPA session.'\n", "techniques": ["T1078", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerUnexpectedCountEventResult.yaml", "query_name": "Zscaler - Unexpected event count of rejects by policy", "query": "let threshold = 1000;\nZPAEvent\n| where EventResult has \"REJECTED_BY_POLICY\"\n| summarize rejected = count() by EventResult, DstUserName\n| where rejected > threshold\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects unexpected event count of rejects by policy.'\n", "techniques": ["T1078", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerUnexpectedCountries.yaml", "query_name": "Zscaler - Forbidden countries", "query": "let bl_countries = dynamic(['CH', 'RU']);       //List of countries from which you do not expect connections\nZPAEvent \n| where DvcAction == 'open'\n| where SrcGeoCountry in~ (bl_countries)\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects suspicious ZPA connections from forbidden countries.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerUnexpectedUpdateOperation.yaml", "query_name": "Zscaler - Unexpected update operation", "query": "ZPAEvent\n| where isnotempty(AuditOperationType)\n| extend ExpectedVersion1 = extract(@'(expectedVersion\":\")([0-9]+)\\.([0-9]+\\.[0-9]+)', 2, AuditOldValue)\n| extend ExpectedVersion2 = extract(@'(expectedVersion\":\")([0-9]+)\\.([0-9]+\\.[0-9]+)', 3, AuditOldValue)\n| extend NewVersion1 = extract(@'(\"currentVersion\":\")([0-9]+)\\.([0-9]+\\.[0-9]+)', 2, AuditNewValue)\n| extend NewVersion2 = extract(@'(\"currentVersion\":\")([0-9]+)\\.([0-9]+\\.[0-9]+)', 3, AuditNewValue)\n| extend Comparision1 = iff(tolong(ExpectedVersion2) > tolong(NewVersion2), 'Unexpected version', 'Expected version')\n| extend VersionCheck = iff(tolong(ExpectedVersion1) > tolong(NewVersion1), 'Unexpected version', Comparision1)\n| project-away ExpectedVersion1, ExpectedVersion2, NewVersion1, NewVersion2, Comparision1\n| extend ProcessCustomEntity = AuditOperationType\n", "attributes": {"description": "'Detects unexpected version of update operation.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerZPAConnectionsByDormantUser.yaml", "query_name": "Zscaler - Connections by dormant user", "query": "let dt_lastlogintime = 14d;\nlet activeUsers =\nZPAEvent \n| where TimeGenerated > ago(dt_lastlogintime)\n| where DvcAction == 'open'\n| summarize lastLoginTime = max(TimeGenerated) by DstUserName\n| summarize makelist(DstUserName);\nZPAEvent\n| where DstUserName !in~ (activeUsers)\n| summarize EventCount = count() by DstUserName\n| project-away EventCount\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects ZPA connections by dormant user.'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerZPAConnectionsByNewUser.yaml", "query_name": "Zscaler - ZPA connections by new user", "query": "let listUsers =\nZPAEvent \n| where TimeGenerated > ago(14d)\n| where DvcAction == 'open'\n| summarize ListofUsers = make_set(DstUserName) by DstUserName\n| project ListofUsers;\nZPAEvent\n| where DstUserName !in (listUsers)\n| summarize EventCount = count() by DstUserName\n| project-away EventCount\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects ZPA connections by new user.'\n", "techniques": ["T1078"], "tactics": ["Persistence"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerZPAConnectionsFromNewCountry.yaml", "query_name": "Zscaler - ZPA connections from new country", "query": "let listCountries =\nZPAEvent \n| where TimeGenerated > ago(14d)\n| where DvcAction == 'open'\n| summarize ListofCountries = make_set(SrcGeoCountry) by DstUserName\n| project ListofCountries;\nZPAEvent\n| where isnotempty(SrcGeoCountry)\n| where SrcGeoCountry !in (listCountries)\n| summarize EventCount = count() by DstUserName, SrcGeoCountry\n| project-away EventCount\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects ZPA connections from new country.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerZPAConnectionsFromNewIP.yaml", "query_name": "Zscaler - ZPA connections from new IP", "query": "let listIPs =\nZPAEvent \n| where TimeGenerated > ago(14d)\n| where DvcAction == 'open'\n| summarize ListofIPs = make_set(SrcIpAddr) by DstUserName\n| project ListofIPs;\nZPAEvent\n| where isnotempty(SrcIpAddr)\n| where SrcIpAddr !in (listIPs)\n| summarize EventCount = count() by DstUserName, SrcIpAddr\n| project-away EventCount\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects ZPA connections from new IP.'\n", "techniques": ["T1078", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerZPAConnectionsOutsideOperationalHours.yaml", "query_name": "Zscaler - ZPA connections outside operational hours", "query": "ZPAEvent \n| where DvcAction == 'open'\n| where datetime_part(\"Hour\", todatetime(LogTimestamp)) between (datetime_part(\"Hour\", todatetime('19:01:00.7654321')) .. datetime_part(\"Hour\", todatetime('08:01:00.7654321')))\n| summarize count() by DstUserName \n| project DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects ZAP connections outside operational hours.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Analytic%20Rules/ZscalerZPAUnexpectedSessionDuration.yaml", "query_name": "Zscaler - Unexpected ZPA session duration", "query": "let dt_lookBack = 24h;\nlet time_treshhold = timespan(08:00:00);\nlet open_sessions =\nZPAEvent\n| where TimeGenerated > ago(dt_lookBack)\n| where DvcAction == 'open'\n| summarize timestampstart = min(TimeGenerated) by DstUserName, SrcIpAddr, NetworkSessionId\n| sort by timestampstart asc;\nlet closed_sessions =\nZPAEvent\n| where TimeGenerated > ago(dt_lookBack)\n| where DvcAction == 'close'\n| summarize timestampend = max(TimeGenerated) by DstUserName, SrcIpAddr, NetworkSessionId\n| sort by timestampend asc;\nopen_sessions\n| join (closed_sessions) on DstUserName, SrcIpAddr, NetworkSessionId\n| extend duration = timestampend - timestampstart\n| where duration > time_treshhold\n| where DstUserName !has \"ZPA LSS\"\n| sort by timestampstart asc\n| extend IPCustomEntity = SrcIpAddr, AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Detects Unexpected ZPA session duration.'\n", "techniques": ["T1078", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerAbnormalTotalBytesSize.yaml", "query_name": "Zscaler - Abnormal total bytes size", "query": "let Average_Body_Bytes = toscalar(ZPAEvent\n| summarize Avg_Size = avg(tolong(ZENTotalBytesRxConnector)));\nZPAEvent\n| where tolong(ZENTotalBytesRxConnector) > 1000*Average_Body_Bytes\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query shows abnormal total bytes size.'\n", "techniques": ["T1530", "T1537"], "tactics": ["Exfiltration", "Collection"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerApplicationByUsers.yaml", "query_name": "Zscaler - Applications using by accounts", "query": "ZPAEvent\n| where isnotempty(Application)\n| summarize Users = make_set(DstUserName) by Application\n| extend AccountCustomEntity = Users\n", "attributes": {"description": "'Query shows applications using by accounts.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerConnectionCloseReason.yaml", "query_name": "Zscaler - Connection close reasons", "query": "let User_set = \nZPAEvent\n| where DvcAction has \"close\"\n| summarize Users = make_set(DstUserName)by EventResult;\nZPAEvent\n| where DvcAction has \"close\"\n| summarize EventCount = count()by EventResult\n| join (User_set) on EventResult\n| project-away EventResult1\n| top 20 by EventCount desc \n| extend AccountCustomEntity = Users\n", "attributes": {"description": "'Query shows connection close reasons.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerIPsByPorts.yaml", "query_name": "Zscaler - Destination ports by IP", "query": "ZPAEvent\n| where isnotempty(DstPortNumber)\n| summarize IP_Dst = make_set(DstIpAddr) by DstPortNumber\n| extend IPCustomEntity = DstIpAddr\n", "attributes": {"description": "'Query shows destination ports by IP address.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerSourceLocation.yaml", "query_name": "Zscaler - Users by source location countries", "query": "ZPAEvent\n| where isnotempty(SrcGeoCountry)\n| summarize Users = make_set(DstUserName) by SrcGeoCountry\n| extend AccountCustomEntity = Users\n", "attributes": {"description": "'Query shows Users by source location countries.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerTopConnectors.yaml", "query_name": "Zscaler - Top connectors", "query": "ZPAEvent\n| where isnotempty(Connector) \n| where Connector != 0\n| summarize summ = sum(tolong(BytesRxInterface))by Connector\n| top 20 by summ desc \n| extend ProcessCustomEntity = Connector\n", "attributes": {"description": "'Query shows top connectors.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerTopSourceIP.yaml", "query_name": "Zscaler - Top source IP", "query": "ZPAEvent\n| where DvcAction == 'open'\n| summarize EventCount = count()by SrcIpAddr\n| top 20 by EventCount desc \n| extend IPCustomEntity = SrcIpAddr\n", "attributes": {"description": "'Query shows top source IP.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerUrlhostname.yaml", "query_name": "Zscaler - Rare urlhostname requests", "query": "ZPAEvent\n| where isnotempty(UrlHostname)\n| summarize url = count()by UrlHostname\n| top 20 by url asc \n| extend UrlCustomEntity = UrlHostname\n", "attributes": {"description": "'Query shows rare urlhostname requests.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerUserAccessGroups.yaml", "query_name": "Zscaler - Users access groups", "query": "ZPAEvent\n| summarize ApplicationGroup = make_set(AppGroup)by DstUserName\n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query shows users access groups.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"source_path": "https://github.com/Azure/Azure-Sentinel/blob/master/Solutions/Zscaler%20Private%20Access%20%28ZPA%29/Hunting%20Queries/ZscalerUserServerErrors.yaml", "query_name": "Zscaler - Server error by user", "query": "ZPAEvent\n| where EventResult has \"AST_MT_SETUP_ERR_OPEN_SERVER_ERROR\"\n| summarize ips = count()by DstUserName\n| top 20 by ips desc \n| extend AccountCustomEntity = DstUserName\n", "attributes": {"description": "'Query shows server error by user.'\n", "techniques": ["T1190", "T1133"], "tactics": ["InitialAccess"]}}, {"query": "\"//Returns any machines with a significant increase in syslog events over the last 5 days in every 30 minutes of data\\nlet starttime = 5d;\\nlet timeframe = 30m;\\nlet Computers=Syslog\\n    | where TimeGenerated >= ago(starttime)\\n    | summarize EventCount=count() by Computer, bin(TimeGenerated, timeframe)\\n    | where EventCount > 1500\\n    | order by TimeGenerated\\n    | summarize EventCount=make_list(EventCount), TimeGenerated=make_list(TimeGenerated) by Computer\\n    | extend outliers=series_decompose_anomalies(EventCount, 2)\\n    | mv-expand TimeGenerated, EventCount, outliers\\n    | where outliers == 1\\n    | distinct Computer\\n;\\nSyslog\\n| where TimeGenerated >= ago(starttime)\\n| where Computer in (Computers)\\n| summarize EventCount=count() by Computer, bin(TimeGenerated, timeframe)\\n| render timechart \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Anamoly-HigherThanExpectedSysLog.kql", "query_name": "Anamoly-HigherThanExpectedSysLog", "attributes": {}}, {"query": "\"//Query to find public IP addresses associated to AWS instances\\nAWSCloudTrail\\n| where EventName has \\\"AllocateAddress\\\"\\n| extend IPAssigned = tostring(parse_json(ResponseElements).publicIp)\\n| extend AllocationID = tostring(parse_json(ResponseElements).allocationId)\\n| project TimeGenerated, UserIdentityArn, UserIdentityAccountId, IPAssigned, AllocationID\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/AWS-PublicIPAddedtoInstance.kql", "query_name": "AWS-PublicIPAddedtoInstance", "attributes": {}}, {"query": "\"//Parser for Duo data sent to a custom table and join to identity info to correlate legacy usernames with userprincipalname\\nlet id=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | extend DuoUserName = AccountName\\n    | project AccountUPN, DuoUserName;\\nDuoLogs_CL\\n| where TimeGenerated > ago(1d)\\n| extend logs = split(SyslogMessage_s, \\\"|\\\")\\n| extend vendor = logs[1]\\n| extend app = logs[2]\\n| extend version = logs[3]\\n| extend event = logs[4]\\n| extend msg = (logs[5])\\n| where event == \\\"authentication\\\"\\n| extend DuoTime = EventTime_t\\n| extend DuoApplication = extract(\\\"cs1=(.*?) c\\\", 1, SyslogMessage_s)\\n| extend DuoIPAddr = extract(\\\"src=(.*?) c\\\", 1, SyslogMessage_s)\\n| extend DuoMethod = extract(\\\"cs3=(.*?) o\\\", 1, SyslogMessage_s)\\n| extend DuoOutcome = extract(\\\"outcome=(.*?) r\\\", 1, SyslogMessage_s)\\n| parse SyslogMessage_s with * \\\"duser=\\\" DuoUserName\\n| join kind=inner id on DuoUserName\\n| project\\n    DuoTime,\\n    DuoUserName,\\n    AccountUPN,\\n    DuoIPAddr,\\n    DuoApplication,\\n    DuoOutcome,\\n    DuoMethod\\n| sort by DuoTime desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Duo-LogParserwithIdentityInfo.kql", "query_name": "Duo-LogParserwithIdentityInfo", "attributes": {}}, {"query": "\"//Detect potential anomalous increase in syslog volume, adjust time frames to suit\\nlet Computers=Syslog_CL\\n    | where TimeGenerated >= ago(4d)\\n    | summarize EventCount=count() by Computer, bin(TimeGenerated, 15m)\\n    | where EventCount >= 1000\\n    | order by TimeGenerated\\n    | summarize EventCount=make_list(EventCount), TimeGenerated=make_list(TimeGenerated) by Computer\\n    | extend outliers=series_decompose_anomalies(EventCount, 2)\\n    | mv-expand TimeGenerated, EventCount, outliers\\n    | where outliers == 1\\n    | distinct Computer\\n;\\nSyslog_CL\\n| where TimeGenerated >= ago(4d)\\n| where Computer in (Computers)\\n| summarize EventCount=count() by Computer, bin(TimeGenerated, 15m)\\n| render timechart \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/SysLog-DetectAnomaliesInEvents.kql", "query_name": "SysLog-DetectAnomaliesInEvents", "attributes": {}}, {"query": "\"//If you add \\\"Microsoft-AzureADPasswordProtection-DCAgent/Admin\\\" as a log source to Sentinel/Log Analytics you can query Azure AD Password Protection events\\nEvent\\n| where Source == \\\"Microsoft-AzureADPasswordProtection-DCAgent\\\"\\n| where EventID in (\\\"10014\\\", \\\"10015\\\", \\\"10016\\\", \\\"30002\\\", \\\"30004\\\", \\\"30026\\\", \\\"10024\\\", \\\"30008\\\", \\\"30010\\\", \\\"30028\\\", \\\"30024\\\", \\\"30003\\\", \\\"30005\\\", \\\"30027\\\", \\\"30022\\\", \\\"30007\\\", \\\"10025\\\", \\\"30009\\\", \\\"30029\\\", \\\"30023\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/AADPasswordProtection-AllEvents.kql", "query_name": "AADPasswordProtection-AllEvents", "attributes": {}}, {"query": "\"//Detect when Kerberos preauthentication is enabled or disabled for a user\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where EventID == 4738\\n| where AccountType == \\\"User\\\"\\n| where UserAccountControl has_any (\\\"2064\\\", \\\"2096\\\")\\n| extend Action = case(UserAccountControl has \\\"2096\\\", strcat(\\\"Kerberos preauthentication disabled\\\"),\\n    UserAccountControl has \\\"2064\\\", strcat(\\\"Kerberos preauthentication enabled\\\"),\\n    \\\"unknown\\\")\\n| project TimeGenerated, Actor=SubjectAccount, User=TargetAccount, Action\\n\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-AccountPreAuthChanges.kql", "query_name": "SecurityEvent-AccountPreAuthChanges", "attributes": {}}, {"query": "\"//Detect when the 'account is sensitive and cannot be delegated' flag on an account is changed\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| project TimeGenerated, EventID, TargetAccount, SubjectAccount, UserAccountControl\\n| where EventID == \\\"4738\\\"\\n| where UserAccountControl has_any(\\\"2094\\\", \\\"2062\\\")\\n| extend Activity = case\\n    (UserAccountControl contains \\\"2094\\\", strcat(\\\"Account Sensitivity Enabled\\\"),\\n     UserAccountControl contains \\\"2062\\\", strcat(\\\"Account Sensitivity Disabled\\\"),\\n    \\\"Unknown\\\")\\n| project TimeGenerated, Target=TargetAccount, Actor=SubjectAccount, Activity\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-AccountSensitivityChanged.kql", "query_name": "SecurityEvent-AccountSensitivityChanged", "attributes": {}}, {"query": "\"//Alert when an Active Directory account is set to password not required\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\n\\nSecurityEvent\\n| project TimeGenerated, EventID, TargetAccount, SubjectAccount, UserAccountControl\\n| where EventID == \\\"4738\\\"\\n| where UserAccountControl has (\\\"2082\\\")\\n| extend Activity = strcat(\\\"Account set to password not required\\\")\\n| project TimeGenerated, Target=TargetAccount, Actor=SubjectAccount, Activity\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-AccountSetPasswordNotRequired.kql", "query_name": "SecurityEvent-AccountSetPasswordNotRequired", "attributes": {}}, {"query": "\"//Use series_decompose_anomalies to detect potentially anomalous IPC$ recon events. Configure start time as your anomaly learning period and timeframe as your detection period.\\n// Detection threshold determines the sensitivity, the higher the threshold value the higher the anomaly required to detect\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\n\\nlet starttime = 7d;\\nlet timeframe = 30m;\\nlet detectionthreshold = 2;\\nlet outliers = \\nSecurityEvent\\n| project TimeGenerated, Account, Computer, EventID, ShareName\\n| where TimeGenerated > ago(starttime)\\n// Exclude known Accounts that often connect to various machines, such as Defender for ID or vulnerability management software\\n| where Account !in (\\\"DOMAIN\\\\\\\\Account1\\\")\\n| where EventID == \\\"5140\\\"\\n| where ShareName == \\\"\\\\\\\\\\\\\\\\*\\\\\\\\IPC$\\\"\\n| order by TimeGenerated\\n| summarize Events=count()by Account, bin(TimeGenerated, timeframe)\\n| summarize EventCount=make_list(Events),TimeGenerated=make_list(TimeGenerated) by Account\\n| extend outliers=series_decompose_anomalies(EventCount, detectionthreshold)\\n| mv-expand TimeGenerated, EventCount, outliers\\n| where outliers == 1\\n| distinct Account;\\nSecurityEvent\\n| project TimeGenerated, Account, Computer, EventID, ShareName, IpAddress\\n| where TimeGenerated > ago(timeframe)\\n| where EventID == \\\"5140\\\"\\n| where ShareName == \\\"\\\\\\\\\\\\\\\\*\\\\\\\\IPC$\\\"\\n// Exclude computer objects connecting to themselves by parsing DOMAIN\\\\Computer$ objects and Computer.DOMAIN.COM objects and excluding matches\\n| parse Account with * \\\"\\\\\\\\\\\" AccountParse \\\"$\\\"\\n| parse Computer with ComputerParse \\\".\\\" * \\n| where AccountParse != ComputerParse\\n// Find remaining outliers and make a set\\n| where Account in (outliers)\\n| summarize AccountActivity=make_set(Computer) by Account\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-AnomalousIPCRecon.kql", "query_name": "SecurityEvent-AnomalousIPCRecon", "attributes": {}}, {"query": "\"//Create a daily report of users being added to on premise Active Directory groups, summarized by group name\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where TimeGenerated > ago (7d)\\n| where AccountType == \\\"User\\\"\\n| where EventID in (4728, 4732, 4756, 4761, 4746, 4751)\\n| project TimeGenerated, MemberName, ['Group Name']=TargetUserName, EventID\\n| parse MemberName with * 'CN=' UserAdded ',' *\\n| summarize UsersAdded=make_set(UserAdded) by ['Group Name'], startofday(TimeGenerated)\\n| sort by ['Group Name'] asc, TimeGenerated desc \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-DailySummaryofGroupAdditions.kql", "query_name": "SecurityEvent-DailySummaryofGroupAdditions", "attributes": {}}, {"query": "\"//Detects when a user with a privileged Azure AD role has had their on premises Active Directory password changed by someone other than themselves.\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet timeframe=7d;\\n//First find any users that hold privileged Azure AD roles\\nIdentityInfo\\n| where TimeGenerated > ago(21d)\\n| where isnotempty(AssignedRoles)\\n| where AssignedRoles != \\\"[]\\\"\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| project AccountUPN, AccountName, AccountSID\\n//Join those users based on AccountSID to on premises Active Directory password reset events\\n| join kind=inner (\\n    SecurityEvent\\n    | where TimeGenerated > ago(timeframe)\\n    | where EventID == \\\"4724\\\"\\n    | project\\n        TimeGenerated,\\n        Activity,\\n        SubjectAccount,\\n        TargetAccount,\\n        TargetSid,\\n        SubjectUserSid\\n    )\\n    on $left.AccountSID == $right.TargetSid\\n| where SubjectUserSid != TargetSid\\n//Summarize event data to make it easy to read\\n| project ['Time of Password Reset']=TimeGenerated, Activity, Actor=SubjectAccount, ['Target UserPrincipalName']=AccountUPN,['Target AccountName']=TargetAccount\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-DetectPrivilegedAADAdminPasswordChange.kql", "query_name": "SecurityEvent-DetectPrivilegedAADAdminPasswordChange", "attributes": {}}, {"query": "\"//Detect when group policy inheritance is either allowed or blocked\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| project TimeGenerated, EventID, EventData, SubjectAccount\\n| where EventID == \\\"5136\\\"\\n| parse EventData with * 'ObjectDN\\\">' OU '</Data' *\\n| parse EventData with * 'AttributeLDAPDisplayName\\\">' LDAPAttribute '</Data' *\\n| parse EventData with * 'AttributeValue\\\">' AttributeValue '</Data' *\\n| parse EventData with * 'OperationType\\\">%%' OperationType '</Data' *\\n| project\\n    TimeGenerated,\\n    Actor=SubjectAccount,\\n    OU,\\n    LDAPAttribute,\\n    AttributeValue,\\n    OperationType\\n| where LDAPAttribute == \\\"gPOptions\\\"\\n| where AttributeValue == \\\"1\\\"\\n| extend Activity = case\\n(OperationType == \\\"14674\\\" and AttributeValue == \\\"1\\\", strcat(\\\"Group Policy Inheritance Blocked\\\"),\\n OperationType == \\\"14675\\\" and AttributeValue == \\\"1\\\", strcat(\\\"Group Policy Inheritance Allowed\\\"),\\n \\\"Unknown\\\")\\n| project TimeGenerated, Actor, OU, Activity\\n\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-GPOInheritanceChanged.kql", "query_name": "SecurityEvent-GPOInheritanceChanged", "attributes": {}}, {"query": "\"//Alert when the 'Log on to' device list is changed for a user\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where EventID == 4738\\n| where AccountType == \\\"User\\\"\\n//Include domain accounts only (excluding local accounts)\\n| where TargetDomainName == SubjectDomainName\\n| extend ['Allowed Devices'] = case(isnotempty(UserWorkstations) and UserWorkstations != \\\"-\\\" and UserWorkstations != \\\"%%1793\\\", split(UserWorkstations, \\\",\\\"),\\n    (isnotempty(UserWorkstations) and UserWorkstations == \\\"%%1793\\\"), strcat(\\\"User can log onto all devices\\\"),\\n    \\\"unknown\\\")\\n//Exclude other 4738 events where the device list isn't changed\\n| where ['Allowed Devices'] != \\\"unknown\\\"\\n| project TimeGenerated, Actor=SubjectAccount, User=TargetAccount, ['Allowed Devices']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-LogonToDeviceListChanged.kql", "query_name": "SecurityEvent-LogonToDeviceListChanged", "attributes": {}}, {"query": "\"//Create a summary of your computers and the accounts that have logged on with special privileges over the last 30 days\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where TimeGenerated > ago (30d)\\n| project TimeGenerated, EventID, Account, AccountType, PrivilegeList, Computer\\n| where EventID == \\\"4672\\\"\\n| where Account != \\\"NT AUTHORITY\\\\\\\\SYSTEM\\\" and Account !has \\\"Window Manager\\\"\\n| where AccountType == \\\"User\\\"\\n//The privilege list is stored in a string of text that we need to split\\n| extend Privs=extract_all(@\\\"Se(.*?)Privilege\\\", PrivilegeList)\\n//Once we retrieve the privileges from the string of text we can recreate the proper naming\\n| mv-expand Privs\\n| extend Privilege=strcat('Se', Privs, 'Privilege')\\n| project TimeGenerated, Account, Computer, Privilege\\n| summarize ['List of Privileges']=make_set(Privilege) by Computer, Account\\n| sort by Computer asc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-SummarizePrivilegesAssignedonLogon.kql", "query_name": "SecurityEvent-SummarizePrivilegesAssignedonLogon", "attributes": {}}, {"query": "\"//Creates a list of computers that your users have connected to via RDP and the total count of distinct computers each user has connected to\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where TimeGenerated > ago(7d)\\n| where EventID == \\\"4624\\\"\\n| where LogonType == 10\\n//Extend new column that drops Account to lower case so users are correctly summarized, i.e User123 and user123 are combined\\n| extend AccountName=tolower(Account)\\n| summarize\\n    ['Count of Computers']=dcount(Computer),\\n    ['List of Computers']=make_set(Computer)\\n    by AccountName\\n| sort by ['Count of Computers'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-SummarizeRDPActivity.kql", "query_name": "SecurityEvent-SummarizeRDPActivity", "attributes": {}}, {"query": "\"//Creates a parser for all user account control changes changing the code into a readable message\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where isnotempty(UserAccountControl) and UserAccountControl != \\\"-\\\"\\n| where AccountType == \\\"User\\\"\\n| extend x = extract_all(@\\\"([0-9]{4})\\\", UserAccountControl)\\n| mv-expand x\\n| extend ['User Account Flag Description'] = case\\n    (\\n    x == \\\"2048\\\", strcat(\\\"Account Enabled\\\"),\\n    x == \\\"2049\\\", strcat(\\\"Home Directory Required - Disabled\\\"),\\n    x == \\\"2050\\\", strcat(\\\"Password Not Required - Disabled\\\"),\\n    x == \\\"2051\\\", strcat(\\\"Temp Duplicate Account - Disabled\\\"),\\n    x == \\\"2052\\\", strcat(\\\"Normal Account - Disabled\\\"),\\n    x == \\\"2053\\\", strcat(\\\"MNS Logon Account - Disabled\\\"),\\n    x == \\\"2054\\\", strcat(\\\"Interdomain Trust Account - Disabled\\\"),\\n    x == \\\"2055\\\", strcat(\\\"Workstation Trust Account - Disabled\\\"),\\n    x == \\\"2056\\\", strcat(\\\"Server Trust Account - Disabled\\\"),\\n    x == \\\"2057\\\", strcat(\\\"Don't Expire Password - Disabled\\\"),\\n    x == \\\"2058\\\", strcat(\\\"Account Unlocked\\\"),\\n    x == \\\"2059\\\", strcat(\\\"Encrypted Text Password Allowed - Disabled\\\"),\\n    x == \\\"2060\\\", strcat(\\\"Smartcard Required - Disabled\\\"),\\n    x == \\\"2061\\\", strcat(\\\"Trusted For Delegation - Disabled\\\"),\\n    x == \\\"2062\\\", strcat(\\\"Not Delegated - Disabled\\\"),\\n    x == \\\"2063\\\", strcat(\\\"Use DES Key Only - Disabled\\\"),\\n    x == \\\"2064\\\", strcat(\\\"Don't Require Preauth - Disabled\\\"),\\n    x == \\\"2065\\\", strcat(\\\"Password Expired - Disabled\\\"),\\n    x == \\\"2066\\\", strcat(\\\"Trusted To Authenticate For Delegation - Disabled\\\"),\\n    x == \\\"2067\\\", strcat(\\\"Exclude Authorization Information - Disabled\\\"),\\n    x == \\\"2068\\\", strcat(\\\"Undefined UserAccountControl Bit 20 - Disabled\\\"),\\n    x == \\\"2069\\\", strcat(\\\"Protect Kerberos Service Tickets with AES Keys - Disabled\\\"),\\n    x == \\\"2070\\\", strcat(\\\"Undefined UserAccountControl Bit 22 - Disabled\\\"),\\n    x == \\\"2071\\\", strcat(\\\"Undefined UserAccountControl Bit 23 - Disabled\\\"),\\n    x == \\\"2072\\\", strcat(\\\"Undefined UserAccountControl Bit 24 - Disabled\\\"),\\n    x == \\\"2073\\\", strcat(\\\"Undefined UserAccountControl Bit 25 - Disabled\\\"),\\n    x == \\\"2074\\\", strcat(\\\"Undefined UserAccountControl Bit 26 - Disabled\\\"),\\n    x == \\\"2075\\\", strcat(\\\"Undefined UserAccountControl Bit 27 - Disabled\\\"),\\n    x == \\\"2076\\\", strcat(\\\"Undefined UserAccountControl Bit 28 - Disabled\\\"),\\n    x == \\\"2077\\\", strcat(\\\"Undefined UserAccountControl Bit 29 - Disabled\\\"),\\n    x == \\\"2078\\\", strcat(\\\"Undefined UserAccountControl Bit 30 - Disabled\\\"),\\n    x == \\\"2079\\\", strcat(\\\"Undefined UserAccountControl Bit 31 - Disabled\\\"),\\n    x == \\\"2080\\\", strcat(\\\"Account Disabled\\\"),\\n    x == \\\"2081\\\", strcat(\\\"Home Directory Required - Enabled\\\"),\\n    x == \\\"2082\\\", strcat(\\\"Password Not Required - Enabled\\\"),\\n    x == \\\"2083\\\", strcat(\\\"Temp Duplicate Account - Enabled\\\"),\\n    x == \\\"2084\\\", strcat(\\\"Normal Account - Enabled\\\"),\\n    x == \\\"2085\\\", strcat(\\\"MNS Logon Account - Enabled\\\"),\\n    x == \\\"2086\\\", strcat(\\\"Interdomain Trust Account - Enabled\\\"),\\n    x == \\\"2087\\\", strcat(\\\"Workstation Trust Account - Enabled\\\"),\\n    x == \\\"2088\\\", strcat(\\\"Server Trust Account - Enabled\\\"),\\n    x == \\\"2089\\\", strcat(\\\"Don't Expire Password - Enabled\\\"),\\n    x == \\\"2090\\\", strcat(\\\"Account Locked\\\"),\\n    x == \\\"2091\\\", strcat(\\\"Encrypted Text Password Allowed - Enabled\\\"),\\n    x == \\\"2092\\\", strcat(\\\"Smartcard Required - Enabled\\\"),\\n    x == \\\"2093\\\", strcat(\\\"Trusted For Delegation - Enabled\\\"),\\n    x == \\\"2094\\\", strcat(\\\"Not Delegated - Enabled\\\"),\\n    x == \\\"2095\\\", strcat(\\\"Use DES Key Only - Enabled\\\"),\\n    x == \\\"2096\\\", strcat(\\\"Don't Require Preauth - Enabled\\\"),\\n    x == \\\"2097\\\", strcat(\\\"Password Expired - Enabled\\\"),\\n    x == \\\"2098\\\", strcat(\\\"Trusted To Authenticate For Delegation - Enabled\\\"),\\n    x == \\\"2099\\\", strcat(\\\"Exclude Authorization Information - Enabled\\\"),\\n    x == \\\"2100\\\", strcat(\\\"Undefined UserAccountControl Bit 20 - Enabled\\\"),\\n    x == \\\"2101\\\", strcat(\\\"Protect Kerberos Service Tickets with AES Keys - Enabled\\\"),\\n    x == \\\"2102\\\", strcat(\\\"Undefined UserAccountControl Bit 22 - Enabled\\\"),\\n    x == \\\"2103\\\", strcat(\\\"Undefined UserAccountControl Bit 23 - Enabled\\\"),\\n    x == \\\"2104\\\", strcat(\\\"Undefined UserAccountControl Bit 24 - Enabled\\\"),\\n    x == \\\"2105\\\", strcat(\\\"Undefined UserAccountControl Bit 25 - Enabled\\\"),\\n    x == \\\"2106\\\", strcat(\\\"Undefined UserAccountControl Bit 26 - Enabled\\\"),\\n    x == \\\"2107\\\", strcat(\\\"Undefined UserAccountControl Bit 27 - Enabled\\\"),\\n    x == \\\"2108\\\", strcat(\\\"Undefined UserAccountControl Bit 28 - Enabled\\\"),\\n    x == \\\"2109\\\", strcat(\\\"Undefined UserAccountControl Bit 29 - Enabled\\\"),\\n    x == \\\"2110\\\", strcat(\\\"Undefined UserAccountControl Bit 30 - Enabled\\\"),\\n    x == \\\"2111\\\", strcat(\\\"Undefined UserAccountControl Bit 31 - Enabled\\\"),\\n    \\\"Unknown\\\")\\n| project\\n    TimeGenerated,\\n    TargetAccount,\\n    Actor=SubjectAccount,\\n    UserAccountControl=x,\\n    ['User Account Flag Description']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-UACFlagParser.kql", "query_name": "SecurityEvent-UACFlagParser", "attributes": {}}, {"query": "\"//Detects when unconstrained kerberos delegation is enabled on a computer object\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where EventID == \\\"4742\\\"\\n| parse EventData with * 'NewUacValue\\\">' NewUacValue '</Data>' *\\n| parse EventData with * 'TargetUserName\\\">' ComputerName '</Data>' *\\n| parse EventData with * 'SubjectUserName\\\">' Actor '</Data>' *\\n| where NewUacValue == \\\"0x2080\\\"\\n| project TimeGenerated, Activity, ComputerName, Actor\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-UnconstrainedDelegationEnabled.kql", "query_name": "SecurityEvent-UnconstrainedDelegationEnabled", "attributes": {}}, {"query": "\"//Detects when unconstrained kerberos delegation is enabled on a user object\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where EventID == \\\"4738\\\"\\n| parse EventData with * 'NewUacValue\\\">' NewUacValue '</Data>' *\\n| parse EventData with * 'TargetUserName\\\">' UserName '</Data>' *\\n| parse EventData with * 'SubjectUserName\\\">' Actor '</Data>' *\\n| where NewUacValue == \\\"0x2010\\\"\\n| project TimeGenerated, Activity, UserName, Actor\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-UnconstrainedDelegationtoUser.kql", "query_name": "SecurityEvent-UnconstrainedDelegationtoUser", "attributes": {}}, {"query": "\"//Visualize Active Directory accounts created, disabled and deleted per day\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where TimeGenerated > ago(30d)\\n| where AccountType == \\\"User\\\"\\n| project TimeGenerated, Account, EventID, TargetAccount\\n| where EventID in (\\\"4720\\\", \\\"4725\\\", \\\"4726\\\")\\n| where TargetAccount !endswith \\\"$\\\"\\n| summarize\\n    ['Accounts Created']=countif(EventID == \\\"4720\\\"),\\n    ['Accounts Deleted']=countif(EventID == \\\"4726\\\"),\\n    ['Accounts Disabled']=countif(EventID == \\\"4725\\\")\\n    by startofday(TimeGenerated)\\n| render columnchart\\n    with (\\n    kind=unstacked,\\n    xtitle=\\\"Day\\\",\\n    ytitle=\\\"Count\\\",\\n    title=\\\"Active Directory User Accounts Created, Disabled and Deleted per day\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Active%20Directory/SecurityEvent-VisualizeAccountsCreatedDisabledDeleted.kql", "query_name": "SecurityEvent-VisualizeAccountsCreatedDisabledDeleted", "attributes": {}}, {"query": "\"//Detect when an Azure AD Entitlement Package is created. You may want to review to see what resources and roles have been included in the package.\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName == \\\"Create access package\\\"\\n| where TargetResources[0].type == \\\"AccessPackage\\\"\\n| extend AccessPackageName = tostring(TargetResources[0].displayName)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| project TimeGenerated, OperationName, AccessPackageName, Actor\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-AccessPackageCreated.kql", "query_name": "Audit-AccessPackageCreated", "attributes": {}}, {"query": "\"//Detect when a domain is added or removed to either the allow or block list in Azure AD external identities\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"Update policy\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| mv-expand TargetResources\\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\\n| mv-expand modifiedProperties  \\n| extend newValue = parse_json(modifiedProperties).newValue\\n| mv-expand todynamic(newValue)\\n| where newValue has \\\"InvitationsAllowedAndBlockedDomainsPolicy\\\"\\n| project TimeGenerated, OperationName, Actor, ['New Domain Policy']=newValue\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-AllowedBlockedDomainListChanges.kql", "query_name": "Audit-AllowedBlockedDomainListChanges", "attributes": {}}, {"query": "\"//Alert when an application using Azure AD app proxy is set to pass through as it's pre-auth setting\\nAuditLogs\\n| where LoggedByService == \\\"Application Proxy\\\"\\n| where OperationName == \\\"Update application\\\"\\n| where Result == \\\"success\\\"\\n| extend PreAuthSetting = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\\n| where PreAuthSetting == \\\"Passthru\\\"\\n| extend ['App Display Name'] = tostring(TargetResources[0].displayName)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| project TimeGenerated, PreAuthSetting, ['App Display Name'], Actor, ['Actor IP Address']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-AppProxySettoPassThrough.kql", "query_name": "Audit-AppProxySettoPassThrough", "attributes": {}}, {"query": "\"//Detects when a BitLocker key is read in Azure AD and retrieves the device and key ids\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"Read BitLocker key\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend s = tostring(AdditionalDetails[0].value)\\n| parse s with * \\\"ID: '\\\" KeyId \\\"'\\\" *\\n| parse s with * \\\"device: '\\\" DeviceId \\\"'\\\"\\n| project TimeGenerated, OperationName, Actor, KeyId, DeviceId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-BitLockerKeyRetrieved.kql", "query_name": "Audit-BitLockerKeyRetrieved", "attributes": {}}, {"query": "\"//Detect when a custom security attribute is set on a user\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"Update attribute values assigned to a user\\\"\\n| extend x = tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].displayName)\\n| extend [\\\"Attribute Value\\\"] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue))[0])\\n| extend Target = tostring(TargetResources[0].userPrincipalName)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| parse x with * '.' ['Attribute Set Name'] \\\"_\\\" *\\n| extend [\\\"Attribute Name\\\"]=split(x, \\\"_\\\")[1]\\n| project\\n    TimeGenerated,\\n    OperationName,\\n    Target,\\n    ['Attribute Set Name'],\\n    ['Attribute Name'],\\n    ['Attribute Value'],\\n    Actor\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-CustomSecurityAttributeSet.kql", "query_name": "Audit-CustomSecurityAttributeSet", "attributes": {}}, {"query": "\"//Create a daily summary of activities completed by your Azure AD privileged users\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet timerange=30d;\\nIdentityInfo\\n| where TimeGenerated > ago(21d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| where isnotempty(AssignedRoles)\\n| where AssignedRoles != \\\"[]\\\"\\n| project Actor=AccountUPN\\n| join kind=inner (\\n    AuditLogs\\n    | where TimeGenerated > ago(timerange)\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | where isnotempty(Actor)\\n    )\\n    on Actor\\n| summarize AdminActivity = make_list(OperationName) by Actor, startofday(TimeGenerated)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DailySummaryofAdminActivity.kql", "query_name": "Audit-DailySummaryofAdminActivity", "attributes": {}}, {"query": "\"//Alert when a user is assigned to a permanent active Azure AD role\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName in (\\\"Add member to role in PIM completed (permanent)\\\",\\\"Add member to role in PIM completed (timebound)\\\")\\n| where TargetResources[2].type == \\\"User\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend User = tostring(TargetResources[2].userPrincipalName)\\n| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)\\n| project TimeGenerated, Actor, User, ['Azure AD Role Name']\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectActivePIMAssignment.kql", "query_name": "Audit-DetectActivePIMAssignment", "attributes": {}}, {"query": "\"//Detect when Advanced Auditing is disabled for a user\\n//Reference - https://www.mandiant.com/resources/remediation-and-hardening-strategies-microsoft-365-defend-against-apt29-v13\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"Update user\\\"\\n| where Result == \\\"success\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend targetResources=parse_json(TargetResources)\\n| extend Target = tostring(TargetResources[0].userPrincipalName)\\n| extend ['Target ObjectId'] = tostring(TargetResources[0].id)\\n| mv-apply tr = targetResources on (\\n    extend targetResource = tr.displayName\\n    | mv-apply mp = tr.modifiedProperties on (\\n        where mp.displayName == \\\"LicenseAssignmentDetail\\\"\\n        | extend NewValue = tostring(mp.newValue)\\n        ))\\n| mv-expand todynamic(NewValue)\\n| where parse_json(tostring(NewValue.DisabledPlans))[0] == \\\"2f442157-a11c-46b9-ae5b-6e39ff4e5849\\\"\\n| project\\n    TimeGenerated,\\n    Actor,\\n    Target,\\n    ['Target ObjectId'],\\n    Activity=\\\"Advanced Auditing Disabled\\\"\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectAdvancedAuditingDisabled.kql", "query_name": "Audit-DetectAdvancedAuditingDisabled", "attributes": {}}, {"query": "\"//Detect changes to Azure AD Conditional Access policies on weekends or outside of business hours\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet Saturday = time(6.00:00:00);\\nlet Sunday = time(0.00:00:00);\\nAuditLogs\\n| where OperationName has \\\"conditional access\\\"\\n// extend LocalTime to your time zone\\n| extend LocalTime=TimeGenerated + 5h\\n// Change hours of the day to suit your company, i.e this would find activations between 6pm and 6am\\n| where dayofweek(LocalTime) in (Saturday, Sunday) or hourofday(LocalTime) !between (6 .. 18)\\n| extend ['Conditional Access Policy Name'] = tostring(TargetResources[0].displayName)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| project LocalTime, \\n    OperationName, \\n    ['Conditional Access Policy Name'], \\n    Actor\\n| sort by LocalTime desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectConditionalAccessChangesAfterHours.kql", "query_name": "Audit-DetectConditionalAccessChangesAfterHours", "attributes": {}}, {"query": "\"//Detect when a new credential is added to an Azure AD application registration\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName has \\\"Update application \\u2013 Certificates and secrets management\\\"\\n| extend ApplicationName = tostring(TargetResources[0].displayName)\\n| extend ApplicationObjectId = tostring(TargetResources[0].id)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ActorIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| project TimeGenerated, ApplicationName, ApplicationObjectId, Actor, ActorIPAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectCredentialAddedtoApp.kql", "query_name": "Audit-DetectCredentialAddedtoApp", "attributes": {}}, {"query": "\"//Detects users who add, delete or update a Azure AD Conditional Access policy for the first time.\\n//First find users who have previously made CA policy changes, this example looks back 90 days\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet knownusers=\\n    AuditLogs\\n    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)\\n    | where OperationName in (\\\"Update conditional access policy\\\", \\\"Add conditional access policy\\\", \\\"Delete conditional access policy\\\")\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | distinct Actor;\\n//Find new events from users not in the known user list\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName in (\\\"Update conditional access policy\\\", \\\"Add conditional access policy\\\", \\\"Delete conditional access policy\\\")\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Policy Name'] = tostring(TargetResources[0].displayName)\\n| extend ['Policy Id'] = tostring(TargetResources[0].id)\\n| where Actor !in (knownusers)\\n| project TimeGenerated, Actor, ['Policy Name'], ['Policy Id']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectFirstTimeCAPolicyChange.kql", "query_name": "Audit-DetectFirstTimeCAPolicyChange", "attributes": {}}, {"query": "\"//Detects users who add a service principal to Azure AD for the first time.\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet knownusers=\\n    AuditLogs\\n    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)\\n    | where OperationName == \\\"Add service principal\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | where isnotempty(Actor)\\n    | distinct Actor;\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName == \\\"Add service principal\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| where isnotempty(Actor)\\n| where Actor !in (knownusers)\\n| extend AppId = tostring(AdditionalDetails[1].value)\\n| project TimeGenerated, Actor, AppId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectFirstTimeServicePrincipalCreation.kql", "query_name": "Audit-DetectFirstTimeServicePrincipalCreation", "attributes": {}}, {"query": "\"//Detect when another Azure AD tenant is added to cross-tenant settings and for each tenant added, retrieve any domain names from your sign in data.\\n//First retrieve the event where a cross-tenant setting was added\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName == \\\"Add a partner to cross-tenant access setting\\\"\\n| where Result == \\\"success\\\"\\n| extend GuestTenantId = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| project TimeGenerated, OperationName, Actor, GuestTenantId\\n//join back to Azure AD sign in logs for the last 30 days to retrieve inbound guest activity\\n| join kind=inner (\\n    SigninLogs\\n    | where TimeGenerated > ago (180d)\\n    | where UserType == \\\"Guest\\\"\\n    | where ResultType == 0\\n    | where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId\\n    //Split all the domains belonging to inbound guest domains and summarize the list per TenantId\\n    | extend ['Guest Domains'] = split(UserPrincipalName, '@')[-1]\\n    | summarize ['Guest Domain Names']=make_set(['Guest Domains']) by HomeTenantId)\\n    //Join back to the audit even where the TenantId from the added setting matches the sign in data\\n    on $left.GuestTenantId == $right.HomeTenantId\\n| project-away HomeTenantId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectNewCrossTenantSetting.kql", "query_name": "Audit-DetectNewCrossTenantSetting", "attributes": {}}, {"query": "\"//Detect when a group is added to Azure AD with the 'Azure AD roles can be assigned to this group' flag enabled\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago(90d)\\n| where OperationName == \\\"Add group\\\"\\n| where parse_json(tostring(TargetResources[0].modifiedProperties))[1].displayName == \\\"IsAssignableToRole\\\"\\n| where parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue))[0] == true\\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue))[0])\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| project TimeGenerated, OperationName, GroupName, Actor, ['Actor IP Address']\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectNewPrivilegedGroupAdded.kql", "query_name": "Audit-DetectNewPrivilegedGroupAdded", "attributes": {}}, {"query": "\"//Detect Azure AD PIM activiations outside of working hours\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet timerange=30d;\\nAuditLogs\\n// extend LocalTime to your time zone\\n| extend LocalTime=TimeGenerated + 5h\\n| where LocalTime > ago(timerange)\\n// Change hours of the day to suit your company, i.e this would find activations between 6pm and 6am\\n| where hourofday(LocalTime) !between (6 .. 18)\\n| where OperationName == \\\"Add member to role completed (PIM activation)\\\"\\n| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)\\n| project LocalTime, User, ['Azure AD Role Name'], ['Activation Reason']=ResultReason\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectPIMActivationsOutsideWorkingHours.kql", "query_name": "Audit-DetectPIMActivationsOutsideWorkingHours", "attributes": {}}, {"query": "\"//Detect when a service principal is added to Azure AD after working hours or on weekends\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet Saturday = time(6.00:00:00);\\nlet Sunday = time(0.00:00:00);\\nAuditLogs\\n| where TimeGenerated > ago(7d)\\n// extend LocalTime to your time zone\\n| extend LocalTime=TimeGenerated + 5h\\n// Change hours of the day to suit your company, i.e this would find activations between 6pm and 6am\\n| where dayofweek(LocalTime) in (Saturday, Sunday) or hourofday(LocalTime) !between (6 .. 18)\\n| where OperationName == \\\"Add service principal\\\"\\n//Exclude service principals created by managed identities (if you have automation tasks running this may trigger), but you can remove the exclusion if required\\n| where parse_json(tostring(InitiatedBy.app)).displayName != \\\"Managed Service Identity\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend AppId = tostring(AdditionalDetails[1].value)\\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| project LocalTime, Actor, ['Actor IP Address'], AppId\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectSPAddedAfterHours.kql", "query_name": "Audit-DetectSPAddedAfterHours", "attributes": {}}, {"query": "\"//Alert on successful self service password resets at suspicious times\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n// extend LocalTime to your time zone\\n| extend LocalTime=TimeGenerated + 5h\\n| where LocalTime > ago(7d)\\n| where OperationName == \\\"Reset password (self-service)\\\"\\n| where ResultDescription == \\\"Successfully completed reset.\\\"\\n// Change hours of the day to suit your company, i.e this would find self service password reset events between 11pm and 4am\\n| where hourofday(LocalTime) !between (4 .. 23)\\n| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['IP Address of User'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| project LocalTime, OperationName, ResultDescription, User, ['IP Address of User']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectSSPRAfterHours.kql", "query_name": "Audit-DetectSSPRAfterHours", "attributes": {}}, {"query": "\"//Detect a successful self service password reset or account unlock from an IP address that user hasn't successfully signed into from in the last 30 days\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Find successful password reset and account unlocks in the last day\\nAuditLogs\\n| where TimeGenerated > ago (1d)\\n| where OperationName == \\\"Unlock user account (self-service)\\\" and ResultDescription == \\\"Success\\\" or OperationName == \\\"Reset password (self-service)\\\" and ResultDescription == \\\"Successfully completed reset.\\\"\\n| extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| project\\n    ['Reset Unlock or Time']=TimeGenerated,\\n    OperationName,\\n    UserPrincipalName,\\n    IPAddress\\n//Take the UserPrincipalName of the event and the IP address, join back to sign on logs to find events where the IP address has not been seen from that user\\n| join kind=leftanti \\n    (\\n    SigninLogs\\n    | where TimeGenerated > ago(30d)\\n    | where ResultType == 0\\n    )\\n    on UserPrincipalName, IPAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-DetectSSPRFromUnknownIP.kql", "query_name": "Audit-DetectSSPRFromUnknownIP", "attributes": {}}, {"query": "\"//When a user holding a privileged role triggers an Azure AD risk event, retrieve the operations completed by that user\\n//Lookup the IdentityInfo table for any users holding a privileged role\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet privusers=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | where isnotempty(AssignedRoles)\\n    | where AssignedRoles != \\\"[]\\\"\\n    | distinct AccountUPN;\\nAADUserRiskEvents\\n| where TimeGenerated > ago (7d)\\n| where UserPrincipalName in (privusers)\\n| where RiskDetail != \\\"aiConfirmedSigninSafe\\\"\\n| project RiskTime=TimeGenerated, UserPrincipalName\\n| join kind=inner\\n    (\\n    AuditLogs\\n    | where TimeGenerated > ago(7d)\\n    | extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    )\\n    on UserPrincipalName\\n| project-rename OperationTime=TimeGenerated\\n| project\\n    RiskTime,\\n    OperationTime,\\n    ['Time Between Events']=datetime_diff(\\\"minute\\\", OperationTime, RiskTime),\\n    OperationName,\\n    Category,\\n    CorrelationId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-EventsbyRiskyPrivilegedUser.kql", "query_name": "Audit-EventsbyRiskyPrivilegedUser", "attributes": {}}, {"query": "\"//Find users who have failed 3 or more times to set a new password during a SSPR flow. Worth reaching out to them to give them a hand or see if you can onboard them to something like Windows Hello for Business\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where LoggedByService == \\\"Self-service Password Management\\\"\\n| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['User IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| sort by TimeGenerated asc \\n| summarize ['SSPR Actions']=make_list_if(ResultReason, ResultReason has \\\"User submitted a new password\\\") by CorrelationId, User, ['User IP Address']\\n| where array_length(['SSPR Actions']) >= 3\\n| sort by User desc \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-FindUsersFailingNewPasswordSSPR.kql", "query_name": "Audit-FindUsersFailingNewPasswordSSPR", "attributes": {}}, {"query": "\"//Detect users who are trying to use self service password reset but failing as they don't have any authentication methods listed\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where LoggedByService == \\\"Self-service Password Management\\\"\\n| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['User IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| sort by TimeGenerated asc \\n| summarize ['SSPR Actions']=make_list(ResultReason) by CorrelationId, User, ['User IP Address']\\n| where ['SSPR Actions'] has \\\"User's account has insufficient authentication methods defined. Add authentication info to resolve this\\\"\\n| sort by User desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-FindUsersFailingSSPR.kql", "query_name": "Audit-FindUsersFailingSSPR", "attributes": {}}, {"query": "\"//Detects when a user activates a PIM role for the first time on weekends or after working hours\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet Saturday = time(6.00:00:00);\\nlet Sunday = time(0.00:00:00);\\nlet timeframe = 90d;\\n//Find users who have previously activated PIM roles outside of business hours or on weekends in the last 90 days\\n//In this example business hours are 6am to 6pm\\nlet knownusers=\\n    AuditLogs\\n    | where TimeGenerated > ago(timeframe) and TimeGenerated < ago(7d)\\n    // extend LocalTime to your time zone\\n    | extend LocalTime=TimeGenerated + 5h\\n    // Change hours of the day to suit your company, i.e this would find activations between 6pm and 6am\\n    | where dayofweek(LocalTime) in (Saturday, Sunday) or hourofday(LocalTime) !between (6 .. 18)\\n    | where OperationName == \\\"Add member to role completed (PIM activation)\\\"\\n    | extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | distinct User;\\n//Find users who activate a PIM role outside of business hours or on weekends for the first time in the last week\\nAuditLogs\\n| where TimeGenerated > ago(7d)\\n| extend LocalTime=TimeGenerated + 5h\\n| where dayofweek(LocalTime) in (Saturday, Sunday) or hourofday(LocalTime) !between (6 .. 18)\\n| where OperationName == \\\"Add member to role completed (PIM activation)\\\"\\n| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)\\n| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| where User !in (knownusers)\\n| project LocalTime, User, ['Azure AD Role Name'], ['Activation Reason']=ResultReason\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-FirstTimePIMActivationOutsideWorkingHours.kql", "query_name": "Audit-FirstTimePIMActivationOutsideWorkingHours", "attributes": {}}, {"query": "\"//Find when an Azure AD group is assigned (either permanent or eligble) to an Azure AD PIM assignment\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName in (\\\"Add eligible member to role in PIM completed (permanent)\\\", \\\"Add member to role in PIM completed (permanent)\\\")\\n| where TargetResources[2].type == \\\"Group\\\"\\n| extend GroupName = tostring(TargetResources[2].displayName)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)\\n| project TimeGenerated, OperationName, Actor, GroupName, ['Azure AD Role Name']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-GroupAddedtoPIM.kql", "query_name": "Audit-GroupAddedtoPIM", "attributes": {}}, {"query": "\"//Detect when an Azure AD guest account is assigned to an Azure AD PIM role\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago (1d)\\n| where OperationName in (\\\"Add eligible member to role in PIM completed (permanent)\\\", \\\"Add eligible member to role in PIM completed (timebound)\\\", \\\"Add member to role in PIM completed (permanent)\\\", \\\"Add member to role in PIM completed (timebound)\\\")\\n| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)\\n| extend Target = tostring(TargetResources[2].userPrincipalName)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| where Target contains \\\"#ext#\\\"\\n| project TimeGenerated, OperationName, Actor, Target, ['Azure AD Role Name']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-GuestAddedtoPIM.kql", "query_name": "Audit-GuestAddedtoPIM", "attributes": {}}, {"query": "\"//List the bulk activities attempted by your privileged Azure AD users and parse the results\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName has_all (\\\"(bulk)\\\", \\\"finished\\\")\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| project TimeGenerated, Actor, ResultDescription, OperationName\\n| parse ResultDescription with * \\\"Total activities count:\\\" ['Total Activity Count'] \\\";\\\" *\\n| parse ResultDescription with * \\\"succeeded activities count\\\" ['Total Succeeded'] \\\";\\\" *\\n| parse ResultDescription with * \\\"failed activities count\\\" ['Total Failed']\\n| project\\n    TimeGenerated,\\n    Actor,\\n    OperationName,\\n    ['Total Activity Count'],\\n    ['Total Succeeded'],\\n    ['Total Failed'] \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-ListBulkActivities.kql", "query_name": "Audit-ListBulkActivities", "attributes": {}}, {"query": "\"//Alert when any users who hold a privileged Azure AD role make MFA configuration changes or an admin changes MFA details on a privileged user\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\n//Lookup the IdentityInfo table for any users holding a privileged role\\nlet privusers=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | where isnotempty(AssignedRoles)\\n    | where AssignedRoles != \\\"[]\\\"\\n    | distinct AccountUPN;\\n//Lookup MFA configuration events for those privileged users\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName in~ (\\\"Admin registered security info\\\", \\\"Admin updated security info\\\", \\\"Admin deleted security info\\\", \\\"User registered security info\\\", \\\"User changed default security info\\\", \\\"User deleted security info\\\")\\n| extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)\\n| where UserPrincipalName in~ (privusers)\\n| project TimeGenerated, OperationName, UserPrincipalName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-MFAChangesforPrivlegedUsers.kql", "query_name": "Audit-MFAChangesforPrivlegedUsers", "attributes": {}}, {"query": "\"//Detect when Azure AD Named Locations are changed (either IP or Country) and retrieve the current list \\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet updatedip=\\n    AuditLogs\\n    | where OperationName == \\\"Update named location\\\"\\n    | mv-expand TargetResources\\n    | extend modifiedProperties = parse_json(TargetResources).modifiedProperties\\n    | mv-expand modifiedProperties  \\n    | extend newValue = tostring(parse_json(modifiedProperties).newValue)\\n    | mv-expand todynamic(newValue)\\n    | extend ipRanges = tostring(parse_json(newValue).ipRanges)\\n    | mv-expand todynamic(ipRanges) \\n    | extend cidr = tostring(ipRanges.cidrAddress)\\n    | where isnotempty(cidr)\\n    | extend ['Named Location name'] = tostring(TargetResources.displayName)\\n    | summarize ['IP List']=make_list(cidr) by ['Named Location name'];\\nlet updatedcountries=\\n    AuditLogs\\n    | where OperationName == \\\"Update named location\\\"\\n    | mv-expand TargetResources\\n    | extend modifiedProperties = parse_json(TargetResources).modifiedProperties\\n    | mv-expand modifiedProperties  \\n    | extend newValue = tostring(parse_json(modifiedProperties).newValue)\\n    | extend countriesAndRegions = tostring(parse_json(newValue).countriesAndRegions)\\n    | mv-expand todynamic(countriesAndRegions) \\n    | where isnotempty(countriesAndRegions)\\n    | extend ['Named Location name'] = tostring(TargetResources.displayName)\\n    | summarize ['Country List']=make_list(countriesAndRegions) by ['Named Location name'];\\nunion updatedip, updatedcountries\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-NamedLocationsChanged.kql", "query_name": "Audit-NamedLocationsChanged", "attributes": {}}, {"query": "\"//Detect when an admin adds a new unverified or verified domain into your Azure AD tenant\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName in (\\\"Add verified domain\\\", \\\"Add unverified domain\\\")\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| extend Domain = tostring(TargetResources[0].displayName)\\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], Domain\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-NewDomainAdded.kql", "query_name": "Audit-NewDomainAdded", "attributes": {}}, {"query": "\"//Find any new operations generated in the Azure AD audit table in the last week compared to the last 90 days\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet existingoperations=\\n    AuditLogs\\n    | where TimeGenerated > ago(90d) and TimeGenerated < ago(7d)\\n    | distinct OperationName;\\nAuditLogs\\n| where TimeGenerated > ago(7d)\\n| summarize Count=count() by OperationName, Category\\n| where OperationName !in (existingoperations)\\n| sort by Count desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-NewOperations.kql", "query_name": "Audit-NewOperations", "attributes": {}}, {"query": "\"//Detect when a user activates an Azure AD PIM role never seen by them before\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago(180d) and TimeGenerated < ago(1d)\\n| where OperationName == \\\"Add member to role completed (PIM activation)\\\"\\n| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)\\n| distinct User, ['Azure AD Role Name']\\n| join kind=rightanti (\\n    AuditLogs\\n    | where TimeGenerated > ago(1d)\\n    | where OperationName == \\\"Add member to role completed (PIM activation)\\\"\\n    | extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)\\n    )\\n    on User, ['Azure AD Role Name']\\n| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| project TimeGenerated, User, ['Azure AD Role Name']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-NewPIMRoleActivated.kql", "query_name": "Audit-NewPIMRoleActivated", "attributes": {}}, {"query": "\"//Find new operations completed by your privileged Azure AD users not seen before\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\n//Lookup the IdentityInfo table for any users holding a privileged role\\nlet privusers=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | where isnotempty(AssignedRoles)\\n    | where AssignedRoles != \\\"[]\\\"\\n    | distinct AccountUPN;\\n//Find actions taken by those users previously\\nAuditLogs\\n| where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)\\n| extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| where isnotempty(UserPrincipalName)\\n| where UserPrincipalName in (privusers)\\n| distinct UserPrincipalName, OperationName\\n//Find any new actions taken in the last day not seen before from that user\\n| join kind=rightanti (\\n    AuditLogs\\n    | where TimeGenerated > ago(1d)\\n    | extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | where UserPrincipalName in (privusers)\\n    | where isnotempty(UserPrincipalName)\\n    )\\n    on UserPrincipalName, OperationName\\n| project TimeGenerated, UserPrincipalName, OperationName, Category, CorrelationId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-NewPrivilegedActions.kql", "query_name": "Audit-NewPrivilegedActions", "attributes": {}}, {"query": "\"//Create a pivot table showing all the actions taken by your privileged users\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\n//Lookup the IdentityInfo table for any users holding a privileged role\\nlet privusers=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | where isnotempty(AssignedRoles)\\n    | where AssignedRoles != \\\"[]\\\"\\n    | distinct AccountUPN;\\n//Search for all actions taken by those users in the last 7 days\\nAuditLogs\\n| where TimeGenerated > ago(7d)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| where Actor in (privusers)\\n//Create a pivot table counting each action for each user\\n| evaluate pivot(OperationName, count(), Actor)\\n| order by Actor asc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-PivotTableofPrivilegedUserActions.kql", "query_name": "Audit-PivotTableofPrivilegedUserActions", "attributes": {}}, {"query": "\"//Alert when the redirect URI list is changed for a service principal\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"Update service principal\\\"\\n| mv-expand TargetResources\\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\\n| mv-expand modifiedProperties \\n| where modifiedProperties.displayName == \\\"AppAddress\\\" \\n| extend newValue = tostring(parse_json(modifiedProperties).newValue)\\n| mv-expand todynamic(newValue)\\n| extend RedirectURI = tostring(newValue.Address)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Service Principal Name'] = tostring(TargetResources.displayName)\\n| summarize ['List of Redirect URIs']=make_list(RedirectURI) by Actor, ['Service Principal Name']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-RedirectURIChanged.kql", "query_name": "Audit-RedirectURIChanged", "attributes": {}}, {"query": "\"//Summarize and visualize the roles being activated in Azure AD PIM\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago(30d)\\n| where OperationName == \\\"Add member to role completed (PIM activation)\\\"\\n| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)\\n| summarize Count=count()by ['Azure AD Role Name']\\n| sort by Count\\n| render barchart with (title=\\\"Count of Azure AD PIM activations by role\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-SummarizePIMRolesActivated.kql", "query_name": "Audit-SummarizePIMRolesActivated", "attributes": {}}, {"query": "\"//Create a summary of PIM activations for all your users per week\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago (30d)\\n| where OperationName == \\\"Add member to role completed (PIM activation)\\\"\\n| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend Role = tostring(TargetResources[0].displayName)\\n| where isnotempty(User)\\n| summarize\\n    ['Roles Activated']=make_list(Role),\\n    ['Times Activated']=make_list(TimeGenerated)\\n    by User, ['Week Starting']=startofweek(TimeGenerated)\\n| sort by User asc, ['Week Starting'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-SummarizeWeeklyPIM.kql", "query_name": "Audit-SummarizeWeeklyPIM", "attributes": {}}, {"query": "\"//Detect when a user is added and removed from an Azure AD role within a short time frame\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\n//Timerange = the amount of data to look back on, timeframe = the time between the role being added and removed\\nlet timerange=7d;\\nlet timeframe=4h;\\nAuditLogs\\n| where TimeGenerated > ago (timerange)\\n| where OperationName == \\\"Add member to role\\\"\\n| where Result == \\\"success\\\"\\n//Exclude role additions from Azure AD PIM\\n| where Identity <> \\\"MS-PIM\\\"\\n| extend User = tostring(TargetResources[0].userPrincipalName)\\n| extend Role = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n| extend UserWhoAdded = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| project TimeAdded=TimeGenerated, User, Role, UserWhoAdded\\n| join kind=inner (\\n    AuditLogs\\n    | where TimeGenerated > ago (timerange)\\n    | where OperationName == \\\"Remove member from role\\\"\\n    //Exclude role removals from Azure AD PIM\\n    | where Result == \\\"success\\\"\\n    | where Identity <> \\\"MS-PIM\\\"\\n    | extend User = tostring(TargetResources[0].userPrincipalName)\\n    | extend Role = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].oldValue)))\\n    | extend UserWhoRemoved = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | project TimeRemoved=TimeGenerated, User, Role, UserWhoRemoved\\n    )\\n    on User, Role\\n| extend ['Time User Held Role'] = TimeRemoved - TimeAdded\\n| where ['Time User Held Role'] < ['timeframe']\\n| project\\n    TimeAdded,\\n    TimeRemoved,\\n    ['Time User Held Role'],\\n    User,\\n    Role,\\n    UserWhoAdded,\\n    UserWhoRemoved\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-UserAddedandRemovedfromRole.kql", "query_name": "Audit-UserAddedandRemovedfromRole", "attributes": {}}, {"query": "\"//Alert when a user is added directly to an Azure AD role, bypassing PIM\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName has \\\"Add member to role outside of PIM\\\"\\n| extend RoleName = tostring(TargetResources[0].displayName)\\n| extend UserAdded = tostring(TargetResources[2].displayName)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| project TimeGenerated, OperationName, RoleName, UserAdded, Actor\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-UserAddedtoRoleOutsidePIM.kql", "query_name": "Audit-UserAddedtoRoleOutsidePIM", "attributes": {}}, {"query": "\"//Summarize all groups that have had users added to them via dynamic rules\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName == \\\"Add member to group\\\"\\n| where Identity == \\\"Microsoft Approval Management\\\"\\n| where TargetResources[0].type == \\\"User\\\"\\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n| extend User = tostring(TargetResources[0].userPrincipalName)\\n| summarize ['Count of Users Added']=dcount(User), ['List of Users Added']=make_set(User) by GroupName\\n| sort by GroupName asc  \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-UsersAddedtoDynamicGroups.kql", "query_name": "Audit-UsersAddedtoDynamicGroups", "attributes": {}}, {"query": "\"//Find users who have not elevated any roles in Azure AD PIM in 30 days\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago (365d)\\n| project TimeGenerated, OperationName, Result, TargetResources, InitiatedBy\\n| where OperationName == \\\"Add member to role completed (PIM activation)\\\"\\n| where Result == \\\"success\\\"\\n| extend ['Last Role Activated'] = tostring(TargetResources[0].displayName)\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| summarize arg_max(TimeGenerated, *) by Actor\\n| project\\n    Actor,\\n    ['Last Role Activated'],\\n    ['Last Activation Time']=TimeGenerated,\\n    ['Days Since Last Activation']=datetime_diff(\\\"day\\\", now(), TimeGenerated)\\n| where ['Days Since Last Activation'] >= 30\\n| sort by ['Days Since Last Activation'] desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-UsersWhoHaventElevatedPIM.kql", "query_name": "Audit-UsersWhoHaventElevatedPIM", "attributes": {}}, {"query": "\"//Find users who hold a privileged Azure AD role but haven't completed any activities in Azure AD for 45 days\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\n//Lookup the IdentityInfo table for any users holding a privileged role\\nIdentityInfo\\n| where TimeGenerated > ago(21d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| where isnotempty(AssignedRoles)\\n| where AssignedRoles != \\\"[]\\\"\\n| project UserPrincipalName=AccountUPN, AssignedRoles\\n| join kind=leftanti (\\n    AuditLogs\\n    | where TimeGenerated > ago(45d)\\n    | extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | where isnotempty(UserPrincipalName)\\n    | distinct UserPrincipalName\\n    )\\n    on UserPrincipalName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-UserswithPrivRolesbutnoActivity.kql", "query_name": "Audit-UserswithPrivRolesbutnoActivity", "attributes": {}}, {"query": "\"//Visualize successful vs failed self service password reset attempts in your Azure AD tenant\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago (30d)\\n| where LoggedByService == \\\"Self-service Password Management\\\"\\n| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['User IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| sort by TimeGenerated asc \\n//Create a list of all SSPR actions that make up a single correlation id which represents one attempts at completing SSPR\\n| summarize ['SSPR Actions']=make_list(ResultReason) by CorrelationId, bin(TimeGenerated, 1d)\\n//Summarize those lists of actions into those that have a successful password reset and those that don't\\n| summarize\\n    ['Successful self service password resets']=countif(['SSPR Actions'] has \\\"Successfully completed reset\\\"),\\n    ['Failed self service password resets']=countif(['SSPR Actions'] !has \\\"User successfully reset password\\\")\\n    by bin(TimeGenerated, 1d) \\n| render timechart with (title=\\\"Self service password reset success vs failure\\\", ytitle=\\\"Count\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Audit-VisualizeSSPRSuccessvsFailure.kql", "query_name": "Audit-VisualizeSSPRSuccessvsFailure", "attributes": {}}, {"query": "\"//This query will hunt for real time risk events flagged as medium or high that aren't confirmed safe by Microsoft and then enrich that data with information from the IdentityInfo table\\n\\n//Data connector required for this query - Azure Active Directory - AAD User Risk Events\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet id=\\n    IdentityInfo\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN;\\nlet signin=\\n    SigninLogs\\n    | where TimeGenerated > ago (14d)\\n    | where RiskLevelDuringSignIn in ('high', 'medium')\\n    | join kind=inner id on $left.UserPrincipalName == $right.AccountUPN\\n    | extend SigninTime = TimeGenerated\\n    | where RiskEventTypes_V2 != \\\"[]\\\";\\nAADUserRiskEvents\\n| where TimeGenerated > ago (14d)\\n| extend RiskTime = TimeGenerated\\n| where DetectionTimingType == \\\"realtime\\\"\\n| where RiskDetail !has \\\"aiConfirmedSigninSafe\\\"\\n| join kind=inner signin on CorrelationId\\n| extend TimeDelta = abs(SigninTime - RiskTime)\\n| project\\n    SigninTime,\\n    UserPrincipalName,\\n    RiskTime,\\n    TimeDelta,\\n    RiskEventTypes,\\n    RiskLevelDuringSignIn,\\n    City,\\n    Country,\\n    EmployeeId,\\n    AssignedRoles\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-AADRiskEventCorrelation.kql", "query_name": "Identity-AADRiskEventCorrelation", "attributes": {}}, {"query": "\"//Detects when an admin changes the authentication phone details for another user\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"Admin updated security info\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend Target = tostring(TargetResources[0].userPrincipalName)\\n| extend ['New Phone Number'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[2].newValue)))\\n| extend ['Old Phone Number'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[2].oldValue)))\\n| project TimeGenerated, Actor, Target, ['New Phone Number'], ['Old Phone Number']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-AdminUpdatingSecurityInfo.kql", "query_name": "Identity-AdminUpdatingSecurityInfo", "attributes": {}}, {"query": "\"//Alert when Azure AD guest accounts are denied access (either by Conditional Access or because they aren't granted specific access) to multiple applications in a short time period\\n//This query uses 3 or more applications within an hour\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nSigninLogs\\n| where TimeGenerated > ago (7d)\\n| where UserType == \\\"Guest\\\"\\n| where ResultType in (\\\"53003\\\", \\\"50105\\\")\\n| summarize\\n    ['Application Count']=dcount(AppDisplayName),\\n    ['Application List']=make_set(AppDisplayName)\\n    by UserPrincipalName, bin(TimeGenerated, 1h)\\n| where ['Application Count'] >= 3\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n| where Timestamp > ago (7d)\\n| where IsGuestUser == 1\\n| where ErrorCode  in (\\\"53003\\\", \\\"50105\\\")\\n| summarize\\n    ['Application Count']=dcount(Application),\\n    ['Application List']=make_set(Application)\\n    by AccountUpn, bin(Timestamp, 1h)\\n| where ['Application Count'] >= 3\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-AlertGuestDeniedAccesstoMultipleApps.kql", "query_name": "Identity-AlertGuestDeniedAccesstoMultipleApps", "attributes": {}}, {"query": "\"//Query to find security alerts for users who have privileged Azure AD roles\\n\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nlet PrivRoles = dynamic([\\\"Global Administrator\\\", \\\"Security Administrator\\\", \\\"Teams Administrator\\\"]);\\nlet identityinfo=\\n    IdentityInfo\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | where AssignedRoles has_any (PrivRoles)\\n    | extend TargetUserName = AccountName\\n    | extend UserPrincipalName = AccountUPN\\n    | project TargetUserName, UserPrincipalName, AssignedRoles;\\nSecurityAlert\\n| where TimeGenerated >= ago(5d)\\n| extend AlertTime = TimeGenerated\\n| extend UserPrincipalName = CompromisedEntity\\n| join kind=inner identityinfo on UserPrincipalName\\n| project AlertTime, TargetUserName, UserPrincipalName, AlertName, AssignedRoles\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-AlertsFromPrivilegedUsers.kql", "query_name": "Identity-AlertsFromPrivilegedUsers", "attributes": {}}, {"query": "\"//Detect anomalies in the amount of conditional access failures by users in your tenant, then visualize those conditional access failures\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Starttime and endtime = which period of data to look at, i.e from 21 days ago until today.\\nlet startdate=21d;\\nlet enddate=1d;\\n//Timeframe = time period to break the data up into, i.e 1 hour blocks.\\nlet timeframe=1h;\\n//Sensitivity = the lower the number the more sensitive the anomaly detection is, i.e it will find more anomalies, default is 1.5\\nlet sensitivity=2;\\n//Threshold = set this to tune out low count anomalies, i.e when total failures for a user doubles from 1 to 2\\nlet threshold=5;\\nlet outlierusers=\\nSigninLogs\\n| where TimeGenerated between (startofday(ago(startdate))..startofday(ago(enddate)))\\n| where ResultType == \\\"53003\\\"\\n| project TimeGenerated, ResultType, UserPrincipalName\\n| make-series CAFailureCount=count() on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserPrincipalName \\n| extend outliers=series_decompose_anomalies(CAFailureCount, sensitivity)\\n| mv-expand TimeGenerated, CAFailureCount, outliers\\n| where outliers == 1 and CAFailureCount > threshold\\n| distinct UserPrincipalName;\\n//Optionally visualize the anomalies\\nSigninLogs\\n| where TimeGenerated between (startofday(ago(startdate))..startofday(ago(enddate)))\\n| where ResultType == \\\"53003\\\"\\n| project TimeGenerated, ResultType, UserPrincipalName\\n| where UserPrincipalName in (outlierusers)\\n| summarize CAFailures=count()by UserPrincipalName, bin(TimeGenerated, timeframe)\\n| render timechart with (ytitle=\\\"Failure Count\\\",title=\\\"Anomalous Conditional Access Failures\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-AnomalousConditionalAccessFailures.kql", "query_name": "Identity-AnomalousConditionalAccessFailures", "attributes": {}}, {"query": "\"//Creates a list of your applications and summarizes successful signins by members vs guests separated to total and distinct signins\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| project TimeGenerated, UserType, ResultType, AppDisplayName, UserPrincipalName\\n| where ResultType == 0\\n| summarize\\n    ['Total Member Signins']=countif(UserType == \\\"Member\\\"),\\n    ['Distinct Member Signins']=dcountif(UserPrincipalName, UserType == \\\"Member\\\"),\\n    ['Total Guest Signins']=countif(UserType == \\\"Guest\\\"),\\n    ['Distinct Guest Signins']=dcountif(UserPrincipalName, UserType == \\\"Guest\\\")\\n    by AppDisplayName\\n| sort by AppDisplayName asc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-AppAccessMembersvsGuests.kql", "query_name": "Identity-AppAccessMembersvsGuests", "attributes": {}}, {"query": "\"//Query to find users who have access to an application but haven't signed in for 90 days\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet signins=\\nSigninLogs\\n| where TimeGenerated > ago (90d)\\n| where AppDisplayName has \\\"Application Name\\\"\\n| project TimeGenerated, UserPrincipalName, AppDisplayName;\\nIdentityInfo\\n| where TimeGenerated > ago (21d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| extend UserPrincipalName = AccountUPN\\n| where GroupMembership contains \\\"Group that gives access to Application\\\"\\n| join kind=leftanti signins on UserPrincipalName\\n| project UserPrincipalName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ApplicationAccessReview.kql", "query_name": "Identity-ApplicationAccessReview", "attributes": {}}, {"query": "\"//Find Azure AD applications that have more guests than members accessing them\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel Query\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == \\\"0\\\"\\n| summarize Guests=dcountif(UserPrincipalName,UserType == \\\"Guest\\\"), Members=dcountif(UserPrincipalName,UserType == \\\"Member\\\") by AppDisplayName\\n| where Guests > Members\\n| sort by Guests desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n| where Timestamp > ago(30d)\\n| where LogonType == @\\\"[\\\"\\\"interactiveUser\\\"\\\"]\\\"\\n| where ErrorCode == \\\"0\\\"\\n| summarize Guests=dcountif(AccountUpn,IsGuestUser == \\\"true\\\"), Members=dcountif(AccountUpn,IsGuestUser == \\\"false\\\") by Application\\n| where Guests > Members\\n| sort by Guests desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-AppsWithMoreGuests.kql", "query_name": "Identity-AppsWithMoreGuests", "attributes": {}}, {"query": "\"//Find the applications that have the most privileged users accessing them using only single factor authentication\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet privusers=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | where isnotempty(AssignedRoles)\\n    | where AssignedRoles != \\\"[]\\\"\\n    | distinct AccountUPN;\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where UserPrincipalName in (privusers)\\n| where ResultType == 0\\n| where AuthenticationRequirement == \\\"singleFactorAuthentication\\\"\\n| summarize\\n    ['List of Users']=make_set(UserPrincipalName),\\n    ['Count of Users']=dcount(UserPrincipalName)\\n    by AppDisplayName\\n| sort by ['Count of Users'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-AppswithmostSFAPrivUsers.kql", "query_name": "Identity-AppswithmostSFAPrivUsers", "attributes": {}}, {"query": "\"//Calculate the percentage of signins to all your Azure AD apps considered risky. Those requiring single factor authentication, coming from an unknown location and from an unknown device\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| extend DeviceTrustType = tostring(DeviceDetail.trustType)\\n| summarize\\n    ['Total Signins']=count(),\\n    ['At Risk Signins']=countif(NetworkLocationDetails == '[]' and isempty(DeviceTrustType) and AuthenticationRequirement == \\\"singleFactorAuthentication\\\")\\n    by AppDisplayName\\n| extend ['At Risk Percentage']=(todouble(['At Risk Signins']) * 100 / todouble(['Total Signins']))\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-CalculateRiskyApps.kql", "query_name": "Identity-CalculateRiskyApps", "attributes": {}}, {"query": "\"//Calculate the percentage for all your Azure AD users considered risky. Those requiring single factor authentication, coming from an unknown location and from an unknown device\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n//Include only member accounts if you want to ignore guest signins\\n| where UserType == \\\"Member\\\"\\n| extend DeviceTrustType = tostring(DeviceDetail.trustType)\\n| summarize\\n    ['Total Signins']=count(),\\n    ['At Risk Signins']=countif(NetworkLocationDetails == '[]' and isempty(DeviceTrustType) and AuthenticationRequirement == \\\"singleFactorAuthentication\\\")\\n    by UserPrincipalName\\n| extend ['At Risk Percentage']=(todouble(['At Risk Signins']) * 100 / todouble(['Total Signins']))\\n| sort by ['At Risk Percentage'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-CalculateRiskyUsers.kql", "query_name": "Identity-CalculateRiskyUsers", "attributes": {}}, {"query": "\"//Find which users are failing the most Conditional Access policies, retrieve the total failure count, distinct policy count and the names of the failed policies\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| project TimeGenerated, ConditionalAccessPolicies, UserPrincipalName\\n| mv-expand ConditionalAccessPolicies\\n| extend CAResult = tostring(ConditionalAccessPolicies.result)\\n| extend CAPolicyName = tostring(ConditionalAccessPolicies.displayName)\\n| where CAResult == \\\"failure\\\"\\n| summarize\\n    ['Total Conditional Access Failures']=count(),\\n    ['Distinct Policy Failure Count']=dcount(CAPolicyName),\\n    ['Policy Names']=make_set(CAPolicyName)\\n    by UserPrincipalName\\n| sort by ['Distinct Policy Failure Count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ConditionalAccessMostFailures.kql", "query_name": "Identity-ConditionalAccessMostFailures", "attributes": {}}, {"query": "\"//Create a pivot table showing all conditional access policy outcomes over the last 30 days\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| extend CA = parse_json(ConditionalAccessPolicies)\\n| mv-expand bagexpansion=array CA\\n| evaluate bag_unpack(CA)\\n| extend\\n    ['CA Outcome']=tostring(column_ifexists('result', \\\"\\\")),\\n    ['CA Policy Name'] = column_ifexists('displayName', \\\"\\\")\\n| evaluate pivot(['CA Outcome'], count(), ['CA Policy Name'])\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ConditionalAccessPivotTable.kql", "query_name": "Identity-ConditionalAccessPivotTable", "attributes": {}}, {"query": "\"//Find Azure AD conditional access policies that have no hits for 'success' or 'failure' over the last month\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Check that these policies are configured correctly or still required\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| project TimeGenerated, ConditionalAccessPolicies\\n| mv-expand ConditionalAccessPolicies\\n| extend CAResult = tostring(ConditionalAccessPolicies.result)\\n| extend ['Conditional Access Policy Name'] = tostring(ConditionalAccessPolicies.displayName)\\n| summarize ['Conditional Access Result']=make_set(CAResult) by ['Conditional Access Policy Name']\\n| where ['Conditional Access Result'] !has \\\"success\\\"\\n    and ['Conditional Access Result'] !has \\\"failure\\\"\\n    and ['Conditional Access Result'] !has \\\"unknownFutureValue\\\"\\n| sort by ['Conditional Access Policy Name'] asc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ConditionalAccessPoliciesNotinUse.kql", "query_name": "Identity-ConditionalAccessPoliciesNotinUse", "attributes": {}}, {"query": "\"//Create a daily summary of Azure Active Directory group additions\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet timerange=7d;\\nAuditLogs\\n| where TimeGenerated > ago (timerange)\\n| where OperationName == \\\"Add member to group\\\"\\n| extend Type = tostring(TargetResources[0].type)\\n| where Type == \\\"User\\\"\\n| extend ['Group Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n| extend UserAdded = tostring(TargetResources[0].userPrincipalName)\\n| where isnotempty(UserAdded)\\n| summarize ['Users Added']=make_set(UserAdded) by ['Group Name'], startofday(TimeGenerated)\\n| sort by ['Group Name'] asc, TimeGenerated desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-DailySummaryofUsersAddedtoAADGroups.kql", "query_name": "Identity-DailySummaryofUsersAddedtoAADGroups", "attributes": {}}, {"query": "\"//Detects users who have accessed Azure AD Management interfaces, such as Azure AD PowerShell or Graph Explorer, who have not accessed in the previous timeframe. \\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Add additional applications to include them in the same query, i.e Defender for Cloud Apps portal.\\n//Select a time frame to look back on, i.e find users logging on for the first time today not seen in the prior 60 days\\nlet timeframe = startofday(ago(60d));\\nlet applications = dynamic([\\\"Azure Active Directory PowerShell\\\", \\\"Microsoft Azure PowerShell\\\", \\\"Graph Explorer\\\", \\\"ACOM Azure Website\\\", \\\"Azure Portal\\\", \\\"Azure Advanced Threat Protection\\\"]);\\nSigninLogs\\n| where TimeGenerated > timeframe and TimeGenerated < startofday(now())\\n| where AppDisplayName in (applications)\\n| project UserPrincipalName, AppDisplayName\\n| join kind=rightanti\\n    (\\n    SigninLogs\\n    | where TimeGenerated > startofday(now())\\n    | where AppDisplayName in (applications)\\n    )\\n    on UserPrincipalName, AppDisplayName\\n| where ResultType == 0\\n| project TimeGenerated, UserPrincipalName, ResultType, AppDisplayName, IPAddress, Location, UserAgent\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-DetectingFirstTimeAccesstoAzureManagement.kql", "query_name": "Identity-DetectingFirstTimeAccesstoAzureManagement", "attributes": {}}, {"query": "\"//Detect when a user flags 3 or more distinct Azure AD risk events within a single day\\n\\n//Data connector required for this query - Azure Active Directory - AAD User Risk Events\\n\\nAADUserRiskEvents\\n| where TimeGenerated > ago(7d)\\n| where RiskState != \\\"dismissed\\\"\\n| summarize\\n    ['Distinct count of risk events']=dcount(RiskEventType),\\n    ['List of risk events']=make_set(RiskEventType)\\n    by UserPrincipalName, bin(TimeGenerated, 1d)\\n| where ['Distinct count of risk events'] >= 3\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-DetectMultipleDistinctRiskEvents.kql", "query_name": "Identity-DetectMultipleDistinctRiskEvents", "attributes": {}}, {"query": "\"//Find Azure AD applications that have had no signins for over 30 days. May be a sign of an app no longer in use or users bypassing SSO.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (365d)\\n| where ResultType == 0\\n| summarize arg_max(TimeGenerated, *) by AppId\\n| project\\n    AppDisplayName,\\n    ['Last Logon Time']=TimeGenerated,\\n    ['Days Since Last Logon']=datetime_diff(\\\"day\\\", now(), TimeGenerated)\\n| where ['Days Since Last Logon'] > 30\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FindAppswithNoSignins.kql", "query_name": "Identity-FindAppswithNoSignins", "attributes": {}}, {"query": "\"//Calculate the percentage of signins failing against each of your Conditional Access policies. If the percentage is high it may be worth evaulating the policy if it is fit for purpose.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| project ConditionalAccessPolicies\\n| extend CA = parse_json(ConditionalAccessPolicies)\\n| mv-expand bagexpansion=array CA\\n| extend ['CA Policy Name'] = tostring(CA.displayName)\\n| extend  ['CA Outcome'] = tostring(CA.result)\\n| summarize\\n    ['Total Signin Count']=count(),\\n    ['Total Failed Count']=countif(['CA Outcome'] == \\\"failure\\\")\\n    by ['CA Policy Name']\\n| extend ['Failed Percentage'] = todouble(['Total Failed Count']) * 100 / todouble(['Total Signin Count'])\\n| project-reorder\\n    ['CA Policy Name'],\\n    ['Total Signin Count'],\\n    ['Total Failed Count'],\\n    ['Failed Percentage']\\n| order by ['Failed Percentage']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FindCAFailurePercentage.kql", "query_name": "Identity-FindCAFailurePercentage", "attributes": {}}, {"query": "\"//Find the guests in your tenant connecting to the most applications. They are the biggest risk and the best target for additional controls like Conditional Access.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| where UserType == \\\"Guest\\\"\\n//Exclude the Microsoft apps for guest account management\\n| where AppDisplayName !in (\\\"My Apps\\\", \\\"Microsoft App Access Panel\\\", \\\"My Access\\\", \\\"My Profile\\\", \\\"Microsoft Invitation Acceptance Portal\\\")\\n| summarize\\n    ['Count of Applications']=dcount(AppDisplayName),\\n    ['List of Application']=make_set(AppDisplayName)\\n    by UserPrincipalName\\n| sort by ['Count of Applications'] desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n| where Timestamp > ago(30d)\\n| where ErrorCode == 0\\n| where IsGuestUser == 1\\n//Exclude the Microsoft apps for guest account management\\n| where Application  !in (\\\"My Apps\\\", \\\"Microsoft App Access Panel\\\", \\\"My Access\\\", \\\"My Profile\\\", \\\"Microsoft Invitation Acceptance Portal\\\")\\n| summarize\\n    ['Count of Applications']=dcount(Application),\\n    ['List of Application']=make_set(Application)\\n    by AccountUpn\\n| sort by ['Count of Applications'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FindGuestsAccessingMostApps.kql", "query_name": "Identity-FindGuestsAccessingMostApps", "attributes": {}}, {"query": "\"//Find Managed Identity service principals that have not successfully signed in in the last 30 days, for each Managed Identity list the Azure resources it has accessed\\n//Hopefully it means the resource has already been decommissioned, if not, check to see if it still requires the access it has been granted\\n\\n//Data connector required for this query - Azure Active Directory - Managed Identity Signin Logs\\n\\n//First find any Managed Identities that haven't successfully signed on for 30 days\\nAADManagedIdentitySignInLogs\\n| where TimeGenerated > ago(365d)\\n| where ResultType == \\\"0\\\"\\n| summarize arg_max(TimeGenerated, *) by AppId\\n| extend ['Days Since Last Signin'] = datetime_diff(\\\"day\\\", now(), TimeGenerated)\\n| project\\n    ['Last Sign in Time']=TimeGenerated,\\n    ServicePrincipalName,\\n    ServicePrincipalId,\\n    ['Days Since Last Signin'],\\n    AppId\\n| where ['Days Since Last Signin'] > 30\\n//Join that list of Managed Identities back to the sign in data and retrieve the Azure resources (such as Key Vault or Storage) it has accessed\\n| join kind=inner (\\n    AADManagedIdentitySignInLogs\\n    | where TimeGenerated > ago(365d)\\n    | where ResultType == \\\"0\\\"\\n    | summarize ['Resources Accessed']=make_set(ResourceDisplayName) by AppId)\\n    on AppId\\n| project-reorder\\n    ['Last Sign in Time'],\\n    ['Days Since Last Signin'],\\n    ServicePrincipalName,\\n    ServicePrincipalId,\\n    AppId,\\n    ['Resources Accessed']\\n| order by ['Days Since Last Signin'] desc\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FindInactiveManagedIdentities.kql", "query_name": "Identity-FindInactiveManagedIdentities", "attributes": {}}, {"query": "\"//Find Azure AD Service Principals that have not successfully signed on for the last 30 days\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\nAADServicePrincipalSignInLogs\\n| where TimeGenerated > ago(180d)\\n| where ResultType == 0\\n| summarize arg_max(TimeGenerated, *) by AppId\\n| project\\n    ['Last Successful Logon']=TimeGenerated,\\n    ServicePrincipalName,\\n    ServicePrincipalId,\\n    AppId\\n| join kind = leftanti (\\n    AADServicePrincipalSignInLogs\\n    | where TimeGenerated > ago(30d)\\n    | where ResultType == 0\\n    | summarize arg_max(TimeGenerated, *) by AppId\\n    )\\n    on AppId\\n| extend ['Days Since Last Logon']=datetime_diff(\\\"day\\\", now(), ['Last Successful Logon'])\\n| project-reorder ['Days Since Last Logon'], ['Last Successful Logon'], ServicePrincipalName, AppId, ServicePrincipalId\\n| sort by ['Last Successful Logon'] desc    \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FindInactiveServicePrincipals.kql", "query_name": "Identity-FindInactiveServicePrincipals", "attributes": {}}, {"query": "\"//Find new applications your users are signing into in the last month vs the previous 6 months. For each find the first time the app was used, how many total signins and distinct users accessing each one\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet knownapps=\\n    SigninLogs\\n    | where TimeGenerated > ago(180d) and TimeGenerated < ago (30d)\\n    | distinct AppId;\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where AppId !in (knownapps)\\n| where isnotempty(AppDisplayName)\\n| summarize\\n    ['First Time Seen']=min(TimeGenerated),\\n    Count=count(),\\n    ['User Count']=dcount(UserPrincipalName)\\n    by AppDisplayName\\n| sort by Count desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FindNewEnterpriseApps.kql", "query_name": "Identity-FindNewEnterpriseApps", "attributes": {}}, {"query": "\"//Find users who have successfully signed into Azure AD from 3 or more countries in the same day\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nSigninLogs\\n| where TimeGenerated > ago(7d)\\n| where ResultType == 0\\n| where isnotempty(Location)\\n| summarize\\n    ['Count of countries']=dcount(Location),\\n    ['List of countries']=make_set(Location)\\n    by UserPrincipalName, bin(TimeGenerated, 1d)\\n| where ['Count of countries'] >= 3\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n| where Timestamp > ago(7d)\\n| where ErrorCode == 0\\n| where isnotempty(Country)\\n| summarize\\n    ['Count of countries']=dcount(Country),\\n    ['List of countries']=make_set(Country)\\n    by AccountUpn, bin(Timestamp, 1d)\\n| where ['Count of countries'] >= 3\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FindUsersMultipleCountriesSameDay.kql", "query_name": "Identity-FindUsersMultipleCountriesSameDay", "attributes": {}}, {"query": "\"//Find users who are only using text message as their MFA method\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n//You can exclude guests if you want, they may be harder to move to more secure methods, comment out the below line to include all users\\n| where UserType == \\\"Member\\\"\\n| mv-expand todynamic(AuthenticationDetails)\\n| extend ['Authentication Method'] = tostring(AuthenticationDetails.authenticationMethod)\\n| where ['Authentication Method'] !in (\\\"Previously satisfied\\\", \\\"Password\\\", \\\"Other\\\")\\n| where isnotempty(['Authentication Method'])\\n| summarize\\n    ['Count of distinct MFA Methods']=dcount(['Authentication Method']),\\n    ['List of MFA Methods']=make_set(['Authentication Method'])\\n    by UserPrincipalName\\n//Find users with only one method found and it is text message\\n| where ['Count of distinct MFA Methods'] == 1 and ['List of MFA Methods'] has \\\"text\\\"\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FindUsersOnlyusingTextforMFA.kql", "query_name": "Identity-FindUsersOnlyusingTextforMFA", "attributes": {}}, {"query": "\"//Find users that have connected successfully via legacy auth for the first time\\n//First find users with existing successful legacy auth connections\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nlet knownusers=\\n    SigninLogs\\n    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)\\n    | where ResultType == 0\\n    | where ClientAppUsed !in (\\\"Mobile Apps and Desktop clients\\\", \\\"Browser\\\")\\n    | distinct UserPrincipalName;\\n//Find any new connections in the last day from users not in the existing list\\nSigninLogs\\n| where TimeGenerated > ago(1d)\\n| where ResultType == 0\\n| where ClientAppUsed !in (\\\"Mobile Apps and Desktop clients\\\", \\\"Browser\\\")\\n| where isnotempty(ClientAppUsed)\\n| where UserPrincipalName !in (knownusers)\\n| distinct UserPrincipalName, AppDisplayName, ClientAppUsed, IPAddress\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\n//First find users with existing successful legacy auth connections. Advanced Hunting only stores 30 days of data, but otherwise the same query works\\nlet knownusers=\\n    AADSignInEventsBeta\\n    | where Timestamp > ago(30d) and Timestamp < ago(1d)\\n    | where LogonType == @\\\"[\\\"\\\"interactiveUser\\\"\\\"]\\\"\\n    | where ErrorCode == 0\\n    | where ClientAppUsed !in (\\\"Mobile Apps and Desktop clients\\\", \\\"Browser\\\")\\n    | where isnotempty(ClientAppUsed)\\n    | distinct AccountUpn;\\n//Find any new connections in the last day from users not in the existing list\\nAADSignInEventsBeta\\n| where Timestamp > ago(1d)\\n| where LogonType == @\\\"[\\\"\\\"interactiveUser\\\"\\\"]\\\"\\n| where ErrorCode == 0\\n| where ClientAppUsed !in (\\\"Mobile Apps and Desktop clients\\\", \\\"Browser\\\")\\n| where isnotempty(ClientAppUsed)\\n| where AccountUpn !in (knownusers)\\n| distinct AccountUpn, Application, ClientAppUsed, IPAddress\\n\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FirstTimeLegacyAuth.kql", "query_name": "Identity-FirstTimeLegacyAuth", "attributes": {}}, {"query": "\"//Detect when a user adds someone to an Azure AD privileged role for the first time\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\n//First build a set of known users who have completed this action previously\\nlet knownusers=\\n    AuditLogs\\n    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)\\n    | where OperationName == \\\"Add member to role\\\"\\n    //Exclude role additions made by the Azure AD PIM service\\n    | where Identity != \\\"MS-PIM\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | distinct Actor;\\n//Find events in the last day by users not in the known list\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName == \\\"Add member to role\\\"\\n| where Identity != \\\"MS-PIM\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Azure AD Role Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n| extend Target = tostring(TargetResources[0].userPrincipalName)\\n| where Actor !in (knownusers)\\n| project TimeGenerated, Actor, Target, ['Azure AD Role Name']\\n\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FirstTimeRoleAddition.kql", "query_name": "Identity-FirstTimeRoleAddition", "attributes": {}}, {"query": "\"//Detect the first time a service principal fails Conditional Access\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\n//Microsoft Sentinel query\\n//First find service principals that have previously failed\\nlet knownfailures=\\n    AADServicePrincipalSignInLogs\\n    | where TimeGenerated > ago(30d) and TimeGenerated < ago (1d)\\n    | where ResultType == \\\"53003\\\"\\n    | distinct AppId;\\n//Find any new failures in the last day\\nAADServicePrincipalSignInLogs\\n| where TimeGenerated > ago(1d)\\n| where ResultType == \\\"53003\\\"\\n| where AppId !in (knownfailures)\\n| project\\n    TimeGenerated,\\n    ServicePrincipalName,\\n    ServicePrincipalId,\\n    AppId,\\n    ConditionalAccessPolicies,\\n    IPAddress\\n\\n//Detect the first time a service principal fails Conditional Access\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\n//Advanced Hunting query\\nlet knownfailures=\\n    AADSpnSignInEventsBeta\\n    | where Timestamp > ago(30d) and Timestamp < ago (1d)\\n    | where ErrorCode == \\\"53003\\\"\\n    | distinct ApplicationId;\\nAADSpnSignInEventsBeta\\n| where Timestamp > ago(1d)\\n| where ErrorCode == \\\"53003\\\"\\n| where ApplicationId  !in (knownfailures)\\n| project\\n    Timestamp,\\n    ServicePrincipalName,\\n    ServicePrincipalId,\\n    ApplicationId,\\n    IPAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-FirstTimeSPBlockedbyCA.kql", "query_name": "Identity-FirstTimeSPBlockedbyCA", "attributes": {}}, {"query": "\"//Detects when an Azure AD guest is added to an Azure AD role\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"Add member to role\\\"\\n| extend Target = tostring(TargetResources[0].userPrincipalName)\\n| extend RoleAdded = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| where Target contains \\\"#ext#\\\"\\n| project TimeGenerated, OperationName, Actor, Target, RoleAdded\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-GuestAddedtoAADRole.kql", "query_name": "Identity-GuestAddedtoAADRole", "attributes": {}}, {"query": "\"//Visualizes the total guest invites sent from your Azure AD tenant vs those redeemed. Data is summarized per week.\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet timerange=180d;\\nAuditLogs\\n| where TimeGenerated > ago (timerange)\\n| where OperationName in (\\\"Redeem external user invite\\\", \\\"Invite external user\\\")\\n| summarize\\n    InvitesSent=countif(OperationName == \\\"Invite external user\\\"),\\n    InvitesRedeemed=countif(OperationName == \\\"Redeem external user invite\\\")\\n    by startofweek(TimeGenerated)\\n| render columnchart\\n    with (\\n    title=\\\"Guest Invites Sent v Guest Invites Redeemed\\\",\\n    xtitle=\\\"Invites\\\",\\n    kind=unstacked)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-GuestInvitesSentvsRedeemed.kql", "query_name": "Identity-GuestInvitesSentvsRedeemed", "attributes": {}}, {"query": "\"//Find when inbound Azure AD guests access applications for the first time\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//First find applications that have previously had Azure AD guest signins\\nlet knownapps=\\n    SigninLogs\\n    | where TimeGenerated > ago (90d) and TimeGenerated < ago(7d)\\n    | where ResultType == 0\\n    | where UserType == \\\"Guest\\\"\\n//Include only inbound guests (guests accessing your tenant)\\n    | where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId\\n    | distinct AppDisplayName;\\n//Lookup signins from the last week and find guest sign ins to applications not on the known list\\nSigninLogs\\n| where TimeGenerated > ago (7d)\\n| where ResultType == 0\\n| where UserType == \\\"Guest\\\"\\n| where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId\\n| where AppDisplayName !in (knownapps)\\n//Summarize the access to those applications by time first seen and who is accessing each application\\n| summarize\\n    ['First Logon Time']=min(TimeGenerated),\\n    ['Total Guest Signins']=count(),\\n    ['Distinct Guest Signins']=dcount(UserPrincipalName),\\n    ['List of Guest Users']=make_set(UserPrincipalName)\\n    by AppDisplayName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-GuestsAccessingNewApplications.kql", "query_name": "Identity-GuestsAccessingNewApplications", "attributes": {}}, {"query": "\"//Lists guests who have been invited but not yet redeemed their invites.\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\n//Excludes newly invited guests (last 30 days).\\nlet timerange=365d;\\nlet timeframe=30d;\\nAuditLogs\\n| where TimeGenerated between (ago(timerange) .. ago(timeframe)) \\n| where OperationName == \\\"Invite external user\\\"\\n| extend GuestUPN = tolower(tostring(TargetResources[0].userPrincipalName))\\n| project TimeGenerated, GuestUPN\\n| join kind=leftanti  (\\n    AuditLogs\\n    | where TimeGenerated > ago (timerange)\\n    | where OperationName == \\\"Redeem external user invite\\\"\\n    | where CorrelationId <> \\\"00000000-0000-0000-0000-000000000000\\\"\\n    | extend d = tolower(tostring(TargetResources[0].displayName))\\n    | parse d with * \\\"upn: \\\" GuestUPN \\\",\\\" *\\n    | project TimeGenerated, GuestUPN)\\n    on GuestUPN\\n| distinct GuestUPN\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-GuestsInvitedbutnotRedeemed.kql", "query_name": "Identity-GuestsInvitedbutnotRedeemed", "attributes": {}}, {"query": "\"//Query to find high or medium real time risk events for users who have an assigned Azure AD role\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Azure Active Directory - AAD User Risk Events\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet id=\\n    IdentityInfo\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN;\\nlet signin=\\n    SigninLogs\\n    | where TimeGenerated > ago (14d)\\n    | where RiskLevelDuringSignIn in ('high', 'medium')\\n    | join kind=inner id on $left.UserPrincipalName == $right.AccountUPN\\n    | extend SigninTime = TimeGenerated\\n    | where RiskEventTypes_V2 != \\\"[]\\\";\\nAADUserRiskEvents\\n| where TimeGenerated > ago (14d)\\n| extend RiskTime = TimeGenerated\\n| where DetectionTimingType == \\\"realtime\\\"\\n| where RiskDetail !has \\\"aiConfirmedSigninSafe\\\"\\n| join kind=inner signin on CorrelationId\\n| where AssignedRoles != \\\"[]\\\"\\n| extend TimeDelta = abs(SigninTime - RiskTime)\\n| project\\n    SigninTime,\\n    UserPrincipalName,\\n    RiskTime,\\n    TimeDelta,\\n    RiskEventTypes,\\n    RiskLevelDuringSignIn,\\n    City,\\n    Country,\\n    EmployeeId,\\n    AssignedRoles\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-HighMediumRealtimeRiskforAADRoles.kql", "query_name": "Identity-HighMediumRealtimeRiskforAADRoles", "attributes": {}}, {"query": "\"//Find guest accounts that haven't signed in for a period of time, this example uses 45 days\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet timerange=180d;\\nlet timeframe=45d;\\nSigninLogs\\n| where TimeGenerated > ago(timerange)\\n| where UserType == \\\"Guest\\\" or UserPrincipalName contains \\\"#ext#\\\"\\n| where ResultType == 0\\n| summarize arg_max(TimeGenerated, *) by UserPrincipalName\\n| join kind = leftanti  \\n    (\\n    SigninLogs\\n    | where TimeGenerated > ago(timeframe)\\n    | where UserType == \\\"Guest\\\" or UserPrincipalName contains \\\"#ext#\\\"\\n    | where ResultType == 0\\n    | summarize arg_max(TimeGenerated, *) by UserPrincipalName\\n    )\\n    on UserPrincipalName\\n| project UserPrincipalName\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-InactiveGuestAccounts.kql", "query_name": "Identity-InactiveGuestAccounts", "attributes": {}}, {"query": "\"//Find users who hold privileged Azure AD roles but haven't signed onto Azure for 30 days\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet applications = dynamic([\\\"Azure Active Directory PowerShell\\\", \\\"Microsoft Azure PowerShell\\\", \\\"Graph Explorer\\\", \\\"ACOM Azure Website\\\", \\\"Azure Portal\\\", \\\"Azure Advanced Threat Protection\\\"]);\\nIdentityInfo\\n| where TimeGenerated > ago(21d)\\n| where isnotempty(AssignedRoles)\\n| project-rename UserPrincipalName=AccountUPN\\n| where AssignedRoles != \\\"[]\\\"\\n| summarize arg_max(TimeGenerated, *) by UserPrincipalName\\n| join kind=leftanti (\\n    SigninLogs\\n    | where TimeGenerated > ago(30d)\\n    | where AppDisplayName in (applications)\\n    | where ResultType == \\\"0\\\"\\n    )\\n    on UserPrincipalName\\n| project UserPrincipalName, AssignedRoles\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-InactivePrivilegedUsers.kql", "query_name": "Identity-InactivePrivilegedUsers", "attributes": {}}, {"query": "\"//Create a pivot table showing all your users who have signed in with legacy auth, which applications they are using (such as IMAP or ActiveSync) and the count of each\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| where ClientAppUsed !in (\\\"Mobile Apps and Desktop clients\\\", \\\"Browser\\\")\\n| where isnotempty(ClientAppUsed)\\n| evaluate pivot(ClientAppUsed, count(), UserPrincipalName)\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n| where Timestamp > ago(30d)\\n| where ErrorCode == 0\\n| where ClientAppUsed !in (\\\"Mobile Apps and Desktop clients\\\", \\\"Browser\\\")\\n| where isnotempty(ClientAppUsed)\\n| evaluate pivot(ClientAppUsed, count(), AccountUpn)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-LegacyAuthPivotTable.kql", "query_name": "Identity-LegacyAuthPivotTable", "attributes": {}}, {"query": "\"//Detect when an Azure AD managed identity accesses a resource for the first time, i.e an identity that previously only accessed storage accesses a key vault\\n\\n//Data connector required for this query - Azure Active Directory - Managed Identity Signin Logs\\n\\nAADManagedIdentitySignInLogs\\n| where TimeGenerated > ago (60d) and TimeGenerated < ago(1d)\\n| where ResultType == \\\"0\\\"\\n| distinct ServicePrincipalId, ResourceIdentity\\n| join kind=rightanti (\\n    AADManagedIdentitySignInLogs\\n    | where TimeGenerated > ago (1d)\\n    | where ResultType == \\\"0\\\"\\n    )\\n    on ServicePrincipalId, ResourceIdentity\\n| project\\n    ['Service Principal DisplayName']=ServicePrincipalName,\\n    ['Service Principal Id']=ServicePrincipalId,\\n    ['Azure Resource Identity Id']=ResourceIdentity,\\n    ['Azure Resource DisplayName']=ResourceDisplayName\\n| distinct\\n    ['Service Principal DisplayName'],\\n    ['Service Principal Id'],\\n    ['Azure Resource DisplayName'],\\n    ['Azure Resource Identity Id']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ManagedIdentityAccessingNewResources.kql", "query_name": "Identity-ManagedIdentityAccessingNewResources", "attributes": {}}, {"query": "\"//Summarize the Azure resources that each of your managed identities are accessing. The higher the count the higher the potential blast radius.\\n\\n//Data connector required for this query - Azure Active Directory - Managed Identity Signin Logs\\n\\nAADManagedIdentitySignInLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| summarize\\n    ['List of Azure Resources Accessed']=make_set(ResourceDisplayName),\\n    ['Distinct Resources Accessed']=dcount(ResourceDisplayName)\\n    by ServicePrincipalName\\n| sort by ['Distinct Resources Accessed'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ManagedIdentitySummaryofResources.kql", "query_name": "Identity-ManagedIdentitySummaryofResources", "attributes": {}}, {"query": "\"//Detect when MFA details for a user are changed, deleted or registered from an IP address that user has never signed in successfully from\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\n//Cache all successful sign in data for users using materialize operator\\nlet signindata=materialize (\\n    SigninLogs\\n    | where TimeGenerated > ago(180d)\\n    | where ResultType == 0\\n    | distinct UserPrincipalName, UserId, IPAddress);\\n//Search for audit events showing MFA registrations, deletions or changes in the last day\\nAuditLogs\\n| where TimeGenerated > ago(10d)\\n| where OperationName in (\\\"User registered security info\\\", \\\"User deleted security info\\\", \\\"User registered all required security info\\\")\\n| where Result == \\\"success\\\"\\n| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend UserId = tostring(TargetResources[0].id)\\n| project UserPrincipalName, UserId, IPAddress, OperationName\\n//Join those events back to our summarized sign in data looking for users who register MFA from an IP they have never signed in from\\n| where isnotempty(IPAddress)\\n| join kind=leftanti (signindata) on IPAddress, UserId\\n| distinct UserPrincipalName, IPAddress, OperationName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-MFAChangesfromunknownIP.kql", "query_name": "Identity-MFAChangesfromunknownIP", "attributes": {}}, {"query": "\"//Calculate how often your users are actively challenged for MFA vs when it was previously satisfied per day\\n//Return users who are challenged over the threshold per day\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet threshold = 5;\\nSigninLogs\\n| where TimeGenerated > ago(90d)\\n| where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n| extend x=todynamic(AuthenticationDetails)\\n| mv-expand x\\n| project TimeGenerated, x, UserPrincipalName\\n| extend MFAResultStep = tostring(x.authenticationStepResultDetail)\\n| summarize MFARequired=countif(MFAResultStep == \\\"MFA completed in Azure AD\\\"), PreviouslySatisfied=countif(MFAResultStep == \\\"MFA requirement satisfied by claim in the token\\\") by UserPrincipalName, startofday(TimeGenerated)\\n| where MFARequired >= threshold\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-MFACountPerUser.kql", "query_name": "Identity-MFACountPerUser", "attributes": {}}, {"query": "\"//Create a pivot table of all non password authentication methods by user. This is useful to migrate users from less secure methods like text message to more secure methods.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet isGUID = \\\"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\\\";\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| mv-expand todynamic(AuthenticationDetails)\\n| extend ['Authentication Method'] = tostring(AuthenticationDetails.authenticationMethod)\\n//Exclude previously satisifed, passwords and other data and any UserPrincipalName that comes through as a guid\\n| where ['Authentication Method'] !in (\\\"Previously satisfied\\\", \\\"Password\\\", \\\"Other\\\")\\n    and isnotempty(['Authentication Method'])\\n    and not(UserPrincipalName matches regex isGUID)\\n//Create pivot table of each method and the count by user\\n| evaluate pivot(['Authentication Method'], count(), UserPrincipalName)\\n| sort by UserPrincipalName asc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-MFAMethodsPivotTable.kql", "query_name": "Identity-MFAMethodsPivotTable", "attributes": {}}, {"query": "\"//Alert when a user successfully signs in from both a new location and using a new MFA method\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Cache all authentication methods and locations to memory using the materialize function for the last 6 months\\nlet mfahistory = materialize  (\\n    SigninLogs\\n    | where TimeGenerated > ago (180d) and TimeGenerated < ago(1d)\\n    | where ResultType == 0\\n    | where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n    | extend AuthMethod = tostring(MfaDetail.authMethod)\\n    | where isnotempty(AuthMethod)\\n    | distinct UserPrincipalName, AuthMethod, Location);\\n//Find sign ins from the last day that have both a new location and MFA method\\nmfahistory\\n| join kind=rightanti  (\\n    SigninLogs\\n    | where TimeGenerated > ago (1d)\\n    | where ResultType == 0\\n    | where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n    | extend AuthMethod = tostring(MfaDetail.authMethod)\\n    | where isnotempty(AuthMethod)\\n    | distinct \\n        UserPrincipalName,\\n        AuthMethod,\\n        AppDisplayName,\\n        Location,\\n        IPAddress)\\n    on UserPrincipalName, Location\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-MFANewLocationandMethod.kql", "query_name": "Identity-MFANewLocationandMethod", "attributes": {}}, {"query": "\"//Calculate the percentage of signins to each of your Azure AD applications that used MFA\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| summarize\\n    ['Total Signin Count']=count(),\\n    ['Total MFA Count']=countif(AuthenticationRequirement == \\\"multiFactorAuthentication\\\"),\\n    ['Total non MFA Count']=countif(AuthenticationRequirement == \\\"singleFactorAuthentication\\\")\\n    by AppDisplayName\\n| project\\n    AppDisplayName,\\n    ['Total Signin Count'],\\n    ['Total MFA Count'],\\n    ['Total non MFA Count'],\\n    MFAPercentage=(todouble(['Total MFA Count']) * 100 / todouble(['Total Signin Count']))\\n| sort by ['Total Signin Count'] desc, MFAPercentage asc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-MFAPercentageperapp.kql", "query_name": "Identity-MFAPercentageperapp", "attributes": {}}, {"query": "\"//Detects when a user registers MFA details on their account and then completes self service password reset with a short timeframe\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet timeframe=4h;\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName in (\\\"User changed default security info\\\", \\\"User registered all required security info\\\", \\\"User registered security info\\\")\\n| extend User = tostring(TargetResources[0].userPrincipalName)\\n| project SecurityInfoTime=TimeGenerated, User, OperationName\\n| join kind=inner (\\n    AuditLogs\\n    | where TimeGenerated > ago(1d)\\n    | where OperationName in (\\\"Reset password (self-service)\\\", \\\"Change password (self-service)\\\")\\n    | where Result == \\\"success\\\"\\n    | extend User = tostring(TargetResources[0].userPrincipalName)\\n    | project PasswordResetTime=TimeGenerated, OperationName, User)\\n    on User\\n| where (PasswordResetTime - SecurityInfoTime) between (0min .. timeframe)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-MFARegistrationfollowedbySSPR.kql", "query_name": "Identity-MFARegistrationfollowedbySSPR", "attributes": {}}, {"query": "\"//Alert when a user fails Azure AD Conditional Access policies to 5 or more unique applications within a short time period, this example uses 1 hour.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (1d)\\n| project TimeGenerated, ConditionalAccessPolicies, UserPrincipalName, AppDisplayName\\n| mv-expand ConditionalAccessPolicies\\n| extend CAResult = tostring(ConditionalAccessPolicies.result)\\n| extend CAPolicyName = tostring(ConditionalAccessPolicies.displayName)\\n| where CAResult == \\\"failure\\\"\\n| summarize\\n    ['List of Failed Application']=make_set(AppDisplayName),\\n    ['Count of Failed Application']=dcount(AppDisplayName)\\n    by UserPrincipalName, bin(TimeGenerated, 1h)\\n| where ['Count of Failed Application'] >= 5\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-MuiltipleConditionalAccessFailures.kql", "query_name": "Identity-MuiltipleConditionalAccessFailures", "attributes": {}}, {"query": "\"//Detect when a user is blocked by Conditional Access after failing 3 unique CA policies or 3 unique applications over a 2 hour period\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(1d)\\n| where ResultType == \\\"53003\\\"\\n| mv-expand ConditionalAccessPolicies\\n| extend ['CA Policy Name'] = tostring(ConditionalAccessPolicies.displayName)\\n| where ConditionalAccessPolicies.result == \\\"failure\\\"\\n| summarize\\n    ['Total count of logon failures']=count(),\\n    ['Count of failed applications']=dcount(AppDisplayName),\\n    ['List of failed applications']=make_set(AppDisplayName),\\n    ['Count of failed policy names']=dcount(['CA Policy Name']),\\n    ['List of failed policy names']=make_set(['CA Policy Name'])\\n    by UserPrincipalName, bin(TimeGenerated, 2h)\\n| where ['Count of failed applications'] >= 3 or ['Count of failed policy names'] >= 3\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-MultipleCAFailures.kql", "query_name": "Identity-MultipleCAFailures", "attributes": {}}, {"query": "\"//Detect when a user who holds an Azure AD privilege role fails MFA multiple times in a short time period. This example uses 2 failures within 20 minutes.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet privusers=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | where isnotempty(AssignedRoles)\\n    | where AssignedRoles != \\\"[]\\\"\\n    | distinct AccountUPN;\\nSigninLogs\\n| where TimeGenerated > ago(1d)\\n| where ResultType == \\\"500121\\\"\\n| where UserPrincipalName in (privusers)\\n| mv-expand todynamic(AuthenticationDetails)\\n| extend ['MFA Failure Type'] = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)\\n| where ['MFA Failure Type'] startswith \\\"MFA denied\\\"\\n| summarize\\n    ['MFA Failure Count']=count(),\\n    ['MFA Failure Reasons']=make_list(['MFA Failure Type'])\\n    by UserPrincipalName, bin(TimeGenerated, 20m)\\n| where ['MFA Failure Count'] >= 2\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-MultipleMFAFailuresPrivUsers.kql", "query_name": "Identity-MultipleMFAFailuresPrivUsers", "attributes": {}}, {"query": "\"//Query to parse IP information from Security Alerts\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where AlertName in (\\\"Impossible travel activity\\\", \\\"Atypical Travel\\\", \\\"Anonymous IP address\\\", \\\"Anomalous Token\\\")\\n| parse Entities with * 'AadUserId\\\": \\\"' aadid_ '\\\",' *\\n| extend ep_ = parse_json(ExtendedProperties)\\n| extend s = tostring(ep_[\\\"IP Addresses\\\"])\\n| extend ipv4_ = extract_all(@\\\"(([\\\\d]{1,3}\\\\.){3}[\\\\d]{1,3})\\\", dynamic([1]), s)\\n| extend ipv4Add_ = translate('[\\\"]', '', tostring(ipv4_))\\n| extend ipv6_ = extract_all(@\\\"(([\\\\d|\\\\w]{1,4}\\\\:){7}[\\\\d|\\\\w]{1,4})\\\", dynamic([1]), s)\\n| extend ipv6Add_ = translate('[\\\"]', '', tostring(ipv6_))\\n| project TimeGenerated, AlertName, ipv4Add_, ipv6Add_, CompromisedEntity\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ParseIPInfofromSecurityAlert.kql", "query_name": "Identity-ParseIPInfofromSecurityAlert", "attributes": {}}, {"query": "\"//Parses the user agent into its various components to allow hunting on specific browser versions or patch levels\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| extend UserAgentDetail = todynamic(parse_user_agent(UserAgent, \\\"browser\\\"))\\n| extend UserAgentFamily = tostring(parse_json(tostring(UserAgentDetail.Browser)).Family)\\n| extend UserAgentMajorVersion = toint(parse_json(tostring(UserAgentDetail.Browser)).MajorVersion)\\n| extend UserAgentMinorVersion = toint(parse_json(tostring(UserAgentDetail.Browser)).MinorVersion)\\n| extend UserAgentPatch = toint(parse_json(tostring(UserAgentDetail.Browser)).Patch)\\n| project\\n    TimeGenerated,\\n    UserPrincipalName,\\n    AppDisplayName,\\n    ResultType,\\n    IPAddress,\\n    Location,\\n    UserAgentFamily,\\n    UserAgentMajorVersion,\\n    UserAgentMinorVersion,\\n    UserAgentPatch,\\n    UserAgent\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ParseUserAgent.kql", "query_name": "Identity-ParseUserAgent", "attributes": {}}, {"query": "\"//Detect when a user has been potentially comrpomised but is stopped by MFA number matching or otherwise denied. Even if stopped by MFA the users credentials need to be rotated.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//This query finds any time a user denies an authentication, enters the wrong number or just doesn't respond three or more times in a single sign in event\\nSigninLogs\\n| project\\n    TimeGenerated,\\n    AuthenticationRequirement,\\n    AuthenticationDetails,\\n    UserPrincipalName,\\n    CorrelationId,\\n    ResultType\\n| where ResultType == 500121\\n| mv-expand todynamic(AuthenticationDetails)\\n| extend AuthResult = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)\\n| where AuthResult in (\\\"MFA denied; user did not select the correct number\\\", \\\"MFA denied; user declined the authentication\\\",\\\"MFA denied; user did not respond to mobile app notification\\\")\\n//Create a list of denied MFA challenges by sign in attempt (single CorrelationId)\\n| summarize ['Result Types']=make_list(AuthResult) by CorrelationId, UserPrincipalName\\n//Find results where there are at least 3 failures within the same sign in, i.e three denies, three did not respond events or three did not select the correct number\\n| where array_length( ['Result Types']) > 2\\n\\n//This is the same query but grouped by username and 10 minute period, in case the attacker is starting a new authentication flow and generates a new CorrelationId\\nSigninLogs\\n| project\\n    TimeGenerated,\\n    AuthenticationRequirement,\\n    AuthenticationDetails,\\n    UserPrincipalName,\\n    CorrelationId,\\n    ResultType\\n| where ResultType == 500121\\n| mv-expand todynamic(AuthenticationDetails)\\n| extend AuthResult = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)\\n| where AuthResult in (\\\"MFA denied; user did not select the correct number\\\", \\\"MFA denied; user declined the authentication\\\",\\\"MFA denied; user did not respond to mobile app notification\\\")\\n//Create a list of denied MFA challenges by UserPrincipalName and 10 minute window (to account for multiple sign in attempts)\\n| summarize ['Result Types']=make_list(AuthResult) by UserPrincipalName, bin(TimeGenerated, 10m)\\n//Find results where there are at least 3 failures within the same sign in, i.e three denies, three did not respond events or three did not select the correct number\\n| where array_length( ['Result Types']) > 2\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-PotentialMFANumberMatchingAbuse.kql", "query_name": "Identity-PotentialMFANumberMatchingAbuse", "attributes": {}}, {"query": "\"//Detect when a user denies MFA several times within a single sign in attempt and then completes MFA.\\n//This could be a sign of someone trying to spam your users with MFA prompts until they accept.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Select your threshold of how many times a user denies MFA before accepting\\nlet threshold=2;\\nSigninLogs\\n| project\\n    TimeGenerated,\\n    AuthenticationRequirement,\\n    AuthenticationDetails,\\n    UserPrincipalName,\\n    CorrelationId\\n//Include only authentications that require MFA\\n| where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n//Extend authentication result description\\n| extend AuthResult = tostring(parse_json(AuthenticationDetails)[1].authenticationStepResultDetail)\\n//Find results that include both denined and completed MFA\\n| where AuthResult in (\\\"MFA completed in Azure AD\\\", \\\"MFA denied; user declined the authentication\\\",\\\"MFA denied; user did not respond to mobile app notification\\\")\\n//Create a list of completed and denied MFA challenges per correlation id\\n| summarize ['Result Types']=make_list(AuthResult) by CorrelationId, UserPrincipalName\\n//Ensure the list includes both completed and denied MFA challenges\\n| where ['Result Types'] has (\\\"MFA completed in Azure AD\\\") and ['Result Types'] has_any (\\\"MFA denied; user declined the authentication\\\", \\\"MFA denied; user did not respond to mobile app notification\\\")\\n| mv-expand ['Result Types'] to typeof(string)\\n//Expand and count all the denied challenges and then return CorrelationId's where the MFA denied count is greater or equal to your threshold\\n| where ['Result Types'] has_any (\\\"MFA denied; user declined the authentication\\\",\\\"MFA denied; user did not respond to mobile app notification\\\")\\n| summarize ['Denied MFA Count']=count()by ['Result Types'], CorrelationId, UserPrincipalName\\n| where ['Denied MFA Count'] >= threshold\\n\\n//Alternate query, instead of grouping signins by CorrelationId we group them by UserPrincipalName and 10 minute blocks of time.\\n//In case the bad actor is starting a whole new sign in each time and generating a new CorrelationId for each attempt.\\n//Select your threshold of how many times a user denies MFA before accepting\\nlet threshold=2;\\nSigninLogs\\n| project\\n    TimeGenerated,\\n    AuthenticationRequirement,\\n    AuthenticationDetails,\\n    UserPrincipalName,\\n    CorrelationId\\n//Include only authentications that require MFA\\n| where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n//Extend authentication result description\\n| extend AuthResult = tostring(parse_json(AuthenticationDetails)[1].authenticationStepResultDetail)\\n//Find results that include both denined and completed MFA\\n| where AuthResult in (\\\"MFA completed in Azure AD\\\", \\\"MFA denied; user declined the authentication\\\",\\\"MFA denied; user did not respond to mobile app notification\\\")\\n//Create a list of completed and denied MFA challenges per user principal name over 10 minute periods\\n| summarize ['Result Types']=make_list(AuthResult) by UserPrincipalName, bin(TimeGenerated, 10m)\\n//Ensure the list includes both completed and denied MFA challenges\\n| where ['Result Types'] has (\\\"MFA completed in Azure AD\\\") and ['Result Types'] has_any (\\\"MFA denied; user declined the authentication\\\", \\\"MFA denied; user did not respond to mobile app notification\\\")\\n| mv-expand ['Result Types'] to typeof(string)\\n//Expand and count all the denied challenges and then return UserPrincipalNames where the MFA denied count is greater or equal to your threshold\\n| where ['Result Types'] has_any (\\\"MFA denied; user declined the authentication\\\",\\\"MFA denied; user did not respond to mobile app notification\\\")\\n| summarize ['Denied MFA Count']=count()by ['Result Types'], UserPrincipalName\\n| where ['Denied MFA Count'] >= threshold\\n\\n//Simple query to count users being spammed with denies or not responding in one hour time windows\\nSigninLogs\\n| project\\n    TimeGenerated,\\n    AuthenticationRequirement,\\n    AuthenticationDetails,\\n    UserPrincipalName,\\n    CorrelationId\\n| where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n| extend AuthResult = tostring(parse_json(AuthenticationDetails)[1].authenticationStepResultDetail)\\n| where AuthResult in (\\\"MFA denied; user declined the authentication\\\",\\\"MFA denied; user did not respond to mobile app notification\\\")\\n| summarize ['Result Types']=make_list(AuthResult), ['Result Count']=count() by UserPrincipalName, bin(TimeGenerated, 60m)\\n//Find hits with greater than 3 failures in an hour\\n| where ['Result Count'] > 3\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-PotentialMFASpam.kql", "query_name": "Identity-PotentialMFASpam", "attributes": {}}, {"query": "\"// Detects when a user flags an Azure AD risk event followed by changes to their MFA profile - potentially detecting a bad actor changing MFA details\\n\\n//Data connector required for this query - Azure Active Directory - AAD User Risk Events\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\n// Timeframe = the minutes between flagging a risk event and MFA details being changed\\nlet timeframe = 120;\\n//Search for real time risk events only and retrieve Correlation Id\\nAADUserRiskEvents\\n| where TimeGenerated > ago (1d)\\n| where DetectionTimingType == \\\"realtime\\\"\\n| where RiskDetail <> \\\"aiConfirmedSigninSafe\\\"\\n| project CorrelationId\\n//Join Correlation Id back to sign in data to retrieve the initial sign in time that was flagged for risk\\n| join kind=inner(\\nSigninLogs\\n| where TimeGenerated > ago (1d))\\non CorrelationId\\n| summarize ['Risky Signin Time']=min(TimeGenerated) by CorrelationId, UserPrincipalName\\n//Join risky sign in UserPrincipalName to audit log for MFA events\\n| join kind=inner (\\n    AuditLogs\\n    | where TimeGenerated > ago (1d)\\n    | where OperationName in (\\\"User registered security info\\\", \\\"User deleted security info\\\",\\\"User registered all required security info\\\")\\n    | where Result == \\\"success\\\"\\n    | extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)\\n//Find the latest event in the MFA registration process\\n    | summarize arg_max(TimeGenerated, *) by UserPrincipalName\\n    | project\\n        ['MFA Change Time']=TimeGenerated,\\n        OperationName,\\n        UserPrincipalName)\\n    on UserPrincipalName\\n//Calculate the time between the initial sign in event and the MFA change time\\n| extend ['Minutes Between Events']=datetime_diff(\\\"minute\\\",['MFA Change Time'], ['Risky Signin Time'])\\n| project-away UserPrincipalName1\\n| project-reorder ['Risky Signin Time'], ['MFA Change Time'], ['Minutes Between Events'], UserPrincipalName, OperationName, CorrelationId\\n//Find events where the time between the two events was less than 120 minutes\\n| where ['Minutes Between Events'] < timeframe\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-RiskEventfollowedbyMFAchanges.kql", "query_name": "Identity-RiskEventfollowedbyMFAchanges", "attributes": {}}, {"query": "\"// Detects when a service principal has been added to an Azure AD role\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"Add member to role\\\"\\n| where TargetResources[0].type == \\\"ServicePrincipal\\\"\\n| extend ['Service Principal Object Id'] = tostring(TargetResources[0].id)\\n| extend ['Application Display Name'] = tostring(TargetResources[0].displayName) \\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['Azure AD Role Added'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n| project TimeGenerated, Actor, ['Azure AD Role Added'], ['Service Principal Object Id'], ['Application Display Name']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-RoleAddedtoServicePrincipal.kql", "query_name": "Identity-RoleAddedtoServicePrincipal", "attributes": {}}, {"query": "\"//Query to identity Security Alerts where they were triggered by a new user agent not seen for the previous 7 days. Update known IP Addresses from \\\"1.1.1\\\" to your corporate IP addresses to exclude\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nlet IPs=\\n    SecurityAlert\\n    | project\\n        TimeGenerated,\\n        Status,\\n        AlertName,\\n        CompromisedEntity,\\n        ExtendedProperties,\\n        ProviderName\\n    | where TimeGenerated > ago (1h)\\n    | where ProviderName in ('MCAS', 'IPC')\\n    | where AlertName in ('Impossible travel activity', 'Multiple failed login attempts', 'Unfamiliar sign-in properties', 'Anonymous IP address', 'Atypical travel')\\n    | where Status contains \\\"New\\\"\\n    | extend Properties = tostring(parse_json(ExtendedProperties))\\n    | extend UserPrincipalName = CompromisedEntity\\n    | extend ipv4Addresses = extract_all(@\\\"(([\\\\d]{1,3}\\\\.){3}[\\\\d]{1,3})\\\", dynamic([1]), Properties)\\n    | extend ipv4Add = translate('[\\\"]', '', tostring(ipv4Addresses))\\n    | extend ipv4Split =split(ipv4Add, \\\",\\\")\\n    | mv-expand ipv4Split\\n    | extend ipv4Split_s = tostring(ipv4Split);\\nSigninLogs\\n| project\\n    TimeGenerated,\\n    UserPrincipalName,\\n    IPAddress,\\n    AppDisplayName,\\n    ResultType,\\n    UserAgent,\\n    Location\\n| where TimeGenerated > ago(7d)\\n| where IPAddress !startswith \\\"1.1.1.\\\"\\n| where ResultType == 0 or ResultType == 50158\\n| join kind=inner IPs on UserPrincipalName, $left.IPAddress == $right.ipv4Split_s\\n| summarize AgentCount = count()by UserPrincipalName, UserAgent\\n| where AgentCount == 1\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SecurityAlertWithNewAgent.kql", "query_name": "Identity-SecurityAlertWithNewAgent", "attributes": {}}, {"query": "\"//Detect when an Azure AD service principal is created for a managed identity\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"Add service principal\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\\n| extend ['Service Principal DisplayName'] = tostring(TargetResources[0].displayName)\\n| extend ['Service Principal Id'] = tostring(TargetResources[0].id)\\n| where Actor == \\\"Managed Service Identity\\\"\\n| project TimeGenerated, ['Service Principal DisplayName'], ['Service Principal Id']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ServicePrincipalCreatedbyManagedIdentity.kql", "query_name": "Identity-ServicePrincipalCreatedbyManagedIdentity", "attributes": {}}, {"query": "\"//Find Azure AD service principals that have both successful and failed sign ins because of an expired secret. For both results, find the IP addresses.\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\n//If you are seeing results then the old secret is still in use somewhere and requires updating.\\n//Microsoft Sentinel query\\nAADServicePrincipalSignInLogs\\n| where TimeGenerated > ago(1d)\\n| summarize\\n    ['All Error Codes']=make_set(ResultType),\\n    ['Successful IP Addresses']=make_set_if(IPAddress, ResultType == 0),\\n    ['Failed IP Addresses']=make_set_if(IPAddress, ResultType == \\\"7000222\\\")\\n    by ServicePrincipalId, ServicePrincipalName\\n| where ['All Error Codes'] has_all (\\\"0\\\", \\\"7000222\\\")\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSpnSignInEventsBeta\\n| where Timestamp > ago(1d)\\n| summarize\\n    ['All Error Codes']=make_set(ErrorCode),\\n    ['Successful IP Addresses']=make_set_if(IPAddress, ErrorCode == 0),\\n    ['Failed IP Addresses']=make_set_if(IPAddress, ErrorCode == \\\"7000222\\\")\\n    by ServicePrincipalId, ServicePrincipalName\\n| where ['All Error Codes'] has \\\"0\\\" and ['All Error Codes'] has \\\"7000222\\\"\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ServicePrincipalExpiredSecret.kql", "query_name": "Identity-ServicePrincipalExpiredSecret", "attributes": {}}, {"query": "\"//Adds a friendly error description to the AADServicePrincipalSignInLogs table for any non successful signins\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\nAADServicePrincipalSignInLogs\\n| where ResultType != \\\"0\\\"\\n| extend ErrorDescription = case (\\n    ResultType == \\\"7000215\\\", strcat(\\\"Invalid client secret is provided\\\"),\\n    ResultType == \\\"7000222\\\", strcat(\\\"The provided client secret keys are expired\\\"),\\n    ResultType == \\\"700027\\\", strcat(\\\"Client assertion failed signature validation\\\"),\\n    ResultType == \\\"700024\\\", strcat(\\\"Client assertion is not within its valid time range\\\"),\\n    ResultType == \\\"70021\\\", strcat(\\\"No matching federated identity record found for presented assertion\\\"),\\n    ResultType == \\\"500011\\\", strcat(\\\"The resource principal named {name} was not found in the tenant named {tenant}\\\"),\\n    ResultType == \\\"700082\\\", strcat(\\\"The refresh token has expired due to inactivity\\\"),\\n    ResultType == \\\"90025\\\", strcat(\\\"Request processing has exceeded gateway allowance\\\"),\\n    ResultType == \\\"500341\\\", strcat(\\\"The user account {identifier} has been deleted from the {tenant} directory\\\"),\\n    ResultType == \\\"100007\\\", strcat(\\\"AAD Regional ONLY supports auth either for MSIs OR for requests from MSAL using SN+I for 1P apps or 3P apps in Microsoft infrastructure tenants\\\"),\\n    ResultType == \\\"1100000\\\", strcat(\\\"Non-retryable error has occurred\\\"),\\n    ResultType == \\\"90033\\\", strcat(\\\"A transient error has occurred. Please try again\\\"),\\n    ResultType == \\\"53003\\\", strcat(\\\"Access has been blocked by Conditional Access policies. The access policy does not allow token issuance.\\\"),\\n    \\\"Unknown\\\"\\n    )\\n| project\\n    TimeGenerated,\\n    ServicePrincipalName,\\n    ServicePrincipalId,\\n    ErrorDescription,\\n    ResultType,\\n    IPAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ServicePrincipalSigninErrors.kql", "query_name": "Identity-ServicePrincipalSigninErrors", "attributes": {}}, {"query": "\"//Detect when an Azure AD service principal signs in from an IP previously not seen\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\nAADServicePrincipalSignInLogs\\n| where TimeGenerated > ago(180d) and TimeGenerated < ago(7d)\\n| distinct AppId, IPAddress\\n| join kind=rightanti\\n    (\\n    AADServicePrincipalSignInLogs\\n    | where TimeGenerated > ago(7d)\\n    | project TimeGenerated, AppId, IPAddress, ResultType, ServicePrincipalName\\n    )\\n    on IPAddress\\n| where ResultType == \\\"0\\\"\\n| distinct ServicePrincipalName, AppId, IPAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ServicePrincipalSigninfromnewIP.kql", "query_name": "Identity-ServicePrincipalSigninfromnewIP", "attributes": {}}, {"query": "\"//Make a set of IP addresses that your Azure AD service principals have signed in from\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\nAADServicePrincipalSignInLogs\\n| where TimeGenerated > ago(90d)\\n| where ResultType == \\\"0\\\"\\n| summarize ['List of IP Addresses']=make_set(IPAddress), ['Count of Unique IP Addresses']=dcount(IPAddress) by ServicePrincipalName, AppId\\n| sort by ['Count of Unique IP Addresses'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ServicePrincipalSigninsbyIP.kql", "query_name": "Identity-ServicePrincipalSigninsbyIP", "attributes": {}}, {"query": "\"//Find Azure AD service principals that are logging on from multiple locations, this should be less common than with user accounts\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\n//Return the IP addresses used to sign in and see if you can build conditional access policies around them\\n//Microsoft Sentinel Query\\nAADServicePrincipalSignInLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == \\\"0\\\"\\n| where isnotempty(Location)\\n| summarize\\n    ['Count of Locations']=dcount(Location),\\n    ['List of Locations']=make_set(Location),\\n    ['Count of IP Addresses']=dcount(IPAddress),\\n    ['List of IP Addresses']=make_set(IPAddress)\\n    by ServicePrincipalName, AppId\\n| where ['Count of Locations'] >= 2\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSpnSignInEventsBeta\\n| where Timestamp > ago(30d)\\n| where ErrorCode == \\\"0\\\"\\n| where isnotempty(Country)\\n| summarize\\n    ['Count of Locations']=dcount(Country),\\n    ['List of Locations']=make_set(Country),\\n    ['Count of IP Addresses']=dcount(IPAddress),\\n    ['List of IP Addresses']=make_set(IPAddress)\\n    by ServicePrincipalName, ApplicationId\\n| where ['Count of Locations'] >= 2\\n\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ServicePrincipalsMultipleLocations.kql", "query_name": "Identity-ServicePrincipalsMultipleLocations", "attributes": {}}, {"query": "\"//Find any Azure AD Service Principals with only incorrect or expired secrets being used and no successful signins. These apps may no longer be in use and can be removed.\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\n//Microsoft Sentinel query\\nAADServicePrincipalSignInLogs\\n| where TimeGenerated > ago(14d)\\n| summarize\\n    ['All Error Codes']=make_set(ResultType)\\n    by ServicePrincipalId, ServicePrincipalName\\n| where ['All Error Codes'] !has \\\"0\\\" and ['All Error Codes'] has_any (\\\"7000222\\\", \\\"7000215\\\")\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSpnSignInEventsBeta\\n| where Timestamp > ago(14d)\\n| summarize\\n    ['All Error Codes']=make_set(ErrorCode)\\n    by ServicePrincipalId, ServicePrincipalName\\n| where ['All Error Codes'] !has \\\"0\\\" and ['All Error Codes'] has_any (\\\"7000222\\\", \\\"7000215\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ServicePrincipalsOnlyExpiredSecret.kql", "query_name": "Identity-ServicePrincipalsOnlyExpiredSecret", "attributes": {}}, {"query": "\"//Create a summary of which resources each of your service principals are connecting to. The higher the count the potential higher blast radius.\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\nAADServicePrincipalSignInLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == \\\"0\\\"\\n| summarize\\n    ['List of Azure Resources']=make_set(ResourceDisplayName),\\n    ['Count of Azure Resources']=dcount(ResourceDisplayName)\\n    by ServicePrincipalName\\n| sort by ['Count of Azure Resources'] desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ServicePrincipalSummaryofResources.kql", "query_name": "Identity-ServicePrincipalSummaryofResources", "attributes": {}}, {"query": "\"//Find Azure AD service principals that have only signed in from a single IP address in the last month. You should apply Conditional Access for workloads on them - https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/workload-identity\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\n//Microsoft Sentinel query\\n//First create a distinct count of IP addresses for each AppId and return any AppId with only 1 distinct IP\\nlet appid=\\n    AADServicePrincipalSignInLogs\\n    | where TimeGenerated > ago (30d)\\n    | where ResultType == 0\\n    | summarize dcount(IPAddress) by AppId\\n    | where dcount_IPAddress == 1\\n    | distinct AppId;\\n//Query the same data for only those AppIds and summarize each IP by the AppId and friendly service principal names\\nAADServicePrincipalSignInLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where AppId in (appid)\\n| summarize ['Application Ids']=make_set(AppId) by IPAddress, ServicePrincipalName\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\n//First create a distinct count of IP addresses for each AppId and return any AppId with only 1 distinct IP\\nlet appid=\\n    AADSpnSignInEventsBeta\\n    | where Timestamp > ago (30d)\\n    | where ErrorCode == 0\\n    | where IsManagedIdentity == 0\\n    | summarize dcount(IPAddress) by ApplicationId\\n    | where dcount_IPAddress == 1\\n    | distinct ApplicationId;\\n//Query the same data for only those AppIds and summarize each IP by the AppId and friendly service principal names\\nAADSpnSignInEventsBeta\\n| where Timestamp > ago (30d)\\n| where ErrorCode == 0\\n| where ApplicationId in (appid)\\n| summarize ['Application Ids']=make_set(ApplicationId) by IPAddress, ServicePrincipalName\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ServicePrincipalswithSingleIP.kql", "query_name": "Identity-ServicePrincipalswithSingleIP", "attributes": {}}, {"query": "\"//Find any single factor sign ins to Azure resources such as the Azure portal\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nSigninLogs\\n| where TimeGenerated > ago(7d)\\n| where AppDisplayName has \\\"Azure\\\"\\n| where ResultType == 0\\n| where AuthenticationRequirement == \\\"singleFactorAuthentication\\\"\\n| summarize ['Single Factor Authentications']=make_set(UserPrincipalName) by AppDisplayName\\n| extend ['User Count'] = array_length(['Single Factor Authentications'])\\n| order by ['User Count'] desc\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n| where Timestamp > ago(7d)\\n| where Application has \\\"Azure\\\"\\n| where ErrorCode == 0\\n| where LogonType == @\\\"[\\\"\\\"interactiveUser\\\"\\\"]\\\"\\n| where AuthenticationRequirement == \\\"singleFactorAuthentication\\\"\\n| summarize ['Single Factor Authentications']=make_set(AccountUpn) by Application\\n| extend ['User Count'] = array_length(['Single Factor Authentications'])\\n| order by ['User Count'] desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SingleFactorConnectionstoAzure.kql", "query_name": "Identity-SingleFactorConnectionstoAzure", "attributes": {}}, {"query": "\"//Finds users who hold a privileged Azure Active Directory role who are signing into applications using single factor\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet privusers=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | where isnotempty(AssignedRoles)\\n    | where AssignedRoles != \\\"[]\\\"\\n    | distinct AccountUPN;\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where UserPrincipalName in~ (privusers)\\n| where ResultType == 0\\n| where AuthenticationRequirement == \\\"singleFactorAuthentication\\\"\\n| summarize\\n    ['List of Applications']=make_set(AppDisplayName),\\n    ['Count of Applications']=dcount(AppDisplayName)\\n    by UserPrincipalName\\n| sort by ['Count of Applications'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SingleFactorSigninsFromPrivUsers.kql", "query_name": "Identity-SingleFactorSigninsFromPrivUsers", "attributes": {}}, {"query": "\"//Summarize accounts (both members and guests) that haven't signed on for over 60 days, and summarize them into the month they last signed in\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (365d)\\n| where ResultType == 0\\n| where isnotempty(UserType)\\n| summarize arg_max(TimeGenerated, *) by UserPrincipalName\\n| where TimeGenerated < ago(60d)\\n| summarize\\n    ['Inactive Account List']=make_set(UserPrincipalName),\\n    ['Count of Inactive Accounts']=dcount(UserPrincipalName)\\n    by UserType, Month=startofmonth(TimeGenerated)\\n| sort by Month desc, UserType asc   \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeAccountInactivity.kql", "query_name": "Identity-SummarizeAccountInactivity", "attributes": {}}, {"query": "\"//Summarize the usage of all your applications from last month to this month. Usage is calculated by distinct users per application.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(60d)\\n| where ResultType == \\\"0\\\"\\n| summarize\\n    ['Last Month Signins']=dcountif(UserPrincipalName, TimeGenerated > ago(60d) and TimeGenerated < ago(30d)),\\n    ['This Month Signins']=dcountif(UserPrincipalName, TimeGenerated > ago(30d))\\n    by AppId, AppDisplayName\\n| extend ['Percentage Change']=(todouble(['This Month Signins'] - todouble(['Last Month Signins'])) / todouble(['Last Month Signins']) * 100)\\n| sort by AppDisplayName asc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeAppUsageMonthonMonth.kql", "query_name": "Identity-SummarizeAppUsageMonthonMonth", "attributes": {}}, {"query": "\"//Create a summary showing which of your Azure AD conditional access policies are preventing the most signins and for what reasons\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (7d)\\n| project TimeGenerated, ConditionalAccessPolicies, ResultType, ResultDescription\\n| mv-expand ConditionalAccessPolicies\\n| extend CAResult = tostring(ConditionalAccessPolicies.result)\\n| extend ['Conditional Access Policy Name'] = tostring(ConditionalAccessPolicies.displayName)\\n| where CAResult == \\\"failure\\\"\\n| summarize ['Count of Failures']=count()by ['Conditional Access Policy Name'], ResultType, ResultDescription\\n| sort by ['Count of Failures'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeConditionalAccessPoliciesfailures.kql", "query_name": "Identity-SummarizeConditionalAccessPoliciesfailures", "attributes": {}}, {"query": "\"//Summarize which conditional access policies your inbound guests have logged any successes or failures against.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (90d)\\n| where UserType == \\\"Guest\\\"\\n| where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId\\n| project ConditionalAccessPolicies, UserPrincipalName, HomeTenantId\\n| project-rename GuestTenantId=HomeTenantId\\n| mv-expand ConditionalAccessPolicies\\n| extend CAResult = tostring(ConditionalAccessPolicies.result)\\n| extend CAName = tostring(ConditionalAccessPolicies.displayName)\\n| where CAResult has_any (\\\"success\\\", \\\"failure\\\")\\n| extend ['Conditional Access Result']=strcat(CAName, \\\" || \\\", CAResult)\\n| summarize\\n    ['Conditional Access Outcomes']=make_set(['Conditional Access Result'])\\n    by\\n    GuestTenantId\\n| order by GuestTenantId asc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeGuestConditionalAccess.kql", "query_name": "Identity-SummarizeGuestConditionalAccess", "attributes": {}}, {"query": "\"//Summarize guest activity by external Azure AD guests (those that belong to another Azure AD tenant) vs External Guests (such as Gmail) to your tenant\\n//For each domain list the total number of signins and distinct user \\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where UserType == \\\"Guest\\\"\\n| where ResultType == 0\\n| extend ['Guest Domain'] = tostring(split(UserPrincipalName, \\\"@\\\")[1])\\n| summarize\\n    ['External Azure AD Guest Logins']=countif(ResourceTenantId != HomeTenantId),\\n    ['External Azure AD Guest Distinct Users']=dcountif(UserPrincipalName, ResourceTenantId != HomeTenantId),\\n    ['External Guest Logins']=countif(ResourceTenantId == HomeTenantId),\\n    ['External Guest Distinct Users']=dcountif(UserPrincipalName, ResourceTenantId == HomeTenantId)\\n    by ['Guest Domain']\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeGuestDomainbyType.kql", "query_name": "Identity-SummarizeGuestDomainbyType", "attributes": {}}, {"query": "\"//Group your Azure AD guest accounts into the month they last signed in\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (360d)\\n| where UserType == \\\"Guest\\\" or UserPrincipalName contains \\\"#ext#\\\"\\n| where ResultType == 0\\n| summarize arg_max(TimeGenerated, *) by UserPrincipalName\\n| project TimeGenerated, UserPrincipalName\\n| summarize ['Inactive Guest Accounts']=make_set(UserPrincipalName) by Month=startofmonth(TimeGenerated)\\n| sort by Month desc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeGuestInactivity.kql", "query_name": "Identity-SummarizeGuestInactivity", "attributes": {}}, {"query": "\"//Summarize the domain names, the count of users and list of users for each guest tenant connecting to your Azure AD tenant\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| project\\n    TimeGenerated,\\n    UserPrincipalName,\\n    HomeTenantId,\\n    AADTenantId,\\n    Id,\\n    ResourceTenantId,\\n    ResourceIdentity,\\n    UserId,\\n    AppDisplayName\\n| where UserId != \\\"00000000-0000-0000-0000-000000000000\\\"\\n| where ResourceIdentity != ''\\n| where HomeTenantId != ''\\n| where HomeTenantId != AADTenantId\\n| extend GuestDomain = split(UserPrincipalName, '@')[-1]\\n| summarize\\n    ['Guest Domain Names']=make_set(GuestDomain),\\n    ['Distinct User Count']=dcount(UserPrincipalName),\\n    ['List of Guest Users']=make_set(UserPrincipalName)\\n    by HomeTenantId, AppDisplayName\\n| sort by ['Distinct User Count'] desc \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeGuestTenantActivity.kql", "query_name": "Identity-SummarizeGuestTenantActivity", "attributes": {}}, {"query": "\"//Summarize signins to your Azure AD tenant still using Internet Explorer. Data is grouped into each user and which applications they are accessing.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where ResultType == 0\\n| extend UserAgentDetail = todynamic(parse_user_agent(UserAgent, \\\"browser\\\"))\\n| extend UserAgentFamily = tostring(parse_json(tostring(UserAgentDetail.Browser)).Family)\\n| extend UserAgentMajorVersion = toint(parse_json(tostring(UserAgentDetail.Browser)).MajorVersion)\\n| extend UserAgentMinorVersion = toint(parse_json(tostring(UserAgentDetail.Browser)).MinorVersion)\\n| extend UserAgentPatch = toint(parse_json(tostring(UserAgentDetail.Browser)).Patch)\\n| project\\n    TimeGenerated,\\n    UserPrincipalName,\\n    AppDisplayName,\\n    ResultType,\\n    IPAddress,\\n    Location,\\n    UserAgentFamily,\\n    UserAgentMajorVersion,\\n    UserAgentMinorVersion,\\n    UserAgentPatch,\\n    UserAgent\\n| where UserAgentFamily == \\\"IE\\\"\\n| summarize ['Total IE Signins']=count(), ['Count of Applications']=dcount(AppDisplayName), ['List of Applications']=make_set(AppDisplayName) by UserPrincipalName\\n| sort by ['Count of Applications'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeInternetExplorerSignins.kql", "query_name": "Identity-SummarizeInternetExplorerSignins", "attributes": {}}, {"query": "\"//Summarize legacy auth authentications by type (such as ActiveSync, IMAP etc) and which accounts are using those protocols\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nunion SigninLogs, AADNonInteractiveUserSignInLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| where ClientAppUsed in (\\\"Exchange ActiveSync\\\", \\\"Exchange Web Services\\\", \\\"AutoDiscover\\\", \\\"Unknown\\\", \\\"POP3\\\", \\\"IMAP4\\\", \\\"Other clients\\\", \\\"Authenticated SMTP\\\", \\\"MAPI Over HTTP\\\", \\\"Offline Address Book\\\")\\n| summarize ['Count of legacy auth attempts'] = count()by ClientAppUsed, UserPrincipalName\\n| sort by ClientAppUsed asc, ['Count of legacy auth attempts'] desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n| where Timestamp > ago(30d)\\n| where ErrorCode == 0\\n| where ClientAppUsed in (\\\"Exchange ActiveSync\\\", \\\"Exchange Web Services\\\", \\\"AutoDiscover\\\", \\\"Unknown\\\", \\\"POP3\\\", \\\"IMAP4\\\", \\\"Other clients\\\", \\\"Authenticated SMTP\\\", \\\"MAPI Over HTTP\\\", \\\"Offline Address Book\\\")\\n| summarize ['Count of legacy auth attempts'] = count()by ClientAppUsed, AccountUpn\\n| sort by ClientAppUsed asc, ['Count of legacy auth attempts'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeLegacyAuth.kql", "query_name": "Identity-SummarizeLegacyAuth", "attributes": {}}, {"query": "\"//Summarize sign in activity from a particular country or countries to your tenant over the last week\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\nSigninLogs\\n| where TimeGenerated > ago(7d)\\n//Choose a country code, you could do multiples with | where Location in (\\\"AU\\\",\\\"US\\\")\\n| where Location == \\\"RU\\\"\\n| extend ['Full Location'] = strcat(LocationDetails.countryOrRegion, '|', LocationDetails.state, '|', LocationDetails.city)\\n| where ResultType in(successCodes) or ResultType in(failureCodes)\\n| summarize\\n    ['Count of distinct successful sign ins'] = dcountif(UserPrincipalName, (ResultType in(successCodes))),\\n    ['List of successful users']=make_set_if(UserPrincipalName, (ResultType in(successCodes))),\\n    ['Successful result codes'] = make_set_if(ResultType, (ResultType in(successCodes))),\\n    ['Count of distinct failed sign ins'] = dcountif(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['List of failed users'] = make_set_if(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['Failed result codes'] = make_set_if(ResultType, (ResultType in(failureCodes)))\\n    by ['Full Location'], IPAddress\\n\\n\\n//Summarize Russian sign in activity to your Azure AD tenant\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\n//Advanced Hunting query\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\nAADSignInEventsBeta\\n| where Timestamp > ago(7d)\\n//Choose a country code, you could do multiples with | where Country in (\\\"AU\\\",\\\"US\\\")\\n| where Country == \\\"RU\\\"\\n| extend ['Full Location'] = strcat(Country, '|', State, '|', City)\\n| where ErrorCode in(successCodes) or ErrorCode in(failureCodes)\\n| summarize\\n    ['Count of distinct successful sign ins'] = dcountif(AccountUpn, (ErrorCode in(successCodes))),\\n    ['List of successful users']=make_set_if(AccountUpn, (ErrorCode in(successCodes))),\\n    ['Successful result codes'] = make_set_if(ErrorCode, (ErrorCode in(successCodes))),\\n    ['Count of distinct failed sign ins'] = dcountif(AccountUpn, (ErrorCode in(failureCodes))),\\n    ['List of failed users'] = make_set_if(AccountUpn, (ErrorCode in(failureCodes))),\\n    ['Failed result codes'] = make_set_if(ErrorCode, (ErrorCode in(failureCodes)))\\n    by ['Full Location'], IPAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeLocationSignins.kql", "query_name": "Identity-SummarizeLocationSignins", "attributes": {}}, {"query": "\"//When Azure AD Identity Protection flags an IP Address as malicious, find any successful or failed logon events in your tenant from that IP\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\n//First create a list of success and erorr codes in Azure AD\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\n//Find the suspicious IP information from the SecurityAlert table, this example looks back 7 days as this is an offline detection\\nlet suspiciousip=\\n    SecurityAlert\\n    | where TimeGenerated > ago (7d)\\n    | where AlertName == \\\"Malicious IP address\\\"\\n    | extend IPAddress = tostring(parse_json(ExtendedProperties).[\\\"Client IP Address\\\"])\\n    | distinct IPAddress;\\n//Look back 21 days for any other sign in data from that IP address\\nSigninLogs\\n| where TimeGenerated > ago(14d)\\n| where IPAddress in (suspiciousip)\\n| where ResultType in(successCodes) or ResultType in(failureCodes)\\n//Create a summary showing successful and failed logons from that IP address and which users are affected\\n| summarize\\n    ['Count of distinct successful sign ins'] = dcountif(UserPrincipalName, (ResultType in(successCodes))),\\n    ['List of successful users']=make_set_if(UserPrincipalName, (ResultType in(successCodes))),\\n    ['Successful result codes'] = make_set_if(ResultType, (ResultType in(successCodes))),\\n    ['Count of distinct failed sign ins'] = dcountif(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['List of failed users'] = make_set_if(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['Failed result codes'] = make_set_if(ResultType, (ResultType in(failureCodes)))\\n    by IPAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeLoginInfofromMaliciousIP.kql", "query_name": "Identity-SummarizeLoginInfofromMaliciousIP", "attributes": {}}, {"query": "\"//Summarize the count of the various types of MFA failures (such as user not responding, invalid codes, user declining the authentication)\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (90d)\\n| where ResultType == \\\"500121\\\"\\n| mv-expand todynamic(AuthenticationDetails)\\n| project AuthenticationDetails, ResultType\\n| extend ['MFA Failure Type'] = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)\\n| where ['MFA Failure Type'] startswith \\\"MFA denied\\\"\\n| summarize Count=count()by ['MFA Failure Type']\\n| sort by Count\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeMFAFailures.kql", "query_name": "Identity-SummarizeMFAFailures", "attributes": {}}, {"query": "\"//Summarize the percentage of signins covered by MFA for your top 20 most popular Azure AD apps\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\n//First create a list of your top 20 apps by finding distinct user count by application over 30 days\\nlet top20apps=\\n    SigninLogs\\n    | where TimeGenerated > ago (30d)\\n    | summarize UserCount=dcount(UserPrincipalName)by AppDisplayName\\n    | sort by UserCount desc \\n    | take 20\\n    | project AppDisplayName;\\n//Use that list to calculate the percentage of signins to those apps that are covered by MFA\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where AppDisplayName in (top20apps)\\n| summarize TotalCount=count(),\\n    MFACount=countif(AuthenticationRequirement == \\\"multiFactorAuthentication\\\"),\\n    nonMFACount=countif(AuthenticationRequirement == \\\"singleFactorAuthentication\\\")\\n    by AppDisplayName\\n| project\\n    AppDisplayName,\\n    TotalCount,\\n    MFACount,\\n    nonMFACount,\\n    MFAPercentage=(todouble(MFACount) * 100 / todouble(TotalCount))\\n| sort by MFAPercentage asc  \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\n//First create a list of your top 20 apps by finding distinct user count by application over 30 days\\nlet top20apps=\\n    AADSignInEventsBeta\\n    | where Timestamp > ago (30d)\\n    | where LogonType == @\\\"[\\\"\\\"interactiveUser\\\"\\\"]\\\"\\n    | summarize UserCount=dcount(AccountUpn)by Application\\n    | sort by UserCount desc \\n    | take 20\\n    | project Application;\\n//Use that list to calculate the percentage of signins to those apps that are covered by MFA\\nAADSignInEventsBeta\\n| where Timestamp > ago (30d)\\n| where LogonType == @\\\"[\\\"\\\"interactiveUser\\\"\\\"]\\\"\\n| where Application in (top20apps)\\n| summarize TotalCount=count(),\\n    MFACount=countif(AuthenticationRequirement == \\\"multiFactorAuthentication\\\"),\\n    nonMFACount=countif(AuthenticationRequirement == \\\"singleFactorAuthentication\\\")\\n    by Application\\n| project\\n    Application,\\n    TotalCount,\\n    MFACount,\\n    nonMFACount,\\n    MFAPercentage=(todouble(MFACount) * 100 / todouble(TotalCount))\\n| sort by MFAPercentage asc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeMFATop20Apps.kql", "query_name": "Identity-SummarizeMFATop20Apps", "attributes": {}}, {"query": "\"//Summarize outbound (your users connecting to other tenants) activity by listing the users and which applications they are accessing in each remote tenant\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where UserType == \\\"Guest\\\"\\n| where AADTenantId == HomeTenantId\\n| where ResourceTenantId != AADTenantId\\n| summarize\\n    ['Count of Applications']=dcount(AppDisplayName),\\n    ['List of Applications']=make_set(AppDisplayName),\\n    ['Count of Users']=dcount(UserPrincipalName),\\n    ['List of Users']=make_set(UserPrincipalName)\\n    by ResourceTenantId\\n| sort by ['Count of Users'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeOutboundGuestActivity.kql", "query_name": "Identity-SummarizeOutboundGuestActivity", "attributes": {}}, {"query": "\"//When a user registers or updates MFA details, take that IP address and summarize sign in events for that user and IP address for the last 30 days.\\n//If they have never signed in or signed in a few times from that IP it may a sign the account has been compromised and a threat actor has added MFA details\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName in~ (\\\"Admin registered security info\\\", \\\"Admin updated security info\\\", \\\"Admin deleted security info\\\", \\\"User registered security info\\\", \\\"User changed default security info\\\", \\\"User deleted security info\\\")\\n| extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)\\n| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| project ['MFA Event Time']=TimeGenerated, OperationName, UserPrincipalName, IPAddress\\n| join kind=inner(\\n    SigninLogs\\n    | where TimeGenerated > ago (30d)\\n    )\\n    on UserPrincipalName, IPAddress\\n| project\\n    TimeGenerated,\\n    ['MFA Event Time'],\\n    OperationName,\\n    ResultType,\\n    UserPrincipalName,\\n    IPAddress\\n| summarize\\n    ['Count of successful sign ins from MFA IP Address'] = countif(ResultType in(successCodes)),\\n    ['Count of failed sign ins from MFA IP Address'] = countif(ResultType in(failureCodes))\\n    by UserPrincipalName, OperationName, IPAddress, ['MFA Event Time']\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeSigninInfoafterMFAconfig.kql", "query_name": "Identity-SummarizeSigninInfoafterMFAconfig", "attributes": {}}, {"query": "\"//Investigate potentially suspicious IP addresses for your Azure AD signins. This query lists any IP address with more failures than successful connections and provides a summary for each with at least one successful signin.\\n//This may uncover password spray attacks that have had a successful connections.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\nSigninLogs\\n| where TimeGenerated > ago(7d)\\n| where ResultType in(successCodes) or ResultType in(failureCodes)\\n| summarize\\n    ['Count of successful signins'] = countif((ResultType in(successCodes))),\\n    ['Count of distinct successful sign ins'] = dcountif(UserPrincipalName, (ResultType in(successCodes))),\\n    ['List of successful users']=make_set_if(UserPrincipalName, (ResultType in(successCodes))),\\n    ['Successful result codes'] = make_set_if(ResultType, (ResultType in(successCodes))),\\n    ['Count of failed signins']=countif((ResultType in(failureCodes))),\\n    ['Count of distinct failed sign ins'] = dcountif(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['List of failed users'] = make_set_if(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['Failed result codes'] = make_set_if(ResultType, (ResultType in(failureCodes))) \\n    by IPAddress\\n//Exclude IP addresses with more successful signins than failed. This is a good way to exclude known locations as they will have lots of failures too, but they will be balanced by more successes.\\n//Then find IP addresses with 5 or more distinct failed signins and at least one successful signin\\n| where ['Count of failed signins'] > ['Count of successful signins'] and ['Count of distinct failed sign ins'] > ['Count of distinct successful sign ins'] and ['Count of distinct failed sign ins'] >= 5 and ['Count of distinct successful sign ins'] >= 1\\n| order by ['Count of distinct successful sign ins'] desc \\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\n//Advanced Hunting query\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\nAADSignInEventsBeta\\n| where Timestamp > ago(7d)\\n| where ErrorCode in(successCodes) or ErrorCode in(failureCodes)\\n| summarize\\n    ['Count of successful signins'] = countif((ErrorCode in(successCodes))),\\n    ['Count of distinct successful sign ins'] = dcountif(AccountUpn, (ErrorCode in(successCodes))),\\n    ['List of successful users']=make_set_if(AccountUpn, (ErrorCode in(successCodes))),\\n    ['Successful result codes'] = make_set_if(ErrorCode, (ErrorCode in(successCodes))),\\n    ['Count of failed signins']=countif((ErrorCode in(failureCodes))),\\n    ['Count of distinct failed sign ins'] = dcountif(AccountUpn, (ErrorCode in(failureCodes))),\\n    ['List of failed users'] = make_set_if(AccountUpn, (ErrorCode in(failureCodes))),\\n    ['Failed result codes'] = make_set_if(ErrorCode, (ErrorCode in(failureCodes))) \\n    by IPAddress\\n//Exclude IP addresses with more successful signins than failed. This is a good way to exclude known locations as they will have lots of failures too, but they will be balanced by more successes.\\n//Then find IP addresses with 5 or more distinct failed signins and at least one successful signin\\n| where ['Count of failed signins'] > ['Count of successful signins'] and ['Count of distinct failed sign ins'] > ['Count of distinct successful sign ins'] and ['Count of distinct failed sign ins'] >= 5 and ['Count of distinct successful sign ins'] >= 1\\n| order by ['Count of distinct successful sign ins'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeSuspiciousIPAddresses.kql", "query_name": "Identity-SummarizeSuspiciousIPAddresses", "attributes": {}}, {"query": "\"//Find the applications with the most signins coming from unknown locations (not defined in Conditional Access) and only requiring single factor authentication\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| where NetworkLocationDetails == '[]'\\n| where AuthenticationRequirement == \\\"singleFactorAuthentication\\\"\\n| summarize ['Count of signins']=count(), ['Distinct user count']=dcount(UserPrincipalName) by AppDisplayName\\n| sort by ['Distinct user count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-SummarizeUnknownLocationnoMFA.kql", "query_name": "Identity-SummarizeUnknownLocationnoMFA", "attributes": {}}, {"query": "\"//Retrieve sign in failures due to third party MFA (Okta/Duo etc). Azure AD handles third party MFA different to native MS MFA. A user is sent to the third party MFA service and generates code 50158.\\n//If successful the user then generates a success code 0. When third party MFA fails Azure AD logs the 50158 result code but no corresponding 0 result code.\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nSigninLogs\\n//Create a list of all result codes within a single sign in to Azure AD\\n| summarize MFA=make_list(ResultType) by CorrelationId\\n//Find correlation ids where the user was sent to third party MFA (ResultType 50158) but there is no subsequent success (ResultType 0)\\n| where MFA has \\\"50158\\\" and MFA !has \\\"0\\\"\\n//Join back to SigninLogs table to find the sign in details\\n| join kind=inner (SigninLogs) on CorrelationId\\n| project\\n    TimeGenerated,\\n    UserPrincipalName,\\n    UserType,\\n    AppDisplayName,\\n    IPAddress,\\n    Location,\\n    UserAgent,\\n    ResultType\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n//Create a list of all result codes within a single sign in to Azure AD\\n| summarize MFA=make_list(ErrorCode) by CorrelationId\\n//Find correlation ids where the user was sent to third party MFA (ResultType 50158) but there is no subsequent success (ResultType 0)\\n| where MFA has \\\"50158\\\" and MFA !has \\\"0\\\"\\n//Join back to SigninLogs table to find the sign in details\\n| join kind=inner (AADSignInEventsBeta) on CorrelationId\\n| project\\n    Timestamp,\\n    AccountUpn,\\n    IsGuestUser,\\n    Application,\\n    IPAddress,\\n    Country,\\n    UserAgent,\\n    ErrorCode\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-ThirdPartyMFAFailures.kql", "query_name": "Identity-ThirdPartyMFAFailures", "attributes": {}}, {"query": "\"//Find the top 20 most popular applications in your tenant that have had no Conditional Access policies (success or failure) applied\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet apps=\\n    SigninLogs\\n    | where TimeGenerated > ago (30d)\\n    | project TimeGenerated, ConditionalAccessPolicies, AppDisplayName\\n//Exclude native Microsoft apps that you can't enforce policy on or that are covered natively in Office 365\\n    | where AppDisplayName !in (\\\"Microsoft Office Web Apps Service\\\", \\\"Microsoft App Access Panel\\\", \\\"Office Online Core SSO\\\", \\\"Microsoft Authentication Broker\\\", \\\"Microsoft Account Controls V2\\\", \\\"Microsoft 365 Support Service\\\",\\\"Office Online Maker SSO\\\",\\\"My Apps\\\",\\\"My Profile\\\")\\n    | mv-expand ConditionalAccessPolicies\\n    | extend CAResult = tostring(ConditionalAccessPolicies.result)\\n    | summarize ResultSet=make_set(CAResult) by AppDisplayName\\n    | where ResultSet !has \\\"success\\\" or ResultSet !has \\\"failure\\\"\\n    | project AppDisplayName;\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| where AppDisplayName in (apps)\\n| summarize Count=count()by AppDisplayName\\n| top 20 by Count\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-Top20AppswithnoCA.kql", "query_name": "Identity-Top20AppswithnoCA", "attributes": {}}, {"query": "\"//Find the top 20 of a collection of varied data sets, no real detections in here just interesting data that is captured\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\n\\n//Top 20 users signing into your tenant\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Member\\\"\\n| summarize Count=count() by UserPrincipalName\\n| top 20 by Count\\n\\n//Top 20 locations signing into your tenant\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Member\\\"\\n| summarize Count=count() by Location\\n| where isnotempty(Location)\\n| top 20 by Count\\n\\n//Top 20 users by MFA prompts\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Member\\\"\\n| where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n| mv-expand todynamic(AuthenticationDetails)\\n| project TimeGenerated, AuthenticationDetails, UserPrincipalName\\n| extend AuthenticationMethod = tostring(AuthenticationDetails.authenticationMethod)\\n| where AuthenticationMethod in (\\\"Mobile app notification\\\",\\\"Text message\\\",\\\"OATH verification code\\\")\\n| summarize Count=count()by UserPrincipalName\\n| top 20 by Count\\n\\n//Top 20 users by distinct applications accessed\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Member\\\"\\n| summarize Count=dcount(AppDisplayName) by UserPrincipalName\\n| top 20 by Count\\n\\n//Top 20 users accessing distinct locations accessed\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Member\\\"\\n| summarize Count=dcount(Location) by UserPrincipalName\\n| top 20 by Count\\n\\n//Top 20 applications by distinct users accessing them\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Member\\\"\\n| summarize Count=dcount(UserPrincipalName) by AppDisplayName\\n| where AppDisplayName != \\\"Windows Sign In\\\"\\n| top 20 by Count\\n\\n//Top 20 applications by distinct guests accessing them\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Guest\\\"\\n| summarize Count=dcount(UserPrincipalName) by AppDisplayName\\n| top 20 by Count\\n\\n//Top 20 guests by distinct applications accessed by them\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Guest\\\"\\n| summarize Count=dcount(AppDisplayName) by UserPrincipalName\\n| top 20 by Count\\n\\n//Top 20 guest domains accessing your tenant\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Guest\\\"\\n| where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId\\n| extend ['User Domain'] = tostring(split(UserPrincipalName, \\\"@\\\")[1])\\n| summarize Count=count() by ['User Domain']\\n| top 20 by Count\\n\\n//Top 20 guest domains accessing your tenant by distinct applications accessed\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where ResultType == 0\\n| where UserType == \\\"Guest\\\"\\n| where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId\\n| extend ['User Domain'] = tostring(split(UserPrincipalName, \\\"@\\\")[1])\\n| summarize Count=dcount(AppDisplayName) by ['User Domain']\\n| top 20 by Count\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-Top20RandomStats.kql", "query_name": "Identity-Top20RandomStats", "attributes": {}}, {"query": "\"//Find the top 20 IP addresses that are unknown to Azure AD, with users using unknown devices and single factor auth\\n//Then find the users and applications being accessed from each to help build out conditional access policy\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet top20locations=\\n    SigninLogs\\n    | where TimeGenerated > ago(30d)\\n    | where ResultType == 0\\n    | extend DeviceTrustType = tostring(DeviceDetail.trustType)\\n    | where NetworkLocationDetails == '[]'\\n        and isempty(DeviceTrustType)\\n        and AuthenticationRequirement == \\\"singleFactorAuthentication\\\"\\n    | summarize Count=count()by IPAddress\\n    | top 20 by Count;\\nSigninLogs\\n| where ResultType == 0\\n| where IPAddress in (top20locations)\\n| summarize\\n    ['Total Signin Count']=count(),\\n    ['Distinct User Count']=dcount(UserPrincipalName),\\n    ['List of Users']=make_set(UserPrincipalName),\\n    ['Distinct Application Count']=dcount(AppDisplayName),\\n    ['List of Applications']=make_set(AppDisplayName)\\n    by IPAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-Top20RiskyLocations.kql", "query_name": "Identity-Top20RiskyLocations", "attributes": {}}, {"query": "\"//Detect users trying to access multiple applications they haven't been granted access to over a short period of time\\n//In this example alert when a user attempts to access 2 or more unique applications in 30 minutes\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where ResultType == \\\"50105\\\"\\n| summarize\\n    ['Denied Application List']=make_set(AppDisplayName),\\n    ['Count of Applications']=dcount(AppDisplayName)\\n    by UserPrincipalName, bin(TimeGenerated, 30m)\\n| where ['Count of Applications'] >= 2\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-UserTryingtoAccessMultipleApps.kql", "query_name": "Identity-UserTryingtoAccessMultipleApps", "attributes": {}}, {"query": "\"//Visualizes conditional access policy failures over time by policy name\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet start = now(-90d);\\nlet end = now();\\nlet timeframe= 12h;\\nSigninLogs\\n| project TimeGenerated, ResultType, ConditionalAccessPolicies\\n| where ResultType == 53003\\n| mv-expand ConditionalAccessPolicies\\n| where ConditionalAccessPolicies.result == \\\"failure\\\"\\n| extend ['CA Policy Name'] = tostring(ConditionalAccessPolicies.displayName)\\n| make-series ['Failure Count'] = count() default=0 on TimeGenerated in range(start, end, timeframe) by ['CA Policy Name']\\n| render timechart with (title=\\\"Conditional access policy failure over time\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeConditionalAccessFailures.kql", "query_name": "Identity-VisualizeConditionalAccessFailures", "attributes": {}}, {"query": "\"//Visualize signins to your Azure AD tenant with no controls (known device, known location or MFA) vs those with at least one of those controls\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| extend DeviceTrustType = tostring(DeviceDetail.trustType)\\n| summarize\\n    ['Signins with no controls']=countif(NetworkLocationDetails == '[]' and AuthenticationRequirement == \\\"singleFactorAuthentication\\\" and isempty(DeviceTrustType)),\\n    ['Signins with one or more controls']=countif(NetworkLocationDetails != '[]' or AuthenticationRequirement == \\\"multiFactorAuthentication\\\" or isnotempty(DeviceTrustType)) by\\n    bin(TimeGenerated, 1d)\\n| render timechart with (title=\\\"Azure AD signins no controls vs one or more controls\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeControlsvsNoControls.kql", "query_name": "Identity-VisualizeControlsvsNoControls", "attributes": {}}, {"query": "\"//Visualize distinct inbound guests (guest accounts accessing your tenant) per month\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(365d)\\n| where UserType == \\\"Guest\\\"\\n| where ResultType == 0\\n//Find only inbound guests, i.e those guests accessing your tenant.\\n| summarize Count=dcountif(UserPrincipalName, AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId) by startofmonth(TimeGenerated)\\n| render columnchart with (title=\\\"Distinct guest accounts accessing your tenant per month\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeDistinctInboundGuests.kql", "query_name": "Identity-VisualizeDistinctInboundGuests", "attributes": {}}, {"query": "\"//Visualize signins from External Azure AD guests (those that belong to another Azure AD tenant) vs External Guests (such as Gmail) to your tenant\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (45d)\\n| where UserType == \\\"Guest\\\"\\n| summarize\\n    ['External Guests']=countif(ResourceTenantId == HomeTenantId),\\n    ['External Azure AD Guests']=countif(ResourceTenantId != HomeTenantId)\\n    by bin(TimeGenerated, 1d)\\n| render timechart with (title=\\\"External Azure AD Guests vs External Guests\\\", ytitle=\\\"Count\\\")\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeExternalAADGuestsvsExternalGuests.kql", "query_name": "Identity-VisualizeExternalAADGuestsvsExternalGuests", "attributes": {}}, {"query": "\"//Visualize the most popular enterprise applications accessed by guest accounts\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet timeframe=45d;\\nSigninLogs\\n| where TimeGenerated > ago(timeframe)\\n| where UserType == \\\"Guest\\\" or UserPrincipalName contains \\\"#ext#\\\"\\n| where ResultType == 0\\n// Exclude Microsoft management applications\\n| where AppDisplayName !in (\\\"Microsoft Invitation Acceptance Portal\\\", \\\"My Apps\\\", \\\"Microsoft App Access Panel\\\", \\\"Microsoft Authentication Broker\\\")\\n| summarize AppCount=count()by AppDisplayName\\n| sort by AppCount desc \\n| render piechart with (title=\\\"Most Popular Apps Accessed by Guests\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeGuestAppAccess.kql", "query_name": "Identity-VisualizeGuestAppAccess", "attributes": {}}, {"query": "\"//Visualize the most popular domains that have redeemed invites to your Azure AD tenant over the last 30 days.\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago(30d)\\n| where OperationName == \\\"Redeem external user invite\\\"\\n| extend GuestEmail = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend ['User Domain'] = tostring(split(GuestEmail, \\\"@\\\")[1])\\n| where isnotempty(['User Domain'])\\n| summarize Count=count()by ['User Domain']\\n| sort by Count desc \\n| render barchart\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeGuestDomains.kql", "query_name": "Identity-VisualizeGuestDomains", "attributes": {}}, {"query": "\"//Visualize how many guests are redeeming invites over the time period with trend\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet StartDate = now(-180d);\\nlet EndDate = now();\\nAuditLogs\\n| where OperationName == \\\"Redeem external user invite\\\"\\n| make-series TotalInvites=count() on TimeGenerated in range(StartDate, EndDate, 1d)\\n| extend (RSquare, SplitIdx, Variance, RVariance, TrendLine)=series_fit_2lines(TotalInvites)\\n| project TimeGenerated, TotalInvites, TrendLine\\n| render timechart with (title=\\\"Guest Invites redeemed over time with trend\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeGuestRedemptionswithTrend.kql", "query_name": "Identity-VisualizeGuestRedemptionswithTrend", "attributes": {}}, {"query": "\"//Visualize inbound Azure AD guests (other tenants connecting to your tenant) vs outbound (your users connecting to other tenants)\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where UserType == \\\"Guest\\\"\\n| where ResultType == 0\\n| summarize\\n    ['Inbound Guests']=countif(AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId),\\n    ['Outbound Guests']=countif(AADTenantId == HomeTenantId and ResourceTenantId != AADTenantId)\\n    by bin(TimeGenerated, 1d)\\n| render timechart with (title=\\\"Inbound Guest vs Outbound Guest Access\\\", ytitle=\\\"Number of connections\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeInboundvsOutboundGuests.kql", "query_name": "Identity-VisualizeInboundvsOutboundGuests", "attributes": {}}, {"query": "\"//Visualize sign in attempts to your Azure AD tenant by known or unknown network locations\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n//If a location it will be populated by its name, i.e 'Corporate Internet', if known the NetworkLocationDetails array is empty so we can find it by searching on '[]'\\n| summarize\\n    ['Known Location']=countif(NetworkLocationDetails != '[]'),\\n    ['Unknown Location']=countif(NetworkLocationDetails == '[]')\\n    by bin (TimeGenerated, 1d)\\n| render timechart with (title=\\\"Known vs Unknown signins to Azure AD\\\", ytitle=\\\"Count\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeKnownvsUnknownLocation.kql", "query_name": "Identity-VisualizeKnownvsUnknownLocation", "attributes": {}}, {"query": "\"//Visualize distinct users allowed to connect via legacy auth vs blocked by conditional access\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nSigninLogs\\n| where TimeGenerated > ago(180d)\\n| where ResultType in (\\\"0\\\", \\\"53003\\\")\\n| where ClientAppUsed in (\\\"Exchange ActiveSync\\\", \\\"Exchange Web Services\\\", \\\"AutoDiscover\\\", \\\"Unknown\\\", \\\"POP3\\\", \\\"IMAP4\\\", \\\"Other clients\\\", \\\"Authenticated SMTP\\\", \\\"MAPI Over HTTP\\\", \\\"Offline Address Book\\\")\\n| summarize\\n    ['Legacy Auth Users Allowed']=dcountif(UserPrincipalName, ResultType == 0),\\n    ['Legacy Auth Users Blocked']=dcountif(UserPrincipalName, ResultType == 53003)\\n    by bin(TimeGenerated, 1d)\\n| render timechart with (title=\\\"Legacy auth distinct users allowed vs blocked by Conditional Access\\\")\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\n//Visualize distinct users allowed to connect via legacy auth vs blocked by conditional access\\nAADSignInEventsBeta\\n| where Timestamp > ago(180d)\\n| where ErrorCode  in (\\\"0\\\", \\\"53003\\\")\\n| where ClientAppUsed in (\\\"Exchange ActiveSync\\\", \\\"Exchange Web Services\\\", \\\"AutoDiscover\\\", \\\"Unknown\\\", \\\"POP3\\\", \\\"IMAP4\\\", \\\"Other clients\\\", \\\"Authenticated SMTP\\\", \\\"MAPI Over HTTP\\\", \\\"Offline Address Book\\\")\\n| summarize\\n    ['Legacy Auth Users Allowed']=dcountif(AccountUpn, ErrorCode == 0),\\n    ['Legacy Auth Users Blocked']=dcountif(AccountUpn, ErrorCode == 53003)\\n    by bin(Timestamp, 1d)\\n| render timechart \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeLegacyAuth.kql", "query_name": "Identity-VisualizeLegacyAuth", "attributes": {}}, {"query": "\"//Visualize legacy auth method (i.e Activesync, IMAP etc) by distinct user count over time\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nSigninLogs\\n| where TimeGenerated > ago(90d)\\n| where ResultType == 0\\n| where ClientAppUsed in (\\\"Exchange ActiveSync\\\", \\\"Exchange Web Services\\\", \\\"AutoDiscover\\\", \\\"Unknown\\\", \\\"POP3\\\", \\\"IMAP4\\\", \\\"Other clients\\\", \\\"Authenticated SMTP\\\", \\\"MAPI Over HTTP\\\", \\\"Offline Address Book\\\")\\n| summarize Count=dcount(UserPrincipalName) by ClientAppUsed, bin (TimeGenerated, 1d)\\n| render timechart with (title=\\\"Legacy auth methods by distinct user over time\\\")\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n| where Timestamp > ago(30d)\\n| where ErrorCode == 0\\n| where ClientAppUsed in (\\\"Exchange ActiveSync\\\", \\\"Exchange Web Services\\\", \\\"AutoDiscover\\\", \\\"Unknown\\\", \\\"POP3\\\", \\\"IMAP4\\\", \\\"Other clients\\\", \\\"Authenticated SMTP\\\", \\\"MAPI Over HTTP\\\", \\\"Offline Address Book\\\")\\n| summarize Count=dcount(AccountUpn) by ClientAppUsed, bin (Timestamp, 1d)\\n| render timechart\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeLegacyAuthMethods.kql", "query_name": "Identity-VisualizeLegacyAuthMethods", "attributes": {}}, {"query": "\"//Visualize when your users are actively challenged for MFA vs when it was previously satisfied\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(90d)\\n| where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n| mv-expand todynamic(AuthenticationDetails)\\n| project TimeGenerated, AuthenticationDetails\\n| extend MFAResultStep = tostring(AuthenticationDetails.authenticationStepResultDetail)\\n| summarize\\n    MFARequired=countif(MFAResultStep == \\\"MFA completed in Azure AD\\\"),\\n    PreviouslySatisfied=countif(MFAResultStep == \\\"MFA requirement satisfied by claim in the token\\\")\\n    by bin(TimeGenerated, 1d)\\n| render timechart\\n    with (\\n    xtitle=\\\"Day\\\",\\n    ytitle=\\\"Count\\\",\\n    title=\\\"MFA challenges vs MFA previously satisfied over time\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeMFAChallengevsPreviouslySatisfied.kql", "query_name": "Identity-VisualizeMFAChallengevsPreviouslySatisfied", "attributes": {}}, {"query": "\"//Visualize the MFA types used by your users, i.e text message, mobile app notification, verification code\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n| project AuthenticationDetails\\n| extend ['MFA Method'] = tostring(parse_json(AuthenticationDetails)[1].authenticationMethod)\\n| summarize Count=count()by ['MFA Method']\\n| where ['MFA Method'] != \\\"Previously satisfied\\\" and isnotempty(['MFA Method'])\\n| sort by Count desc\\n| render barchart with (title=\\\"Types of MFA Methods used\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeMFAMethods.kql", "query_name": "Identity-VisualizeMFAMethods", "attributes": {}}, {"query": "\"//Visualize the MFA types used by your users - phone sign in, mobile passcode, push or text message, over time\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (180d)\\n| where AuthenticationRequirement == \\\"multiFactorAuthentication\\\"\\n| project TimeGenerated, AuthenticationDetails\\n| extend ['MFA Method'] = tostring(parse_json(AuthenticationDetails)[1].authenticationMethod)\\n| summarize Count=count()by ['MFA Method'], bin(TimeGenerated, 7d)\\n| where ['MFA Method'] != \\\"Previously satisfied\\\" and isnotempty(['MFA Method']) \\n| render timechart with (ytitle=\\\"Count\\\", xtitle=\\\"Day\\\", title=\\\"MFA methods per week over time\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeMFAMethodsovertime.kql", "query_name": "Identity-VisualizeMFAMethodsovertime", "attributes": {}}, {"query": "\"//Visualize password vs passwordless signins per day\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago (180d)\\n| mv-expand todynamic(AuthenticationDetails)\\n| project TimeGenerated, AuthenticationDetails\\n| extend AuthMethod = tostring(AuthenticationDetails.authenticationMethod)\\n| summarize\\n    Passwordless=countif(AuthMethod in (\\\"Windows Hello for Business\\\", \\\"Passwordless phone sign-in\\\", \\\"FIDO2 security key\\\", \\\"X.509 Certificate\\\")),\\n    Password=countif(AuthMethod == \\\"Password\\\")\\n    by bin(TimeGenerated, 1d)\\n| render timechart with (title=\\\"Passwordless vs Password Authentication\\\", ytitle=\\\"Count\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizePasswordvsPasswordless.kql", "query_name": "Identity-VisualizePasswordvsPasswordless", "attributes": {}}, {"query": "\"//Visualize the different risk types (e.g password spray, unlikely travel) per month\\n\\n//Data connector required for this query - Azure Active Directory - AAD User Risk Events\\n\\nAADUserRiskEvents\\n| where TimeGenerated > ago (180d)\\n| where isnotempty(RiskEventType)\\n| summarize Count=count()by RiskEventType, startofmonth(TimeGenerated)\\n| render columnchart with (kind=unstacked, title=\\\"Risk event types per month\\\", xtitle=\\\"Month\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeRiskEventsoverTime.kql", "query_name": "Identity-VisualizeRiskEventsoverTime", "attributes": {}}, {"query": "\"//Visualize sign in attempts to your Azure AD tenant by device trust type\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| extend DeviceTrustType = tostring(DeviceDetail.trustType)\\n| extend ['Trust Type']=case(isnotempty(DeviceTrustType), strcat=DeviceTrustType,\\n    isempty(DeviceTrustType), strcat=\\\"Untrusted\\\",\\n    \\\"unknown\\\")\\n| summarize Count=count()by ['Trust Type'], bin(TimeGenerated, 1d)\\n| render timechart with (title=\\\"Signins to Azure AD by trust type\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeSigninsbyDeviceTrust.kql", "query_name": "Identity-VisualizeSigninsbyDeviceTrust", "attributes": {}}, {"query": "\"//Visualize successful self service password resets and account unlocks over time\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where TimeGenerated > ago (180d)\\n| where OperationName in (\\\"Reset password (self-service)\\\", \\\"Unlock user account (self-service)\\\")\\n| summarize\\n    ['Password Reset']=countif(OperationName == \\\"Reset password (self-service)\\\" and ResultDescription == \\\"Successfully completed reset.\\\"),\\n    ['Account Unlock']=countif(OperationName == \\\"Unlock user account (self-service)\\\" and ResultDescription == \\\"Success\\\")\\n    by startofweek(TimeGenerated)\\n| render timechart\\n    with (\\n    ytitle=\\\"Count\\\",\\n    xtitle=\\\"Day\\\",\\n    title=\\\"Self Service Password Resets and Account Unlocks over time\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeSSPR.kql", "query_name": "Identity-VisualizeSSPR", "attributes": {}}, {"query": "\"//Visualize the difference been total and distinct user sign ins to an app per day\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Microsoft Sentinel query\\nSigninLogs\\n| where TimeGenerated > ago(90d)\\n| where AppDisplayName == \\\"Office 365 Exchange Online\\\"\\n| where ResultType == 0\\n| summarize ['Total Signins']=count(), ['Distinct user signins']=dcount(UserPrincipalName) by bin(TimeGenerated, 1d)\\n| render timechart\\n    with (\\n    title=\\\"Total vs Distinct signins to Exchange Online\\\",\\n    xtitle=\\\"Day\\\",\\n    ytitle=\\\"Count\\\")\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting with Azure AD P2 License\\n\\nAADSignInEventsBeta\\n| where Timestamp > ago(90d)\\n| where Application == \\\"Office 365 Exchange Online\\\"\\n| where ErrorCode == 0\\n| summarize ['Total Signins']=count(), ['Distinct user signins']=dcount(AccountUpn) by bin(Timestamp, 1d)\\n| render timechart\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-VisualizeTotalvsDistinctsignins.kql", "query_name": "Identity-VisualizeTotalvsDistinctsignins", "attributes": {}}, {"query": "\"//Find sign ins where your users signed into other Azure AD tenants as outbound guests\\n\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where AADTenantId == HomeTenantId\\n| where ResourceTenantId != AADTenantId\\n| where UserType == \\\"Guest\\\"\\n| project\\n    TimeGenerated,\\n    AppDisplayName,\\n    UserPrincipalName,\\n    ResultType,\\n    Location,\\n    IPAddress,\\n    ['Guest Tenant Id']=ResourceTenantId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/Identity-YourUsersSigningIntoOtherTenantsAsGuests.kql", "query_name": "Identity-YourUsersSigningIntoOtherTenantsAsGuests", "attributes": {}}, {"query": "\"//Query to find applications that have had application permissions granted to them\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName has \\\"Add app role assignment to service principal\\\"\\n| extend UpdatedPermission = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n| extend AppName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[4].newValue)))\\n| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| extend AppId = tostring(TargetResources[1].id)\\n| project TimeGenerated, OperationName, UpdatedPermission, AppName, AppId, User\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-ApplicationPermissionsGrant.kql", "query_name": "OAuth-ApplicationPermissionsGrant", "attributes": {}}, {"query": "\"//Detect when either application or delegated access is granted to a service principal in Azure AD\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet delegatedaccess=\\n    AuditLogs\\n    | where OperationName has \\\"Add delegated permission grant\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)\\n    | extend Activity = strcat(\\\"Delegated access added to application\\\")\\n    | project\\n        TimeGenerated,\\n        Activity,\\n        ['Permissions granted'],\\n        ['Service Principal ObjectId'],\\n        Actor;\\nlet appaccess=\\n    AuditLogs\\n    | where OperationName has \\\"Add app role assignment to service principal\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend Activity = strcat(\\\"Application access added to application\\\")\\n    | extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)\\n    | project\\n        TimeGenerated,\\n        Activity,\\n        ['Permissions granted'],\\n        ['Service Principal ObjectId'],\\n        Actor;\\nunion delegatedaccess, appaccess\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-ApporDelegatedAccessGranted.kql", "query_name": "OAuth-ApporDelegatedAccessGranted", "attributes": {}}, {"query": "\"//Query to find applications that have had delegated permissions granted to them\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where Category == \\\"ApplicationManagement\\\"\\n| where OperationName has \\\"Add delegated permission grant\\\"\\n| extend UpdatedPermissions = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue))) \\n| extend AppId = tostring(TargetResources[1].id)\\n| project TimeGenerated, UpdatedPermissions, OperationName, AppId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-DelegatedPermissionsGrant.kql", "query_name": "OAuth-DelegatedPermissionsGrant", "attributes": {}}, {"query": "\"//Detects users who have added a credential to an Azure AD App for the first time in 90 days, adjust timeframe as needed.\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet timeframe = startofday(ago(90d));\\nAuditLogs\\n| where TimeGenerated > timeframe and TimeGenerated < startofday(now())\\n| where OperationName has \\\"Update application \\u2013 Certificates and secrets management\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| project Actor\\n| join kind=rightanti\\n    (\\n    AuditLogs\\n    | where TimeGenerated > startofday(now())\\n    | where OperationName has \\\"Update application \\u2013 Certificates and secrets management\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend AppId = tostring(AdditionalDetails[1].value)\\n    | project TimeGenerated, Actor, AppId\\n    )\\n    on Actor\\n| project TimeGenerated, Actor, AppId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-DetectingFirstTimeCredentialAddition.kql", "query_name": "OAuth-DetectingFirstTimeCredentialAddition", "attributes": {}}, {"query": "\"//Detect when a user adds delegated or application permissions to an Azure AD app for the first time.\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\n//Look back in the last year to find all users who have added access to an app\\nlet newusers=\\nAuditLogs\\n| where TimeGenerated > ago(365d) and TimeGenerated < ago(1d)\\n| where OperationName in (\\\"Add app role assignment to service principal\\\",\\\"Add delegated permission grant\\\")\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| distinct Actor\\n//Find users who add access to an app for the first time in the last day\\n| join kind=rightanti (\\nAuditLogs\\n| where TimeGenerated > ago(1d)\\n| where OperationName in (\\\"Add app role assignment to service principal\\\",\\\"Add delegated permission grant\\\")\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| distinct Actor )\\non Actor;\\n//Retrieve the list of permissions granted by the first time users\\nlet delegatedaccess=\\n    AuditLogs\\n    | where TimeGenerated > ago(1d)\\n    | where OperationName has \\\"Add delegated permission grant\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | where Actor in (newusers)\\n    | extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)\\n    | extend Activity = strcat(\\\"Delegated access added to application\\\")\\n    | project\\n        TimeGenerated,\\n        Activity,\\n        ['Permissions granted'],\\n        ['Service Principal ObjectId'],\\n        Actor;\\nlet appaccess=\\n    AuditLogs\\n    | where TimeGenerated > ago(1d)\\n    | where OperationName has \\\"Add app role assignment to service principal\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | where Actor in (newusers)\\n    | extend Activity = strcat(\\\"Application access added to application\\\")\\n    | extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)\\n    | project\\n        TimeGenerated,\\n        Activity,\\n        ['Permissions granted'],\\n        ['Service Principal ObjectId'],\\n        Actor;\\nunion delegatedaccess, appaccess\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-FirstTimeAppConsent.kql", "query_name": "OAuth-FirstTimeAppConsent", "attributes": {}}, {"query": "\"//Find any Azure AD service principals that have been granted any .All access in the last year that haven't signed in for 30 days. May include already deleted service principals.\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet delegatedaccess=\\n    AuditLogs\\n    | where TimeGenerated > ago(365d)\\n    | where OperationName has \\\"Add delegated permission grant\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend ServicePrincipalId = tostring(TargetResources[1].id)\\n    | extend ['Permission type'] = strcat(\\\"Delegated\\\")\\n    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId\\n    | project\\n        TimeGenerated,\\n        ['Permission type'],\\n        ['Permissions granted'],\\n        ServicePrincipalId;\\nlet appaccess=\\n    AuditLogs\\n    | where TimeGenerated > ago(365d)\\n    | where OperationName has \\\"Add app role assignment to service principal\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend ['Permission type'] = strcat(\\\"Application\\\")\\n    | extend ServicePrincipalId = tostring(TargetResources[1].id)\\n    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId\\n    | project\\n        TimeGenerated,\\n        ServicePrincipalId,\\n        ['Permission type'],\\n        ['Permissions granted'];\\nunion delegatedaccess, appaccess\\n| where ['Permissions granted'] contains \\\".All\\\"\\n| distinct ServicePrincipalId\\n| join kind=leftanti (\\n    AADServicePrincipalSignInLogs\\n    | where TimeGenerated > ago (30d)\\n    | where ResultType == \\\"0\\\"\\n    | distinct ServicePrincipalName, ServicePrincipalId)\\n    on ServicePrincipalId\\n\\n\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-InactiveServicePrincipalswithPrivilege.kql", "query_name": "OAuth-InactiveServicePrincipalswithPrivilege", "attributes": {}}, {"query": "\"//Query to find OAuth applications where permissions were added and removed within 10 minutes\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nlet PermissionAddedAlert=\\n    AuditLogs\\n    | where OperationName has \\\"Add app role assignment to service principal\\\"\\n    | extend UserWhoAdded = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend PermissionAdded = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n    | extend AppId = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[5].newValue)))\\n    | extend TimeAdded = TimeGenerated\\n    | project UserWhoAdded, PermissionAdded, AppId, TimeAdded;\\nlet PermissionRemovedAlert=\\n    AuditLogs\\n    | where OperationName has \\\"Remove app role assignment from service principal\\\"\\n    | extend UserWhoRemoved = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend PermissionRemoved = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].oldValue)))\\n    | extend AppId = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[5].newValue)))\\n    | extend TimeRemoved = TimeGenerated\\n    | project UserWhoRemoved, PermissionRemoved, AppId, TimeRemoved;\\nPermissionAddedAlert\\n| join kind=inner PermissionRemovedAlert on AppId\\n| where abs(datetime_diff('minute', TimeAdded, TimeRemoved)) <= 10\\n| extend TimeDiff = TimeAdded - TimeRemoved\\n| project\\n    TimeAdded,\\n    UserWhoAdded,\\n    PermissionAdded,\\n    AppId,\\n    TimeRemoved,\\n    UserWhoRemoved,\\n    PermissionRemoved,\\n    TimeDiff\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-PermissionsAddedRemoved.kql", "query_name": "OAuth-PermissionsAddedRemoved", "attributes": {}}, {"query": "\"//Summarize your Azure AD apps by what permissions they currently hold\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\n//Find applications that have been deleted\\nlet deletedapps=\\nAuditLogs\\n| where OperationName == \\\"Remove service principal\\\"\\n| extend ServicePrincipalId = tostring(TargetResources[0].id)\\n| project ServicePrincipalId;\\nlet delegatedaccess=\\n    AuditLogs\\n    | where TimeGenerated > ago(365d)\\n    | where OperationName has \\\"Add delegated permission grant\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend ServicePrincipalId = tostring(TargetResources[1].id)\\n    | extend ['Permission type'] = strcat(\\\"Delegated\\\")\\n    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId\\n//Exclude deleted applications\\n    | where ServicePrincipalId !in (deletedapps)\\n    | project\\n        TimeGenerated,\\n        ['Permission type'],\\n        ['Permissions granted'],\\n        ServicePrincipalId;\\nlet appaccess=\\n    AuditLogs\\n    | where TimeGenerated > ago(365d)\\n    | where OperationName has \\\"Add app role assignment to service principal\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend ['Permission type'] = strcat(\\\"Application\\\")\\n    | extend ServicePrincipalId = tostring(TargetResources[1].id)\\n    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId\\n//Exclude deleted applications\\n    | where ServicePrincipalId !in (deletedapps)\\n    | project\\n        TimeGenerated,\\n        ServicePrincipalId,\\n        ['Permission type'],\\n        ['Permissions granted'];\\nunion delegatedaccess, appaccess\\n| mv-expand ['Permissions granted']\\n| where isnotempty( ['Permissions granted'])\\n//Extend new permission field\\n| summarize ['Permission List']=make_set(['Permissions granted']) by ['Permission type'], ServicePrincipalId\\n| extend ['Number of Permissions']=array_length(['Permission List']) \\n| sort by ServicePrincipalId desc, ['Permission type'] asc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-SummarizeCurrentAppPermissions.kql", "query_name": "OAuth-SummarizeCurrentAppPermissions", "attributes": {}}, {"query": "\"//Summarize the permissions granted to your Azure AD apps over the last year\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\n//Find applications that have been deleted\\nlet deletedapps=\\nAuditLogs\\n| where OperationName == \\\"Remove service principal\\\"\\n| extend ServicePrincipalId = tostring(TargetResources[0].id)\\n| project ServicePrincipalId;\\nlet delegatedaccess=\\n    AuditLogs\\n    | where TimeGenerated > ago(365d)\\n    | where OperationName has \\\"Add delegated permission grant\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend ServicePrincipalId = tostring(TargetResources[1].id)\\n    | extend ['Permission type'] = strcat(\\\"Delegated\\\")\\n    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId\\n//Exclude deleted applications\\n    | where ServicePrincipalId !in (deletedapps)\\n    | project\\n        TimeGenerated,\\n        ['Permission type'],\\n        ['Permissions granted'],\\n        ServicePrincipalId;\\nlet appaccess=\\n    AuditLogs\\n    | where TimeGenerated > ago(365d)\\n    | where OperationName has \\\"Add app role assignment to service principal\\\"\\n    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n    | extend ['Permissions granted'] = split(x, ' ')\\n    | extend ['Permission type'] = strcat(\\\"Application\\\")\\n    | extend ServicePrincipalId = tostring(TargetResources[1].id)\\n    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId\\n//Exclude deleted applications\\n    | where ServicePrincipalId !in (deletedapps)\\n    | project\\n        TimeGenerated,\\n        ServicePrincipalId,\\n        ['Permission type'],\\n        ['Permissions granted'];\\nunion delegatedaccess, appaccess\\n| mv-expand ['Permissions granted']\\n| where isnotempty( ['Permissions granted'])\\n//Extend new permission field\\n| extend Permission = strcat(['Permission type'],\\\" - \\\",['Permissions granted'])\\n| summarize PermissionCount=count()by Permission\\n| sort by PermissionCount desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-SummarizePermissionGrantedtoApps.kql", "query_name": "OAuth-SummarizePermissionGrantedtoApps", "attributes": {}}, {"query": "\"//Summarize your Azure AD service principals by the last time they signed in, grouped by month\\n\\n//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs\\n\\nAADServicePrincipalSignInLogs\\n| project TimeGenerated, AppId, ResultType, ServicePrincipalName\\n| where TimeGenerated > ago (360d)\\n| where ResultType == 0\\n| summarize arg_max(TimeGenerated, *) by AppId\\n| summarize ['Application List']=make_set(ServicePrincipalName) by Month=startofmonth(TimeGenerated)\\n| sort by Month asc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-SummarizeServicePrincipalInactivity.kql", "query_name": "OAuth-SummarizeServicePrincipalInactivity", "attributes": {}}, {"query": "\"//Tracks privileged post creation events on your Azure AD service principals, such as secrets being generated, permissions being added or an admin consenting.\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\n//Events are then summarized by operation and time. Add a specific Application ID to track events for that one app.\\nlet timeframe=60d;\\nlet AppAdded=\\n    AuditLogs\\n    | where TimeGenerated > ago (timeframe)\\n    | where OperationName == \\\"Add service principal\\\"\\n    | extend AppId = tostring(AdditionalDetails[1].value)\\n    | extend ServicePrincipalId = tostring(TargetResources[0].id)\\n    // Optionally add a specific Application ID\\n    //| where AppId == \\\"id\\\"\\n    | extend AppName = tostring(TargetResources[0].displayName)\\n    | where isnotempty(AppId)\\n    | project TimeGenerated, OperationName, AppId, AppName, ServicePrincipalId;\\nlet AppSecretAdded=\\n    AuditLogs\\n    | where OperationName contains 'Update application \\u2013 Certificates and secrets management'\\n    | extend AppId = tostring(AdditionalDetails[1].value)\\n    | project TimeGenerated, AppId, OperationName\\n    | join kind=inner AppAdded on AppId\\n    | project TimeGenerated, OperationName, AppId, AppName;\\nlet AppApplicationAccess=\\n    AuditLogs\\n    | where OperationName == \\\"Add app role assignment to service principal\\\"\\n    | extend AppId = tostring(TargetResources[1].displayName)\\n    | project TimeGenerated, AppId, OperationName\\n    | join kind=inner AppAdded on AppId\\n    | project TimeGenerated, OperationName, AppId, AppName;\\nlet AppDelegatedAccess=\\n    AuditLogs\\n    | where OperationName == \\\"Add delegated permission grant\\\"\\n    | extend ServicePrincipalId = tostring(TargetResources[1].id)\\n    | project TimeGenerated, ServicePrincipalId, OperationName\\n    | join kind=inner AppAdded on ServicePrincipalId\\n    | project TimeGenerated, OperationName, AppId, AppName;\\nlet AppConsentGiven=\\n    AuditLogs\\n    | where OperationName == \\\"Consent to application\\\"\\n    | extend AppId = tostring(AdditionalDetails[1].value)\\n    | project TimeGenerated, AppId, OperationName\\n    | join kind=inner AppAdded on AppId\\n    | project TimeGenerated, OperationName, AppId, AppName;\\nlet AppDeleted=\\n    AuditLogs\\n    | where OperationName == \\\"Delete application\\\"\\n    | extend AppId = tostring(AdditionalDetails[1].value)\\n    | project TimeGenerated, AppId, OperationName\\n    | join kind=inner AppAdded on AppId\\n    | project TimeGenerated, OperationName, AppId, AppName;\\nAppAdded\\n| union\\n    AppSecretAdded,\\n    AppApplicationAccess,\\n    AppConsentGiven,\\n    AppDelegatedAccess,\\n    AppDeleted\\n| sort by TimeGenerated asc \\n| summarize\\n    AppOperations=(make_list(OperationName)),\\n    AppOperationTime=(make_list(TimeGenerated))\\n    by AppId, AppName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/OAuth-TrackEventsonServicePrincipals.kql", "query_name": "OAuth-TrackEventsonServicePrincipals", "attributes": {}}, {"query": "\"// Find users who are assigned a privileged role in Azure AD but haven't activated a role in the last 45 days\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nIdentityInfo\\n| where TimeGenerated > ago(21d)\\n| where isnotempty(AssignedRoles)\\n| where AssignedRoles != \\\"[]\\\"\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| join kind=leftanti  (\\n    AuditLogs\\n    | where TimeGenerated > ago(45d)\\n    | where OperationName == \\\"Add member to role completed (PIM activation)\\\"\\n    | extend AccountUPN = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN)\\n    on AccountUPN\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/PIM-UserAssignedRolebutHasntActivated.kql", "query_name": "PIM-UserAssignedRolebutHasntActivated", "attributes": {}}, {"query": "\"// Detects when a self service password reset has been initiated via MS Graph and is successful\\n\\n//Data connector required for this query - Azure Active Directory - Audit Logs\\n\\nAuditLogs\\n| where OperationName == \\\"POST UserAuthMethod.ResetPasswordOnPasswordMethods\\\"\\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| project TimeGenerated, OperationName, Actor, CorrelationId\\n| join kind=inner\\n    (AuditLogs\\n    | where OperationName == \\\"Reset password (by admin)\\\"\\n    | extend Target = tostring(TargetResources[0].userPrincipalName)\\n    | where Result == \\\"success\\\"\\n    )\\n    on CorrelationId\\n| project GraphPostTime=TimeGenerated, PasswordResetTime=TimeGenerated1, Actor, Target\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Active%20Directory/SSPR-PasswordResetInitiatedviaMSGraph.kql", "query_name": "SSPR-PasswordResetInitiatedviaMSGraph", "attributes": {}}, {"query": "\"//Detect when a resource lock is added or removed from an Azure resource\\n\\n//Data connector required for this query - Azure Activity \\n\\nAzureActivity\\n| where OperationNameValue in (\\\"MICROSOFT.AUTHORIZATION/LOCKS/WRITE\\\", \\\"MICROSOFT.AUTHORIZATION/LOCKS/DELETE\\\")\\n| where ActivityStatusValue == \\\"Success\\\"\\n| extend Activity = case(OperationNameValue == \\\"MICROSOFT.AUTHORIZATION/LOCKS/WRITE\\\", strcat(\\\"Resource Lock Added\\\"),\\n    OperationNameValue == \\\"MICROSOFT.AUTHORIZATION/LOCKS/DELETE\\\", strcat(\\\"Resource Lock Removed\\\"),\\n    \\\"unknown\\\")\\n| extend ResourceGroup = tostring(parse_json(Properties).resourceGroup)\\n| extend AzureResource = tostring(parse_json(Properties).resourceProviderValue)\\n| extend x = tostring(parse_json(Properties).resource)\\n| parse x with ResourceName \\\"/\\\" *\\n| parse x with * \\\"microsoft.authorization/\\\" LockName\\n| project\\n    TimeGenerated,\\n    Activity,\\n    ResourceName,\\n    ['Azure Resource']=AzureResource,\\n    ['Azure Subscription Id']=SubscriptionId,\\n    ['Azure Resource Group']=ResourceGroup,\\n    LockName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Activity/Azure-ResourceLockAddedorRemoved.kql", "query_name": "Azure-ResourceLockAddedorRemoved", "attributes": {}}, {"query": "\"//Detect when an Azure AD service principal is given access to an Azure RBAC scope, i.e contributor to a subscription or resource group\\n\\n//Data connector required for this query - Azure Activity \\n\\nAzureActivity\\n| where OperationNameValue == \\\"MICROSOFT.AUTHORIZATION/ROLEASSIGNMENTS/WRITE\\\"\\n| extend ServicePrincipalObjectId = tostring(parse_json(tostring(parse_json(tostring(Properties_d.requestbody)).Properties)).PrincipalId)\\n| extend ServicePrincipalType = tostring(parse_json(tostring(parse_json(tostring(Properties_d.requestbody)).Properties)).PrincipalType)\\n| extend Scope = tostring(parse_json(tostring(parse_json(tostring(Properties_d.requestbody)).Properties)).Scope)\\n| extend RoleAdded = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).requestbody)).Properties)).RoleDefinitionId)\\n| extend Actor = tostring(Properties_d.caller)\\n| where ServicePrincipalType == \\\"ServicePrincipal\\\"\\n| project TimeGenerated, RoleAdded, Scope, ServicePrincipalObjectId, Actor\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Activity/Azure-ServicePrincipalAddedtoAzure.kql", "query_name": "Azure-ServicePrincipalAddedtoAzure", "attributes": {}}, {"query": "\"//Detect when the workspace keys to an Azure log analytics workspace are read\\n\\n//Data connector required for this query - Azure Activity \\n\\nAzureActivity\\n| where OperationNameValue == \\\"MICROSOFT.OPERATIONALINSIGHTS/WORKSPACES/SHAREDKEYS/ACTION\\\"\\n| extend WorkspaceName = tostring(parse_json(Properties).resource)\\n| where ActivityStatusValue == \\\"Success\\\"\\n| project\\n    TimeGenerated,\\n    Actor=Caller,\\n    ['Log Analytics Workspace Name']=WorkspaceName,\\n    ['Actor IP Address']=CallerIpAddress,\\n    ['Azure Subscription Id']=SubscriptionId,\\n    ['Azure Resource Group']=ResourceGroup\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Activity/AzureLogAnalytics-DetectwhenWorkspaceKeysareRead.kql", "query_name": "AzureLogAnalytics-DetectwhenWorkspaceKeysareRead", "attributes": {}}, {"query": "\"//Detect when a user retrieves keys for Azure storage for the first time compared to the previous time range\\n\\n//Data connector required for this query - Azure Activity \\n\\nlet knownusers=\\n    AzureActivity\\n    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)\\n    | where OperationName == \\\"List Storage Account Keys\\\"\\n    | where ActivityStatus == \\\"Succeeded\\\"\\n    | project-rename Actor=Caller\\n    | distinct Actor;\\nAzureActivity\\n| where TimeGenerated > ago(1d)\\n| where OperationName == \\\"List Storage Account Keys\\\"\\n| where ActivityStatus == \\\"Succeeded\\\"\\n| project-rename Actor=Caller\\n| where Actor !in (knownusers)\\n| project\\n    TimeGenerated,\\n    Actor,\\n    ['Actor IP Address']=CallerIpAddress,\\n    ['Storage Account Name']=Resource,\\n    ['Azure Subscription Id']=SubscriptionId,\\n    ['Azure Resource Group']=ResourceGroup \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Activity/AzureStorage-FirstTimeStorageKeyEnumeration.kql", "query_name": "AzureStorage-FirstTimeStorageKeyEnumeration", "attributes": {}}, {"query": "\"//Detect when a download URL is generated for an Azure virtual machine disk\\n\\n//Data connector required for this query - Azure Activity \\n\\nAzureActivity\\n| where OperationNameValue == \\\"MICROSOFT.COMPUTE/DISKS/BEGINGETACCESS/ACTION\\\"\\n| where ActivityStatusValue == \\\"Success\\\"\\n| extend DiskName = tostring(Properties_d.resource)\\n| project\\n    TimeGenerated,\\n    Actor=Caller,\\n    ['Actor IP Address']=CallerIpAddress,\\n    ['Azure Subscription Id']=SubscriptionId,\\n    ['Azure Resource Group']=ResourceGroup,\\n    DiskName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Activity/AzureVM-DiskImageURLGenerated.kql", "query_name": "AzureVM-DiskImageURLGenerated", "attributes": {}}, {"query": "\"//Alerts on users being added to roles on your Azure Sentinel log analytics workspace.\\n\\n//Data connector required for this query - Azure Activity \\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\n//Uses a lookup to a GitHub gist to match Azure role ids to friendly role names and the IdentityInfo to retrieve identity details\\n\\nlet workspaceid=\\\"your Sentinel workspace id\\\";\\nlet timeframe=1d;\\nlet AZRoles = externaldata(Name: string, Id: string) [@\\\"https://gist.githubusercontent.com/reprise99/363eee70938c9a3d662e3f6da4610fe4/raw/b25b2d7a626396684ab578363888a0e360e7b287/.csv\\\"] with(ignoreFirstRecord=true, format=\\\"csv\\\");\\nlet accesschange =AzureActivity\\n    | where TimeGenerated > ago(timeframe)\\n    | where OperationName == \\\"Create role assignment\\\"\\n    | where TenantId == workspaceid\\n    | extend TargetAADUserId = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).requestbody)).Properties)).PrincipalId)\\n    | extend RoleDefinitionId = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).requestbody)).Properties)).RoleDefinitionId)\\n    | parse RoleDefinitionId with * '/roleDefinitions/' AzureRoleId\\n    | where ActivityStatus == \\\"Started\\\"\\n    | project\\n        AccessChangeTime=TimeGenerated,\\n        Actor=Caller,\\n        ActorIPAddress=CallerIpAddress,\\n        ResourceGroup,\\n        WorkspaceId=TenantId,\\n        AzureRoleId,\\n        TargetAADUserId\\n    | join kind=inner (AZRoles \\n        )\\n        on $left.AzureRoleId == $right.Id\\n    | project-away Id;\\nIdentityInfo\\n| where TimeGenerated > ago(21d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| join kind=inner accesschange on $left.AccountObjectId == $right.TargetAADUserId\\n| project\\n    AccessChangeTime=TimeGenerated,\\n    Actor,\\n    ActorIPAddress,\\n    ResourceGroup,\\n    WorkspaceId=TenantId,\\n    AzureRoleId,\\n    AzureRoleName=Name,\\n    TargetAADUserId,\\n    AccountUPN\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Activity/Sentinel-DetectAccessAddedtoWorkspace.kql", "query_name": "Sentinel-DetectAccessAddedtoWorkspace", "attributes": {}}, {"query": "\"//Find which users have attempted to connect to virtual machines using RDP or SSH in Azure Bastion\\n\\n//Data connector required for this query - Azure Bastion\\n\\nMicrosoftAzureBastionAuditLogs\\n| parse TargetResourceId with * 'VIRTUALMACHINES/' ['Virtual Machine Name']\\n| project\\n    TimeGenerated,\\n    Message,\\n    UserName,\\n    Protocol,\\n    ['Virtual Machine Name'],\\n    ['Virtual Machine IP']=TargetVMIPAddress\\n| sort by TimeGenerated desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Bastion/Bastion-AuditUsage.kql", "query_name": "Bastion-AuditUsage", "attributes": {}}, {"query": "\"//Summarize your Bastion usage by which users are connecting to which devices via which protocl (RDP or SSH)\\n\\n//Data connector required for this query - Azure Bastion\\n\\nMicrosoftAzureBastionAuditLogs \\n| where TimeGenerated > ago (30d)\\n| where Message == \\\"Successfully Connected.\\\"\\n| summarize\\n    ['Count of RDP Devices']=dcountif(TargetVMIPAddress, Protocol == \\\"rdp\\\"),\\n    ['List of RDP Devices']=make_set_if(TargetVMIPAddress, Protocol == \\\"rdp\\\"),\\n    ['Count of SSH Devices']=dcountif(TargetVMIPAddress, Protocol == \\\"ssh\\\"),\\n    ['List of SSH Devices']=make_set_if(TargetVMIPAddress, Protocol == \\\"ssh\\\")\\n    by UserName\\n| sort by ['Count of RDP Devices'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Bastion/Bastion-SummarizeAccountAccess.kql", "query_name": "Bastion-SummarizeAccountAccess", "attributes": {}}, {"query": "\"//Visualize the most attacked hostname behind an Azure App Gateway/WAF\\n\\n//Data connector required for this query - Azure Diagnostics (Application Gateways)\\n\\nAzureDiagnostics\\n| where TimeGenerated > ago(30d)\\n| where ResourceType == \\\"APPLICATIONGATEWAYS\\\"\\n| where isnotempty(ruleId_s)\\n| summarize ['WAF Hit Count']=count() by hostname_s\\n| where isnotempty(hostname_s)\\n| sort by ['WAF Hit Count'] desc\\n| render barchart with (title=\\\"Most WAF Hits by Hostname\\\", xtitle=\\\"Hostname\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Diagnostics/AppGateway-MostAttackedHostName.kql", "query_name": "AppGateway-MostAttackedHostName", "attributes": {}}, {"query": "\"//Visualize WAF rule actions such as allowed, blocked, detected and matched over time\\n\\n//Data connector required for this query - Azure Diagnostics (Application Gateways)\\n\\nAzureDiagnostics\\n| where TimeGenerated > ago(30d)\\n| where ResourceType == \\\"APPLICATIONGATEWAYS\\\"\\n| summarize count()by action_s, bin(TimeGenerated, 1h)\\n| where isnotempty(action_s)\\n| render timechart with (ytitle=\\\"WAF Hit Count\\\", title=\\\"Web application firewall traffic over time\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Diagnostics/AppGateway-VisualizeWAFTraffic.kql", "query_name": "AppGateway-VisualizeWAFTraffic", "attributes": {}}, {"query": "\"//Parse all request uris over the last 30 days and create a new column from the string between / and ://\\n//Example - from /${jndi:ldap:// we parse ${jndi:ldap: to a new column called HeaderUri\\n\\n//Data connector required for this query - Azure Diagnostics (Application Gateways)\\n\\n//Look up the last 3 days of data to find any new HeaderUri strings between / and :// not seen for the previous 30 days\\nAzureDiagnostics\\n| where TimeGenerated > ago(30d) and TimeGenerated < ago(3d)\\n| where ResourceType == \\\"APPLICATIONGATEWAYS\\\"\\n| project TimeGenerated, host_s, originalRequestUriWithArgs_s, clientIP_s\\n| parse-where originalRequestUriWithArgs_s with * '/' HeaderUri '://' *\\n| distinct host_s, HeaderUri\\n| join kind=rightanti (\\n    AzureDiagnostics\\n    | where TimeGenerated > ago(3d)\\n    | where ResourceType == \\\"APPLICATIONGATEWAYS\\\"\\n    | project TimeGenerated, host_s, originalRequestUriWithArgs_s, clientIP_s\\n    | parse-where originalRequestUriWithArgs_s with * '/' HeaderUri '://' *\\n    | project TimeGenerated, originalRequestUriWithArgs_s, host_s, HeaderUri)\\n    on host_s, HeaderUri\\n| parse-where originalRequestUriWithArgs_s with * '://' MaliciousHost '/' *\\n| project TimeGenerated, originalRequestUriWithArgs_s, HeaderUri, MaliciousHost, Target=host_s\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Diagnostics/CVE-2021-44228-2.kql", "query_name": "CVE-2021-44228-2", "attributes": {}}, {"query": "\"//Detection rule for App Gateway rule hits for log4j vulnerability. Retrieve attacked host, malicious IP and malicious User Agent\\n\\n//Data connector required for this query - Azure Diagnostics (Application Gateways)\\n\\nAzureDiagnostics\\n| where details_data_s contains \\\"jndi\\\"\\n| parse-where details_data_s with * 'User-Agent:' MaliciousHost \\n| project TimeGenerated, Target=hostname_s, Actor=clientIp_s, MaliciousHost\\n\\n//Detect uri directly where starts with /$ or contains ldap\\nAzureDiagnostics\\n| where TimeGenerated > ago(1d)\\n| where ResourceType == \\\"APPLICATIONGATEWAYS\\\"\\n| project TimeGenerated, host_s, originalRequestUriWithArgs_s, clientIP_s\\n| where originalRequestUriWithArgs_s startswith \\\"/$\\\" or originalRequestUriWithArgs_s contains \\\"jndi\\\"\\n| parse-where originalRequestUriWithArgs_s with * '://' MaliciousHost \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Diagnostics/CVE-2021-44228.kql", "query_name": "CVE-2021-44228", "attributes": {}}, {"query": "\"//Searches for access by applications that have not previously accessed an Azure Key Vault in the last 30 days and returns all actions by those applications\\n\\n//Data connector required for this query - Azure Key Vault\\n\\nlet operationlist = dynamic([\\\"SecretGet\\\", \\\"KeyGet\\\", \\\"VaultGet\\\"]);\\nlet starttime = 30d;\\nlet endtime = 1d;\\nlet detection=\\n    AzureDiagnostics\\n    | where TimeGenerated between (ago(starttime) .. ago(endtime))\\n    | where ResourceType == \\\"VAULTS\\\"\\n    | where ResultType == \\\"Success\\\"\\n    | where OperationName in (operationlist)\\n    | where isnotempty(identity_claim_appid_g)\\n    | project-rename KeyVaultName=Resource, AppId=identity_claim_appid_g\\n    | distinct KeyVaultName, AppId\\n    | join kind=rightanti  (\\n        AzureDiagnostics\\n        | where TimeGenerated > ago(endtime)\\n        | where ResourceType == \\\"VAULTS\\\"\\n        | where ResultType == \\\"Success\\\"\\n        | where OperationName in (operationlist)\\n        | where isnotempty(identity_claim_appid_g)\\n        | project-rename\\n            KeyVaultName=Resource,\\n            AppId=identity_claim_appid_g\\n        | distinct KeyVaultName, AppId)\\n        on KeyVaultName, AppId;\\nAzureDiagnostics\\n| where TimeGenerated > ago(endtime)\\n| where ResourceType == \\\"VAULTS\\\"\\n| where ResultType == \\\"Success\\\"\\n| project-rename\\n    KeyVaultName=Resource,\\n    AppId=identity_claim_appid_g\\n| join kind=inner detection on KeyVaultName, AppId\\n| project\\n    TimeGenerated,\\n    AppId,\\n    ResourceGroup,\\n    SubscriptionId,\\n    KeyVaultName,\\n    KeyVaultTarget=id_s,\\n    OperationName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Key%20Vault/KeyVault-AnomalousKeyVaultAccessbyApp.kql", "query_name": "KeyVault-AnomalousKeyVaultAccessbyApp", "attributes": {}}, {"query": "\"//Searches for access by users who have not previously accessed an Azure Key Vault in the last 30 days and returns all actions by those users\\n\\n//Data connector required for this query - Azure Key Vault\\n\\nlet operationlist = dynamic([\\\"SecretGet\\\", \\\"KeyGet\\\", \\\"VaultGet\\\"]);\\nlet starttime = 30d;\\nlet endtime = 1d;\\nlet detection=\\n    AzureDiagnostics\\n    | where TimeGenerated between (ago(starttime) .. ago(endtime))\\n    | where ResourceType == \\\"VAULTS\\\"\\n    | where ResultType == \\\"Success\\\"\\n    | where OperationName in (operationlist)\\n    | where isnotempty(identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_upn_s)\\n    | project-rename KeyVaultName=Resource, UserPrincipalName=identity_claim_appid_g\\n    | distinct KeyVaultName, UserPrincipalName\\n    | join kind=rightanti  (\\n        AzureDiagnostics\\n        | where TimeGenerated > ago(endtime)\\n        | where ResourceType == \\\"VAULTS\\\"\\n        | where ResultType == \\\"Success\\\"\\n        | where OperationName in (operationlist)\\n        | where isnotempty(identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_upn_s)\\n        | project-rename\\n            KeyVaultName=Resource,\\n            UserPrincipalName=identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_upn_s\\n        | distinct KeyVaultName, UserPrincipalName)\\n        on KeyVaultName, UserPrincipalName;\\nAzureDiagnostics\\n| where TimeGenerated > ago(endtime)\\n| where ResourceType == \\\"VAULTS\\\"\\n| where ResultType == \\\"Success\\\"\\n| project-rename\\n    KeyVaultName=Resource,\\n    UserPrincipalName=identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_upn_s\\n| join kind=inner detection on KeyVaultName, UserPrincipalName\\n| project\\n    TimeGenerated,\\n    UserPrincipalName,\\n    ResourceGroup,\\n    SubscriptionId,\\n    KeyVaultName,\\n    KeyVaultTarget=id_s,\\n    OperationName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Key%20Vault/KeyVault-AnomalousKeyVaultAccessbyUser.kql", "query_name": "KeyVault-AnomalousKeyVaultAccessbyUser", "attributes": {}}, {"query": "\"// Detects when an Azure Key Vault firewall is set to allow all by default\\n\\n//Data connector required for this query - Azure Key Vault\\n\\nAzureDiagnostics\\n| where ResourceType == \\\"VAULTS\\\"\\n| where OperationName == \\\"VaultPatch\\\"\\n| where ResultType == \\\"Success\\\"\\n| project-rename ExistingACL=properties_networkAcls_defaultAction_s, VaultName=Resource\\n| where isnotempty(ExistingACL)\\n| where ExistingACL == \\\"Deny\\\"\\n| sort by TimeGenerated desc  \\n| project\\n    TimeGenerated,\\n    SubscriptionId,\\n    VaultName,\\n    ExistingACL\\n| join kind=inner\\n(\\nAzureDiagnostics\\n| project-rename NewACL=properties_networkAcls_defaultAction_s, VaultName=Resource\\n| where ResourceType == \\\"VAULTS\\\"\\n| where OperationName == \\\"VaultPatch\\\"\\n| where ResultType == \\\"Success\\\"\\n| summarize arg_max(TimeGenerated, *) by VaultName, NewACL\\n) \\non VaultName\\n| where ExistingACL != NewACL and NewACL == \\\"Allow\\\"\\n| project DetectionTime=TimeGenerated1, VaultName, ExistingACL, NewACL, SubscriptionId, IPAddressofActor=CallerIPAddress, Actor=identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_upn_s\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Key%20Vault/KeyVault-DefaultFirewallRuleSettoAllow.kql", "query_name": "KeyVault-DefaultFirewallRuleSettoAllow", "attributes": {}}, {"query": "\"// Detects when an IP address has been added to an Azure Key Vault firewall allow list\\n\\n//Data connector required for this query - Azure Key Vault\\n\\nAzureDiagnostics\\n| where ResourceType == \\\"VAULTS\\\"\\n| where OperationName == \\\"VaultPatch\\\"\\n| where ResultType == \\\"Success\\\"\\n| where isnotempty(addedIpRule_Value_s)\\n| project\\n    TimeGenerated,\\n    VaultName=Resource,\\n    SubscriptionId,\\n    IPAddressofActor=CallerIPAddress,\\n    Actor=identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_upn_s,\\n    IPRangeAdded=addedIpRule_Value_s\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Key%20Vault/KeyVault-IPAddedtoFirewall.kql", "query_name": "KeyVault-IPAddedtoFirewall", "attributes": {}}, {"query": "\"// Detects when a service principal (user, group or app) has been granted access to Key Vault data\\n\\n//Data connector required for this query - Azure Key Vault\\n\\nAzureDiagnostics\\n| where ResourceType == \\\"VAULTS\\\"\\n| where OperationName == \\\"VaultPatch\\\"\\n| where ResultType == \\\"Success\\\"\\n| project-rename ServicePrincipalAdded=addedAccessPolicy_ObjectId_g, Actor=identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_name_s, AddedKeyPolicy = addedAccessPolicy_Permissions_keys_s, AddedSecretPolicy = addedAccessPolicy_Permissions_secrets_s,AddedCertPolicy = addedAccessPolicy_Permissions_certificates_s\\n| where isnotempty(AddedKeyPolicy)\\n    or isnotempty(AddedSecretPolicy)\\n    or isnotempty(AddedCertPolicy)\\n| project\\n    TimeGenerated,\\n    KeyVaultName=Resource,\\n    ServicePrincipalAdded,\\n    Actor,\\n    IPAddressofActor=CallerIPAddress,\\n    AddedSecretPolicy,\\n    AddedKeyPolicy,\\n    AddedCertPolicy\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Key%20Vault/KeyVault-ObjectIDAddedtoAccessPolicy.kql", "query_name": "KeyVault-ObjectIDAddedtoAccessPolicy", "attributes": {}}, {"query": "\"// Detects Key Vault operations that could be malicious\\n\\n//Data connector required for this query - Azure Key Vault\\n\\nlet operationlist = dynamic(\\n    [\\\"VaultDelete\\\", \\\"KeyDelete\\\", \\\"SecretDelete\\\", \\\"SecretPurge\\\", \\\"KeyPurge\\\", \\\"SecretBackup\\\", \\\"KeyBackup\\\", \\\"SecretListDeleted\\\", \\\"CertificateCreate\\\", \\\"CertificatePurge\\\"]);\\nAzureDiagnostics\\n| where ResourceType == \\\"VAULTS\\\" and ResultType == \\\"Success\\\" \\n| where OperationName in (operationlist)\\n| project TimeGenerated,\\n    ResourceGroup,\\n    SubscriptionId,\\n    KeyVaultName=Resource,\\n    KeyVaultTarget=id_s,\\n    Actor=identity_claim_upn_s,\\n    IPAddressofActor=CallerIPAddress,\\n    OperationName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Key%20Vault/KeyVault-PotentiallySensitiveOperations.kql", "query_name": "KeyVault-PotentiallySensitiveOperations", "attributes": {}}, {"query": "\"//Calculate how many days since each analytic rule last triggered, useful to determine if rules are still valid\\n\\n//Data connector required for this query - Microsoft Sentinel Incidents (generated automatically if you create incidents in Sentinel)\\n\\nSecurityIncident\\n| where TimeGenerated > ago(180d)\\n| where Status == \\\"New\\\" and ModifiedBy == \\\"Incident created from alert\\\"\\n| summarize arg_max(TimeGenerated, *) by Title\\n| extend ['Days Since Last Incident'] = datetime_diff(\\\"day\\\", now(), TimeGenerated)\\n| project Title, ['Days Since Last Incident']\\n| sort by ['Days Since Last Incident'] desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Sentinel%20Incidents/SecurityIncident-DaysSinceLastIncident.kql", "query_name": "SecurityIncident-DaysSinceLastIncident", "attributes": {}}, {"query": "\"//Visualize which playbooks are interacting with security incidents\\n\\n//Data connector required for this query - Microsoft Sentinel Incidents (generated automatically if you create incidents in Sentinel)\\n\\nlet timeframe=45d;\\nSecurityIncident\\n| where TimeGenerated > ago (timeframe)\\n| where ModifiedBy startswith \\\"Playbook\\\"\\n| summarize Count=count() by ModifiedBy\\n| sort by Count desc \\n| render barchart\\n    with (\\n    title=\\\"Count of playbooks interacting with Microsoft Sentinel incidents\\\",\\n    ytitle=\\\"Playbook Name\\\")  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Sentinel%20Incidents/SecurityIncident-PlaybookActivities.kql", "query_name": "SecurityIncident-PlaybookActivities", "attributes": {}}, {"query": "\"//Visualize the severity of your Microsoft Sentinel incidents per month\\n\\n//Data connector required for this query - Microsoft Sentinel Incidents (generated automatically if you create incidents in Sentinel)\\n\\nSecurityIncident\\n| where TimeGenerated > ago(365d)\\n| summarize Count=dcount(IncidentNumber)by Severity, startofmonth(TimeGenerated)\\n| render columnchart with (kind=unstacked, title=\\\"Microsoft Sentinel Incident Severity\\\", xtitle=\\\"Month\\\") \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Sentinel%20Incidents/SecurityIncident-VisualizeIncidentSeverity.kql", "query_name": "SecurityIncident-VisualizeIncidentSeverity", "attributes": {}}, {"query": "\"//Create a visualization showing the total Sentinel incidents and the trend of incidents over time\\n\\n//Data connector required for this query - Microsoft Sentinel Incidents (generated automatically if you create incidents in Sentinel)\\n\\nSecurityIncident\\n| summarize arg_min(TimeGenerated, *) by IncidentNumber\\n| make-series TotalIncidents=count() default=0 on TimeGenerated in range(ago(90d), now(), 1d)\\n| extend (RSquare, SplitIdx, Variance, RVariance, TrendLine)=series_fit_2lines(TotalIncidents)\\n| project TimeGenerated, TotalIncidents, TrendLine\\n| render timechart with (title=\\\"Microsoft Sentinel incidents over time with trend\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Sentinel%20Incidents/SecurityIncident-VisualizeIncidentswithTrend.kql", "query_name": "SecurityIncident-VisualizeIncidentswithTrend", "attributes": {}}, {"query": "\"//Visualize the incidents generated in Microsoft Sentinel by MITRE ATT&CK tactics\\n\\n//Data connector required for this query - Microsoft Sentinel Incidents (generated automatically if you create incidents in Sentinel)\\n\\nSecurityIncident\\n| where TimeGenerated > ago(30d)\\n| summarize arg_min(TimeGenerated, *) by IncidentNumber\\n| extend Tactics = tostring(AdditionalData.tactics)\\n| where Tactics != \\\"[]\\\"\\n| mv-expand todynamic(Tactics)\\n| summarize Count=count()by tostring(Tactics)\\n| sort by Count\\n| render barchart with (title=\\\"Microsoft Sentinel incidents by MITRE ATT&CK tactic\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Azure%20Sentinel%20Incidents/SecurityIncident-VisualizeMitreAtt%26ck.kql", "query_name": "SecurityIncident-VisualizeMitreAtt&ck", "attributes": {}}, {"query": "\"//Visualize the breakdown of 365 days of KQL\\nexternaldata(Category: string, Count: int)\\n[\\nh@'https://gist.githubusercontent.com/reprise99/12487ffefee2c2c417e2706150e25b8e/raw/0679cbb29e43e370c7304bb9b3d0007042a8ad52/365daysofkql.csv'\\n] | sort by Count desc | render piechart \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Data%20Management/365-Visualize365DaysofKql.kql", "query_name": "365-Visualize365DaysofKql", "attributes": {}}, {"query": "\"//Calculate the percentage that each table in your Sentinel workspace is contributing to total ingestion for billable data\\n\\n//Data connector required for this query - Usage (generated automatically on a log analytics workspace)\\n\\nUsage\\n| where TimeGenerated > ago(30d)\\n| where IsBillable = true\\n| summarize ['Table size in GB']=sum(Quantity / 1024) by DataType\\n| as T\\n| extend Percentage = round(100.0 * ['Table size in GB'] / toscalar (T\\n    | summarize sum(['Table size in GB'])), 2)\\n| project-reorder DataType, ['Table size in GB'], Percentage\\n| sort by Percentage desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Data%20Management/Data-CalculatePercentageperTable.kql", "query_name": "Data-CalculatePercentageperTable", "attributes": {}}, {"query": "\"//Calculate the change in size of all your tables from last week to this week\\n\\n//Data connector required for this query - query will automatically union any data you have\\n\\nlet lastweek=\\nunion withsource=_TableName *\\n| where TimeGenerated > ago(14d) and TimeGenerated < ago(7d)\\n| summarize\\n    Entries = count(), Size = sum(_BilledSize) by Type\\n| project ['Table Name'] = Type, ['Last Week Table Size'] = Size, ['Last Week Table Entries'] = Entries, ['Last Week Size per Entry'] = 1.0 * Size / Entries\\n| order by ['Table Name']  desc;\\nlet thisweek=\\nunion withsource=_TableName *\\n| where TimeGenerated > ago(7d)\\n| summarize\\n    Entries = count(), Size = sum(_BilledSize) by Type\\n| project ['Table Name'] = Type, ['This Week Table Size'] = Size, ['This Week Table Entries'] = Entries, ['This Week Size per Entry'] = 1.0 * Size / Entries\\n| order by ['Table Name']  desc;\\nlastweek\\n| join kind=inner thisweek on ['Table Name']\\n| extend PercentageChange=todouble(['This Week Table Size']) * 100 / todouble(['Last Week Table Size'])\\n| project ['Table Name'], ['Last Week Table Size'], ['This Week Table Size'], PercentageChange\\n| sort by PercentageChange desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Data%20Management/Data-CalculateTableSizeChanges.kql", "query_name": "Data-CalculateTableSizeChanges", "attributes": {}}, {"query": "\"//Detect anomalies in the amount of data being ingested into your Sentinel workspace\\n\\n//Data connector required for this query - Usage (generated automatically on a log analytics workspace)\\n\\n//Sensitivity = the lower the number the more sensitive the anomaly detection is, i.e it will find more anomalies, default is 1.5\\nlet sensitivity = 1.5;\\n//Threshold = set a threshold to account for low volume anomailies, i.e moving from 1 GB of data to 2 GB. This example uses tables larger than 2 GB every 3 hours as a threshold\\nlet threshold = 2;\\n//First find the anomalies by creating a series of all the data ingestion and using series_decompose_anomalies\\nlet outliers=\\nUsage\\n| where IsBillable = true\\n| make-series TableSize=sum(Quantity / 1024) default=0 on TimeGenerated from ago(7d) to now() step 3h by DataType\\n| extend outliers=series_decompose_anomalies(TableSize, sensitivity)\\n| mv-expand TimeGenerated, TableSize, outliers\\n| where outliers == 1 and TableSize > threshold\\n//Optionally visualize the anomalies - remove everything below this line to just retrieve the data instead of visualizing\\n| distinct DataType;\\nUsage\\n| where IsBillable = true\\n| where DataType in (outliers)\\n| make-series TableSize=sum(Quantity / 1024) default=0 on TimeGenerated from ago(7d) to now() step 3h by DataType\\n| render timechart with (ytitle=\\\"Table Size\\\",title=\\\"Anomalous data ingestion\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Data%20Management/Data-DetectAnomalousDataIngestion.kql", "query_name": "Data-DetectAnomalousDataIngestion", "attributes": {}}, {"query": "\"//Detect when new tables have been written to in the last week compared to the last 90 days\\n\\n//Data connector required for this query - query will automatically union any data you have\\n\\nlet existingtables=\\n    union withsource=_TableName *\\n    | where TimeGenerated > ago(90d) and TimeGenerated < ago(7d)\\n    | distinct Type;\\nlet newtables=\\n    union withsource=_TableName *\\n    | where TimeGenerated > ago(7d)\\n    | summarize ['First Log Received'] = min(TimeGenerated) by Type\\n    | project Type, ['First Log Received'];\\nexistingtables\\n| join kind=rightanti newtables on Type\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Data%20Management/Data-NewTablesFound.kql", "query_name": "Data-NewTablesFound", "attributes": {}}, {"query": "\"//Calculate the size of the combined Device* tables from Defender for Endpoint by device name\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nunion withsource=_TableName Device*\\n| where TimeGenerated > ago(7d)\\n| summarize\\n    Entries = count(), Size = sum(_BilledSize)\\n    by DeviceName\\n| project\\n    ['Device Name'] = DeviceName,\\n    ['Table Size'] = Size,\\n    ['Table Entries'] = Entries,\\n    ['Size per Entry'] = 1.0 * Size / Entries\\n| order by ['Table Size']  desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Data%20Management/Data-TableSizePerMDEDevice.kql", "query_name": "Data-TableSizePerMDEDevice", "attributes": {}}, {"query": "\"//Detect when one of your Exchange admins grants themselves access to another users mailbox\\n\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//Microsoft Sentinel query\\nCloudAppEvents\\n| extend Operation= tostring(RawEventData.Operation)\\n| where Operation == \\\"Add-MailboxPermission\\\"\\n| extend TargetMailbox = tostring(parse_json(tostring(RawEventData.Parameters))[2].Value)\\n| extend UserAdded = tostring(parse_json(tostring(RawEventData.Parameters))[3].Value)\\n| extend AccessGranted = tostring(parse_json(tostring(RawEventData.Parameters))[4].Value)\\n| extend Actor = tostring(RawEventData.UserId)\\n| where Actor =~ UserAdded \\n| project TimeGenerated, Actor, TargetMailbox, UserAdded, AccessGranted\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nCloudAppEvents\\n| extend Operation= tostring(RawEventData.Operation)\\n| where Operation == \\\"Add-MailboxPermission\\\"\\n| extend TargetMailbox = tostring(parse_json(tostring(RawEventData.Parameters))[2].Value)\\n| extend UserAdded = tostring(parse_json(tostring(RawEventData.Parameters))[3].Value)\\n| extend AccessGranted = tostring(parse_json(tostring(RawEventData.Parameters))[4].Value)\\n| extend Actor = tostring(RawEventData.UserId)\\n| where Actor =~ UserAdded \\n| project Timestamp, Actor, TargetMailbox, UserAdded, AccessGranted\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-DetectAdminGrantingOwnAccesstoMailbox.kql", "query_name": "DCA-DetectAdminGrantingOwnAccesstoMailbox", "attributes": {}}, {"query": "\"//Use the Defender for Cloud Apps logs to detect when a mail forward is created on a mailbox (not an individual mailbox rule). Retrieve the address the mail was forwarded to and whether is both stored and forwarded\\n\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//Microsoft Sentinel query\\nCloudAppEvents\\n| where ActionType == \\\"Set-Mailbox\\\"\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend ForwardingSetting = tostring(parse_json(tostring(RawEventData.Parameters))[1].Name)\\n| extend ForwardingAddress = tostring(parse_json(tostring(RawEventData.Parameters))[1].Value)\\n| extend StoreandForward = tostring(parse_json(tostring(RawEventData.Parameters))[2].Name)\\n| extend ['Email Stored and Forwarded'] = tostring(parse_json(tostring(RawEventData.Parameters))[2].Value)\\n| where ForwardingSetting == \\\"ForwardingSmtpAddress\\\" and isnotempty(ForwardingAddress)\\n| extend ['Forwarding Email Address']=split(ForwardingAddress, \\\":\\\")[-1]\\n| project-away ForwardingSetting, StoreandForward\\n| project\\n    TimeGenerated,\\n    UserId,\\n    IPAddress, \\n    ['Forwarding Email Address'], \\n    ['Email Stored and Forwarded']\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nCloudAppEvents\\n| where ActionType == \\\"Set-Mailbox\\\"\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend ForwardingSetting = tostring(parse_json(tostring(RawEventData.Parameters))[1].Name)\\n| extend ForwardingAddress = tostring(parse_json(tostring(RawEventData.Parameters))[1].Value)\\n| extend StoreandForward = tostring(parse_json(tostring(RawEventData.Parameters))[2].Name)\\n| extend ['Email Stored and Forwarded'] = tostring(parse_json(tostring(RawEventData.Parameters))[2].Value)\\n| where ForwardingSetting == \\\"ForwardingSmtpAddress\\\" and isnotempty(ForwardingAddress)\\n| extend ['Forwarding Email Address']=split(ForwardingAddress, \\\":\\\")[-1]\\n| project-away ForwardingSetting, StoreandForward\\n| project\\n    Timestamp,\\n    UserId,\\n    IPAddress, \\n    ['Forwarding Email Address'], \\n    ['Email Stored and Forwarded']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-DetectMailboxForward.kql", "query_name": "DCA-DetectMailboxForward", "attributes": {}}, {"query": "\"//Create a pivot table of all actions taken during a risky sign in\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n//First find the SessionId of any medium or high risk sign ins (where risk level is 50 or 100)\\n//Advanced Hunting query, this query doesn't work in Sentinel because SessionId isn't sent over currently\\nlet riskysignins=\\n    AADSignInEventsBeta\\n    | where Timestamp > ago(7d)\\n    | where RiskLevelDuringSignIn in (50, 100)\\n    | distinct SessionId;\\nCloudAppEvents\\n| where Timestamp > ago(7d)\\n| extend RawEventData = parse_json(RawEventData)\\n| extend SessionId = RawEventData.SessionId\\n| where isnotempty(SessionId)\\n//Match on the risky sign in SessionId from above\\n| where SessionId in (riskysignins)\\n| extend Activity = strcat(Application, \\\" - \\\", ActionType)\\n//Create pivot table of all actions by each user\\n| evaluate pivot(Activity, count(), AccountDisplayName)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-ExchangeOnlineEventsduringRiskySignin.kql", "query_name": "DCA-ExchangeOnlineEventsduringRiskySignin", "attributes": {}}, {"query": "\"//Find new events in Defender for Cloud Apps seen in the last week vs the previously 90 days\\n\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//Microsoft Sentinel query\\n//First find all the activities from the last 90 days prior to this week\\nlet knownactivities=\\n    CloudAppEvents\\n    | where TimeGenerated > ago(90d) and TimeGenerated < ago (7d)\\n    | extend Operation = tostring(RawEventData.Operation)\\n    | extend UserId = tostring(RawEventData.UserId)\\n    | extend Workload = tostring(RawEventData.Workload)\\n    //Create a new column that adds workload and operation together to make the events more readable\\n    | extend Activity = strcat(Workload, \\\" - \\\", Operation)\\n    | distinct Activity;\\n//Find activities from the last week\\nCloudAppEvents\\n| where TimeGenerated > ago(7d)\\n| extend Operation = tostring(RawEventData.Operation)\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend Workload = tostring(RawEventData.Workload)\\n//Create a new column that adds workload and operation together to make the events more readable\\n| extend Activity = strcat(Workload, \\\" - \\\", Operation)\\n//Exclude activities we have already seen\\n| where Activity !in (knownactivities)\\n//Find the time the new activity was first seen and how many counts seen this week\\n| summarize ['First Time Seen']=min(TimeGenerated), Count=count() by Activity\\n| sort by Count desc \\n\\n\\n//Advanced Hunting query, only 30 days of data is retained in Advanced Hunting so we can instead look at events new in the last 3 compared to the prior 30, but you can change the times around if needed\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n//First find all the activities from the last 30 days prior to this week\\nlet knownactivities=\\n    CloudAppEvents\\n    | where Timestamp > ago(30d) and Timestamp < ago (3d)\\n    | extend Operation = tostring(RawEventData.Operation)\\n    | extend UserId = tostring(RawEventData.UserId)\\n    | extend Workload = tostring(RawEventData.Workload)\\n    //Create a new column that adds workload and operation together to make the events more readable\\n    | extend Activity = strcat(Workload, \\\" - \\\", Operation)\\n    | distinct Activity;\\n//Find activities from the last week\\nCloudAppEvents\\n| where Timestamp > ago(3d)\\n| extend Operation = tostring(RawEventData.Operation)\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend Workload = tostring(RawEventData.Workload)\\n//Create a new column that adds workload and operation together to make the events more readable\\n| extend Activity = strcat(Workload, \\\" - \\\", Operation)\\n//Exclude activities we have already seen\\n| where Activity !in (knownactivities)\\n//Find the time the new activity was first seen and how many counts seen this week\\n| summarize ['First Time Seen']=min(Timestamp), Count=count() by Activity\\n| sort by Count desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-FindNewEvents.kql", "query_name": "DCA-FindNewEvents", "attributes": {}}, {"query": "\"//Find emails that have been reported by your users as spam/phishing that have been rescanned and found to be genuine spam or phishing\\n\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//Microsoft Sentinel query\\nCloudAppEvents\\n| where ActionType == \\\"UserSubmission\\\"\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend RescanVerdict = tostring(parse_json(tostring(RawEventData.RescanResult)).RescanVerdict)\\n| extend RescanTimeTimestamp = tostring(parse_json(tostring(RawEventData.RescanResult)).Timestamp)\\n| extend Subject = tostring(RawEventData.Subject)\\n| extend P1Sender = tostring(RawEventData.P1Sender)\\n| extend P2Sender = tostring(RawEventData.P2Sender)\\n| where RescanVerdict != \\\"NotSpam\\\"\\n| project\\n    TimeGenerated,\\n    UserId,\\n    P1Sender,\\n    P2Sender,\\n    Subject,\\n    RescanVerdict,\\n    RescanTimeTimestamp\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n//Advanced Hunting query\\nCloudAppEvents\\n| where ActionType == \\\"UserSubmission\\\"\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend RescanVerdict = tostring(parse_json(tostring(RawEventData.RescanResult)).RescanVerdict)\\n| extend RescanTimeTimestamp = tostring(parse_json(tostring(RawEventData.RescanResult)).Timestamp)\\n| extend Subject = tostring(RawEventData.Subject)\\n| extend P1Sender = tostring(RawEventData.P1Sender)\\n| extend P2Sender = tostring(RawEventData.P2Sender)\\n| where RescanVerdict != \\\"NotSpam\\\"\\n| project\\n    Timestamp,\\n    UserId,\\n    P1Sender,\\n    P2Sender,\\n    Subject,\\n    RescanVerdict,\\n    RescanTimeTimestamp\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-FindUserSubmittedPhishingSpam.kql", "query_name": "DCA-FindUserSubmittedPhishingSpam", "attributes": {}}, {"query": "\"//Alert when the phishing status of a Microsoft Form is changed, this could be a sign one of your accounts has been compromised and being used to host malicious Forms\\n\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//Microsoft Sentinel query\\nCloudAppEvents\\n| where TimeGenerated > ago (7d)\\n| extend Operation = tostring(RawEventData.Operation)\\n| where Operation == \\\"UpdatePhishingStatus\\\"\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend Workload = tostring(RawEventData.Workload)\\n| extend FormStatus = tostring(parse_json(tostring(RawEventData.ActivityParameters)).FormPhishingStatus)\\n| extend FormId = tostring(RawEventData.FormId)\\n| extend FormName = tostring(RawEventData.FormName)\\n| where FormStatus == \\\"Auto Blocked\\\"\\n| project TimeGenerated, Operation, UserId, FormStatus, FormName, FormId\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nCloudAppEvents\\n| where Timestamp > ago (7d)\\n| extend Operation = tostring(RawEventData.Operation)\\n| where Operation == \\\"UpdatePhishingStatus\\\"\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend Workload = tostring(RawEventData.Workload)\\n| extend FormStatus = tostring(parse_json(tostring(RawEventData.ActivityParameters)).FormPhishingStatus)\\n| extend FormId = tostring(RawEventData.FormId)\\n| extend FormName = tostring(RawEventData.FormName)\\n| where FormStatus == \\\"Auto Blocked\\\"\\n| project Timestamp, Operation, UserId, FormStatus, FormName, FormId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-FormPhishingStatusChanged.kql", "query_name": "DCA-FormPhishingStatusChanged", "attributes": {}}, {"query": "\"//Alert when a user starts a paid trial of a M365 product\\n\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\nCloudAppEvents\\n| extend Operation = tostring(RawEventData.Operation)\\n| where Operation == \\\"StartAPaidTrial\\\"\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend LicenseDisplayName = tostring(RawEventData.LicenseDisplayName)\\n| extend Workload = tostring(RawEventData.Workload)\\n| project TimeGenerated, Operation, UserId, LicenseDisplayName, Workload\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-PaidTrialStarted.kql", "query_name": "DCA-PaidTrialStarted", "attributes": {}}, {"query": "\"//Create a pivot table of all actions in Defender for Cloud Apps by your privileged users over the last 7 days\\n//Lookup the IdentityInfo table for any users holding a privileged role\\n\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//Microsoft Sentinel query\\nlet privusers=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    //Add any roles that you are interested in auditing\\n    | where AssignedRoles has_any (\\\"Global Administrator\\\", \\\"Security Administrator\\\", \\\"SharePoint Administrator\\\")\\n    | distinct AccountUPN;\\nCloudAppEvents\\n| where TimeGenerated > ago(7d)\\n| extend Operation = tostring(RawEventData.Operation)\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend Workload = tostring(RawEventData.Workload)\\n//Create a new column that adds workload and operation together to make the events more readable\\n| extend Activity = strcat(Workload, \\\" - \\\", Operation)\\n| where UserId in~ (privusers)\\n//Create pivot table of all actions by each user\\n| evaluate pivot(Activity, count(), UserId)\\n\\n//Advanced hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nCloudAppEvents\\n| where Timestamp > ago(7d)\\n| extend Operation = tostring(RawEventData.Operation)\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend Workload = tostring(RawEventData.Workload)\\n//Advanced hunting doesn't retain role information about users, but you can add a list of users in manually to create a table\\n| where UserId in~ (\\\"admin1@domain.com\\\", \\\"admin2@domain.com\\\")\\n//Create a new column that adds workload and operation together to make the events more readable\\n| extend Activity = strcat(Workload, \\\" - \\\", Operation)\\n//Create pivot table of all actions by each user\\n| evaluate pivot(Activity, count(), UserId)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-PivotTableAdminActions.kql", "query_name": "DCA-PivotTableAdminActions", "attributes": {}}, {"query": "\"//Defender for Cloud Apps tracks administrative actions under the 'isAdminOperation' flag. This query will build a pivot table of all admin operations completed by your users\\n//Works in both Sentinel and Advanced Hunting\\n\\n//Data connector required for this query - Advanced Hunting license or M365 Defender - CloudAppEvents for Sentinel\\n\\nCloudAppEvents\\n| where IsAdminOperation == \\\"true\\\"\\n| where AccountType == \\\"Regular\\\"\\n| extend UserPrincipalName = tostring(RawEventData.UserId)\\n| evaluate pivot(ActionType, count(), UserPrincipalName)\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-PivotTableAdminOperations.kql", "query_name": "DCA-PivotTableAdminOperations", "attributes": {}}, {"query": "\"//Detect when a user flags a risky sign in within 8 hours of installing a service principal, could be a sign of OAuth consent phishing. This example uses 8 hours between events.\\n\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//Microsoft Sentinel query. This query could also use Azure AD audit logs as a trigger but this example uses Defender for Cloud App logs.\\nlet threshold=8;\\nCloudAppEvents\\n| where ActionType == \\\"Add service principal.\\\"\\n| where AccountType == \\\"Regular\\\"\\n| extend UserId = tostring(RawEventData.UserId)\\n| project\\n    ['Service Principal Install Time']=TimeGenerated,\\n    UserId,\\n    ['Service Principal Name']=ObjectName\\n| join kind=inner (\\n    AADUserRiskEvents\\n    | where DetectionTimingType == \\\"realtime\\\"\\n    | where RiskDetail !in (\\\"aiConfirmedSigninSafe\\\", \\\"userPerformedSecuredPasswordReset\\\")\\n    | project\\n        ['Risk Event Time']=TimeGenerated,\\n        UserId=UserPrincipalName,\\n        ['Risk Event IP']=IpAddress\\n    )\\n    on UserId\\n| extend ['Minutes Between Events']=datetime_diff(\\\"hour\\\", ['Service Principal Install Time'], ['Risk Event Time'])\\n| where ['Minutes Between Events'] < threshold\\n| project\\n    UserId,\\n    ['Risk Event Time'],\\n    ['Service Principal Install Time'],\\n    ['Minutes Between Events'],\\n    ['Risk Event IP'],\\n    ['Service Principal Name']\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nlet threshold=8;\\nCloudAppEvents\\n| where ActionType == \\\"Add service principal.\\\"\\n| where AccountType == \\\"Regular\\\"\\n| extend UserId = tostring(RawEventData.UserId)\\n| project\\n    ['Service Principal Install Time']=Timestamp,\\n    UserId,\\n    ['Service Principal Name']=ObjectName\\n| join kind=inner (\\n    AADSignInEventsBeta\\n    | where RiskLevelDuringSignIn in (50, 100)\\n    | project ['Risk Event Time']=Timestamp, UserId=AccountUpn, ['Risk Event IP']=IPAddress\\n    )\\n    on UserId\\n| extend ['Minutes Between Events']=datetime_diff(\\\"hour\\\", ['Service Principal Install Time'], ['Risk Event Time'])\\n| where ['Minutes Between Events'] < threshold\\n| project\\n    UserId,\\n    ['Risk Event Time'],\\n    ['Service Principal Install Time'],\\n    ['Minutes Between Events'],\\n    ['Risk Event IP'],\\n    ['Service Principal Name']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-PotentialConsentPhishing.kql", "query_name": "DCA-PotentialConsentPhishing", "attributes": {}}, {"query": "\"//Alert when a user triggers an Azure AD risk event followed closely by a mail forward being configured on their mailbox\\n\\n//Data connector required for this query - Azure Active Directory - AAD User Risk Events\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//Choose a threshold of the time between events you want to alert one, this example uses 240 minutes between risky event and mail forward creation\\nlet threshold=240;\\n//First find any real time risk events in Azure AD\\nAADUserRiskEvents\\n| where TimeGenerated > ago (7d)\\n| where DetectionTimingType == \\\"realtime\\\"\\n| where RiskDetail <> \\\"aiConfirmedSigninSafe\\\"\\n| project RiskTime=TimeGenerated, UserPrincipalName, RiskEventType, RiskyIP=IpAddress\\n| join kind=inner (\\n//Join to Defender for Cloud App events looking for email forward creation events\\n    CloudAppEvents\\n    | where TimeGenerated > ago (7d)\\n    | where ActionType == \\\"Set-Mailbox\\\"\\n    | extend UserId = tostring(RawEventData.UserId)\\n    | extend ForwardingSetting = tostring(parse_json(tostring(RawEventData.Parameters))[1].Name)\\n    | extend ForwardingAddress = tostring(parse_json(tostring(RawEventData.Parameters))[1].Value)\\n    | extend StoreandForward = tostring(parse_json(tostring(RawEventData.Parameters))[2].Name)\\n    | extend ['Email Stored and Forwarded'] = tostring(parse_json(tostring(RawEventData.Parameters))[2].Value)\\n    | where ForwardingSetting == \\\"ForwardingSmtpAddress\\\" and isnotempty(ForwardingAddress)\\n    | extend ['Forwarding Email Address']=split(ForwardingAddress, \\\":\\\")[-1]\\n    | project-away ForwardingSetting, StoreandForward\\n    | project\\n        MailForwardTime=TimeGenerated,\\n        UserId,\\n        MailForwardIP=IPAddress, ['Forwarding Email Address'], ['Email Stored and Forwarded']\\n    ) \\n    on $left.UserPrincipalName == $right.UserId\\n//Calculate the time between the two events and alert when less than the threshold\\n| extend ['Minutes Between Events']=datetime_diff(\\\"minute\\\", MailForwardTime, RiskTime)\\n| where ['Minutes Between Events'] < threshold\\n| project-away UserId\\n| project-reorder\\n    UserPrincipalName,\\n    RiskTime,\\n    MailForwardTime,\\n    ['Minutes Between Events'],\\n    ['Forwarding Email Address'],\\n    ['Email Stored and Forwarded'],\\n    RiskyIP,\\n    MailForwardIP,\\n    RiskEventType\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-RiskEventFollowedbyEmailForward.kql", "query_name": "DCA-RiskEventFollowedbyEmailForward", "attributes": {}}, {"query": "\"//Alert when a user flags an Azure AD risk event followed by creating or updating inbox rules within a short time frame\\n\\n//Data connector required for this query - Azure Active Directory - AAD User Risk Events\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//In this example it will detect when the two events are less than 120 minutes apart\\nAADUserRiskEvents\\n| where TimeGenerated > ago (1d)\\n| where DetectionTimingType == \\\"realtime\\\"\\n| where RiskDetail <> \\\"aiConfirmedSigninSafe\\\"\\n| project RiskTime=TimeGenerated, UserPrincipalName, RiskEventType, RiskyIP=IpAddress\\n| join kind=inner (\\n    CloudAppEvents\\n    | where TimeGenerated > ago (1d)\\n    | extend Operation = tostring(RawEventData.Operation)\\n    | where Operation in (\\\"New-InboxRule\\\", \\\"Set-InboxRule\\\")\\n    | extend UserId = tostring(RawEventData.UserId)\\n    | project RuleTime=TimeGenerated, UserId, MailForwardIP=IPAddress, ActivityObjects\\n    )\\n    on $left.UserPrincipalName == $right.UserId\\n| extend ['Minutes Between Events']=datetime_diff(\\\"minute\\\", RuleTime, RiskTime)\\n| where ['Minutes Between Events'] < 120\\n| project-away UserId\\n| project-reorder\\n    UserPrincipalName,\\n    RiskTime,\\n    RuleTime,\\n    ['Minutes Between Events'],\\n    RiskyIP,\\n    MailForwardIP,\\n    RiskEventType,\\n    ActivityObjects\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-RiskEventFollowedbyMailboxRuleChanges.kql", "query_name": "DCA-RiskEventFollowedbyMailboxRuleChanges", "attributes": {}}, {"query": "\"//Find when an app is installed into Teams using the Defender for Cloud App logs\\n\\n//Data connector required for this query - M365 Defender - CloudAppEvents\\n\\n//Microsoft Sentinel query\\nCloudAppEvents\\n| where Application == \\\"Microsoft Teams\\\"\\n| where ActionType == \\\"AppInstalled\\\"\\n| extend AppDistributionMode = tostring(RawEventData.AppDistributionMode)\\n| extend AzureADAppId = tostring(RawEventData.AzureADAppId)\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend AppName = tostring(RawEventData.AddOnName)\\n| project TimeGenerated, AppName, AzureADAppId, UserId, AppDistributionMode\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nCloudAppEvents\\n| where Application == \\\"Microsoft Teams\\\"\\n| where ActionType == \\\"AppInstalled\\\"\\n| extend AppDistributionMode = tostring(RawEventData.AppDistributionMode)\\n| extend AzureADAppId = tostring(RawEventData.AzureADAppId)\\n| extend UserId = tostring(RawEventData.UserId)\\n| extend AppName = tostring(RawEventData.AddOnName)\\n| project Timestamp, AppName, AzureADAppId, UserId, AppDistributionMode\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Cloud%20Apps/DCA-TeamsAppInstalled.kql", "query_name": "DCA-TeamsAppInstalled", "attributes": {}}, {"query": "\"//Searches OfficeActivity table for anomalies in download actions and then retrives all USB file copy events by those users over the last week\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n//Data connector required for this query - Office 365\\n\\nlet starttime = 7d;\\nlet timeframe = 30m;\\nlet operations = dynamic([\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\"]);\\nlet outlierusers=\\n    OfficeActivity\\n    | where TimeGenerated > ago(starttime)\\n    | where Operation in (['operations'])\\n    | extend UserPrincipalName = UserId\\n    | project TimeGenerated, UserPrincipalName\\n    | order by TimeGenerated\\n    | summarize Events=count()by UserPrincipalName, bin(TimeGenerated, timeframe)\\n    | summarize EventCount=make_list(Events), TimeGenerated=make_list(TimeGenerated) by UserPrincipalName\\n    | extend outliers=series_decompose_anomalies(EventCount, 3)\\n    | mv-expand TimeGenerated, EventCount, outliers\\n    | where outliers == 1\\n    | distinct UserPrincipalName;\\nlet id=\\n    IdentityInfo\\n    | where AccountUPN in (outlierusers)\\n    | where TimeGenerated > ago (21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountName\\n    | extend LoggedOnUser = AccountName\\n    | project LoggedOnUser, AccountUPN, JobTitle, EmployeeId, Country, City\\n    | join kind=inner \\n        (\\n        DeviceInfo\\n        | where TimeGenerated > ago (21d)\\n        | summarize arg_max(TimeGenerated, *) by DeviceName\\n        | extend LoggedOnUser = tostring(LoggedOnUsers[0].UserName)\\n        )\\n        on LoggedOnUser\\n    | project LoggedOnUser, AccountUPN, JobTitle, Country, DeviceName, EmployeeId;\\nDeviceEvents\\n| where TimeGenerated > ago(7d)\\n| join kind=inner id on DeviceName\\n| where ActionType == \\\"UsbDriveMounted\\\"\\n| extend DriveLetter = tostring(todynamic(AdditionalFields).DriveLetter)\\n| join kind=inner (DeviceFileEvents\\n    | where TimeGenerated > ago(7d)\\n    | extend FileCopyTime = TimeGenerated\\n    | where ActionType == \\\"FileCreated\\\"\\n    | parse FolderPath with DriveLetter '\\\\\\\\' *\\n    | extend DriveLetter = tostring(DriveLetter)\\n    )\\n    on DeviceId, DriveLetter\\n| extend FileCopied = FileName1\\n| distinct\\n    DeviceName,\\n    DriveLetter,\\n    FileCopied,\\n    LoggedOnUser,\\n    AccountUPN,\\n    JobTitle,\\n    EmployeeId,\\n    Country\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Anamoly-USBFileCopiesfromUserswithAnamolousDownloads.kql", "query_name": "Anamoly-USBFileCopiesfromUserswithAnamolousDownloads", "attributes": {}}, {"query": "\"//Find which of your accounts have logged onto the most devices with local admin credentials. These accounts are potential targets for lateral movement and privilege escalation\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceLogonEvents\\n| where TimeGenerated > ago(30d)\\n| project DeviceName, ActionType, LogonType, AdditionalFields, InitiatingProcessCommandLine, AccountName, IsLocalAdmin\\n| where ActionType == \\\"LogonSuccess\\\"\\n| where LogonType == \\\"Interactive\\\"\\n| where AdditionalFields.IsLocalLogon == true\\n| where InitiatingProcessCommandLine == \\\"lsass.exe\\\"\\n| summarize\\n    ['Local Admin Count']=dcountif(DeviceName,IsLocalAdmin == \\\"true\\\"),\\n    ['Local Admins']=make_set_if(DeviceName, IsLocalAdmin == \\\"true\\\")\\n    by AccountName\\n| sort by ['Local Admin Count'] desc  \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceLogonEvents\\n| where Timestamp > ago(30d)\\n| project DeviceName, ActionType, LogonType, AdditionalFields, InitiatingProcessCommandLine, AccountName, IsLocalAdmin\\n| where ActionType == \\\"LogonSuccess\\\"\\n| where LogonType == \\\"Interactive\\\"\\n| where IsLocalAdmin == true\\n| where InitiatingProcessCommandLine == \\\"lsass.exe\\\"\\n| summarize\\n    ['Local Admin Count']=dcountif(DeviceName,IsLocalAdmin == \\\"true\\\"),\\n    ['Local Admins']=make_set_if(DeviceName, IsLocalAdmin == \\\"true\\\")\\n    by AccountName\\n| sort by ['Local Admin Count'] desc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-AccountswithMostLocalAdmin.kql", "query_name": "Device-AccountswithMostLocalAdmin", "attributes": {}}, {"query": "\"//Summarize attack surface reduction audit hits for each device\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where TimeGenerated > ago (1d)\\n| where ActionType startswith \\\"Asr\\\"\\n| extend isAudit = tostring(AdditionalFields.IsAudit)\\n| where isAudit = true\\n| project\\n    TimeGenerated,\\n    ActionType,\\n    DeviceName,\\n    FileName,\\n    InitiatingProcessAccountDomain,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    InitiatingProcessParentFileName,\\n    ProcessTokenElevation\\n| summarize\\n    ['Total ASR audit hits']=count(),\\n    ['Distinct ASR audit rule hits']=dcount(ActionType),\\n    ['List of processes']=make_set(InitiatingProcessCommandLine)\\n    by DeviceName\\n| sort by ['Total ASR audit hits'] desc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-ASRAudit.kql", "query_name": "Device-ASRAudit", "attributes": {}}, {"query": "\"//Summarize which processes are triggering Lsass credential theft audit alerts in your attack surface reduction rules\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Summarize each device by which processes are triggering the audit alert\\nDeviceEvents\\n| where TimeGenerated > ago (7d)\\n| where ActionType == \\\"AsrLsassCredentialTheftAudited\\\"\\n| extend isAudit = tostring(AdditionalFields.IsAudit)\\n| where isAudit = true\\n| summarize LsassAudit=make_set(InitiatingProcessCommandLine) by DeviceName\\n| extend ['Count of Processes']=array_length(LsassAudit)\\n| sort by ['Count of Processes'] desc \\n\\n//Change the query to summarize each process by which devices are triggering the audit alert\\nDeviceEvents\\n| where TimeGenerated > ago (7d)\\n| where ActionType == \\\"AsrLsassCredentialTheftAudited\\\"\\n| extend isAudit = tostring(AdditionalFields.IsAudit)\\n| where isAudit = true\\n| summarize LsassAudit=make_set(DeviceName) by InitiatingProcessCommandLine\\n| extend ['Count of Devices']=array_length(LsassAudit)\\n| sort by ['Count of Devices'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-ASRLsassAudit.kql", "query_name": "Device-ASRLsassAudit", "attributes": {}}, {"query": "\"//Detects when you have audit hits on the \\\"Block all Office applications from creating child processes\\\" ASR rule. \\n//For instance if you want to audit the impact for the MSDT vulnerability - https://msrc-blog.microsoft.com/2022/05/30/guidance-for-cve-2022-30190-microsoft-support-diagnostic-tool-vulnerability/\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType == \\\"AsrOfficeChildProcessAudited\\\"\\n| where AdditionalFields.IsAudit == true\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    FileName,\\n    ProcessCommandLine,\\n    InitiatingProcessFileName\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where Timestamp > ago (30d)\\n| where ActionType == \\\"AsrOfficeChildProcessAudited\\\"\\n| project\\n    Timestamp,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    FileName,\\n    ProcessCommandLine,\\n    InitiatingProcessFileName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-ASROfficeChildProcessAudit.kql", "query_name": "Device-ASROfficeChildProcessAudit", "attributes": {}}, {"query": "\"//Provides a summary of Attack Surface Reduction rules, which ASR rules are being hit and by which processes\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceEvents\\n| where TimeGenerated > ago(30d)\\n| where ActionType startswith \\\"Asr\\\"\\n| where isnotempty(InitiatingProcessCommandLine)\\n| summarize ['ASR Hit Count']=count()by ActionType, InitiatingProcessCommandLine\\n| sort by ['ASR Hit Count'] desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where TimeGenerated > ago(30d)\\n| where ActionType startswith \\\"Asr\\\"\\n| where isnotempty(InitiatingProcessCommandLine)\\n| summarize ['ASR Hit Count']=count()by ActionType, InitiatingProcessCommandLine\\n| sort by ['ASR Hit Count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-ASRSummary.kql", "query_name": "Device-ASRSummary", "attributes": {}}, {"query": "\"// Searches device info table for non server operating systems then return any users who have logged on interactively as an admin as a set per device. Can add exclusions for known IT admin accounts\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nlet devices=\\n    DeviceInfo\\n    | where TimeGenerated > ago(30d)\\n    | where OSPlatform !contains \\\"Server\\\"\\n    | summarize arg_max(TimeGenerated, *) by DeviceName\\n    | project DeviceName;\\nDeviceLogonEvents\\n| where LogonType == \\\"Interactive\\\"\\n| where IsLocalAdmin == true\\n| join kind=inner devices on DeviceName\\n| where AccountName !contains \\\"admin\\\"\\n| summarize make_set(AccountName) by DeviceName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-CreateSetofLocalAdminsperDevice.kql", "query_name": "Device-CreateSetofLocalAdminsperDevice", "attributes": {}}, {"query": "\"//Visualizes potentially anomalous RDP connections from your devices.\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Starttime and timeframe = how many days of data to look at to build your data set and in what grouping, i.e 30 days of data over 2 hour periods.\\n//Threshold = the amount of total RDP connections required to be included in anomaly calculations. Reduces noise from low level anomalies, e.g going from 1 connection to 2.\\n//Sensitivity = adjust to make the query more or less sensitive, the higher the value, the greater the anomaly required to be detected.\\nlet starttime = 30d;\\nlet timeframe = 2h;\\nlet sensitivity = 3;\\nlet threshold = 5;\\nlet outlierdevices=\\n    DeviceNetworkEvents\\n    | where TimeGenerated > ago(starttime)\\n    | where LocalIPType == \\\"Private\\\"\\n    | where RemotePort == \\\"3389\\\"\\n    // Exclude Defender for Identity which uses RDP to map your network\\n    | where InitiatingProcessFileName <> \\\"Microsoft.Tri.Sensor.exe\\\"\\n    | project TimeGenerated, DeviceName\\n    | order by TimeGenerated\\n    | summarize RDPEvents=count()by DeviceName, bin(TimeGenerated, timeframe)\\n    | where RDPEvents > threshold\\n    | summarize EventCount=make_list(RDPEvents), TimeGenerated=make_list(TimeGenerated) by DeviceName\\n    | extend outliers=series_decompose_anomalies(EventCount, sensitivity)\\n    | mv-expand TimeGenerated, EventCount, outliers\\n    | where outliers == 1\\n//Optionally visualize the anomalies, remove everything below this line to just retrieve the data\\n    | distinct DeviceName;\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(starttime)\\n| where DeviceName in (outlierdevices)\\n| where LocalIPType == \\\"Private\\\"\\n| where RemotePort == \\\"3389\\\"\\n| where InitiatingProcessFileName <> \\\"Microsoft.Tri.Sensor.exe\\\"\\n| summarize RDPCount=count() by DeviceName, bin(TimeGenerated, timeframe)\\n| render timechart\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectAnomalousRDPConnections.kql", "query_name": "Device-DetectAnomalousRDPConnections", "attributes": {}}, {"query": "\"//Detects when certutil is used to connect to a public IP. This could indicate abuse of cert util, see - https://www.avira.com/en/blog/certutil-abused-by-attackers-to-spread-threats\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where TimeGenerated > ago (7d)\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    LocalIPType,\\n    LocalIP,\\n    RemoteIPType,\\n    RemoteIP,\\n    RemoteUrl,\\n    RemotePort\\n| where InitiatingProcessCommandLine contains \\\"certutil\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where TimeGenerated > ago (7d)\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    LocalIPType,\\n    LocalIP,\\n    RemoteIPType,\\n    RemoteIP,\\n    RemoteUrl,\\n    RemotePort\\n| where InitiatingProcessCommandLine contains \\\"certutil\\\"\\n| where RemoteIPType == \\\"Public\\\"\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectCertUtilConnectingExternally.kql", "query_name": "Device-DetectCertUtilConnectingExternally", "attributes": {}}, {"query": "\"//Detect when a backup is taken from Windows Credential manager\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceEvents\\n| where ActionType == \\\"CredentialsBackup\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    InitiatingProcessFileName,\\n    InitiatingProcessFolderPath\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where ActionType == \\\"CredentialsBackup\\\"\\n| project\\n    Timestamp,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    InitiatingProcessFileName,\\n    InitiatingProcessFolderPath\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectCredentialBackup.kql", "query_name": "Device-DetectCredentialBackup", "attributes": {}}, {"query": "\"//Finds encoded PowerShell commands and then decodes the encoded string\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Query modified from this post - https://techcommunity.microsoft.com/t5/microsoft-sentinel/finding-base64-encoded-commands/m-p/1891876\\nDeviceProcessEvents\\n| where ProcessCommandLine contains \\\"powershell\\\" or InitiatingProcessCommandLine contains \\\"powershell\\\"\\n| where ProcessCommandLine contains \\\"-enc\\\"\\n    or ProcessCommandLine contains \\\"-encodedcommand\\\"\\n    or InitiatingProcessCommandLine contains \\\"-enc\\\"\\n    or InitiatingProcessCommandLine contains \\\"-encodedcommand\\\"\\n//Extract encoded command using regex\\n//This query will only return results when the command can be matched via regex and decoded, if you run only the above lines it will return all encoded commands without attempting to match and decode\\n| extend EncodedCommand = extract(@'\\\\s+([A-Za-z0-9+/]{20}\\\\S+$)', 1, ProcessCommandLine)\\n| where EncodedCommand != \\\"\\\"\\n| extend DecodedCommand = base64_decode_tostring(EncodedCommand)\\n| where DecodedCommand != \\\"\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    ProcessCommandLine,\\n    EncodedCommand,\\n    DecodedCommand\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectEncodedPowershellandDecode.kql", "query_name": "Device-DetectEncodedPowershellandDecode", "attributes": {}}, {"query": "\"//Detects Teamviewer being used for the first time on a device\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Build a list of known devices using Teamviewer over the last 60 days\\nlet knowndevices=\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(60d) and TimeGenerated < ago(1d)\\n| project DeviceName, InitiatingProcessFileName, ActionType, LocalIPType, RemoteIPType\\n| where InitiatingProcessFileName contains \\\"teamviewer.exe\\\"\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where LocalIPType == \\\"Private\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| distinct DeviceName;\\n//Find new devices in the last day not in the known list\\n    DeviceNetworkEvents\\n    | where TimeGenerated > ago(1d)\\n    | where InitiatingProcessFileName contains \\\"teamviewer.exe\\\"\\n    | where ActionType == \\\"ConnectionSuccess\\\"\\n    | where LocalIPType == \\\"Private\\\"\\n    | where RemoteIPType == \\\"Public\\\"\\n    | where DeviceName !in (knowndevices)\\n    | distinct DeviceName\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectFirstTimeTeamviewerUsage.kql", "query_name": "Device-DetectFirstTimeTeamviewerUsage", "attributes": {}}, {"query": "\"//Detects successful TeamViewer connections from internal to external IP addresses\\n\\n//Data connector required for this query - M365 Defender - Device* tables or Advanced Hunting license\\n\\n//If TeamViewer is a sanctioned app then you will get lots of hits.\\n//Works in both Microsoft Sentinel and Advanced Hunting\\nDeviceNetworkEvents\\n| where InitiatingProcessFileName contains \\\"teamviewer.exe\\\"\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where LocalIPType == \\\"Private\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| project TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessFileName,\\n    LocalIP,\\n    RemoteIP\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectInternaltoExternalTeamviewer.kql", "query_name": "Device-DetectInternaltoExternalTeamviewer", "attributes": {}}, {"query": "\"// Searches for local admin log on events and then on process events that require full token elevation, query returns users who have logged on as an admin but not required admin access for 30 days\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n// Exclude a list of known processes in your environment that require TokenElevationTypeFull such as conhost, DismHost\\nlet process = dynamic([\\\"conhost.exe\\\", \\\"DismHost.exe\\\", \\\"git.exe\\\", \\\"HPUpdate.exe\\\"]);\\nlet devices =\\n    DeviceInfo\\n    | where TimeGenerated > ago(30d)\\n    | where OSPlatform !contains \\\"Server\\\"\\n    | summarize arg_max(TimeGenerated, *) by DeviceName\\n    | project DeviceName\\n    | join kind=inner ( \\n        DeviceLogonEvents\\n        | where TimeGenerated > ago (14d)\\n        | where LogonType == \\\"Interactive\\\"\\n// Exclude accounts such as service desk users who log on to complete admin work\\n        | where AccountName !contains \\\"admin\\\"\\n        | where IsLocalAdmin == true\\n        )\\n        on DeviceName\\n    | summarize arg_max (TimeGenerated, *) by DeviceName\\n    | project DeviceName, AccountName;\\nDeviceProcessEvents\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    AccountName,\\n    FileName,\\n    InitiatingProcessFileName,\\n    InitiatingProcessTokenElevation\\n| where TimeGenerated > ago(30d)\\n| where InitiatingProcessTokenElevation == \\\"TokenElevationTypeFull\\\"\\n| where FileName !in (process)\\n| join kind=rightanti devices on DeviceName, AccountName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectLocalAdminsWhoHaventElevated.kql", "query_name": "Device-DetectLocalAdminsWhoHaventElevated", "attributes": {}}, {"query": "\"//Detect allowed RDP connections from private to public networks\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == \\\"3389\\\"\\n| where LocalIPType == \\\"Private\\\" and RemoteIPType == \\\"Public\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemoteUrl\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == \\\"3389\\\"\\n| where LocalIPType == \\\"Private\\\" and RemoteIPType == \\\"Public\\\"\\n| project\\n    Timestamp,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemoteUrl\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectLocaltoPublicRDP.kql", "query_name": "Device-DetectLocaltoPublicRDP", "attributes": {}}, {"query": "\"//Detect when a local user account is created on an endpoint\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceEvents\\n| where TimeGenerated > ago(7d)\\n| where ActionType == \\\"UserAccountCreated\\\"\\n//Exclude defaultuser1 which is created by Windows through different processes \\n| where AccountName != \\\"defaultuser1\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    ['Account Created Name']=AccountName,\\n    Actor=InitiatingProcessAccountName\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where Timestamp > ago(7d)\\n| where ActionType == \\\"UserAccountCreated\\\"\\n//Exclude defaultuser1 which is created by Windows through different processes \\n| where AccountName != \\\"defaultuser1\\\"\\n| project\\n    Timestamp,\\n    DeviceName,\\n    ['Account Created Name']=AccountName,\\n    Actor=InitiatingProcessAccountName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectLocalUserCreated.kql", "query_name": "Device-DetectLocalUserCreated", "attributes": {}}, {"query": "\"//When a Defender for Endpoint alert is triggered, search for the most recent interactive logon to the device prior to the alert.\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\n//Also returns if that user is a local admin on the device.\\nlet timeframe = 48h;\\nSecurityAlert\\n| where TimeGenerated > ago(timeframe)\\n| where ProviderName == \\\"MDATP\\\"\\n| project AlertTime=TimeGenerated, DeviceName=CompromisedEntity, AlertName\\n| join kind=inner (\\n    DeviceLogonEvents\\n    | project\\n        TimeGenerated,\\n        LogonType,\\n        ActionType,\\n        InitiatingProcessCommandLine,\\n        IsLocalAdmin,\\n        AccountName,\\n        DeviceName\\n    | where LogonType in (\\\"Interactive\\\", \\\"RemoteInteractive\\\")\\n    | where ActionType == \\\"LogonSuccess\\\"\\n    | where InitiatingProcessCommandLine == \\\"lsass.exe\\\"\\n    )\\n    on DeviceName\\n| where (AlertTime - TimeGenerated) between (0min .. timeframe)\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| project\\n    LogonTime=TimeGenerated,\\n    AlertTime,\\n    AlertName,\\n    DeviceName,\\n    AccountName,\\n    IsLocalAdmin\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectLogonsPriortoMDEAlert.kql", "query_name": "Device-DetectLogonsPriortoMDEAlert", "attributes": {}}, {"query": "\"//Detect when an Excel macro connects to the internet. \\n//Some IPs returned shown may be Microsoft telemetry but these events are still worth investigating.\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where InitiatingProcessFileName contains \\\"excel.exe\\\"\\n| where InitiatingProcessCommandLine contains \\\".xlsm\\\" or InitiatingProcessCommandLine contains \\\".xltm\\\"\\n//Exclude Microsoft telemetry endpoints \\n| where RemoteUrl !endswith \\\"outlook.com\\\" \\n    and RemoteUrl !endswith \\\"office.com\\\"\\n    and RemoteUrl !endswith \\\"microsoft.com\\\"\\n    and RemoteUrl !endswith \\\"office365.com\\\"\\n    and RemoteUrl !endswith \\\"live.com\\\"\\n    and RemoteUrl !endswith \\\"office.net\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemotePort,\\n    RemoteUrl\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where InitiatingProcessFileName contains \\\"excel.exe\\\"\\n| where InitiatingProcessCommandLine contains \\\".xlsm\\\" or InitiatingProcessCommandLine contains \\\".xltm\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n//Exclude Microsoft telemetry endpoints \\n| where RemoteUrl !endswith \\\"outlook.com\\\" \\n    and RemoteUrl !endswith \\\"office.com\\\"\\n    and RemoteUrl !endswith \\\"microsoft.com\\\"\\n    and RemoteUrl !endswith \\\"office365.com\\\"\\n    and RemoteUrl !endswith \\\"live.com\\\"\\n    and RemoteUrl !endswith \\\"office.net\\\"\\n| project\\n    Timestamp,\\n    DeviceName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemotePort,\\n    RemoteUrl\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectMacroConnectingtoInternet.kql", "query_name": "Device-DetectMacroConnectingtoInternet", "attributes": {}}, {"query": "\"//Lookup Identity info table to find the most recent device a user has logged onto and any macro usage from that device and return identity info\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet id=\\n    IdentityInfo\\n    | where TimeGenerated > ago (21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountName\\n    | extend LoggedOnUser = AccountName\\n    | project LoggedOnUser, AccountUPN, JobTitle, EmployeeId, Country, City\\n    | join kind=inner (\\n        DeviceInfo\\n        | where TimeGenerated > ago (21d)\\n        | summarize arg_max(TimeGenerated, *) by DeviceName\\n        | extend LoggedOnUser = tostring(LoggedOnUsers[0].UserName)\\n        )\\n        on LoggedOnUser\\n    | project LoggedOnUser, AccountUPN, JobTitle, Country, DeviceName, EmployeeId;\\nDeviceProcessEvents\\n| join kind=inner id on DeviceName\\n| where TimeGenerated > ago (21d)\\n| where InitiatingProcessFileName == \\\"EXCEL.EXE\\\"\\n| where InitiatingProcessCommandLine contains \\\".xlsm\\\" or InitiatingProcessCommandLine contains \\\".xltm\\\"\\n| extend Process = InitiatingProcessFileName\\n| extend Command = InitiatingProcessCommandLine\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    LoggedOnUser,\\n    AccountUPN,\\n    Process,\\n    Command,\\n    JobTitle,\\n    EmployeeId,\\n    SHA1,\\n    SHA256\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectMacroUsage.kql", "query_name": "Device-DetectMacroUsage", "attributes": {}}, {"query": "\"//Detect when the same IP attempts to brute force a remote connection or attempts to connect to multiple devices and fails over a short time period\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceLogonEvents\\n| where TimeGenerated > ago (1d)\\n| where LogonType == \\\"RemoteInteractive\\\"\\n| where ActionType == \\\"LogonFailed\\\"\\n| summarize\\n    ['Count of logon attempts']=count(),\\n    ['Count of distinct devices']=dcount(DeviceName),\\n    ['List of devices']=make_set(DeviceName)\\n    by RemoteIP, bin(TimeGenerated, 1h)\\n| where ['Count of distinct devices'] >= 3 or ['Count of logon attempts'] >= 10\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceLogonEvents\\n| where Timestamp > ago (1d)\\n| where LogonType == \\\"RemoteInteractive\\\"\\n| where ActionType == \\\"LogonFailed\\\"\\n| summarize\\n    ['Count of logon attempts']=count(),\\n    ['Count of distinct devices']=dcount(DeviceName),\\n    ['List of devices']=make_set(DeviceName)\\n    by RemoteIP, bin(Timestamp, 1h)\\n| where ['Count of distinct devices'] >= 3 or ['Count of logon attempts'] >= 10\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectMultipleFailedRemoteLogons.kql", "query_name": "Device-DetectMultipleFailedRemoteLogons", "attributes": {}}, {"query": "\"//Detect when the same device attempts to connect to multiple devices and is denied within a short time frame\\n//This example will alert when the same device attempts to connect to three or more different devices in 30 minutes\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceEvents\\n| where ActionType == \\\"FirewallInboundConnectionBlocked\\\"\\n| summarize\\n    ['Count of Devices']=dcount(DeviceName),\\n    ['List of Devices']=make_set(DeviceName)\\n    by RemoteIP, bin(TimeGenerated, 30m)\\n| where ['Count of Devices'] >= 3\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where ActionType == \\\"FirewallInboundConnectionBlocked\\\"\\n| summarize\\n    ['Count of Devices']=dcount(DeviceName),\\n    ['List of Devices']=make_set(DeviceName)\\n    by RemoteIP, bin(Timestamp, 30m)\\n| where ['Count of Devices'] >= 3\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectPotentialNetworkRecon.kql", "query_name": "Device-DetectPotentialNetworkRecon", "attributes": {}}, {"query": "\"//Detect successful internal to public connections using Putty\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where LocalIPType == \\\"Private\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| where InitiatingProcessCommandLine contains \\\"putty.exe\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    LocalIP,\\n    RemoteIP,\\n    RemoteUrl,\\n    RemotePort\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where LocalIPType == \\\"Private\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| where InitiatingProcessCommandLine contains \\\"putty.exe\\\"\\n| project\\n    Timestamp,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    LocalIP,\\n    RemoteIP,\\n    RemoteUrl,\\n    RemotePort\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectPuttyConnectingPublic.kql", "query_name": "Device-DetectPuttyConnectingPublic", "attributes": {}}, {"query": "\"//Search for devices connecting to multiple IP addresses via RDP witin a time window and alert when over a particular threshold\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nlet timerange=1d;\\nlet window=20m;\\nlet threshold=5;\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(timerange)\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == \\\"3389\\\"\\n// Exclude Defender for Identity which uses RDP to map your network\\n| where InitiatingProcessFileName <> \\\"Microsoft.Tri.Sensor.exe\\\"\\n| summarize ['Target Device List']=make_set(RemoteIP), ['Count of Devices']=dcount(RemoteIP) by bin(TimeGenerated, window), DeviceName\\n| where ['Count of Devices'] > threshold\\n| sort by ['Count of Devices'] desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectRDPRecon.kql", "query_name": "Device-DetectRDPRecon", "attributes": {}}, {"query": "\"//Detect when a user or process attempts to tamper with Defender for Endpoint registry settings\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where ActionType == \\\"TamperingAttempt\\\"\\n| extend OriginalRegistryValue = tostring(AdditionalFields.OriginalValue)\\n| extend Status = tostring(AdditionalFields.Status)\\n| extend TamperingAction = tostring(AdditionalFields.TamperingAction)\\n| extend AttemptedRegistryValue = tostring(AdditionalFields.TamperingAttemptedValue)\\n| extend TargetRegistryKey = tostring(AdditionalFields.Target)\\n| where TamperingAction == \\\"RegistryModification\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    TamperingAction,\\n    Status,\\n    OriginalRegistryValue,\\n    AttemptedRegistryValue,\\n    TargetRegistryKey,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectRegistryTampering.kql", "query_name": "Device-DetectRegistryTampering", "attributes": {}}, {"query": "\"//Detect when a user clears the security event log on one of your devices\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where ActionType == \\\"SecurityLogCleared\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountDomain,\\n    InitiatingProcessAccountName\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where ActionType == \\\"SecurityLogCleared\\\"\\n| project\\n    Timestamp,\\n    DeviceName,\\n    InitiatingProcessAccountDomain,\\n    InitiatingProcessAccountName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectSecurityLogCleared.kql", "query_name": "Device-DetectSecurityLogCleared", "attributes": {}}, {"query": "\"//Detect when a user mounts an ISO file and then within 20 minutes launches a browser. These events could be unrelated because a BrowserLaunchedToOpenUrl event doesn't confirm if the lnk file was in the ISO file. \\n//The detection is just based on time between mounting an ISO file and then launching a URL.\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\n//Find events where an ISO file is mounted by detecting the creation of a .iso.lnk file\\nDeviceFileEvents\\n| where TimeGenerated > ago(1d)\\n| where ActionType == \\\"FileCreated\\\"\\n//This may create some false positives with files named iso.lnk at the end like summary-ciso.lnk\\n| where FileName endswith \\\"iso.lnk\\\"\\n| project\\n    ISOMountTime=TimeGenerated,\\n    DeviceName,\\n    FileName,\\n    FolderPath,\\n    InitiatingProcessAccountName\\n//Join to our DeviceEvents where a browser is opened to launch a URL\\n| join kind=inner(\\n    DeviceEvents\\n    | where TimeGenerated > ago(1d)\\n    | where ActionType == \\\"BrowserLaunchedToOpenUrl\\\"\\n    //Find only RemoteURLs that are web sites\\n    | where RemoteUrl startswith \\\"http\\\"\\n    | project\\n        URLOpenTime=TimeGenerated,\\n        DeviceName,\\n        InitiatingProcessAccountName,\\n        RemoteIP,\\n        RemoteUrl,\\n        RemotePort\\n    )\\n    on DeviceName, InitiatingProcessAccountName\\n//Find browser opened to URL events that happened within 20 minutes of the ISO file being mounted\\n| where URLOpenTime between ((ISOMountTime - timespan(0min)) .. (ISOMountTime + timespan(20min)))\\n| extend ['ISO FileName'] = trim(@\\\".lnk\\\", FileName)\\n| project\\n    ISOMountTime,\\n    URLOpenTime,\\n    ['ISO FileName'],\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    RemoteUrl,\\n    RemoteIP,\\n    RemotePort\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceFileEvents\\n| where Timestamp > ago(1d)\\n| where ActionType == \\\"FileCreated\\\"\\n//This may create some false positives with files named iso.lnk at the end like summary-ciso.lnk\\n| where FileName endswith \\\"iso.lnk\\\"\\n| project\\n    ISOMountTime=Timestamp,\\n    DeviceName,\\n    FileName,\\n    FolderPath,\\n    InitiatingProcessAccountName\\n//Join to our DeviceEvents where a browser is opened to launch a URL\\n| join kind=inner(\\n    DeviceEvents\\n    | where Timestamp > ago(1d)\\n    | where ActionType == \\\"BrowserLaunchedToOpenUrl\\\"\\n    //Find only RemoteURLs that are web sites\\n    | where RemoteUrl startswith \\\"http\\\"\\n    | project\\n        URLOpenTime=Timestamp,\\n        DeviceName,\\n        InitiatingProcessAccountName,\\n        RemoteIP,\\n        RemoteUrl,\\n        RemotePort\\n    )\\n    on DeviceName, InitiatingProcessAccountName\\n//Find browser opened to URL events that happened within 20 minutes of the ISO file being mounted\\n| where URLOpenTime between ((ISOMountTime - timespan(0min)) .. (ISOMountTime + timespan(20min)))\\n| extend ['ISO FileName'] = trim(@\\\".lnk\\\", FileName)\\n| project\\n    ISOMountTime,\\n    URLOpenTime,\\n    ['ISO FileName'],\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    RemoteUrl,\\n    RemoteIP,\\n    RemotePort\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-DetectURLopenedfromISOfile.kql", "query_name": "Device-DetectURLopenedfromISOfile", "attributes": {}}, {"query": "\"//Detects a user that downloaded a file from O365 and then wrote the same file to USB, matches on both filename and the user\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n//Data connector required for this query - Office 365\\n\\nlet filedownloads=\\n    OfficeActivity\\n    | where TimeGenerated > ago(1d)\\n    | extend DownloadTime = TimeGenerated\\n    | where Operation in ('FileSyncDownloadedFull', 'FileDownloaded')\\n    | project DownloadTime, UserId, SourceFileName\\n    | join kind=inner\\n        (\\n        IdentityInfo\\n        | where TimeGenerated > ago (21d)\\n        | summarize arg_max(TimeGenerated, *) by AccountUPN) \\n        on $left.UserId == $right.AccountUPN\\n    | project DownloadTime, SourceFileName, UserId, AccountName\\n;\\nDeviceEvents\\n| where TimeGenerated > ago(1d)\\n| where ActionType == \\\"UsbDriveMounted\\\"\\n| extend DriveLetter = tostring(todynamic(AdditionalFields).DriveLetter)\\n| join kind=inner \\n    (\\n    DeviceFileEvents\\n    | where TimeGenerated > ago(1d)\\n    | extend FileCopyTime = TimeGenerated\\n    | where ActionType == \\\"FileCreated\\\"\\n    | join kind=inner filedownloads\\n        on\\n        $left.FileName == $right.SourceFileName,\\n        $left.RequestAccountName == $right.AccountName\\n    | parse FolderPath with DriveLetter '\\\\\\\\' *\\n    | extend DriveLetter = tostring(DriveLetter)\\n    ) \\n    on DeviceId, DriveLetter\\n| extend FileCopied = FileName1\\n| extend User = AccountName1\\n| distinct DeviceName, DriveLetter, FileCopied, User\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FileDownloadedfromO365thenCopiedtoUSB.kql", "query_name": "Device-FileDownloadedfromO365thenCopiedtoUSB", "attributes": {}}, {"query": "\"//Lookup members of a specific group and find any USB file copies completed by those users\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet id=\\n    IdentityInfo\\n    | where GroupMembership has \\\"Group Name\\\"\\n    | where TimeGenerated > ago (21d)\\n    | summarize arg_max(TimeGenerated, *) by AccountName\\n    | extend LoggedOnUser = AccountName\\n    | project LoggedOnUser, AccountUPN, JobTitle, EmployeeId, Country, City\\n    | join kind=inner (\\n        DeviceInfo\\n        | where TimeGenerated > ago (21d)\\n        | summarize arg_max(TimeGenerated, *) by DeviceName\\n        | extend LoggedOnUser = tostring(LoggedOnUsers[0].UserName)\\n        )\\n        on LoggedOnUser\\n    | project LoggedOnUser, AccountUPN, JobTitle, Country, DeviceName, EmployeeId;\\nDeviceEvents\\n| where TimeGenerated > ago(30d)\\n| join kind=inner id on DeviceName\\n| where ActionType == \\\"UsbDriveMounted\\\"\\n| extend DriveLetter = tostring(todynamic(AdditionalFields).DriveLetter)\\n| join kind=inner (DeviceFileEvents\\n    | where TimeGenerated > ago(30d)\\n    | extend FileCopyTime = TimeGenerated\\n    | where ActionType == \\\"FileCreated\\\"\\n    | parse FolderPath with DriveLetter '\\\\\\\\' *\\n    | extend DriveLetter = tostring(DriveLetter)\\n    )\\n    on DeviceId, DriveLetter\\n| distinct\\n    TimeGenerated,\\n    DeviceName,\\n    DriveLetter,\\n    FileName1,\\n    LoggedOnUser,\\n    AccountUPN,\\n    JobTitle,\\n    EmployeeId,\\n    Country\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FilesCopiedtoUSBCertainGroups.kql", "query_name": "Device-FilesCopiedtoUSBCertainGroups", "attributes": {}}, {"query": "\"//Summarize the machines in your environment that are triggering the most total ASR and distinct ASR rule events\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType startswith \\\"Asr\\\"\\n| summarize\\n    ['Total ASR hit count']=count(),\\n    ['Distinct ASR rules count']=dcount(ActionType),\\n    ['List of ASR rules triggered']=make_set(ActionType),\\n    ['List of processess triggering ASR']=make_set(InitiatingProcessCommandLine)\\n    by DeviceName\\n| sort by ['Total ASR hit count'] desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where Timestamp > ago (30d)\\n| where ActionType startswith \\\"Asr\\\"\\n| summarize\\n    ['Total ASR hit count']=count(),\\n    ['Distinct ASR rules count']=dcount(ActionType),\\n    ['List of ASR rules triggered']=make_set(ActionType),\\n    ['List of processess triggering ASR']=make_set(InitiatingProcessCommandLine)\\n    by DeviceName\\n| sort by ['Total ASR hit count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindDevicesMostASR.kql", "query_name": "Device-FindDevicesMostASR", "attributes": {}}, {"query": "\"//Find devices that have stopped sending network events over the last 30 days, retrieve last event time and calculate the days since last event\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceNetworkEvents\\n| project TimeGenerated, DeviceName\\n| where TimeGenerated > ago(365d)\\n| summarize arg_max(TimeGenerated, DeviceName) by DeviceName\\n| project DeviceName, ['Days Since Last Event'] = datetime_diff('day', now(), TimeGenerated), ['Last Event Time']=TimeGenerated\\n| where ['Days Since Last Event'] > 30\\n| sort by ['Days Since Last Event'] desc   \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindDevicesNoLongerSendingEvents.kql", "query_name": "Device-FindDevicesNoLongerSendingEvents", "attributes": {}}, {"query": "\"//Find the information of any devices found by Defender network device discovery that are able to onboarded to Defender\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n//This query only works in Advanced Hunting\\nDeviceInfo\\n| summarize arg_max(Timestamp, *) by DeviceId \\n| where OnboardingStatus == \\\"Can be onboarded\\\"\\n| where isempty(MergedToDeviceId)\\n| project ['Time last seen']=Timestamp, DeviceName, DeviceId, OSDistribution, OSVersion, DeviceCategory, IsAzureADJoined, JoinType\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindDevicesToOnboard.kql", "query_name": "Device-FindDevicesToOnboard", "attributes": {}}, {"query": "\"//Find the devices in your environment triggering the most Defender SmartScreen events\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType startswith \\\"SmartScreen\\\"\\n| extend Experience = tostring(AdditionalFields.Experience)\\n| where isnotempty(Experience)\\n| summarize\\n    ['Count of SmartScreen Events']=count(),\\n    ['List of SmartScreen Event Types']=make_set(Experience)\\n    by DeviceName\\n| sort by ['Count of SmartScreen Events'] desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where Timestamp > ago(30d)\\n| where ActionType startswith \\\"SmartScreen\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend Experience = tostring(AF.Experience)\\n| where isnotempty(Experience)\\n| summarize\\n    ['Count of SmartScreen Events']=count(),\\n    ['List of SmartScreen Event Types']=make_set(Experience)\\n    by DeviceName\\n| sort by ['Count of SmartScreen Events'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindDeviceswithmostSmartScreenEvents.kql", "query_name": "Device-FindDeviceswithmostSmartScreenEvents", "attributes": {}}, {"query": "\"//Find devices in your environment that have never triggered an ASR rule, you can likely turn on ASR for these devices without causing issues for the users.\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\n//First find devices that have triggered an Attack Surface Reduction rule, either block or in audit mode.\\nlet asrdevices=\\n    DeviceEvents\\n    | where TimeGenerated > ago (30d)\\n    | where ActionType startswith \\\"Asr\\\"\\n    | distinct DeviceName;\\n//Find all devices and exclude those that have previously triggered a rule\\nDeviceInfo\\n| where TimeGenerated > ago (30d)\\n| where OSPlatform startswith \\\"Windows\\\"\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| where DeviceName !in (asrdevices)\\n| project\\n    ['Time Last Seen']=TimeGenerated,\\n    DeviceId,\\n    DeviceName,\\n    OSPlatform,\\n    OSVersion,\\n    LoggedOnUsers\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n//First find devices that have triggered an Attack Surface Reduction rule, either block or in audit mode.\\nlet asrdevices=\\n    DeviceEvents\\n    | where Timestamp > ago (30d)\\n    | where ActionType startswith \\\"Asr\\\"\\n    | distinct DeviceName;\\n//Find all devices and exclude those that have previously triggered a rule\\nDeviceInfo\\n| where Timestamp > ago (30d)\\n| where OSPlatform startswith \\\"Windows\\\"\\n| summarize arg_max(Timestamp, *) by DeviceName\\n| where DeviceName  !in (asrdevices)\\n| project\\n    ['Time Last Seen']=Timestamp,\\n    DeviceId,\\n    DeviceName,\\n    OSPlatform,\\n    OSVersion,\\n    LoggedOnUsers\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindDeviceswithnoASR.kql", "query_name": "Device-FindDeviceswithnoASR", "attributes": {}}, {"query": "\"// Devices without successful AV scan in the last n days\\n// As of 27.01.2022 only the following platforms are support\\n// Windows10, Windows10WVD, Windows11, WindowsServer2012R2, WindowsServer2016, WindowsServer2019, WindowsServer2022\\n\\n//Data connector required for this query - Advanced Hunting license\\n//Query only works in Advanced Hunting\\n\\nlet Timerange = 14d;\\nDeviceInfo\\n| where OnboardingStatus == \\\"Onboarded\\\"\\n| where isnotempty( OSVersion)\\n| where Timestamp > ago(Timerange)\\n| summarize LastSeen = arg_max(Timestamp, *) by DeviceId\\n| extend LastSuccessfulAVScan = strcat(\\\"Not in the last \\\",format_timespan(Timerange,'d'),\\\" days\\\")\\n| project LastSeen, DeviceId, DeviceName, MachineGroup, OSPlatform, OSVersion, DeviceType, LastSuccessfulAVScan, JoinType\\n// use rightsemi to return all devices that had a successful AV scan in the last n days\\n// use leftanti to return all devices that NOT had a successful AV scan in the last n days\\n| join kind=leftanti (\\n    DeviceEvents\\n    | where ActionType == \\\"AntivirusScanCompleted\\\"\\n    | where Timestamp > ago(Timerange)\\n    | summarize LastSuccessfulAVScan = max(Timestamp) by DeviceName, DeviceId\\n    | join kind=innerunique (\\n        DeviceInfo\\n        | where isnotempty( OSVersion )\\n    ) on DeviceId\\n    | summarize LastSeen = arg_max(Timestamp,*) by DeviceName\\n    | project LastSeen, DeviceId, DeviceName, MachineGroup, OSPlatform, OSVersion, DeviceType, LastSuccessfulAVScan, JoinType\\n) on DeviceId\\n| where OSPlatform in (\\\"Windows10\\\",\\\"Windows10WVD\\\",\\\"Windows11\\\",\\\"WindowsServer2012R2\\\",\\\"WindowsServer2016\\\",\\\"WindowsServer2019\\\",\\\"WindowsServer2022\\\")\\n| sort by DeviceType, MachineGroup, OSPlatform\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindDeviceWithoutCurrentAVScan.kql", "query_name": "Device-FindDeviceWithoutCurrentAVScan", "attributes": {}}, {"query": "\"//Find potential network recon on one of your devices by detecting when it connects to more than 10 common ports used to map your network and 10 distinct endpoints within an hour\\n//Use that data to then return more details on each IP that device attempted to connect to\\n\\n//Data connector required for this query - M365 Defender - Device* tables or Advanced Hunting license\\n\\n//Query works in both Sentinel and Advanced Hunting\\n//First look for devices connecting to 10 or more common ports and 10 or more devices within an hour\\nlet devices=\\n    DeviceNetworkEvents\\n    | where ActionType in (\\\"ConnectionSuccess\\\", \\\"ConnectionFailed\\\")\\n    | where RemotePort in (\\\"21\\\", \\\"22\\\", \\\"25\\\", \\\"53\\\", \\\"80\\\", \\\"110\\\", \\\"123\\\", \\\"139\\\", \\\"389\\\", \\\"443\\\", \\\"445\\\", \\\"636\\\", \\\"993\\\", \\\"995\\\", \\\"8080\\\")\\n    | where RemoteIPType == \\\"Private\\\"\\n    | summarize\\n        ['Total connection count']=count(),\\n        ['Count of distinct ports']=dcount(RemotePort),\\n        ['List of ports']=make_set(RemotePort),\\n        ['Count of remote IPs']=dcount(RemoteIP),\\n        ['List of remote IPs']=make_set(RemoteIP)\\n        by DeviceName, bin(TimeGenerated, 1h)\\n    | where ['Count of distinct ports'] >= 10 and ['Count of remote IPs'] >= 10\\n    | distinct DeviceName;\\n//Take those devices and return more detail on each attempt\\nDeviceNetworkEvents\\n| where ActionType in (\\\"ConnectionSuccess\\\", \\\"ConnectionFailed\\\")\\n| where RemotePort in (\\\"21\\\", \\\"22\\\", \\\"25\\\", \\\"53\\\", \\\"80\\\", \\\"110\\\", \\\"123\\\", \\\"139\\\", \\\"389\\\", \\\"443\\\", \\\"445\\\", \\\"636\\\", \\\"993\\\", \\\"995\\\", \\\"8080\\\")\\n| where DeviceName in (devices)\\n| where RemoteIPType == \\\"Private\\\"\\n| summarize\\n    ['Total connection count']=count(),\\n    ['Count of distinct ports']=dcount(RemotePort),\\n    ['List of ports']=make_set(RemotePort)\\n    by DeviceName, RemoteIP, ActionType\\n| project-reorder\\n    DeviceName,\\n    ActionType,\\n    RemoteIP,\\n    ['Total connection count'],\\n    ['Count of distinct ports'],\\n    ['List of ports']\\n| sort by DeviceName desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindNetworkRecon.kql", "query_name": "Device-FindNetworkRecon", "attributes": {}}, {"query": "\"//Find new devices onboarded to Defender in the last month\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nlet knowndevices=\\n    DeviceNetworkInfo\\n    | where TimeGenerated > ago (180d) and TimeGenerated < ago(30d)\\n    | distinct DeviceName;\\nDeviceNetworkInfo\\n| where TimeGenerated > ago (30d)\\n| summarize arg_min(TimeGenerated, *) by DeviceName\\n| where DeviceName !in (knowndevices)\\n| project TimeGenerated, DeviceName\\n| extend ['Days Since First Seen']=datetime_diff(\\\"day\\\", now(), TimeGenerated)\\n| project ['Time First Seen']=TimeGenerated, ['Days Since First Seen'], DeviceName\\n| sort by ['Days Since First Seen'] desc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindNewDevices.kql", "query_name": "Device-FindNewDevices", "attributes": {}}, {"query": "\"//Find any new DeviceEvents found in your environment over the last week compared to the last 6 months\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//First find existing action types over the six months\\nlet knownevents=\\n    DeviceEvents\\n    | where TimeGenerated > ago (180d) and TimeGenerated < ago(7d)\\n    | distinct ActionType;\\n//Find new action types in the last week, the time they were first seen and how many counts seen this week\\nDeviceEvents\\n| where TimeGenerated > ago(7d)\\n| where ActionType !in (knownevents)\\n| summarize ['First Time Seen']=min(TimeGenerated), Count=count() by ActionType\\n| sort by Count desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindNewEvents.kql", "query_name": "Device-FindNewEvents", "attributes": {}}, {"query": "\"//Find which users clicked on a phishing link after it was detected by Defender for Office 365\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where ProviderName == \\\"OATP\\\"\\n| where AlertName in (\\\"Email messages containing malicious URL removed after delivery\\u200b\\\",\\\"Email messages containing phish URLs removed after delivery\\\")\\n| extend x = todynamic(Entities)\\n| mv-expand x\\n| parse-where x with * '\\\"Url\\\":\\\"' MaliciousURL '\\\"' *\\n| project PhishTime=TimeGenerated, MaliciousURL\\n| join kind=inner (\\n    DeviceEvents\\n    | project TimeGenerated, ActionType, DeviceName, InitiatingProcessAccountName, RemoteUrl\\n    | where ActionType == \\\"BrowserLaunchedToOpenUrl\\\"\\n    | where RemoteUrl startswith \\\"http\\\")\\n    on $left.MaliciousURL == $right.RemoteUrl\\n| project-rename URLOpenTime=TimeGenerated\\n| extend TimeDelta = abs(URLOpenTime - PhishTime)\\n| project PhishTime, URLOpenTime, TimeDelta, ActionType, RemoteUrl, DeviceName, InitiatingProcessAccountName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FindUsersWhoClickedonPhishing.kql", "query_name": "Device-FindUsersWhoClickedonPhishing", "attributes": {}}, {"query": "\"//Detect when a 'whoami' command is sent for the first time from a device & account combination not seen before\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceProcessEvents\\n| where TimeGenerated > ago (30d) and TimeGenerated < ago(1d)\\n| project DeviceName, InitiatingProcessAccountName, InitiatingProcessCommandLine\\n| where InitiatingProcessCommandLine contains \\\"whoami\\\"\\n| distinct DeviceName, InitiatingProcessAccountName\\n| join kind=rightanti (\\n    DeviceProcessEvents\\n    | where TimeGenerated > ago(1d)\\n    | project\\n        TimeGenerated,\\n        DeviceName,\\n        InitiatingProcessAccountName,\\n        InitiatingProcessCommandLine\\n    | where InitiatingProcessCommandLine contains \\\"whoami\\\"\\n    )\\n    on DeviceName, InitiatingProcessAccountName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-FirstTimeWhoAmI.kql", "query_name": "Device-FirstTimeWhoAmI", "attributes": {}}, {"query": "\"//Use the DeviceNetworkEvents to find what listening ports are being opened on a device and then query that list\\n//You can look for SSH, DNS etc being run from your end user devices\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(7d)\\n| where ActionType == \\\"ListeningConnectionCreated\\\"\\n//Exclude high ports\\n| where LocalPort < 1025\\n| summarize ['Ports Opened']=make_set(LocalPort), ['Count of Ports Opened']=dcount(LocalPort) by DeviceName\\n//Look for machines running services such as FTP, SSH, DNS etc\\n| where ['Ports Opened'] has_any (\\\"21\\\",\\\"22\\\",\\\"53\\\")\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where Timestamp > ago(7d)\\n| where ActionType == \\\"ListeningConnectionCreated\\\"\\n//Exclude high ports\\n| where LocalPort < 1025\\n| summarize ['Ports Opened']=make_set(LocalPort), ['Count of Ports Opened']=dcount(LocalPort) by DeviceName\\n//Look for machines running services such as FTP, SSH, DNS etc\\n| where ['Ports Opened'] has_any (\\\"21\\\",\\\"22\\\",\\\"53\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-InterestingPortsOpened.kql", "query_name": "Device-InterestingPortsOpened", "attributes": {}}, {"query": "\"//Summarize all local user accounts (non-domain) per device which have logged on with administrative rights\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceLogonEvents\\n| where TimeGenerated > ago(7d)\\n| project\\n    TimeGenerated,\\n    AdditionalFields,\\n    IsLocalAdmin,\\n    LogonType,\\n    DeviceName,\\n    AccountDomain,\\n    AccountName\\n| extend LocalLogon = toboolean(AdditionalFields.IsLocalLogon)\\n| where LocalLogon == true\\n| where IsLocalAdmin == true\\n| where LogonType == \\\"Interactive\\\"\\n| distinct AccountDomain, AccountName, DeviceName\\n//Split domain from device name to match for local logons\\n| extend Device = split(DeviceName, \\\".\\\")[0]\\n| where Device == AccountDomain\\n| summarize ['Local Accounts with Admin']=make_set(AccountName), ['Count of Admin Accounts']=dcount(AccountName) by DeviceName\\n| sort by ['Count of Admin Accounts'] desc   \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-LocalUserswithAdmin.kql", "query_name": "Device-LocalUserswithAdmin", "attributes": {}}, {"query": "\"//Detections based on the emerging information found here - https://twitter.com/nao_sec/status/1530196847679401984, https://twitter.com/GossiTheDog/status/1531018365606707206 and https://doublepulsar.com/follina-a-microsoft-office-code-execution-vulnerability-1a47fce5629e\\n//Microsoft Sentinel queries\\n//Search your device process events for msdt.exe being generated by Outlook, Word or Excel - should be low noise and high value alerts, seems very rare behaviour\\nDeviceProcessEvents\\n| where ProcessCommandLine contains \\\"msdt.exe\\\" and InitiatingProcessCommandLine has_any (\\\"outlook.exe\\\", \\\"winword.exe\\\", \\\"excel.exe\\\") \\n\\n//Search your device process events for msdt.exe spawning processes other than itself\\nDeviceProcessEvents\\n| where InitiatingProcessCommandLine contains \\\"msdt.exe\\\" and ProcessCommandLine !contains \\\"msdt.exe\\\"\\n\\n//Likely to get false positives with msdt.exe spawning a process other than itself, so instead look for new events seen today for the first time based on distinct process and parent process\\nDeviceProcessEvents\\n| where TimeGenerated > ago (30d) and TimeGenerated < ago(1d)\\n| project InitiatingProcessCommandLine, ProcessCommandLine\\n| where InitiatingProcessCommandLine contains \\\"msdt.exe\\\" and ProcessCommandLine !contains \\\"msdt.exe\\\"\\n| distinct InitiatingProcessCommandLine, ProcessCommandLine\\n| join kind=rightanti \\n    (\\n    DeviceProcessEvents\\n    | where TimeGenerated > ago (1d)\\n    | where InitiatingProcessCommandLine contains \\\"msdt.exe\\\" and ProcessCommandLine !contains \\\"msdt.exe\\\"\\n    )\\n on InitiatingProcessCommandLine, ProcessCommandLine\\n | project TimeGenerated, DeviceName, InitiatingProcessAccountName, InitiatingProcessCommandLine, ProcessCommandLine\\n\\n//Look for new public connections from \\\"sdiagnhost.exe\\\" or \\\"msdt.exe\\\" as per https://twitter.com/MalwareJake/status/1531088843792957442\\n//\\\"sdiagnhost.exe\\\" legimitately connects to some internet endpoints as part of Microsoft telemetry so find events new to today to investigate\\nlet knownips=\\n    DeviceNetworkEvents\\n    | where TimeGenerated > ago(30d) and TimeGenerated < ago(1d)\\n    | where InitiatingProcessFileName has_any (\\\"sdiagnhost.exe\\\", \\\"msdt.exe\\\")\\n    | where RemoteIPType == \\\"Public\\\"\\n    | distinct RemoteIP;\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(1d)\\n| where InitiatingProcessFileName has_any (\\\"sdiagnhost.exe\\\", \\\"msdt.exe\\\")\\n| where RemoteIPType == \\\"Public\\\"\\n| where RemoteIP !in (knownips)\\n| project\\n    TimeGenerated,\\n    ActionType,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessFileName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemotePort,\\n    RemoteUrl\\n\\n\\n\\n//Advanced Hunting queries\\n//Search your device process events for msdt.exe being generated by Outlook, Word or Excel - should be low noise and high value alerts, seems very rare behaviour\\nDeviceProcessEvents\\n| where ProcessCommandLine contains \\\"msdt.exe\\\" and InitiatingProcessCommandLine has_any (\\\"outlook.exe\\\", \\\"winword.exe\\\", \\\"excel.exe\\\") \\n\\n//Search your device process events for msdt.exe spawning processes other than itself\\nDeviceProcessEvents\\n| where InitiatingProcessCommandLine contains \\\"msdt.exe\\\" and ProcessCommandLine !contains \\\"msdt.exe\\\"\\n\\n//Likely to get false positives with msdt.exe spawning a process other than itself, so instead look for new events seen today for the first time based on distinct process and parent process\\nDeviceProcessEvents\\n| where Timestamp > ago (30d) and Timestamp < ago(1d)\\n| project InitiatingProcessCommandLine, ProcessCommandLine\\n| where InitiatingProcessCommandLine contains \\\"msdt.exe\\\" and ProcessCommandLine !contains \\\"msdt.exe\\\"\\n| distinct InitiatingProcessCommandLine, ProcessCommandLine\\n| join kind=rightanti \\n    (\\n    DeviceProcessEvents\\n    | where Timestamp > ago (1d)\\n    | where InitiatingProcessCommandLine contains \\\"msdt.exe\\\" and ProcessCommandLine !contains \\\"msdt.exe\\\"\\n    )\\n on InitiatingProcessCommandLine, ProcessCommandLine\\n | project Timestamp, DeviceName, InitiatingProcessAccountName, InitiatingProcessCommandLine, ProcessCommandLine\\n\\n//Look for new public connections from \\\"sdiagnhost.exe\\\" or \\\"msdt.exe\\\" as per https://twitter.com/MalwareJake/status/1531088843792957442\\n//\\\"sdiagnhost.exe\\\" legimitately connects to some internet endpoints as part of Microsoft telemetry so find events new to today to investigate\\nlet knownips=\\n    DeviceNetworkEvents\\n    | where Timestamp > ago(30d) and Timestamp < ago(1d)\\n    | where InitiatingProcessFileName has_any (\\\"sdiagnhost.exe\\\", \\\"msdt.exe\\\")\\n    | where RemoteIPType == \\\"Public\\\"\\n    | distinct RemoteIP;\\nDeviceNetworkEvents\\n| where Timestamp > ago(1d)\\n| where InitiatingProcessFileName has_any (\\\"sdiagnhost.exe\\\", \\\"msdt.exe\\\")\\n| where RemoteIPType == \\\"Public\\\"\\n| where RemoteIP !in (knownips)\\n| where RemoteUrl !endswith \\\".visualstudio.com\\\" and RemoteUrl !endswith \\\".microsoft.com\\\"\\n| project\\n    Timestamp,\\n    ActionType,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessFileName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemotePort,\\n    RemoteUrl\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-msdtPotentialExploit.kql", "query_name": "Device-msdtPotentialExploit", "attributes": {}}, {"query": "\"//Retrieve any new ASR alerts in your environment over the last week not previously seen in the prior 90 days and which devices have triggered them\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nlet timerange=90d;\\nlet existingalerts=\\nDeviceEvents\\n| where TimeGenerated > ago (timerange) and TimeGenerated < ago(7d)\\n| where ActionType startswith \\\"Asr\\\"\\n| distinct ActionType;\\n    DeviceEvents\\n    | where TimeGenerated > ago(7d)\\n    | where ActionType startswith \\\"Asr\\\"\\n    | where ActionType !in (existingalerts)\\n| summarize ['Device List']=make_set(DeviceName) by ActionType\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-NewASREvents.kql", "query_name": "Device-NewASREvents", "attributes": {}}, {"query": "\"//Detect when a process with a hash not previously seen before in your environment accesses lsass.exe via an open process API call\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nlet knownhashes=\\n    DeviceEvents\\n    | where TimeGenerated > ago(30d) and TimeGenerated < ago (1d)\\n    | where ActionType == \\\"OpenProcessApiCall\\\"\\n    | where FileName == \\\"lsass.exe\\\"\\n    | distinct InitiatingProcessSHA256;\\nDeviceEvents\\n| where TimeGenerated > ago (1d)\\n| where ActionType == \\\"OpenProcessApiCall\\\"\\n| where FileName == \\\"lsass.exe\\\"\\n| where InitiatingProcessSHA256 !in (knownhashes)\\n| extend DesiredAccess = tostring(AdditionalFields.DesiredAccess)\\n| distinct\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    DesiredAccess\\n\\n//Detect when a process with a hash not previously seen before in your environment accesses lsass.exe via an open process API call\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n//Advanced Hunting query\\nlet knownhashes=\\n    DeviceEvents\\n    | where Timestamp > ago(30d) and Timestamp < ago (1d)\\n    | where ActionType == \\\"OpenProcessApiCall\\\"\\n    | where FileName == \\\"lsass.exe\\\"\\n    | distinct InitiatingProcessSHA256;\\nDeviceEvents\\n| where Timestamp > ago (1d)\\n| where ActionType == \\\"OpenProcessApiCall\\\"\\n| where FileName == \\\"lsass.exe\\\"\\n| where InitiatingProcessSHA256 !in (knownhashes)\\n| distinct DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    AdditionalFields\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-NewHashAccessingLSASS.kql", "query_name": "Device-NewHashAccessingLSASS", "attributes": {}}, {"query": "\"//Use the inbuilt KQL parse_url function to return the various components of a URL\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where ActionType == \\\"BrowserLaunchedToOpenUrl\\\"\\n| extend Url = parse_url(RemoteUrl)\\n| extend Hostname = tostring(Url.Host)\\n| extend Fragment = tostring(Url.Fragment)\\n| extend Password = tostring(Url.Password)\\n| extend Path = tostring(Url.Path)\\n| extend Port = tostring(Url.Port)\\n| extend Query = tostring(Url.Query)\\n| extend Schema = tostring(Url.Scheme)\\n| extend Username = tostring(Url.Username)\\n| where isnotempty(Hostname)\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    RemoteUrl,\\n    Schema,\\n    Port,\\n    Hostname,\\n    Path,\\n    Query,\\n    Username,\\n    Password,\\n    Fragment\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-ParseURL.kql", "query_name": "Device-ParseURL", "attributes": {}}, {"query": "\"//Identifies potential DNS tunnelling over HTTPS \\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where ActionType == \\\"NetworkSignatureInspected\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend NetworkSignature = AF.SignatureName\\n//Search for network signatures that are DNS but not on regular DNS ports including Netbios & LLMNR if those are in use\\n| where NetworkSignature == \\\"DNS_Request\\\" and RemotePort !in (\\\"53\\\", \\\"137\\\", \\\"5353\\\", \\\"5355\\\")\\n//Exclude traffic where the remote IP is a private/local IP address, you can remove this if also interested in that traffic\\n| where not(ipv4_is_private(RemoteIP))\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    NetworkSignature,\\n    LocalIP,\\n    LocalPort,\\n    RemoteIP,\\n    RemotePort,\\n    RemoteUrl\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where ActionType == \\\"NetworkSignatureInspected\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend NetworkSignature = AF.SignatureName\\n//Search for network signatures that are DNS but not on regular DNS ports including Netbios & LLMNR if those are in use\\n| where NetworkSignature == \\\"DNS_Request\\\" and RemotePort !in (\\\"53\\\", \\\"137\\\", \\\"5353\\\", \\\"5355\\\")\\n//Exclude traffic where the remote IP is a private/local IP address, you can remove this if also interested in that traffic\\n| where not(ipv4_is_private(RemoteIP))\\n| project\\n    Timestamp,\\n    DeviceName,\\n    NetworkSignature,\\n    LocalIP,\\n    LocalPort,\\n    RemoteIP,\\n    RemotePort,\\n    RemoteUrl\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-PotentialDNSTunnelling.kql", "query_name": "Device-PotentialDNSTunnelling", "attributes": {}}, {"query": "\"//Find users that are connecting to internet endpoints via PowerShell commands\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceNetworkEvents\\n| project\\n    TimeGenerated,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    DeviceName,\\n    LocalIPType,\\n    LocalIP,\\n    RemoteIPType,\\n    RemotePort,\\n    RemoteIP,\\n    RemoteUrl\\n//Exclude system processes\\n| where InitiatingProcessAccountName != \\\"system\\\"\\n| where InitiatingProcessAccountName != \\\"local service\\\"\\n| where InitiatingProcessCommandLine contains \\\"powershell\\\"\\n| where LocalIPType == \\\"Private\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemotePort,\\n    RemoteUrl\\n| sort by TimeGenerated desc \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-PowershellConnectingtoInternet.kql", "query_name": "Device-PowershellConnectingtoInternet", "attributes": {}}, {"query": "\"//Detect when a non system account changes the PowerShell execution policy on a device\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where ActionType == \\\"PowerShellCommand\\\"\\n| where InitiatingProcessFileName == \\\"powershell.exe\\\"\\n| where InitiatingProcessAccountName != \\\"system\\\"\\n| where AdditionalFields.Command == \\\"Set-ExecutionPolicy\\\"\\n| project TimeGenerated, DeviceName, InitiatingProcessAccountName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-PowerShellExecutionModeChanged.kql", "query_name": "Device-PowerShellExecutionModeChanged", "attributes": {}}, {"query": "\"//Find when a process modifies the primary access token and parse the relevant details such as any privilege attached to the token, whether it is system level and the token integrity level\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceEvents\\n| where TimeGenerated > ago(30m)\\n| project\\n    DeviceName,\\n    ActionType,\\n    AdditionalFields,\\n    TimeGenerated,\\n    InitiatingProcessParentFileName,\\n    InitiatingProcessCommandLine\\n| where ActionType == \\\"ProcessPrimaryTokenModified\\\"\\n| extend TokenModificationProperties = AdditionalFields.TokenModificationProperties\\n| where isnotempty(TokenModificationProperties)\\n| parse TokenModificationProperties with * 'tokenChangeDescription\\\":\\\"' ['Token Change Description'] '\\\",\\\"privilegesFlags\\\":' ['Token Privileges'] ',\\\"isChangedToSystemToken\\\":' ['is Changed to System Token'] ',\\\"originalTokenIntegrityLevelName\\\":\\\"' ['Original Token Level'] '\\\",\\\"currentTokenIntegrityLevelName\\\":\\\"' ['Current Token Level'] '\\\"' *\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessParentFileName,\\n    InitiatingProcessCommandLine,\\n    ['Original Token Level'],\\n    ['Current Token Level'],\\n    ['Token Privileges'],\\n    ['is Changed to System Token'],\\n    ['Token Change Description']\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where Timestamp > ago(30m)\\n| project\\n    DeviceName,\\n    ActionType,\\n    AdditionalFields,\\n    Timestamp,\\n    InitiatingProcessParentFileName,\\n    InitiatingProcessCommandLine\\n| where ActionType == \\\"ProcessPrimaryTokenModified\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend OriginalTokenLevel = AF.OriginalTokenIntegrityLevel\\n| extend OriginalTokenPriv = AF.OriginalTokenPrivEnabled\\n| extend CurrentTokenLevel = AF.CurrentTokenIntegrityLevel\\n| extend CurrentTokenPriv = AF.CurrentTokenPrivEnabled\\n| extend TokenModification = AF.TokenModificationProperties\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-ProcessModifiedPrimaryToken.kql", "query_name": "Device-ProcessModifiedPrimaryToken", "attributes": {}}, {"query": "\"//Find successful connections from a private to public network on TCP port 22\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(1d)\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == 22\\n| where LocalIPType == \\\"Private\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemoteUrl\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where Timestamp > ago(1d)\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == 22\\n| where LocalIPType == \\\"Private\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| project\\n    Timestamp,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemoteUrl\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-PublicPort22Allowed.kql", "query_name": "Device-PublicPort22Allowed", "attributes": {}}, {"query": "\"//Detect SSH traffic that isn't on port 22 connecting to public IP addresses\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microosft Sentinel query\\nDeviceNetworkEvents\\n| where ActionType == \\\"NetworkSignatureInspected\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend NetworkSignature = AF.SignatureName\\n//Search for network signatures that are SSH but not on port 22\\n| where NetworkSignature == \\\"SSH\\\" and RemotePort != 22\\n//Exclude traffic where the remote IP is a private/local IP address, you can remove this if also interested in that traffic\\n| where not(ipv4_is_private(RemoteIP))\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    NetworkSignature,\\n    LocalIP,\\n    LocalPort,\\n    RemoteIP,\\n    RemotePort,\\n    RemoteUrl\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where ActionType == \\\"NetworkSignatureInspected\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend NetworkSignature = AF.SignatureName\\n//Search for network signatures that are SSH but not on port 22\\n| where NetworkSignature == \\\"SSH\\\" and RemotePort != 22\\n//Exclude traffic where the remote IP is a private/local IP address, you can remove this if also interested in that traffic\\n| where not(ipv4_is_private(RemoteIP))\\n| project\\n    Timestamp,\\n    DeviceName,\\n    NetworkSignature,\\n    LocalIP,\\n    LocalPort,\\n    RemoteIP,\\n    RemotePort,\\n    RemoteUrl\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SSHTrafficOnNonStandardPort.kql", "query_name": "Device-SSHTrafficOnNonStandardPort", "attributes": {}}, {"query": "\"//Create a summary of the devices with inbound LDAP and LDAPS connections, sorted by the devices with the most inbound LDAP\\n\\n//Data connector required for this query - M365 Defender - Device* tables or Advanced Hunting license\\n\\n//Query works in both Microsoft Sentinel and Advanced Hunting\\nDeviceNetworkEvents\\n| where ActionType == \\\"InboundConnectionAccepted\\\"\\n| where LocalPort in (\\\"389\\\", \\\"636\\\", \\\"3269\\\")\\n| summarize\\n    ['Count of Inbound LDAP Connections']=countif(LocalPort == 389),\\n    ['Count of Distinct Inbound LDAP Connections']=dcountif(RemoteIP, LocalPort == 389),\\n    ['List of Inbound LDAP Connections']=make_set_if(RemoteIP, LocalPort == 389),\\n    ['Count of Inbound LDAPS Connections']=countif(LocalPort in (\\\"636\\\", \\\"3269\\\")),\\n    ['Count of Distinct Inbound LDAPS Connections']=dcountif(RemoteIP, LocalPort in (\\\"636\\\", \\\"3269\\\")),\\n    ['List of Inbound LDAPS Connections']=make_set_if(RemoteIP, LocalPort in (\\\"636\\\", \\\"3269\\\"))\\n    by DeviceName\\n| sort by ['Count of Distinct Inbound LDAP Connections'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SummarizeLDAPandLDAPStraffic.kql", "query_name": "Device-SummarizeLDAPandLDAPStraffic", "attributes": {}}, {"query": "\"//Summarize the total count of all local group additions by group name\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType == \\\"UserAccountAddedToLocalGroup\\\"\\n| summarize ['Local Group Addition Count']=count() by ['Local Group Name']=tostring(AdditionalFields.GroupName)\\n| sort by ['Local Group Addition Count']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SummarizeLocalGroupAdditions.kql", "query_name": "Device-SummarizeLocalGroupAdditions", "attributes": {}}, {"query": "\"//Summarize the local (non domain) logon activity for your devices for both successful and failed logons. You may have users using a local account to bypass security policy\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceLogonEvents\\n| where TimeGenerated > ago(30d)\\n//Find logons where AccountDomain == DeviceName indicating a local logon\\n| where AccountDomain == DeviceName\\n| where AdditionalFields.IsLocalLogon == true\\n| where LogonType == \\\"Interactive\\\"\\n| where RemoteIPType != \\\"Loopback\\\"\\n| summarize\\n    ['Count of successful local logon attempts']=countif(ActionType == \\\"LogonSuccess\\\"),\\n    ['Distinct count of successful local logon attempts']=dcountif(AccountName, ActionType == \\\"LogonSuccess\\\"),\\n    ['List of succesful local account logons']=make_set_if(AccountName, ActionType == \\\"LogonSuccess\\\"),\\n    ['Count of failed local logon attempts']=countif(ActionType == \\\"LogonFailed\\\"),\\n    ['Distinct count of failed local logon attempts']=dcountif(AccountName, ActionType == \\\"LogonFailed\\\"),\\n    ['List of failed local account logons']=make_set_if(AccountName, ActionType == \\\"LogonFailed\\\")\\n    by DeviceName\\n| project-reorder\\n    DeviceName,\\n    ['Count of successful local logon attempts'],\\n    ['Distinct count of successful local logon attempts'],\\n    ['List of succesful local account logons'],\\n    ['Count of failed local logon attempts'],\\n    ['Distinct count of failed local logon attempts'],\\n    ['List of failed local account logons']\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceLogonEvents\\n| where Timestamp > ago(30d)\\n| where AccountDomain == DeviceName\\n| where LogonType == @\\\"Interactive\\\"\\n| where RemoteIPType != \\\"Loopback\\\"\\n| summarize\\n    ['Count of successful local logon attempts']=countif(ActionType == \\\"LogonSuccess\\\"),\\n    ['Distinct count of successful local logon attempts']=dcountif(AccountName, ActionType == \\\"LogonSuccess\\\"),\\n    ['List of succesful local account logons']=make_set_if(AccountName, ActionType == \\\"LogonSuccess\\\"),\\n    ['Count of failed local logon attempts']=countif(ActionType == \\\"LogonFailed\\\"),\\n    ['Distinct count of failed local logon attempts']=dcountif(AccountName, ActionType == \\\"LogonFailed\\\"),\\n    ['List of failed local account logons']=make_set_if(AccountName, ActionType == \\\"LogonFailed\\\")\\n    by DeviceName\\n| project-reorder\\n    DeviceName,\\n    ['Count of successful local logon attempts'],\\n    ['Distinct count of successful local logon attempts'],\\n    ['List of succesful local account logons'],\\n    ['Count of failed local logon attempts'],\\n    ['Distinct count of failed local logon attempts'],\\n    ['List of failed local account logons']\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SummarizeLocalLogonActivity.kql", "query_name": "Device-SummarizeLocalLogonActivity", "attributes": {}}, {"query": "\"//Summarize macro usage on your devies by creating a list all macros used, a count of how many users are using each one and the account names\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Macro usage may be double counted if the same file is executed from two locations, i.e from a network share and a local drive.\\n//Microsoft Sentinel query\\nunion DeviceFileEvents, DeviceNetworkEvents\\n| where TimeGenerated > ago(30d)\\n| project InitiatingProcessCommandLine, InitiatingProcessAccountName\\n| where InitiatingProcessCommandLine startswith '\\\"EXCEL.EXE'  \\n| where InitiatingProcessCommandLine endswith '.xltm\\\"' or InitiatingProcessCommandLine endswith '.xlsm\\\"'\\n//Retrieve distinct values for process, hash and account\\n| distinct InitiatingProcessCommandLine, InitiatingProcessAccountName\\n//Parse the file path and file name from the process\\n| parse-where InitiatingProcessCommandLine with * '\\\"EXCEL.EXE\\\" \\\"' ['Macro Filename'] '\\\"' *\\n//Summarize the list of macro files by which users have used them\\n| summarize ['List of Users']=make_set(InitiatingProcessAccountName), ['Count of Users']=dcount(InitiatingProcessAccountName) by ['Macro Filename']\\n| sort by ['Count of Users'] desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nunion DeviceFileEvents, DeviceNetworkEvents\\n| where Timestamp > ago(30d)\\n| project InitiatingProcessCommandLine, InitiatingProcessAccountName\\n| where InitiatingProcessCommandLine startswith '\\\"EXCEL.EXE'  \\n| where InitiatingProcessCommandLine endswith '.xltm\\\"' or InitiatingProcessCommandLine endswith '.xlsm\\\"'\\n//Retrieve distinct values for process, hash and account\\n| distinct InitiatingProcessCommandLine, InitiatingProcessAccountName\\n//Parse the file path and file name from the process\\n| parse-where InitiatingProcessCommandLine with * '\\\"EXCEL.EXE\\\" \\\"' ['Macro Filename'] '\\\"' *\\n//Summarize the list of macro files by which users have used them\\n| summarize ['List of Users']=make_set(InitiatingProcessAccountName), ['Count of Users']=dcount(InitiatingProcessAccountName) by ['Macro Filename']\\n| sort by ['Count of Users'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SummarizeMacroUsage.kql", "query_name": "Device-SummarizeMacroUsage", "attributes": {}}, {"query": "\"//Summarize your devices by their RDP activity. The data is sorted to show total outbound RDP connections, a count of distinct RDP connections and the list of IP's connected to.\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Data is sorted by the devices with the most unique outbound RDP connections. Those devices have the biggest lateral movement blast radius.\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(30d)\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == \\\"3389\\\"\\n//Exclude Defender for Identity that uses an initial RDP connection to map your network\\n| where InitiatingProcessCommandLine <> \\\"\\\\\\\"Microsoft.Tri.Sensor.exe\\\\\\\"\\\"\\n| summarize\\n    ['RDP Outbound Connection Count']=count(),\\n    ['RDP Distinct Outbound Endpoint Count']=dcount(RemoteIP),\\n    ['RDP Outbound Endpoints']=make_set(RemoteIP)\\n    by DeviceName\\n| sort by ['RDP Distinct Outbound Endpoint Count'] desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where Timestamp > ago(30d)\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == \\\"3389\\\"\\n//Exclude Defender for Identity that uses an initial RDP connection to map your network\\n| where InitiatingProcessCommandLine <> \\\"\\\\\\\"Microsoft.Tri.Sensor.exe\\\\\\\"\\\"\\n| summarize\\n    ['RDP Outbound Connection Count']=count(),\\n    ['RDP Distinct Outbound Endpoint Count']=dcount(RemoteIP),\\n    ['RDP Outbound Endpoints']=make_set(RemoteIP)\\n    by DeviceName\\n| sort by ['RDP Distinct Outbound Endpoint Count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SummarizeRDPConnections.kql", "query_name": "Device-SummarizeRDPConnections", "attributes": {}}, {"query": "\"//Summarize the domains that Smartscreen is blocking as phishing attempts\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType startswith \\\"SmartScreen\\\"\\n| extend SmartScreenExperience = tostring(AdditionalFields.Experience)\\n| where AdditionalFields.Experience == \\\"Phishing\\\"\\n| parse-where RemoteUrl with * '://' RemoteDomain '/' *\\n| summarize Count=count()by RemoteDomain\\n| sort by Count\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SummarizeSmartScreenPhishingDomains.kql", "query_name": "Device-SummarizeSmartScreenPhishingDomains", "attributes": {}}, {"query": "\"//Summarize the most common files in your environment flagging Smartscreen untrusted warnings\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType startswith \\\"SmartScreen\\\"\\n| extend SmartScreenExperience = tostring(AdditionalFields.Experience)\\n| where SmartScreenExperience == \\\"Untrusted\\\"\\n| summarize Count=count()by FileName\\n| sort by Count\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where Timestamp > ago(30d)\\n| where ActionType startswith \\\"SmartScreen\\\"\\n| where AdditionalFields == @\\\"{\\\"\\\"Experience\\\"\\\":\\\"\\\"Untrusted\\\"\\\"}\\\"\\n| summarize Count=count()by FileName\\n| sort by Count\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SummarizeSmartScreenUntrustedFiles.kql", "query_name": "Device-SummarizeSmartScreenUntrustedFiles", "attributes": {}}, {"query": "\"//Find any devices enrolled into Defender that have created an inbound listening connection on port 22 and retrieve the process command line that opened the connection\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(7d)\\n| where ActionType == \\\"ListeningConnectionCreated\\\"\\n| where LocalPort == 22\\n| summarize\\n    ['Total count of listening connections opened']=count(),\\n    ['List of processes creating listening connections']=make_set(InitiatingProcessCommandLine)\\n    by DeviceName\\n| sort by ['Total count of listening connections opened'] desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where Timestamp > ago(7d)\\n| where ActionType == \\\"ListeningConnectionCreated\\\"\\n| where LocalPort == 22\\n| summarize\\n    ['Total count of listening connections opened']=count(),\\n    ['List of processes creating listening connections']=make_set(InitiatingProcessCommandLine)\\n    by DeviceName\\n| sort by ['Total count of listening connections opened'] desc \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SummarizeSSHPortOpenedInbound.kql", "query_name": "Device-SummarizeSSHPortOpenedInbound", "attributes": {}}, {"query": "\"//Create a summary of each device showing all users who have logged on, separated into normal and local admin logons\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceLogonEvents\\n| where TimeGenerated > ago(30d)\\n| project DeviceName, ActionType, LogonType, AdditionalFields, InitiatingProcessCommandLine, AccountName, IsLocalAdmin\\n| where ActionType == \\\"LogonSuccess\\\"\\n| where LogonType == \\\"Interactive\\\"\\n| where AdditionalFields.IsLocalLogon == true\\n| where InitiatingProcessCommandLine == \\\"lsass.exe\\\"\\n| summarize\\n    ['Local Admin Count']=dcountif(AccountName,IsLocalAdmin == \\\"true\\\"),\\n    ['Local Admins']=make_set_if(AccountName, IsLocalAdmin == \\\"true\\\"), \\n    ['Standard User Count']=dcountif(AccountName, IsLocalAdmin == \\\"false\\\"),\\n    ['Standard Users']=make_set_if(AccountName, IsLocalAdmin == \\\"false\\\")\\n    by DeviceName\\n| sort by ['Local Admin Count'] desc  \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceLogonEvents\\n| where Timestamp > ago(30d)\\n| project DeviceName, ActionType, LogonType, AdditionalFields, InitiatingProcessCommandLine, AccountName, IsLocalAdmin\\n| where ActionType == \\\"LogonSuccess\\\"\\n| where LogonType == \\\"Interactive\\\"\\n| where InitiatingProcessCommandLine == \\\"lsass.exe\\\"\\n| summarize\\n    ['Local Admin Count']=dcountif(AccountName,IsLocalAdmin == \\\"true\\\"),\\n    ['Local Admins']=make_set_if(AccountName, IsLocalAdmin == \\\"true\\\"), \\n    ['Standard User Count']=dcountif(AccountName, IsLocalAdmin == \\\"false\\\"),\\n    ['Standard Users']=make_set_if(AccountName, IsLocalAdmin == \\\"false\\\")\\n    by DeviceName\\n| sort by ['Local Admin Count'] desc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-SummaryofDeviceLogons.kql", "query_name": "Device-SummaryofDeviceLogons", "attributes": {}}, {"query": "\"//Top 20 departments copying file data to USB drives by file count\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet id=\\nIdentityInfo\\n| where TimeGenerated > ago (21d)\\n| summarize arg_max(TimeGenerated, *) by AccountName\\n| extend LoggedOnUser = AccountName\\n| project LoggedOnUser, AccountUPN, JobTitle, EmployeeId, Country, City, Department, AccountDisplayName\\n| join kind=inner (\\nDeviceInfo\\n| where TimeGenerated > ago (21d)\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| extend LoggedOnUser = tostring(LoggedOnUsers[0].UserName)\\n) on LoggedOnUser\\n| project LoggedOnUser, AccountUPN, JobTitle, Country, DeviceName, EmployeeId, Department, AccountDisplayName;\\nDeviceEvents\\n| where TimeGenerated > ago(7d)\\n| join kind=inner id on DeviceName\\n| where ActionType == \\\"UsbDriveMounted\\\"\\n| extend Type = tostring(AdditionalFields.Manufacturer)\\n| extend DriveLetter = tostring(todynamic(AdditionalFields).DriveLetter)\\n| join kind=inner (DeviceFileEvents\\n| where TimeGenerated > ago(7d)\\n| extend FileCopyTime = TimeGenerated\\n| where ActionType == \\\"FileCreated\\\"\\n| parse FolderPath with DriveLetter '\\\\\\\\' *\\n| extend DriveLetter = tostring(DriveLetter)\\n) on DeviceId, DriveLetter\\n| extend FileSizeGB = FileSize/1024/1024/1000\\n| project TimeGenerated, DeviceName, DriveLetter, FileName1, FileSizeGB, LoggedOnUser, AccountUPN, JobTitle,EmployeeId, Country, Department, Type, AccountDisplayName\\n| summarize CopyCount=count()by Department\\n| order by CopyCount\\n| take 20\\n| render columnchart \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-Top20DepartmentsCopyingDatatoUSBbyCount.kql", "query_name": "Device-Top20DepartmentsCopyingDatatoUSBbyCount", "attributes": {}}, {"query": "\"//Top 20 departments copying file data to USB drives by file size\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet id=\\nIdentityInfo\\n| where TimeGenerated > ago (21d)\\n| summarize arg_max(TimeGenerated, *) by AccountName\\n| extend LoggedOnUser = AccountName\\n| project LoggedOnUser, AccountUPN, JobTitle, EmployeeId, Country, City, Department, AccountDisplayName\\n| join kind=inner (\\nDeviceInfo\\n| where TimeGenerated > ago (21d)\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| extend LoggedOnUser = tostring(LoggedOnUsers[0].UserName)\\n) on LoggedOnUser\\n| project LoggedOnUser, AccountUPN, JobTitle, Country, DeviceName, EmployeeId, Department, AccountDisplayName;\\nDeviceEvents\\n| where TimeGenerated > ago(7d)\\n| join kind=inner id on DeviceName\\n| where ActionType == \\\"UsbDriveMounted\\\"\\n| extend Type = tostring(AdditionalFields.Manufacturer)\\n| extend DriveLetter = tostring(todynamic(AdditionalFields).DriveLetter)\\n| join kind=inner (DeviceFileEvents\\n| where TimeGenerated > ago(7d)\\n| extend FileCopyTime = TimeGenerated\\n| where ActionType == \\\"FileCreated\\\"\\n| parse FolderPath with DriveLetter '\\\\\\\\' *\\n| extend DriveLetter = tostring(DriveLetter)\\n) on DeviceId, DriveLetter\\n| extend FileSizeGB = FileSize/1024/1024/1000\\n| project TimeGenerated, DeviceName, DriveLetter, FileName1, FileSizeGB, LoggedOnUser, AccountUPN, JobTitle,EmployeeId, Country, Department, Type, AccountDisplayName\\n| summarize CopySize=sum(FileSizeGB)by Department\\n| order by CopySize\\n| take 20\\n| render columnchart \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-Top20DepartmentsCopyingDatatoUSBbySize.kql", "query_name": "Device-Top20DepartmentsCopyingDatatoUSBbySize", "attributes": {}}, {"query": "\"//Find the top 20 of a collection of varied data sets, no real detections in here just interesting data that is captured\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsft Sentinel query\\n\\n//Top 20 USB models plugged in\\nDeviceEvents\\n| where ActionType == \\\"UsbDriveMounted\\\"\\n| extend Manufacturer = tostring(AdditionalFields.Manufacturer)\\n| extend ProductName = tostring(AdditionalFields.ProductName)\\n| where isnotempty(Manufacturer) or isnotempty(Manufacturer)\\n| extend ['USB Drive Model']= strcat(Manufacturer, \\\"-\\\", ProductName)\\n| summarize Count=count()by ['USB Drive Model']\\n| top 20 by Count\\n\\n//Top 20 users taking screenshots\\nDeviceEvents\\n| where ActionType == \\\"ScreenshotTaken\\\"\\n| where InitiatingProcessAccountName != \\\"system\\\"\\n| summarize Count=count() by InitiatingProcessAccountName\\n| top 20 by Count\\n\\n//Top 20 models of monitor being plugged in\\nDeviceEvents\\n| where ActionType == \\\"PnpDeviceConnected\\\"\\n| extend ClassName = tostring(AdditionalFields.ClassName)\\n| where ClassName == \\\"Monitor\\\"\\n| extend ['Monitor Type'] = tostring(AdditionalFields.DeviceDescription)\\n| summarize Count=count()by ['Monitor Type']\\n| top 20 by Count\\n\\n//Top 20 web shortcuts opened\\nDeviceEvents\\n| where ActionType == \\\"BrowserLaunchedToOpenUrl\\\"\\n| summarize Count=count()by RemoteUrl\\n| where RemoteUrl startswith \\\"http\\\"\\n| top 20 by Count\\n\\n\\n//Advanced Hunting queries\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n//Top 20 USB models plugged in\\nDeviceEvents\\n| where ActionType == \\\"UsbDriveMounted\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend Manufacturer = tostring(AF.Manufacturer)\\n| extend ProductName = tostring(AF.ProductName)\\n| where isnotempty(Manufacturer) or isnotempty(Manufacturer)\\n| extend ['USB Drive Model']= strcat(Manufacturer, \\\"-\\\", ProductName)\\n| summarize Count=count()by ['USB Drive Model']\\n| top 20 by Count\\n\\n//Top 20 users taking screenshots\\nDeviceEvents\\n| where ActionType == \\\"ScreenshotTaken\\\"\\n| where InitiatingProcessAccountName != \\\"system\\\"\\n| summarize Count=count() by InitiatingProcessAccountName\\n| top 20 by Count\\n\\n//Top 20 models of monitor being plugged in\\nDeviceEvents\\n| where ActionType == \\\"PnpDeviceConnected\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend ClassName = tostring(AF.ClassName)\\n| where ClassName == \\\"Monitor\\\"\\n| extend ['Monitor Type'] = tostring(AF.DeviceDescription)\\n| summarize Count=count()by ['Monitor Type']\\n| top 20 by Count\\n\\n//Top 20 web shortcuts opened\\nDeviceEvents\\n| where ActionType == \\\"BrowserLaunchedToOpenUrl\\\"\\n| summarize Count=count()by RemoteUrl\\n| where RemoteUrl startswith \\\"http\\\"\\n| top 20 by Count\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-Top20RandomActions.kql", "query_name": "Device-Top20RandomActions", "attributes": {}}, {"query": "\"//Detect when an admin adds another user to the local administrators group on a device and optionally query IdentityInfo to return the UPN of the user added\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nDeviceEvents\\n| where TimeGenerated > ago(7d)\\n| where ActionType == \\\"UserAccountAddedToLocalGroup\\\"\\n| where AdditionalFields.GroupName == \\\"Administrators\\\"\\n// Exclude processes initiated by system as this detection is for end users adding groups\\n| where InitiatingProcessAccountSid != \\\"S-1-5-18\\\"\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    AccountSid,\\n    Actor=InitiatingProcessAccountName\\n//Join query to IdentityInfo table to match the AccountSid\\n//if you do not use the IdentityInfo table remove everything below this line\\n| join kind=inner (\\n    IdentityInfo\\n    | where TimeGenerated > ago (21d)\\n    | summarize arg_max (TimeGenerated, *) by AccountUPN)\\n    on $left.AccountSid == $right.AccountSID\\n| project\\n    TimeGenerated,\\n    DeviceName,\\n    ['User Added']=AccountUPN,\\n    ['User Added Sid']=AccountSID,\\n    Actor\\n\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceEvents\\n| where Timestamp > ago(30d)\\n| where ActionType == \\\"UserAccountAddedToLocalGroup\\\"\\n| where AdditionalFields contains \\\"Administrator\\\"\\n| where InitiatingProcessAccountSid != \\\"S-1-5-18\\\"\\n| project DeviceName, Actor=InitiatingProcessAccountName, AccountSid\\n| join kind=inner (\\nIdentityInfo\\n)\\non $left.AccountSid==$right.OnPremSid\\n| project DeviceName, Actor, AccountSid, UserAdded=AccountUpn\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-UserAddedasLocalAdmin.kql", "query_name": "Device-UserAddedasLocalAdmin", "attributes": {}}, {"query": "\"//Visualize your total attack surface reduction rule events over time with trend\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nlet StartDate = now(-90d);\\nlet EndDate = now();\\nDeviceEvents\\n| where ActionType startswith \\\"Asr\\\"\\n| make-series ['Total ASR Events']=count() on TimeGenerated in range(StartDate, EndDate, 1d)\\n| extend (RSquare, SplitIdx, Variance, RVariance, TrendLine)=series_fit_2lines(['Total ASR Events'])\\n| project TimeGenerated, ['Total ASR Events'], Trend=TrendLine\\n| render timechart\\n    with (\\n    xtitle=\\\"Day\\\",\\n    ytitle=\\\"Count of ASR Events\\\",\\n    title=\\\"Attack surface reduction events over time with trend\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-VisualizeASREventswithtrend.kql", "query_name": "Device-VisualizeASREventswithtrend", "attributes": {}}, {"query": "\"//Visualize the most common domains triggering Microsoft Defender SmartScreen warnings\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType == \\\"SmartScreenUrlWarning\\\"\\n| parse RemoteUrl with * '://' Domain '/' *\\n| where isnotempty(Domain)\\n| summarize Count=count()by Domain\\n| sort by Count\\n| render barchart  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-VisualizeMaliciousSmartScreenURLs.kql", "query_name": "Device-VisualizeMaliciousSmartScreenURLs", "attributes": {}}, {"query": "\"//Visualize the most common ISO files being mounted on your devices\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceFileEvents\\n| where TimeGenerated > ago(30d)\\n| where ActionType == \\\"FileCreated\\\"\\n//When an ISO file is mounted a .iso.lnk file is created, take that name and trim the .lnk out to retrieve the ISO name\\n| where FileName endswith \\\"iso.lnk\\\"\\n| extend ['ISO FileName'] = trim(@\\\".lnk\\\",FileName)\\n//Summarize and visualize the files\\n| summarize Count=count() by ['ISO FileName']\\n| top 20 by Count\\n| render barchart with (title=\\\"Most common ISO files being mounted\\\")\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceFileEvents\\n| where Timestamp > ago(30d)\\n| where ActionType == \\\"FileCreated\\\"\\n//When an ISO file is mounted a .iso.lnk file is created, take that name and trim the .lnk out to retrieve the ISO name\\n| where FileName endswith \\\"iso.lnk\\\"\\n| extend ['ISO FileName'] = trim(@\\\".lnk\\\",FileName)\\n//Summarize and visualize the files\\n| summarize Count=count() by ['ISO FileName']\\n| top 20 by Count\\n| render columnchart \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-VisualizeMostCommonISOFiles.kql", "query_name": "Device-VisualizeMostCommonISOFiles", "attributes": {}}, {"query": "\"//Visualize the OS build numbers of your Windows 10 and 11 devices per month over the last year\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceInfo\\n| where TimeGenerated > ago(365d)\\n| where OSPlatform in (\\\"Windows10\\\", \\\"Windows11\\\")\\n| extend OSBuildNumber=tostring(OSBuild)\\n| summarize arg_max(TimeGenerated, *) by DeviceName, startofmonth(TimeGenerated)\\n| summarize count()by OSBuildNumber, startofmonth(TimeGenerated)\\n| where isnotempty(OSBuildNumber)\\n| render areachart \\n    with (\\n    ytitle=\\\"Device Count\\\",\\n    xtitle=\\\"Month\\\",\\n    title=\\\"Count of Windows 10 and 11 OS Builds per month\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-VisualizeOSBuildspermonth.kql", "query_name": "Device-VisualizeOSBuildspermonth", "attributes": {}}, {"query": "\"//Summarize and visualize the different parent filenames initiating TCP port 22 connections\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(30d)\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == 22\\n| where isnotempty(InitiatingProcessFileName)\\n| summarize Count=count() by InitiatingProcessFileName\\n| top 20 by Count\\n| render barchart with (title=\\\"Proccesses initiating TCP port 22 connections\\\")\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where Timestamp > ago(30d)\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == 22\\n| where isnotempty(InitiatingProcessFileName)\\n| summarize Count=count() by InitiatingProcessFileName\\n| top 20 by Count\\n//Advanced hunting doesn't support barcharts, so can render as a piechart or just remove the line below for a table\\n| render piechart \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-VisualizePort22Proccesses.kql", "query_name": "Device-VisualizePort22Proccesses", "attributes": {}}, {"query": "\"//Visualize the different RDP clients, such as rMemoteNG or RoyalTS being used in your environment\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where TimeGenerated > ago(7d)\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == \\\"3389\\\"\\n//Exclude Defender for Identity which uses RDP traffic to map your network\\n| where InitiatingProcessFileName != \\\"Microsoft.Tri.Sensor.exe\\\"\\n| summarize ['RDP Client Count']=count()by InitiatingProcessFileName\\n| where isnotempty(InitiatingProcessFileName)\\n| sort by ['RDP Client Count'] desc\\n| render barchart \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where Timestamp > ago(7d)\\n| where ActionType == \\\"ConnectionSuccess\\\"\\n| where RemotePort == \\\"3389\\\"\\n//Exclude Defender for Identity which uses RDP traffic to map your network\\n| where InitiatingProcessFileName != \\\"Microsoft.Tri.Sensor.exe\\\"\\n| summarize ['RDP Client Count']=count()by InitiatingProcessFileName\\n| where isnotempty(InitiatingProcessFileName)\\n| sort by ['RDP Client Count'] desc\\n| render barchart \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-VisualizeRDPClients.kql", "query_name": "Device-VisualizeRDPClients", "attributes": {}}, {"query": "\"//Visualize the top 20 remote URLs that your users are connecting to via PowerShell\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceNetworkEvents\\n| where TimeGenerated > ago (7d)\\n//Exclude system and local service processes as this visualization is user focused\\n| where InitiatingProcessAccountName !in~ (\\\"system\\\", \\\"local service\\\")\\n| where InitiatingProcessCommandLine has \\\"powershell\\\"\\n| where LocalIPType == \\\"Private\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| summarize Count=count()by RemoteUrl\\n| where isnotempty(RemoteUrl)\\n| top 20 by Count\\n| render barchart with (title=\\\"Remote URLs accessed by Powershell\\\")\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceNetworkEvents\\n| where Timestamp > ago (7d)\\n//Exclude system and local service processes as this visualization is user focused\\n| where InitiatingProcessAccountName !in~ (\\\"system\\\", \\\"local service\\\")\\n| where InitiatingProcessCommandLine has \\\"powershell\\\"\\n| where LocalIPType == \\\"Private\\\"\\n| where RemoteIPType == \\\"Public\\\"\\n| summarize Count=count()by RemoteUrl\\n| where isnotempty(RemoteUrl)\\n| top 20 by Count\\n//Advanced Hunting does not support barcharts so you can visualize as a piechart or simply remove this line for a table\\n| render piechart with (title=\\\"Remote URLs accessed by Powershell\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-VisualizeRemotePowerShellURLs.kql", "query_name": "Device-VisualizeRemotePowerShellURLs", "attributes": {}}, {"query": "\"//Visualize how much data is being copied to USB drives per day in your environment over the time range.\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceEvents\\n| where TimeGenerated > ago (21d)\\n| project TimeGenerated, ActionType, AdditionalFields, DeviceId, FileName\\n| where ActionType == \\\"UsbDriveMounted\\\"\\n| extend DriveLetter = tostring(todynamic(AdditionalFields).DriveLetter)\\n| join kind=inner (DeviceFileEvents\\n    | where TimeGenerated > ago (21d)\\n    | project TimeGenerated, ActionType, FolderPath, DeviceId, FileName, FileSize\\n    | extend FileCopyTime = TimeGenerated\\n    | where ActionType == \\\"FileCreated\\\"\\n    | parse FolderPath with DriveLetter '\\\\\\\\' *\\n    | extend DriveLetter = tostring(DriveLetter)\\n    )\\n    on DeviceId, DriveLetter\\n| distinct FileCopyTime, FileName1, FileSize\\n| summarize DataCopiedinGB=sum(FileSize / 1024 / 1024 / 1024) by startofday(FileCopyTime)\\n| render columnchart\\n    with (\\n    kind=unstacked,\\n    xtitle=\\\"Data Copied in GB\\\",\\n    ytitle=\\\"Day\\\",\\n    title=\\\"Data Copied to USB per day\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-VisualizeVolumeofDataCopiedtoUSB.kql", "query_name": "Device-VisualizeVolumeofDataCopiedtoUSB", "attributes": {}}, {"query": "\"//Finds Windows 11 devices enrolled in Defender for Endpoint and the last user who logged on interactively\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nDeviceInfo\\n| where TimeGenerated > ago(60d)\\n| where isnotempty( OSPlatform)\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| extend OSBuildString = tostring(OSBuild)\\n| where OSPlatform == \\\"Windows11\\\" or OSBuildString startswith \\\"22\\\" or OSBuildString startswith \\\"21\\\"\\n| project DeviceName, OSBuild, OSPlatform, OSVersion\\n|join kind=inner (\\nDeviceLogonEvents\\n| where LogonType == \\\"Interactive\\\"\\n| where ActionType == \\\"LogonSuccess\\\"\\n| where InitiatingProcessCommandLine == \\\"lsass.exe\\\"\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n) on DeviceName\\n| project DeviceName, AccountName, OSBuild, OSPlatform, OSVersion\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-Windows11DevicesandUsers.kql", "query_name": "Device-Windows11DevicesandUsers", "attributes": {}}, {"query": "\"//Create a pivot table of all Windows OS versions in your environment\\n\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n//Microsoft Sentinel query\\nDeviceInfo\\n| where TimeGenerated > ago(30d)\\n| where isnotempty(OSBuild)\\n| summarize arg_max(TimeGenerated, *) by DeviceId\\n| where isnotempty(OSPlatform)\\n| evaluate pivot(OSBuild, count(), OSPlatform)\\n| where OSPlatform contains \\\"Windows\\\"\\n| sort by OSPlatform desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nDeviceInfo\\n| where Timestamp > ago(30d)\\n| where isnotempty(OSBuild)\\n| summarize arg_max(Timestamp, *) by DeviceName\\n| where isnotempty(OSPlatform)\\n| evaluate pivot(OSBuild, count(), OSPlatform)\\n| where OSPlatform contains \\\"Windows\\\"\\n| sort by OSPlatform desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Device-WindowsVersionPivotTable.kql", "query_name": "Device-WindowsVersionPivotTable", "attributes": {}}, {"query": "\"//CVE-2021-40444 hunting. Find device mshtml image load events initiated by common Office executables, then retrieve process events from the device in the same time period where the initiating process is an Office executable, but the process is different\\n\\n//Data connector required for this query - M365 Defender - Device* tables or Advanced Hunting license\\n\\nlet process = dynamic([\\\"winword.exe\\\", \\\"wordview.exe\\\", \\\"wordpad.exe\\\", \\\"powerpnt.exe\\\", \\\"excel.exe\\\"]);\\nDeviceImageLoadEvents\\n| where FileName in (\\\"mshtml.dll\\\", \\\"Microsoft.mshtml.dll\\\")\\n| where InitiatingProcessFileName in~ (process) \\n| project ImageLoadTime=TimeGenerated, DeviceName, InitiatingProcessFolderPath, \\n    InitiatingProcessParentFileName, InitiatingProcessParentCreationTime, \\n    InitiatingProcessCommandLine\\n| join kind=inner (\\n    DeviceProcessEvents)\\n    on DeviceName\\n| extend ProcessTime = TimeGenerated\\n| extend FileNameLower = tolower(FileName)\\n| extend InitiatingFileNameLower = tolower(InitiatingProcessFileName)\\n| where InitiatingProcessFileName in~ (process)\\n| where FileNameLower != InitiatingFileNameLower\\n| where ProcessTime between ((ImageLoadTime-timespan(5min)).. (ImageLoadTime+timespan(5min)))\\n| project ImageLoadTime, ProcessTime, DeviceName, InitiatingProcessFileName, FileName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Vuln-CVE-2021-40444.kql", "query_name": "Vuln-CVE-2021-40444", "attributes": {}}, {"query": "\"//Summarize your devices by which Microsoft CVEs they are vulnerable too. The data is summarized into severity and ordered by the most exposed devices.\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n//This query only works in Advanced Hunting as the DeviceTvm* tables aren't sent to Sentinel yet\\nDeviceTvmSoftwareVulnerabilities\\n| summarize ['Critical Severity Vulnerabilities']=make_set_if(CveId, SoftwareVendor == \\\"microsoft\\\" and VulnerabilitySeverityLevel == \\\"Critical\\\"),\\n    ['High Severity Vulnerabilities']=make_set_if(CveId, SoftwareVendor == \\\"microsoft\\\" and VulnerabilitySeverityLevel == \\\"High\\\"),\\n    ['Medium Severity Vulnerabilities']=make_set_if(CveId, SoftwareVendor == \\\"microsoft\\\" and VulnerabilitySeverityLevel == \\\"Medium\\\"), \\n    ['Low Severity Vulnerabilities']=make_set_if(CveId, SoftwareVendor == \\\"microsoft\\\" and VulnerabilitySeverityLevel == \\\"Low\\\")\\n    by DeviceName\\n| sort by array_length(['Critical Severity Vulnerabilities']) desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Vuln-HighestExposedDevices.kql", "query_name": "Vuln-HighestExposedDevices", "attributes": {}}, {"query": "\"//Use logon and network telemetry to find machines exposed to the internet, then count the critical and high severity vulnerabilities on those devices\\n//This query only works in Advanced Hunting as the DeviceTvm* tables aren't sent to Sentinel yet\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n//Look for logon events coming from a public IP - query adapted from https://github.com/alexverboon/MDATP/blob/master/AdvancedHunting/Failed%20Logon%20-%20Public%20IP.md\\nlet publicips = \\n    DeviceLogonEvents\\n    | where Timestamp > ago(30d)\\n    | where ActionType in (\\\"LogonFailed\\\", \\\"LogonSuccess\\\")\\n    | where RemoteIPType == \\\"Public\\\"\\n    | distinct RemoteIP;\\n//Use that same list of IP addresses to search for network traffic coming from those IP's, suggesting the device is available on the internet\\nlet publicdevices=\\n    DeviceNetworkEvents\\n    | where Timestamp > ago (30d)\\n    | where RemoteIPType == \\\"Public\\\"\\n    | where RemoteIP in (publicips)\\n    | distinct DeviceName;\\n//Find the high and critical vulnerability count for those devices\\nDeviceTvmSoftwareVulnerabilities\\n| where DeviceName in (publicdevices)\\n| summarize ['Vulnerability Count']=dcountif(CveId, VulnerabilitySeverityLevel in (\\\"Critical\\\", \\\"High\\\")) by DeviceName\\n| sort by ['Vulnerability Count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Vuln-InternetExposedDevices.kql", "query_name": "Vuln-InternetExposedDevices", "attributes": {}}, {"query": "\"//Query the list of Known Exploited Vulnerabilities provided by CISA - https://www.cisa.gov/known-exploited-vulnerabilities-catalog and query your devices for any that are vulnerable\\n\\n//Data connector required for this query - Advanced Hunting license\\n//This query only works in Advanced Hunting as the DeviceTvm* tables aren't sent to Sentinel yet\\n\\nlet KEV=\\nexternaldata(cveID: string, vendorProject: string, product: string, vulnerabilityName: string, dateAdded: datetime, shortDescription: string, requiredAction: string, dueDate: datetime)\\n[\\nh@'https://www.cisa.gov/sites/default/files/csv/known_exploited_vulnerabilities.csv'\\n]\\nwith(format='csv',ignorefirstrecord=true);\\nDeviceTvmSoftwareVulnerabilities\\n| project DeviceName, OSPlatform, cveID=CveId\\n| join kind=inner KEV on cveID\\n| summarize ['Vulnerabilities']=make_set(cveID) by DeviceName\\n| extend ['Count of Known Exploited Vulnerabilities'] = array_length(['Vulnerabilities'])\\n| sort by ['Count of Known Exploited Vulnerabilities']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Endpoint/Vuln-KnownExploitableVuln.kql", "query_name": "Vuln-KnownExploitableVuln", "attributes": {}}, {"query": "\"//Alert when Defender for Identity detects a change in kerberos constrained delegation configuration on a device\\n\\n//Data connector required for this query - M365 Defender - Identity* tables\\n\\nIdentityDirectoryEvents\\n| where ActionType == \\\"Account Constrained Delegation changed\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend ['Previous Delegation Setting'] = AF.[\\\"FROM AccountConstrainedDelegationState\\\"]\\n| extend ['Current Delegation Setting'] = AF.[\\\"TO AccountConstrainedDelegationState\\\"]\\n| extend ['Device Operating System'] = AF.TargetComputerOperatingSystem\\n| project\\n    TimeGenerated,\\n    TargetDeviceName,\\n    ['Device Operating System'],\\n    ['Previous Delegation Setting'],\\n    ['Current Delegation Setting']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Identity/IdentityDirectoryEvents-AccountDelegationChanged.kql", "query_name": "IdentityDirectoryEvents-AccountDelegationChanged", "attributes": {}}, {"query": "\"//Detect when the encryption types on a device are changed and parse the previous and current encryption types.\\n\\n//Data connector required for this query - M365 Defender - Identity* tables or Advanced Hunting license\\n\\n//If you don't send Defender for Id logs to Sentinel you can use the query in M365 Advanced Hunting directly\\nIdentityDirectoryEvents\\n| where ActionType == \\\"Account Supported Encryption Types changed\\\"\\n| parse AdditionalFields with * 'FROM AccountSupportedEncryptionTypes\\\":\\\"' PreviousEncryption '\\\"' *\\n| parse AdditionalFields with * 'TO AccountSupportedEncryptionTypes\\\":\\\"' CurrentEncryption '\\\"' *\\n| project TimeGenerated, TargetDeviceName, PreviousEncryption, CurrentEncryption\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Identity/IdentityDirectoryEvents-EncryptionChange.kql", "query_name": "IdentityDirectoryEvents-EncryptionChange", "attributes": {}}, {"query": "\"//Alert when Defender for Identity detects an account being set to 'password never expires'\\n\\n//Data connector required for this query - M365 Defender - Identity* tables\\n\\n//Microsoft Sentinel query\\nIdentityDirectoryEvents\\n| where ActionType == \\\"Account Password Never Expires changed\\\"\\n| extend ['Password never expires previous setting'] = tostring(AdditionalFields.[\\\"FROM Account Password Never Expires\\\"])\\n| extend ['Password never expires current setting'] = tostring(AdditionalFields.[\\\"TO Account Password Never Expires\\\"])\\n| project\\n    TimeGenerated,\\n    TargetAccountUpn,\\n    ['Password never expires current setting'],\\n    ['Password never expires previous setting']\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nIdentityDirectoryEvents\\n| where ActionType == \\\"Account Password Never Expires changed\\\"\\n| extend ['Password never expires previous setting'] = tostring(AdditionalFields.[\\\"FROM Account Password Never Expires\\\"])\\n| extend ['Password never expires current setting'] = tostring(AdditionalFields.[\\\"TO Account Password Never Expires\\\"])\\n| project\\n    Timestamp,\\n    TargetAccountUpn,\\n    ['Password never expires current setting'],\\n    ['Password never expires previous setting']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Identity/IdentityDirectoryEvents-PasswordSettoNeverExpire.kql", "query_name": "IdentityDirectoryEvents-PasswordSettoNeverExpire", "attributes": {}}, {"query": "\"//Summarize the accounts in your environment using cleartext LDAP connections\\n\\n//Data connector required for this query - M365 Defender - Identity* tables\\n\\n//Microsoft Sentinel query\\nIdentityLogonEvents\\n| where TimeGenerated > ago (30d)\\n| where LogonType == \\\"LDAP cleartext\\\"\\n| summarize\\n    ['Total connection count']=count(),\\n    ['Distinct destination device count']=dcount(DestinationDeviceName),\\n    ['List of destination devices']=make_set(DestinationDeviceName)\\n    by AccountUpn\\n| sort by ['Distinct destination device count'] desc \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nIdentityLogonEvents\\n| where Timestamp > ago (30d)\\n| where LogonType == \\\"LDAP cleartext\\\"\\n| summarize\\n    ['Total connection count']=count(),\\n    ['Distinct destination device count']=dcount(DestinationDeviceName),\\n    ['List of destination devices']=make_set(DestinationDeviceName)\\n    by AccountUpn\\n| sort by ['Distinct destination device count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Identity/IdentityLogonEvents-SummarizeClearTextLDAP.kql", "query_name": "IdentityLogonEvents-SummarizeClearTextLDAP", "attributes": {}}, {"query": "\"//Summarize NTLM authentications by which source computers & accounts are connecting to the most destination devices\\n\\n//Data connector required for this query - M365 Defender - Identity* tables\\n\\n//Microsoft Sentinel query\\nIdentityLogonEvents\\n| where TimeGenerated > ago(7d)\\n| where ActionType == \\\"LogonSuccess\\\"\\n| where Protocol == \\\"Ntlm\\\"\\n| where LogonType == \\\"Credentials validation\\\"\\n| summarize ['Target Device List']=make_set(DestinationDeviceName), ['Target Device Count']=dcount(DestinationDeviceName) by DeviceName, AccountName\\n| sort by ['Target Device Count'] desc \\n\\n//Advanced Hunting query\\nIdentityLogonEvents\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\n| where Timestamp > ago(7d)\\n| where ActionType == \\\"LogonSuccess\\\"\\n| where Protocol == \\\"Ntlm\\\"\\n| where LogonType == \\\"Credentials validation\\\"\\n| summarize ['Target Device List']=make_set(DestinationDeviceName), ['Target Device Count']=dcount(DestinationDeviceName) by DeviceName, AccountName\\n| sort by ['Target Device Count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Defender%20for%20Identity/IdentityLogonEvents-SummarizeNTLM.kql", "query_name": "IdentityLogonEvents-SummarizeNTLM", "attributes": {}}, {"query": "\"//When a domain is flagged by Defender for Cloud (Azure Security Center) as suspicious then find any other clients that have queried that domain in DNS events\\n\\n//Data connector required for this query - DNS\\n\\nlet suspiciousurl=\\nSecurityAlert\\n| where AlertName startswith \\\"Communication with suspicious random domain name\\\"\\n| mv-expand todynamic(Entities)\\n| project Entities\\n| extend SuspiciousURL = tostring(Entities.DomainName)\\n| where isnotempty(SuspiciousURL)\\n| distinct SuspiciousURL;\\n    DnsEvents\\n    | where QueryType == \\\"A\\\"\\n    | project Name, ClientIP\\n    | where Name in (suspiciousurl)\\n| summarize ['Client IPs']=make_set(ClientIP) by Name\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/DNS/DNS-FindDevicesThatHaveQueriedSuspiciousDomains.kql", "query_name": "DNS-FindDevicesThatHaveQueriedSuspiciousDomains", "attributes": {}}, {"query": "\"//Find DNS domains that have not been queried in the last 30 days. These are potentially stale and should be removed.\\n\\n//Data connector required for this query - DNS\\n\\nlet domain=\\\"yourdomain.com\\\";\\nDnsEvents\\n| where TimeGenerated > ago(180d)\\n| where SubType == \\\"LookupQuery\\\"\\n| where QueryType == \\\"A\\\"\\n| where Name endswith domain\\n| summarize LookupCount=count()by Name\\n//Set a threshold for total lookups to be included, to account for typos and low volume queries\\n| where LookupCount > 50\\n| join kind=leftanti \\n    (\\n    DnsEvents\\n    | where TimeGenerated > ago(30d)\\n    | where SubType == \\\"LookupQuery\\\"\\n    | where QueryType == \\\"A\\\"\\n    | where Name endswith domain\\n    | summarize arg_max(TimeGenerated, Name) by Name\\n    | project TimeGenerated, Name)\\n    on Name\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/DNS/DnsEvents-FindStaleDomains.kql", "query_name": "DnsEvents-FindStaleDomains", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as ADGroupChanges\\n// ADGroupChanges | where TimeGenerated > ago(1d) | where Action == \\\"Add\\\" and GroupName == \\\"TestGroup1\\\" // will all group additions to \\\"TestGroup1\\\"\\n// ADGroupChanges | where TimeGenerated > ago(1d) | where Action == \\\"Remove\\\" and Actor == \\\"User1\\\" // will find all group removals by \\\"User1\\\"\\n// This will parse the SecurityEvent log for any group additions or removals.\\nSecurityEvent\\n| project\\n    TimeGenerated,\\n    EventID,\\n    AccountType,\\n    MemberName,\\n    SubjectUserName,\\n    TargetUserName,\\n    Activity,\\n    MemberSid\\n| where EventID in (4728, 4729, 4732, 4733, 4756, 4757)\\n| parse MemberName with * 'CN=' Subject ',OU=' *\\n| extend Action = case(EventID in (\\\"4728\\\", \\\"4756\\\", \\\"4732\\\"), strcat(\\\"Add\\\"),\\n    EventID in (\\\"4729\\\", \\\"4757\\\", \\\"4733\\\"), strcat(\\\"Remove\\\"), \\\"unknown\\\")\\n| project\\n    TimeGenerated,\\n    Action,\\n    AccountType,\\n    Actor=SubjectUserName,\\n    Subject,\\n    GroupName=TargetUserName,\\n    Activity\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-ADGroupChanges.kql", "query_name": "Function-ADGroupChanges", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as KeyVaultAccess\\n// KeyVaultAccess | where TimeGenerated > ago(30d) | where Actor == \\\"user@yourdomain.com\\\" // will find actions taken by that user\\n// KeyVaultAccess | where TimeGenerated > ago(30d) | where * contains \\\"Delete\\\" // will find when delete access is added or removed\\n// This will parse the AzureActivity log for Azure Key Vault access changes.\\nAzureDiagnostics\\n| where ResourceType == \\\"VAULTS\\\"\\n| where OperationName == \\\"VaultPatch\\\"\\n| where ResultType == \\\"Success\\\"\\n| project-rename\\n    ServicePrincipalAdded=addedAccessPolicy_ObjectId_g,\\n    Actor=identity_claim_http_schemas_xmlsoap_org_ws_2005_05_identity_claims_name_s,\\n    AddedKeyPolicy = addedAccessPolicy_Permissions_keys_s,\\n    AddedSecretPolicy = addedAccessPolicy_Permissions_secrets_s,\\n    AddedCertPolicy = addedAccessPolicy_Permissions_certificates_s,\\n    RemovedKeyPolicy = removedAccessPolicy_Permissions_keys_s,\\n    RemovedSecretPolicy = removedAccessPolicy_Permissions_secrets_s,\\n    RemovedCertPolicy = removedAccessPolicy_Permissions_certificates_s,\\n    ServicePrincipalRemoved=removedAccessPolicy_ObjectId_g\\n| project\\n    TimeGenerated,\\n    KeyVaultName=Resource,\\n    ServicePrincipalAdded,\\n    ServicePrincipalRemoved,\\n    Actor,\\n    IPAddressofActor=CallerIPAddress,\\n    AddedSecretPolicy,\\n    AddedKeyPolicy,\\n    AddedCertPolicy,\\n    RemovedSecretPolicy,\\n    RemovedKeyPolicy,\\n    RemovedCertPolicy\\n| where isnotempty(AddedKeyPolicy)\\n    or isnotempty(AddedSecretPolicy)\\n    or isnotempty(AddedCertPolicy)\\n    or isnotempty(RemovedKeyPolicy)\\n    or isnotempty(RemovedSecretPolicy)\\n    or isnotempty(RemovedCertPolicy)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-AzureKeyVaultAccess.kql", "query_name": "Function-AzureKeyVaultAccess", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as ASALogs\\n// ASALogs | where TimeGenerated > ago(30d) | where Action == \\\"A real IP packet was denied by the ACL\\\"\\n// ASALogs | where TimeGenerated > ago(30d) | where DstIP == \\\"1.1.1.1\\\"\\n// This will parse the Syslog messages from a Cisco ASA appliance to separate columns\\nlet asa106017=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Deny IP due to Land Attack\\\"\\n| where Event == \\\"ASA-2-106017\\\"\\n| extend Action = Description\\n| parse SyslogMessage with * 'ASA-2-106017:' Message 'from' x 'to' y\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, Message, SrcIP, DstIP;\\nlet asa210005=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"LU allocate connection failed\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-3-210005\\\"\\n| parse SyslogMessage with * 'ASA-3-210005:' Message 'from' SrcVlan ':' x 'to' DstVLan ':' y\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, Message, SrcVlan, SrcIP,SrcPort, DstVLan, DstIP, DstPort;\\nlet asa106023=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"A real IP packet was denied by the ACL\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-4-106023\\\"\\n| parse SyslogMessage with * 'ASA-4-106023: Deny ' z ' src ' SrcVlan ':' x 'dst' DstVLan ':' y ' ' *\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| extend Protocol = toupper(z)\\n| project TimeGenerated, Computer, Description, Event, Action, Protocol, SrcVlan, SrcIP, SrcPort, DstVLan, DstIP, DstPort;\\nlet asa313005=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"No matching connection for ICMP error message\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-4-313005\\\"\\n| parse SyslogMessage with * 'ASA-4-313005:' Message 'src' SrcVlan ':' x 'dst' DstVLan ':' y ' ' *\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * 'connection for ' Protocol ' error' *\\n| project TimeGenerated, Computer, Description, Event, Protocol, Action, Message, SrcVlan, SrcIP, DstVLan, DstIP;\\nlet asa410001=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Dropped UDP DNS\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-4-410001\\\"\\n| parse SyslogMessage with * 'ASA-4-410001:' Message 'from' SrcVlan ':' x 'to' DstVLan ':' y ';' *\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * 'Dropped ' Protocol ' DNS' *\\n| project TimeGenerated, Computer, Description, Protocol, Event, Action, Message, SrcVlan, SrcIP, SrcPort, DstVLan, DstIP, DstPort;\\nlet asa419002=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Duplicate TCP SYN\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-4-419002\\\"\\n| parse SyslogMessage with * 'ASA-4-419002:' Message 'from' SrcVlan ':' x 'to' DstVLan ':' y ' ' *\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * 'Duplicate ' Protocol ' SYN' *\\n| project TimeGenerated, Computer, Description, Protocol, Event, Action, Message, SrcVlan, SrcIP,SrcPort, DstVLan, DstIP, DstPort;\\nlet asa500004=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Invalid transport field for protocol\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-4-500004\\\"\\n| parse SyslogMessage with * 'ASA-4-500004:' Message ', from' x 'to' y\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, Message, SrcIP, SrcPort, DstIP, DstPort;\\nlet asa733100=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Drop rate exceeded\\\"\\n| where Event == \\\"ASA-4-733100\\\"\\n| extend Action = Description\\n| parse SyslogMessage with * 'ASA-4-733100:' Message\\n| project TimeGenerated, Computer, Description, Event, Action, Message;\\nlet asa111008=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"User command executed\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-5-111008\\\"\\n| parse SyslogMessage with * 'ASA-5-111008:' Message\\n| project TimeGenerated, Computer, Description, Event, Action, Message;\\nlet asa111010=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"User made configuration change\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-5-111010\\\"\\n| parse SyslogMessage with * 'ASA-5-111010:' Message\\n| project TimeGenerated, Computer, Description, Event, Action, Message;\\nlet asa611103=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"User logged out\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-5-611103\\\"\\n| parse SyslogMessage with * 'ASA-5-611103:' Message\\n| project TimeGenerated, Computer, Description, Event, Action, Message;\\nlet asa106015=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Deny TCP (no connection)\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-106015\\\"\\n| parse SyslogMessage with * 'ASA-6-106015:' Message 'from' x 'to' y 'flags' Flags 'on interface' DstVLan\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * 'Deny ' Protocol ' (' *\\n| project TimeGenerated, Computer, Description, Event, Protocol, Action, Message, SrcIP, SrcPort, DstIP, DstPort, Flags, DstVLan;\\nlet asa110002=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Failed to locate egress interface\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-110002\\\"\\n| parse SyslogMessage with * 'ASA-6-110002:' Message 'for' Protocol 'from' SrcVlan ':' x 'to' y\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, Message, Protocol, SrcVlan, SrcIP, SrcPort, DstIP, DstPort;\\nlet asa113004=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"AAA user authentication Successful\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-113004\\\"\\n| parse SyslogMessage with * 'ASA-6-113004:' Message ': server = ' x ' : user = ' User\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, Message, SrcIP, User;\\nlet asa113008=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"AAA transaction status ACCEPT\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-113008\\\"\\n| parse SyslogMessage with * 'ASA-6-113008:' Message ' : user = ' User\\n| project TimeGenerated, Computer, Description, Event, Message, Action, User;\\nlet asa302010=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Connection stats\\\"\\n| where Event == \\\"ASA-6-302010\\\"\\n| extend Action = Description\\n| parse SyslogMessage with * 'ASA-6-302010:' ConnectionsInUse ' in use, ' ConnectionsMostUsed  ' most used';\\nlet asa302013=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Built outbound TCP connection\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-302013\\\"\\n| parse SyslogMessage with * 'connection ' ConnectionId 'for ' DstVlan ':' y ' (' DestNATIp ') to ' SrcVlan ':' x ' (' DstNATIP ')' \\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * ' outbound ' Protocol ' connection' *\\n| project TimeGenerated, Computer, Description, Event, Action, Protocol, ConnectionId, DstVlan, DstIP, DstPort, SrcVlan, SrcIP, SrcPort, DstNATIP;\\nlet asa302014=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Teardown outbound TCP connection\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-302014\\\"\\n| parse SyslogMessage with * 'connection ' ConnectionId 'for ' DstVlan ':' y ' to ' SrcVlan ':' x ' duration ' Duration ' bytes' *\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * ' outbound ' Protocol ' connection' *\\n| project TimeGenerated, Computer, Description, Event, Action, Protocol, ConnectionId, DstVlan, DstIP, DstPort, SrcVlan, SrcIP, SrcPort, Duration;\\nlet asa302015=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Built outbound UDP connection\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-302015\\\"\\n| parse SyslogMessage with * 'connection ' ConnectionId 'for ' DstVlan ':' y ' (' DestNATIp ') to ' SrcVlan ':' x ' (' DstNATIP ')' \\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * ' outbound ' Protocol ' connection' *\\n| project TimeGenerated, Computer, Description, Event, Protocol, Action, ConnectionId, DstVlan, DstIP, DstPort, SrcVlan, SrcIP, SrcPort, DstNATIP;\\nlet asa302016=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Teardown UDP connection\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-302016\\\"\\n| parse SyslogMessage with * 'connection ' ConnectionId 'for ' DstVlan ':' y ' to ' SrcVlan ':' x ' duration ' Duration ' bytes' *\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * 'Teardown ' Protocol ' connection' *\\n| project TimeGenerated, Computer, Description, Protocol, Event, Action, ConnectionId, DstVlan, DstIP, DstPort, SrcVlan, SrcIP, SrcPort, Duration;\\nlet asa302020=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Built outbound ICMP connection\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-302020\\\"\\n| parse SyslogMessage with * 'faddr ' y ' gaddr ' x ' laddr ' SrcNATIP ' type' *\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * ' outbound ' Protocol ' connection' *\\n| project TimeGenerated, Computer, Description, Protocol, Event, Action, DstIP, DstPort, SrcPort, SrcIP, SrcNATIP;\\nlet asa302021=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Teardown ICMP connection\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-302021\\\"\\n| parse SyslogMessage with * 'faddr ' y ' gaddr ' x ' laddr ' SrcNATIP ' type' *\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| parse Action with * 'Teardown ' Protocol ' connection' *\\n| project TimeGenerated, Computer, Description, Protocol, Event, Action, DstIP, DstPort, SrcIP, SrcPort, SrcNATIP;\\nlet asa303002=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"FTP connection\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-303002\\\"\\n| parse SyslogMessage with * 'from ' SrcVlan ':' x ' to ' DstVlan ':' y ',' Message\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, SrcVlan, SrcIP, SrcPort, DstVlan, DstIP, DstPort, Message;\\nlet asa305011=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Build Nat Translation\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-305011\\\"\\n| parse SyslogMessage with * 'dynamic ' Protocol ' translation from ' SrcVlan ':' x ' to ' DstVlan ':' y\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, SrcVlan, SrcIP, SrcPort, DstVlan, DstIP, DstPort;\\nlet asa305012=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Teardown Nat Translation\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-305012\\\"\\n| parse SyslogMessage with * 'dynamic ' Protocol ' translation from ' SrcVlan ':' x ' to ' DstVlan ':' y ' duration ' Duration\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, SrcVlan, SrcIP, SrcPort, DstVlan, DstIP, DstPort, Duration;\\nlet asa315011=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"SSH session\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-315011\\\"\\n| parse SyslogMessage with * 'from ' x 'on interface ' SrcVlan 'for ' Message\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, SrcIP, SrcVlan, Message;\\nlet asa605005=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Login permitted\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-605005\\\"\\n| parse SyslogMessage with * 'from ' x ' to ' DstVlan ':' y ' for user ' User\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| extend DstIP = split(y,'/')[0]\\n| extend DstPort = split(y,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, SrcIP, SrcPort, DstVlan, DstIP, DstPort, User;\\nlet asa611101=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"User authentication succeeded\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-611101\\\"\\n| parse SyslogMessage with * ': IP address: ' x ', Uname: ' User\\n| extend SrcIP = split(x,'/')[0]\\n| extend SrcPort = split(x,'/')[1]\\n| project TimeGenerated, Computer, Description, Event, Action, SrcIP, User;\\nlet asa769007=\\nSyslog\\n| parse SyslogMessage with * '%' Event ':' *\\n| project TimeGenerated, Event, SyslogMessage, Computer\\n| extend Description = \\\"Image version\\\"\\n| extend Action = Description\\n| where Event == \\\"ASA-6-769007\\\"\\n| parse SyslogMessage with * 'UPDATE: ' ImageVersion\\n| project TimeGenerated, Computer, Description, Event, Action, ImageVersion;\\nunion asa106017, asa106023, asa210005, asa313005, asa410001, asa419002, asa500004, asa733100, asa111008, asa111010, asa611103, asa106015, asa110002, asa113004, asa113008, asa302010, asa302013, asa302014, asa302015, asa302016, asa302020, asa302021, asa303002, asa305011, asa305012, asa315011, asa605005, asa611101, asa769007\\n| project TimeGenerated, Computer, Event, Action, Protocol, SrcIP, SrcPort, SrcVlan, SrcNATIP, DstIP, DstPort, DstVlan, DstNATIP ,Duration, Message, User, Flags, ImageVersion, ConnectionsInUse, ConnectionsMostUsed, Description\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-CiscoASAParser.kql", "query_name": "Function-CiscoASAParser", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as DeviceLookup\\n// DeviceLookup | where IPAddresses has \\\"10.10.10.10\\\" // will find all devices that have had the IPAddress 10.10.10.10\\n// DeviceLookup | where ['Logged on Admins'] has \\\"user1\\\" // will find all devices user1 has logged onto as an admin\\n// DeviceLookup | where array_length( ['Logged on Admins']) > 10 // will find devices with more than 10 local admins logged on \\n// This will parse the last 14 days of the DeviceInfo, DeviceLogonEvents and DeviceNetworkInfo tables for information\\nlet deviceinfo=\\n    DeviceInfo\\n    | where TimeGenerated > ago (14d)\\n    | where isnotempty(OSBuild)\\n    | summarize arg_max(TimeGenerated, *) by DeviceId\\n    | project DeviceName, DeviceId, OSPlatform, OSBuild;\\nlet logons=\\n    DeviceLogonEvents\\n    | where TimeGenerated > ago(14d)\\n    | project\\n        DeviceName,\\n        ActionType,\\n        LogonType,\\n        AccountName,\\n        DeviceId,\\n        InitiatingProcessCommandLine,\\n        AdditionalFields,\\n        IsLocalAdmin\\n    | where ActionType == \\\"LogonSuccess\\\"\\n    | where LogonType == \\\"Interactive\\\"\\n    | where AdditionalFields.IsLocalLogon == true\\n    | where InitiatingProcessCommandLine == \\\"lsass.exe\\\"\\n    | summarize\\n        ['Logged on Users']=make_set_if(AccountName, IsLocalAdmin == \\\"false\\\"),\\n        ['Logged on Admins']=make_set_if(AccountName, IsLocalAdmin == \\\"true\\\")\\n        by DeviceId;\\nlet ipaddresses=\\n    DeviceNetworkInfo\\n    | where TimeGenerated > ago (14d)\\n    | mv-expand IPAddresses\\n    | extend IPAddress = tostring(IPAddresses.IPAddress)\\n    | summarize IPAddresses=make_set(IPAddress) by DeviceId;\\ndeviceinfo\\n| lookup logons on DeviceId\\n| lookup ipaddresses on DeviceId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-DeviceLookup.kql", "query_name": "Function-DeviceLookup", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as ADFailedLogons\\n// ADFailedLogons | where TimeGenerated > ago(30d) | where Account == \\\"DOMAIN\\\\username\\\" // will find logon failures by that user\\n// ADFailedLogons | where TimeGenerated > ago(30d) | where ResultReason == \\\"User logon with expired password\\\" // will find logon failures from accounts with expired passwords\\n// This will parse the SecurityEvent log for logon failures and add the descriptive reason.\\nSecurityEvent\\n| where EventID == \\\"4625\\\"\\n| extend ResultReason = case(\\n    Status == \\\"0xc000005e\\\", strcat(\\\"There are currently no logon servers available to service the logon request\\\"),\\n    Status == \\\"0xc0000064\\\", strcat(\\\"User logon with misspelled or bad user account\\\"),\\n    Status == \\\"0xc000006a\\\", strcat(\\\"User logon with misspelled or bad password\\\"),\\n    Status == \\\"0xc000006d\\\", strcat(\\\"The cause is either a bad username or authentication information\\\"),\\n    Status == \\\"0xc000006e\\\", strcat(\\\"Indicates a referenced user name and authentication information are valid, but some user account restriction has prevented successful authentication (such as time-of-day restrictions)\\\"),\\n    Status == \\\"0xc000006f\\\", strcat(\\\"User logon outside authorized hours\\\"),\\n    Status == \\\"0xc0000070\\\", strcat(\\\"User logon from unauthorized workstation\\\"),\\n    Status == \\\"0xc0000071\\\", strcat(\\\"User logon with expired password\\\"),\\n    Status == \\\"0xc0000072\\\", strcat(\\\"User logon to account disabled by administrator\\\"),\\n    Status == \\\"0xc000018b\\\", strcat(\\\"Security database on the server does not have a computer account for this workstation trust relationship\\\"),\\n    Status == \\\"0xc00000dc\\\", strcat(\\\"Indicates the Sam Server was in the wrong state to perform the desired operation\\\"),\\n    Status == \\\"0xc0000133\\\", strcat(\\\"Clocks between DC and other computer too far out of sync\\\"),\\n    Status == \\\"0xc000015b\\\", strcat(\\\"The user has not been granted the requested logon type (also called the logon right) at this machine\\\"),\\n    Status == \\\"0xc000018c\\\", strcat(\\\"The logon request failed because the trust relationship between the primary domain and the trusted domain failed\\\"),\\n    Status == \\\"0xc0000192\\\", strcat(\\\"An attempt was made to logon, but the Netlogon service was not started\\\"),\\n    Status == \\\"0xc0000193\\\", strcat(\\\"User logon with expired account\\\"),\\n    Status == \\\"0xc0000224\\\", strcat(\\\"User is required to change password at next logon\\\"),\\n    Status == \\\"0xc0000225\\\", strcat(\\\"Evidently a bug in Windows and not a risk\\\"),\\n    Status == \\\"0xc0000234\\\", strcat(\\\"User logon with account locked\\\"),\\n    Status == \\\"0xc000015a\\\", strcat(\\\"During a logon attempt, the user's security context accumulated too many security IDs\\\"),\\n    Status == \\\"0xc00002ee\\\", strcat(\\\"Failure Reason: An Error occurred during Logon\\\"),\\n    Status == \\\"0xc0000413\\\", strcat(\\\"Logon Failure: The machine you are logging on to is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine\\\"),\\n    Status == \\\"0x0\\\", strcat(\\\"Status OK\\\"),\\n    \\\"unknown\\\")\\n| project\\n    TimeGenerated,\\n    Status,\\n    ResultReason,\\n    Account,\\n    AccountType,\\n    Computer,\\n    AuthenticationPackageName,\\n    IpAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-FailedActiveDirectoryLogons.kql", "query_name": "Function-FailedActiveDirectoryLogons", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as GroupChanges\\n// GroupChanges | where TimeGenerated > ago(1d) | where Action == \\\"Add\\\" and GroupName == \\\"TestGroup1\\\" // Will find all group additions to \\\"TestGroup1\\\"\\n// GroupChanges | where TimeGenerated > ago(1d) | where Action == \\\"Remove\\\" and Actor == \\\"User1\\\" and Environment == \\\"Azure Active Directory\\\" // will find all group removals by \\\"User1\\\" in Azure Active Directory\\n// GroupChanges | where TimeGenerated > ago(1d) | where Action == \\\"Add\\\" | Will find all Add actions in both Active Directory and Azure Active Directory\\nlet aaduseradded=\\n    AuditLogs\\n    | where OperationName == \\\"Add member to group\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend Target = tostring(TargetResources[0].userPrincipalName)\\n    | extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n    | where isnotempty(Actor) and isnotempty(Target)\\n    | extend Environment = strcat(\\\"Azure Active Directory\\\")\\n    | extend Action = strcat(\\\"Add\\\")\\n    | project TimeGenerated, Action, Actor, Target, GroupName, Environment;\\nlet aaduserremoved=\\n    AuditLogs\\n    | where OperationName == \\\"Remove member from group\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].oldValue)))\\n    | extend Target = tostring(TargetResources[0].userPrincipalName)\\n    | where isnotempty(Actor) and isnotempty(Target)\\n    | extend Action = strcat(\\\"Remove\\\")\\n    | extend Environment = strcat(\\\"Azure Active Directory\\\")\\n    | project TimeGenerated, Action, Actor, Target, GroupName, Environment;\\nlet adchanges=\\n    SecurityEvent\\n    | project TimeGenerated, EventID, AccountType, MemberName, SubjectUserName, TargetUserName\\n    | where AccountType == \\\"User\\\"\\n    | where EventID in (4728, 4729, 4732, 4733, 4756, 4757)\\n    | extend x = tolower(MemberName)\\n    | parse x with * 'cn=' Target ',ou=' *\\n    | extend Action = case(EventID in (\\\"4728\\\", \\\"4756\\\", \\\"4732\\\"), strcat(\\\"Add\\\"),\\n        EventID in (\\\"4729\\\", \\\"4757\\\", \\\"4733\\\"), strcat(\\\"Remove\\\"), \\\"unknown\\\")\\n    | extend Environment = strcat(\\\"Active Directory\\\")\\n    | project TimeGenerated, Action, Actor=SubjectUserName, Target, GroupName=TargetUserName, Environment;\\nunion aaduseradded, aaduserremoved, adchanges\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-GroupChanges.kql", "query_name": "Function-GroupChanges", "attributes": {}}, {"query": "\"//Single function to summarize a single guest domain. It will retrieve the following information about a specific domain.\\n//Azure AD Sign in Logs - total sign in count, distinct sign in count, list of applications, count of applications, list of users\\n//Azure AD Audit Logs - invites sent and redeemed from this domain\\n//Office 365 - total files downloaded, distinct filese downloaded from this domain\\n//Office 365 - count of users added to Teams, distinct count of users added to Teams and the list of Teams\\n\\n//Save as a function in your workspace then invoke via its name, ie UserInvestigation(\\\"user@domain.com\\\"). Your function requires a parameter as per https://github.com/reprise99/Sentinel-Queries/tree/main/Functions\\n//The function requires a parameter which is a string, with the name domain and a default value of \\\"gmail.com\\\" (or any domain you wish)\\n\\nlet signins=\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where UserPrincipalName endswith (domain)\\n| summarize ['Total Signins']=count(), ['Count of Users']=dcount(UserPrincipalName), ['Count of Applications']=dcount(AppDisplayName), ['List of Applications Accessed']=make_set(AppDisplayName), ['List of Users']=make_set(UserPrincipalName), ['List of Locations']=make_set(Location) by Domain=(domain);\\nlet invitedusers=\\nAuditLogs\\n| where TimeGenerated > ago(30d)\\n| where OperationName == \\\"Invite external user\\\"\\n| extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)\\n| where TargetResources contains (domain)\\n| summarize ['Invited User Count']=dcount(UserPrincipalName), ['List of Users Invited']=make_set(UserPrincipalName) by Domain=(domain);\\nlet redeemedusers=\\nAuditLogs\\n| where TimeGenerated > ago(30d)\\n| where OperationName == \\\"Redeem external user invite\\\"\\n| extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| where UserPrincipalName endswith (domain)\\n| summarize ['Invite Redeemed User Count']=dcount(UserPrincipalName), ['List of Redeemed Users']=make_set(UserPrincipalName) by Domain=(domain);\\nlet officedownloads=\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId contains \\\"#EXT#\\\"\\n| extend ['Guest UserPrincipalName'] = tostring(split(UserId,\\\"#\\\")[0])\\n| extend ['Guest Domain'] = tostring(split(['Guest UserPrincipalName'],\\\"_\\\")[-1])\\n| where ['Guest Domain'] =~ (domain)\\n| summarize ['Total Guest Download Count']=count(), ['Distinct File Download Count']=dcount(OfficeObjectId) by Domain=(domain);\\nlet teamsaccess=\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation == \\\"MemberAdded\\\"\\n| mv-expand Members\\n| extend UserPrincipalName = tostring(Members.UPN)\\n| where UserPrincipalName contains \\\"#EXT#\\\"\\n| where CommunicationType == \\\"Team\\\"\\n| where UserPrincipalName contains (domain)\\n| summarize ['Count of Guests Added to Teams']=count(), ['Distinct Count of Guests Added to Teams']=dcount(UserPrincipalName), ['Count of Teams with Guests Added']=dcount(TeamName), ['List of Teams with Guests Added']=make_set(TeamName) by Domain=(domain);\\nsignins\\n| lookup invitedusers on Domain\\n| lookup redeemedusers on Domain\\n| lookup officedownloads on Domain\\n| lookup teamsaccess on Domain\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-GuestDomainInfo.kql", "query_name": "Function-GuestDomainInfo", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as SigninRisk\\n// SigninRisk | where TimeGenerated > ago(30d) | where UserPrincipalName == \\\"user@yourdomain.com\\\"\\n// SigninRisk | where TimeGenerated > ago(30d) | where AssignedRoles contains \\\"Global Administrator\\\"\\n// This will join the users identity information, sign in data and any risky signins for your query\\nIdentityInfo\\n| where TimeGenerated > ago (21d)\\n| summarize arg_max(TimeGenerated,*) by AccountUPN\\n| join kind=inner(\\nSigninLogs) on $left.AccountUPN==$right.UserPrincipalName\\n| project SigninTime=TimeGenerated1, UserPrincipalName, AppDisplayName, ResultType, AssignedRoles, Location, UserAgent, AuthenticationRequirement, Country, City, CorrelationId\\n| join kind=inner (\\nAADUserRiskEvents) on CorrelationId\\n| project SigninTime, UserPrincipalName, AppDisplayName, ResultType, DetectionTimingType, RiskState, RiskLevel, Location, AssignedRoles, UserAgent, AuthenticationRequirement, Country, City\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-IdentityInfowithSigninRisk.kql", "query_name": "Function-IdentityInfowithSigninRisk", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as NewDetections\\n// NewDetections // will find any new detections from your Azure AD Audit logs, Defender for Cloud Apps, Security Alerts, Office Activity and Defender for Endpoint\\n// NewDetections | where Source == \\\"Office 365 Audit Events\\\" // will find new detections from Office 365\\n// NewDetections | where Count > 10 // will find new detections that have been seen more than 10 times\\n// This function looks for new events in Azure AD Audit logs, Defender for Cloud Apps, Security Alerts, Office Activity and Defender for Endpoint in the last week compared to the last 180 days\\nlet newauditevents=\\n    AuditLogs\\n    | where TimeGenerated > ago(180d) and TimeGenerated < ago(7d)\\n    | distinct OperationName, LoggedByService\\n    | join kind=rightanti (\\n        AuditLogs\\n        | where TimeGenerated > ago(7d)\\n        )\\n        on OperationName, LoggedByService\\n    | summarize ['First Time Seen']=min(TimeGenerated), Count=count() by Activity=OperationName, Application=\\\"Azure AD\\\", Source=\\\"Azure AD Audit Events\\\";\\nlet newdeviceevents=\\n    DeviceEvents\\n    | where TimeGenerated > ago(180d) and TimeGenerated < ago(7d)\\n    | distinct ActionType\\n    | join kind=rightanti (\\n        DeviceEvents\\n        | where TimeGenerated > ago(7d)\\n        )\\n        on ActionType\\n    | summarize ['First Time Seen']=min(TimeGenerated), Count=count()\\n        by\\n        Activity=ActionType,\\n        Application=\\\"Defender for EndPoint\\\",\\n        Source=\\\"Defender for Endpoint Device Events\\\";\\nlet newnewofficeactivity=\\n    OfficeActivity\\n    | where TimeGenerated > ago(180d) and TimeGenerated < ago(7d)\\n    | distinct Operation\\n    | join kind=rightanti (\\n        OfficeActivity\\n        | where TimeGenerated > ago(7d)\\n        )\\n        on Operation\\n    | summarize ['First Time Seen']=min(TimeGenerated), Count=count() by Activity=Operation, Application=OfficeWorkload, Source=\\\"Office 365 Audit Events\\\";\\nlet newcloudappevents=\\n    CloudAppEvents\\n    | where TimeGenerated > ago(180d) and TimeGenerated < ago(7d)\\n    | distinct ActionType\\n    | join kind=rightanti (\\n        CloudAppEvents\\n        | where TimeGenerated > ago(7d)\\n        )\\n        on ActionType\\n    | summarize ['First Time Seen']=min(TimeGenerated), Count=count() by Activity=ActionType, Application, Source=\\\"Defender for Cloud Apps Events\\\";\\nlet newsecurityalerts=\\n    SecurityAlert\\n    | where TimeGenerated > ago(180d) and TimeGenerated < ago(7d)\\n    | where ProviderName != \\\"ASI Scheduled Alerts\\\"\\n    | distinct AlertName\\n    | join kind=rightanti (\\n        SecurityAlert\\n        | where TimeGenerated > ago(7d)\\n        | where ProviderName != \\\"ASI Scheduled Alerts\\\"\\n        )\\n        on AlertName\\n    | summarize ['First Time Seen']=min(TimeGenerated), Count=count() by Activity=AlertName, Application=ProviderName, Source=\\\"Security Alert Events\\\";\\nunion\\n    newauditevents,\\n    newdeviceevents,\\n    newnewofficeactivity,\\n    newcloudappevents,\\n    newsecurityalerts\\n| sort by Count desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-NewDetections.kql", "query_name": "Function-NewDetections", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as PrivilegeChanges then call via the same name\\n// This function is designed to unify group or privilege changes across on-premises AD and Azure AD\\n// It will find changes to privileged AD groups, changes to privileged AAD groups, changes to privileged AAD roles (both directly and via PIM)\\n// Default groups and roles have been added, but add your own groups that you wish to monitor unique to your environment\\n// By default it will look back one day\\n\\nlet privADgroups=dynamic([\\\"Domain Admins\\\", \\\"Enterprise Admins\\\", \\\"Schema Admins\\\", \\\"Account Operators\\\", \\\"DnsAdmins\\\", \\\"Backup Operators\\\"]);\\nlet privAADgroups=dynamic([\\\"azure.Privileged Group\\\", \\\"azure.Privileged App\\\", \\\"az.ConditionalAccessBypassGroup\\\"]);\\nlet privAADroles=dynamic([\\\"Global Administrator\\\", \\\"Application Administrator\\\", \\\"Privileged Authentication Administrator\\\", \\\"Privileged Role Administrator\\\", \\\"Security Administrator\\\" \\\"Identity Governance Administrator\\\"]);\\nlet timeframe=1d;\\nlet adchanges=\\n    SecurityEvent\\n    | where TimeGenerated > ago (timeframe)\\n    | project TimeGenerated, Account, MemberName, TargetAccount, TargetUserName, Activity, EventID\\n    | where EventID in (4728, 4729, 4732, 4733, 4756, 4757) and TargetUserName in~ (privADgroups)\\n    | project\\n        TimeGenerated,\\n        Activity,\\n        ['Group or Role Name']=TargetUserName,\\n        Actor=Account,\\n        Target=MemberName,\\n        Environment=\\\"Active Directory\\\";\\nlet aaduseradded=\\n    AuditLogs\\n    | where TimeGenerated > ago (timeframe)\\n    | where OperationName == \\\"Add member to group\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend Target = tostring(TargetResources[0].userPrincipalName)\\n    | extend ['Group or Role Name']= tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n    | where isnotempty(Actor) and isnotempty(Target)\\n    | where ['Group or Role Name'] in~ (privAADgroups)\\n    | project\\n        TimeGenerated,\\n        Activity=\\\"A member was added to a privleged Azure AD Group\\\",\\n        ['Group or Role Name'],\\n        Actor,\\n        Target,\\n        Environment=\\\"Azure Active Directory\\\";\\nlet aaduserremoved=\\n    AuditLogs\\n    | where TimeGenerated > ago (timeframe)\\n    | where OperationName == \\\"Remove member from group\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend ['Group or Role Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].oldValue)))\\n    | extend Target = tostring(TargetResources[0].userPrincipalName)\\n    | where isnotempty(Actor) and isnotempty(Target)\\n    | where ['Group or Role Name'] in~ (privAADgroups)\\n    | extend Environment = strcat(\\\"Azure Active Directory\\\")\\n    | project\\n        TimeGenerated,\\n        Activity=\\\"A member was removed from a privleged Azure AD Group\\\",\\n        ['Group or Role Name'],\\n        Actor,\\n        Target,\\n        Environment=\\\"Azure Active Directory\\\";\\nlet aadroleadded=\\n    AuditLogs\\n    | where TimeGenerated > ago (timeframe)\\n    | where OperationName == \\\"Add member to role\\\"\\n    //Exclude PIM activations\\n    | where Identity != \\\"MS-PIM\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend Target = tostring(TargetResources[0].userPrincipalName)\\n    | extend ['Group or Role Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\\n    | where isnotempty(Actor) and isnotempty(Target)\\n    | where ['Group or Role Name'] in~ (privAADroles)\\n    | project\\n        TimeGenerated,\\n        Activity=\\\"A member was added to a privleged Azure AD Role\\\",\\n        ['Group or Role Name'],\\n        Actor,\\n        Target,\\n        Environment=\\\"Azure Active Directory\\\";\\nlet aadroleremoved=\\n    AuditLogs\\n    | where TimeGenerated > ago (timeframe)\\n    | where OperationName == \\\"Remove member from role\\\"\\n   //Exclude PIM activations\\n    | where Identity != \\\"MS-PIM\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend Target = tostring(TargetResources[0].userPrincipalName)\\n    | extend ['Group or Role Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].oldValue)))\\n    | where isnotempty(Actor) and isnotempty(Target)\\n    | where ['Group or Role Name'] in~ (privAADroles)\\n    | project\\n        TimeGenerated,\\n        Activity=\\\"A member was removed from a privleged Azure AD Role\\\",\\n        ['Group or Role Name'],\\n        Actor,\\n        Target,\\n        Environment=\\\"Azure Active Directory\\\";\\nlet addpim=\\n    AuditLogs\\n    | where TimeGenerated > ago (timeframe)\\n    | where OperationName in (\\\"Add member to role in PIM completed (permanent)\\\", \\\"Add member to role in PIM completed (timebound)\\\", \\\"Add eligible member to role in PIM completed (timebound)\\\", \\\"Add eligible member to role in PIM completed (permanent)\\\")\\n    | where TargetResources[2].type == \\\"User\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend Target = tostring(TargetResources[2].userPrincipalName)\\n    | extend ['Group or Role Name'] = tostring(TargetResources[0].displayName)\\n    | where isnotempty(Actor) and isnotempty(Target)\\n    | where ['Group or Role Name'] in~ (privAADroles)\\n    | extend Activity = case(OperationName == \\\"Add member to role in PIM completed (permanent)\\\", strcat=\\\"A member was assigned to a permanent active Azure AD PIM Role\\\",\\n        OperationName == \\\"Add member to role in PIM completed (timebound)\\\", strcat=\\\"A member was assigned to a timebound active Azure AD PIM Role\\\",\\n        OperationName == \\\"Add eligible member to role in PIM completed (permanent)\\\", strcat=\\\"A member was assigned to a permanent eligible Azure AD PIM Role\\\",\\n        OperationName == \\\"Add eligible member to role in PIM completed (timebound)\\\", strcat=\\\"A member was assigned to a timebound eligible Azure AD PIM Role\\\",\\n        \\\"unknown\\\")\\n    | project\\n        TimeGenerated,\\n        Activity,\\n        ['Group or Role Name'],\\n        Actor,\\n        Target,\\n        Environment=\\\"Azure Active Directory\\\";\\nlet removepim=\\n    AuditLogs\\n    | where TimeGenerated > ago (timeframe)\\n    | where OperationName in (\\\"Remove member from role in PIM completed (permanent)\\\", \\\"Remove member from role in PIM completed (timebound)\\\", \\\"Remove eligible member from role in PIM completed (permanent)\\\", \\\"Remove eligible member from role in PIM completed (timebound)\\\")\\n    | where TargetResources[2].type == \\\"User\\\"\\n    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend Target = tostring(TargetResources[2].userPrincipalName)\\n    | extend ['Group or Role Name'] = tostring(TargetResources[0].displayName)\\n    | where isnotempty(Actor) and isnotempty(Target)\\n    | where ['Group or Role Name'] in~ (privAADroles)\\n    | extend Activity = case(OperationName == \\\"Remove member from role in PIM completed (permanent)\\\", strcat=\\\"A member was removed from a permanent active Azure AD PIM Role\\\",\\n        OperationName == \\\"Remove member from role in PIM completed (timebound)\\\", strcat=\\\"A member was removed from a timebound active Azure AD PIM Role\\\",\\n        OperationName == \\\"Remove eligible member from role in PIM completed (permanent)\\\", strcat=\\\"A member was removed from a permanent eligible Azure AD PIM Role\\\",\\n        OperationName == \\\"Remove eligible member from role in PIM completed (timebound)\\\", strcat=\\\"A member was removed from a timebound eligible Azure AD PIM Role\\\",\\n        \\\"unknown\\\")\\n    | project\\n        TimeGenerated,\\n        Activity,\\n        ['Group or Role Name'],\\n        Actor,\\n        Target,\\n        Environment=\\\"Azure Active Directory\\\";\\nunion adchanges, aaduseradded, aaduserremoved, aadroleadded, aadroleremoved, addpim, removepim\\n| project-reorder TimeGenerated, Activity, ['Group or Role Name'], Actor, Target, Environment\\n| sort by TimeGenerated desc \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-PrivilegeChanges.kql", "query_name": "Function-PrivilegeChanges", "attributes": {}}, {"query": "\"//Query several tables to retireve all your DCs - such as kerberos, DNS, replication events\\nlet SamrDC=\\nIdentityQueryEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType == \\\"SAMR query\\\"\\n| distinct DestinationDeviceName;\\nlet DnsDC=\\nDnsEvents\\n| where TimeGenerated > ago (30d)\\n| where Name startswith \\\"_kerberos.\\\"\\n| distinct Computer\\n| extend DestinationDeviceName = tolower(Computer);\\nlet SrvDC=\\nIdentityQueryEvents\\n| where TimeGenerated > ago (30d)\\n| where QueryType == \\\"Srv\\\"\\n| where QueryTarget startswith \\\"_kerberos.\\\"\\n| distinct DestinationDeviceName;\\nlet directoryeventsDC=\\nIdentityDirectoryEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType in (\\\"Directory Services replication\\\")\\n// Exclude Azure AD Connect\\n| where isnotempty( AccountName) and isnotempty( DestinationDeviceName)\\n| distinct DestinationDeviceName;\\nunion isfuzzy= true SamrDC, DnsDC, SrvDC, directoryeventsDC \\n| distinct DestinationDeviceName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-RetrieveAllDCs.kql", "query_name": "Function-RetrieveAllDCs", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as TeamsAccess\\n// TeamsAccess | where TeamName == \\\"Secret Project\\\"  // will all events, user adds, removes and access changes for the \\\"Secret Project\\\" team\\n// TeamsAccess | where Actor == \\\"user1@domain.com\\\" // will find all events, user adds, removes and changes performed by user1@domain.com\\n// TeamsAccess | where TimeGenerated > ago(1d) and Activity == \\\"User added as guest\\\" // will find all guests being added in the last day\\n// This function makes the data structure for the different events consistent so you can query them quickly\\nlet memberadded=\\n    OfficeActivity\\n    | where Operation == \\\"MemberAdded\\\"\\n    | where CommunicationType == \\\"Team\\\"\\n    | mv-expand Members\\n    | extend User = tostring(Members.UPN)\\n    | extend x = tostring(Members.Role)\\n    | extend Activity = case(x == \\\"1\\\", strcat(\\\"User added as member\\\"),\\n        x == \\\"2\\\", strcat(\\\"User added as owner\\\"), \\n        x == \\\"3\\\", strcat(\\\"User added as guest\\\"),\\n        \\\"unknown\\\")\\n    | extend Action = \\\"Add\\\"\\n    | project\\n        TimeGenerated,\\n        Action,\\n        Activity,\\n        Actor=UserId,\\n        User,\\n        TeamName,\\n        TeamGuid,\\n        ActorType=UserType;\\nlet memberremoved=\\n    OfficeActivity\\n    | where Operation == \\\"MemberRemoved\\\"\\n    | where CommunicationType == \\\"Team\\\"\\n    | mv-expand Members\\n    | extend User = tostring(Members.UPN)\\n    | extend Activity = \\\"User removed from Team\\\"\\n    | extend ActorType = \\\"User\\\"\\n    | extend Action = \\\"Remove\\\"\\n    | project\\n        TimeGenerated,\\n        Action,\\n        Activity,\\n        Actor=UserId,\\n        User,\\n        TeamName,\\n        TeamGuid,\\n        ActorType=UserType;\\nlet memberaccesschanged=\\n    OfficeActivity\\n    | where Operation == \\\"MemberRoleChanged\\\"\\n    | mv-expand Members\\n    | extend User = tostring(Members.UPN)\\n    | extend x = tostring(Members.Role)\\n    | extend Activity = case(x == \\\"1\\\", strcat(\\\"User changed to member\\\"),\\n        x == \\\"2\\\", strcat(\\\"User changed to owner\\\"), \\\"unknown\\\")\\n    | extend Action = \\\"Change\\\"\\n    | project\\n        TimeGenerated,\\n        Action,\\n        Activity,\\n        Actor=UserId,\\n        User,\\n        TeamName,\\n        TeamGuid,\\n        ActorType=UserType;\\nunion memberadded, memberremoved, memberaccesschanged\\n| project-reorder TimeGenerated, Action, Activity, User, Actor, ActorType, TeamName, TeamGuid\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-TeamsAccess.kql", "query_name": "Function-TeamsAccess", "attributes": {}}, {"query": "\"//Single function to investigate potential suspicious activity across several data sources. The function will find the following information.\\n//Azure AD Sign in Logs - legacy auth attempts, conditional access failures, new user agents or locations found in the last day\\n//Azure AD Audit Logs - add service principals, consent to permissions, add credentials to service principals, any MFA configuration changes\\n//Azure AD risk events - any non automatically dismissed risk events\\n//Defender for Cloud Apps - mailbox rule changes\\n//Security Alert - any alerts from the various products such as Azure AD Identity Protection, Defender for Office 365 etc\\n//Save as a function in your workspace then invoke via its name, ie UserInvestigation(\\\"user@domain.com\\\"). Your function requires a parameter as per https://github.com/reprise99/Sentinel-Queries/tree/main/Functions\\nlet legacyauth=\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where UserPrincipalName =~ user\\n| where ClientAppUsed !in (\\\"Mobile Apps and Desktop clients\\\", \\\"Browser\\\") and isnotempty( ClientAppUsed)\\n| extend Indicator = \\\"Legacy auth attempts detected\\\"\\n| extend ['Event Source'] = \\\"Azure AD Signin Logs\\\"\\n| project TimeGenerated, UserPrincipalName, AppDisplayName, ClientAppUsed, IPAddress, Location, UserAgent, ResultType, ResultDescription, Indicator, ['Event Source'], TableName=Type, CorrelationId;\\nlet cafailures=\\nSigninLogs\\n| where TimeGenerated > ago (30d)\\n| where UserPrincipalName =~ user\\n| where ResultType == \\\"53003\\\"\\n| extend Indicator = \\\"Conditional Access failures detected\\\"\\n| extend ['Event Source'] = \\\"Azure AD Signin Logs\\\"\\n| project TimeGenerated, UserPrincipalName, AppDisplayName, ClientAppUsed, IPAddress, tostring(Location), UserAgent, ResultType, ResultDescription, Indicator, ['Event Source'], TableName=Type, CorrelationId;\\nlet newuseragents=\\nSigninLogs\\n| where TimeGenerated > ago(30d) and TimeGenerated < ago(1d)\\n| where UserPrincipalName =~ user\\n| distinct UserAgent\\n| join kind=rightanti (\\nSigninLogs\\n| where TimeGenerated > ago (1d)\\n| where UserPrincipalName =~ user\\n) on UserAgent\\n| extend Indicator = \\\"New user agent detected in last day\\\"\\n| extend ['Event Source'] = \\\"Azure AD Signin Logs\\\"\\n| project TimeGenerated, UserPrincipalName, AppDisplayName, ClientAppUsed, IPAddress, tostring(Location), UserAgent, ResultType, ResultDescription, Indicator, ['Event Source'], TableName=Type, CorrelationId;\\nlet newlocations=\\nSigninLogs\\n| where TimeGenerated > ago(30d) and TimeGenerated < ago(1d)\\n| where UserPrincipalName =~ user\\n| where TimeGenerated > ago(30d) and TimeGenerated < ago(1d)\\n| distinct Location\\n| join kind=rightanti (\\nSigninLogs\\n| where TimeGenerated > ago (1d)\\n| where UserPrincipalName =~ user\\n) on Location\\n| extend Indicator = \\\"New location detected in last day\\\"\\n| extend ['Event Source'] = \\\"Azure AD Signin Logs\\\"\\n| project TimeGenerated, UserPrincipalName, AppDisplayName, ClientAppUsed, IPAddress, tostring(Location), UserAgent, ResultType, ResultDescription, Indicator, ['Event Source'], TableName=Type, CorrelationId;\\nlet riskevents=\\nAADUserRiskEvents\\n| where TimeGenerated > ago (30d)\\n| where UserPrincipalName =~ (user)\\n| where RiskDetail <> \\\"aiConfirmedSigninSafe\\\"\\n| extend Indicator = \\\"Azure AD risk event detected\\\"\\n| extend ['Event Source'] = \\\"Azure AD Risky Signin Logs\\\"\\n| project TimeGenerated, UserPrincipalName, IPAddress=IpAddress, tostring(Location), RiskState, RiskLevel, RiskEventType, RiskDetail, Indicator, ['Event Source'], TableName=Type, CorrelationId;\\nlet audit=\\nAuditLogs\\n| where TimeGenerated > ago (30d)\\n| where OperationName in~ (\\\"Add service principal\\\",\\\"Consent to application\\\",\\\"Update application \\u2013 Certificates and secrets management \\\",\\\"User registered security info\\\", \\\"User changed default security info\\\", \\\"User deleted security info\\\")\\n| extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n| where UserPrincipalName =~ user\\n| extend Indicator = case (\\n    OperationName == \\\"Add service principal\\\", strcat(\\\"Azure AD service principal added\\\"),\\n    OperationName == \\\"Consent to application\\\", strcat(\\\"Azure AD service principal permissions consented to\\\"),\\n    OperationName == \\\"Update application \\u2013 Certificates and secrets management \\\", strcat(\\\"Azure AD service principal credentials added\\\"),\\n    OperationName == \\\"User registered security info\\\", strcat(\\\"MFA method registered\\\"),\\n    OperationName == \\\"User changed default security info\\\", strcat(\\\"MFA default method changed\\\"),\\n    OperationName == \\\"User deleted security info\\\", strcat(\\\"MFA method deleted\\\"),\\n    \\\"unknown\\\"\\n    )\\n| extend ['Event Source'] = \\\"Azure AD Audit Logs\\\"\\n| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\\n| project TimeGenerated, IPAddress, Indicator, ['Event Source'], TableName=Type, CorrelationId;\\nlet cloudapp=\\nCloudAppEvents\\n| where TimeGenerated > ago (30d)\\n| where ActionType in (\\\"New-InboxRule\\\",\\\"Remove-InboxRule\\\",\\\"Set-InboxRule\\\")\\n| extend UserPrincipalName = tostring(RawEventData.UserId)\\n| where UserPrincipalName =~ user\\n| extend CorrelationId = tostring(RawEventData.Id)\\n| extend ['Event Source'] = \\\"Defender for Cloud Apps Logs\\\"\\n| extend Indicator = case (\\n    ActionType == \\\"New-InboxRule\\\", strcat(\\\"Exchange Online inbox rule created\\\"),\\n    ActionType == \\\"Remove-InboxRule\\\", strcat(\\\"Exchange Online inbox rule deleted\\\"),\\n    ActionType == \\\"Set-InboxRule\\\", strcat(\\\"Exchange Online inbox rule changed\\\"),\\n    \\\"unknown\\\"\\n    )\\n| project TimeGenerated, UserPrincipalName, IPAddress, Indicator, TableName=Type, ['Event Source'];\\nlet alerts=\\nSecurityAlert\\n| where TimeGenerated > ago (30d)\\n| where CompromisedEntity =~ user\\n| project TimeGenerated, UserPrincipalName=CompromisedEntity, Indicator=AlertName, TableName=Type, ['Event Source']=ProductName;\\nunion legacyauth, cafailures, newuseragents, newlocations, riskevents, audit, cloudapp, alerts\\n| project-reorder TimeGenerated, UserPrincipalName, Indicator, ['Event Source'], TableName, IPAddress\\n| sort by Indicator asc, TimeGenerated desc\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-UserInvestigation.kql", "query_name": "Function-UserInvestigation", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as UserLogins\\n// UserLogins | where UserPrincipalName == \\\"user1@domain.com\\\" or AccountName == \\\"user2\\\" // will find information for Azure AD user user1@domain.com or AD user user2\\n// UserLogins | where Department has \\\"Human Resources\\\" // will find information for all Human Resources staff\\n// UserLogins | where AccountDisplayName has \\\"Matt\\\" and ['Last Azure AD Sign In'] > ago(30m) // will find information for anyone with \\\"Matt\\\" in their Azure AD displayname and has signed into Azure AD in the last 30 minutes\\n// This will parse the last 30 days of the IdentityInfo, SigninLogs and SecurityEvent tables for logon information\\nlet idinfo=\\n    IdentityInfo\\n    | where TimeGenerated > ago(21d)\\n    | summarize arg_max (TimeGenerated, *) by AccountUPN\\n    | project\\n        UserPrincipalName=AccountUPN,\\n        AccountName,\\n        AccountDisplayName,\\n        JobTitle,\\n        Country,\\n        City,\\n        Department;\\nlet aad=\\n    SigninLogs\\n    | where TimeGenerated > ago(30d)\\n    | where ResultType == 0\\n    | summarize arg_max(TimeGenerated, *) by UserPrincipalName\\n    | project ['Last Azure AD Sign In']=TimeGenerated, UserPrincipalName;\\nlet ad=\\n    SecurityEvent\\n    | where TimeGenerated > ago(30d)\\n    | project TimeGenerated, Computer, EventID, TargetUserName\\n    | where EventID == \\\"4624\\\"\\n    | summarize arg_max(TimeGenerated, TargetUserName) by AccountName=TargetUserName\\n    | project ['Last AD Sign In']=TimeGenerated, AccountName;\\nidinfo\\n| lookup aad on UserPrincipalName\\n| lookup ad on AccountName\\n| project-reorder UserPrincipalName, AccountName, ['Last AD Sign In'], ['Last Azure AD Sign In']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-UserLogins.kql", "query_name": "Function-UserLogins", "attributes": {}}, {"query": "\"// Save as a function in your workspace then invoke via its name, i.e if you save as UserLookup\\n// UserLookup | where UserPrincipalName == \\\"user1@domain.com\\\" // will find information for user1@domain.com\\n// UserLookup | where Countries has \\\"AU\\\" and ['Authentication Methods'] has \\\"Windows Hello for Business\\\" // will find all users who have signed in from Australia and have used WHFB\\n// UserLookup | where JobTitle == \\\"Chief Astronaut\\\" and IPAddresses has \\\"10.10.10.10\\\" // will find all Chief Astronauts who have signed on from 10.10.10.10\\n// This will parse the last 14 days of the IdentityInfo, SigninLogs and SecurityAlerts tables for information\\nlet identity=\\n    IdentityInfo\\n    | where TimeGenerated > ago (14d)\\n    | summarize arg_max(TimeGenerated, *) by AccountUPN\\n    | project\\n        UserPrincipalName=AccountUPN,\\n        AccountName,\\n        AccountDisplayName,\\n        JobTitle,\\n        City,\\n        Country;\\nlet signininfo=\\n    SigninLogs\\n    | where TimeGenerated > ago(14d)\\n    | where ResultType == 0\\n    | extend City = tostring(LocationDetails.city)\\n    | extend Country = tostring(LocationDetails.countryOrRegion)\\n    | extend DeviceName = tostring(DeviceDetail.displayName)\\n    | summarize\\n        Applications=make_set(AppDisplayName),\\n        IPAddresses=make_set(IPAddress),\\n        Countries=make_set_if(Country, isnotempty(Country)),\\n        Cities=make_set_if(City, isnotempty(City)),\\n        Devices=make_set_if(DeviceName, isnotempty(DeviceName))\\n        by UserPrincipalName;\\nlet authmethods=\\n    SigninLogs\\n    | where TimeGenerated > ago(14d)\\n    | where ResultType == 0\\n    | mv-expand todynamic(AuthenticationDetails)\\n    | extend AuthMethod = tostring(AuthenticationDetails.authenticationMethod)\\n    | where AuthMethod !in (\\\"Previously satisfied\\\", \\\"Password\\\", \\\"Other\\\")\\n    | summarize ['Authentication Methods']=make_set(AuthMethod) by UserPrincipalName;\\nlet alerts=\\n    SecurityAlert\\n    | where TimeGenerated > ago(14d)\\n    | extend Alert = strcat(AlertName, \\\" - \\\", ProductName)\\n    | summarize Alerts=make_set(Alert) by UserPrincipalName=CompromisedEntity;\\nidentity\\n| lookup signininfo on UserPrincipalName\\n| lookup authmethods on UserPrincipalName\\n| lookup alerts on UserPrincipalName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Functions/Function-UserLookup.kql", "query_name": "Function-UserLookup", "attributes": {}}, {"query": "\"//Finds computers that haven't sent a heartbeat in the last 30 days\\n\\n//Data connector required for this query - Heartbeat (created automatically when you onboard machines to Sentinel)\\n\\nHeartbeat\\n| where TimeGenerated > ago(365d)\\n| summarize arg_max(TimeGenerated, *) by Computer\\n| project\\n    Computer,\\n    ['Last Heartbeat']=TimeGenerated,\\n    ['Days Since Last Heartbeat']=datetime_diff(\\\"day\\\", now(), TimeGenerated)\\n| where ['Days Since Last Heartbeat'] > 30\\n| sort by ['Days Since Last Heartbeat'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Heartbeat/Heartbeat-NoHeartbeatinTimeframe.kql", "query_name": "Heartbeat-NoHeartbeatinTimeframe", "attributes": {}}, {"query": "\"//Visualize distinct computers per month sending data\\n\\n//Data connector required for this query - Heartbeat (created automatically when you onboard machines to Sentinel)\\n\\nHeartbeat\\n| where TimeGenerated > ago(365d)\\n| summarize Count=dcount(Computer)by Month=startofmonth(TimeGenerated)\\n| render columnchart with (title=\\\"Distinct monthly computers sending data to Microsoft Sentinel\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Heartbeat/Heartbeat-VisualizeDistinctComputersperMonth.kql", "query_name": "Heartbeat-VisualizeDistinctComputersperMonth", "attributes": {}}, {"query": "\"// Detects when a user downgrades a label on a file and that file is then copied to USB\\n\\n//Data connector required for this query - Azure Information Protection\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\n// Timeframe = the time between the label downgrade and file copy event\\nlet timeframe=4h;\\nInformationProtectionEvents\\n| where Time > ago(1d)\\n| where Activity == \\\"DowngradeLabel\\\"\\n| project LabelChangeTime=Time, User, FileDowngraded=ItemName\\n| join kind=inner (\\n    DeviceEvents\\n    | where TimeGenerated > ago(1d)\\n    | where ActionType == \\\"UsbDriveMounted\\\"\\n    | extend DriveLetter = tostring(todynamic(AdditionalFields).DriveLetter)\\n    | join kind=inner (DeviceFileEvents\\n        | where TimeGenerated > ago(1d)\\n        | project TimeGenerated, ActionType, FileName, FolderPath, DeviceId, DeviceName\\n        | extend FileCopyTime = TimeGenerated\\n        | where ActionType == \\\"FileCreated\\\"\\n        | extend FileCopyName = FileName\\n        | parse FolderPath with DriveLetter '\\\\\\\\' *\\n        | extend DriveLetter = tostring(DriveLetter)\\n        )\\n        on DeviceId, DriveLetter) \\n    on $left.FileDowngraded == $right.FileCopyName\\n| project LabelChangeTime, FileCopyTime, FileDowngraded, DeviceName, AccountName\\n| where (FileCopyTime - LabelChangeTime) between (0min .. timeframe)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Information%20Protection/IP-LabelDowngradeThenCopytoUSB.kql", "query_name": "IP-LabelDowngradeThenCopytoUSB", "attributes": {}}, {"query": "\"// Detects when a user downgrades a label on a file and that file is then emailed outbound \\n\\n//Data connector required for this query - Azure Information Protection\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\n// Starttime = the amount of data to look back on\\n// Timeframe = the time between the label downgrade and email event\\nlet starttime=7d;\\nlet timeframe=4h;\\nInformationProtectionEvents\\n| where Time > ago(starttime)\\n| where Activity == \\\"DowngradeLabel\\\"\\n| project LabelChangeTime=Time, User, FileName=ItemName\\n| join kind=inner(\\n    EmailEvents\\n    | where EmailDirection == \\\"Outbound\\\"\\n    | project\\n        TimeGenerated,\\n        SenderMailFromAddress,\\n        RecipientEmailAddress,\\n        EmailDirection,\\n        NetworkMessageId\\n    | join kind=inner (EmailAttachmentInfo) on NetworkMessageId\\n    | project\\n        TimeGenerated,\\n        SenderMailFromAddress,\\n        RecipientEmailAddress,\\n        EmailDirection,\\n        FileName\\n    )\\n    on FileName\\n| project\\n    LabelChangeTime,\\n    EmailSendTime=TimeGenerated,\\n    SenderMailFromAddress,\\n    RecipientEmailAddress,\\n    EmailDirection,\\n    FileName\\n| where (EmailSendTime - LabelChangeTime) between (0min .. timeframe)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Information%20Protection/IP-LabelDowngradeThenEmail.kql", "query_name": "IP-LabelDowngradeThenEmail", "attributes": {}}, {"query": "\"//When Azure AD flags a device as non compliant, retrieve the details about the devices from Intune\\n\\n//Data connector required for this query - Intune data sent to Sentinel workspace\\n\\n//First find the device name from the 'device no longer compliant' action\\nlet devices=\\n    AuditLogs\\n    | where TimeGenerated > ago (1d)\\n    | where OperationName == \\\"Device no longer compliant\\\"\\n    | extend DeviceName = tostring(TargetResources[0].displayName)\\n    | distinct DeviceName;\\n//Lookup those devices in the IntuneDevices table, and retrieve the latest record\\nIntuneDevices\\n| where TimeGenerated > ago (7d)\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| where DeviceName in (devices)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Intune/IntuneDevices-FindDetailsofNonCompliantDevices.kql", "query_name": "IntuneDevices-FindDetailsofNonCompliantDevices", "attributes": {}}, {"query": "\"//When an Intune admin initiates a remote wipe of a managed device, retrieve all the relevant information about the device\\n\\n//Data connector required for this query - Intune data sent to Sentinel workspace\\n\\nIntuneAuditLogs\\n| where TimeGenerated > ago (1d)\\n| where OperationName == \\\"wipe ManagedDevice\\\"\\n| extend DeviceId = tostring(parse_json(tostring(parse_json(Properties).TargetObjectIds))[0])\\n| project TimeGenerated, Actor=Identity, DeviceId\\n| join kind=inner(\\n    IntuneDevices\\n//Go back 7 days to make sure we have information on the device and retrieve the lastest record\\n    | where TimeGenerated > ago(7d)\\n    | summarize arg_max(TimeGenerated, *) by DeviceId\\n    )\\n    on DeviceId\\n| project\\n    TimeGenerated,\\n    Actor,\\n    DeviceId,\\n    Model,\\n    SerialNumber,\\n    OS,\\n    PrimaryUser=UserEmail,\\n    Ownership,\\n    ManagedBy,\\n    LastContact\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Intune/IntuneDevices-RetrieveDeviceInfoAfterWipe.kql", "query_name": "IntuneDevices-RetrieveDeviceInfoAfterWipe", "attributes": {}}, {"query": "\"//Visualize device compliance (compliant, non-compliant, managed by Config Manager, not evaluated or in grace period) per week over time\\n\\n//Data connector required for this query - Intune data sent to Sentinel workspace\\n\\nIntuneDevices\\n| where TimeGenerated > ago (180d)\\n| summarize arg_max(DeviceName, *) by DeviceName, startofweek(TimeGenerated)\\n| where isnotempty(CompliantState)\\n| summarize ComplianceCount=count()by CompliantState, startofweek(TimeGenerated)\\n| render timechart\\n    with (\\n    ytitle=\\\"Device Count\\\",\\n    xtitle=\\\"Week\\\",\\n    title=\\\"Device compliance per week over time\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Intune/IntuneDevices-VisualizeDeviceComplianceovertime.kql", "query_name": "IntuneDevices-VisualizeDeviceComplianceovertime", "attributes": {}}, {"query": "\"//Visualize the join type (Azure AD joined, Azure AD registered or Hybrid joined) of your MEM/Intune devices per week\\n\\n//Data connector required for this query - Intune data sent to Sentinel workspace\\n\\nIntuneDevices\\n//Gets all data generated in 180 days\\n| where TimeGenerated > ago(180d) \\n//Optionally filter only devices have contact to Intune in 30 days\\n| where todatetime(LastContact) > ago (30d) \\n| summarize arg_max(TimeGenerated, *) by DeviceName, startofweek(TimeGenerated)\\n| where OS == \\\"Windows\\\"\\n| summarize JoinSummary=count()by JoinType, startofweek(TimeGenerated)\\n| where isnotempty(JoinType)\\n| render columnchart\\n    with (\\n    kind=unstacked,\\n    ytitle=\\\"Device Count\\\",\\n    xtitle=\\\"Week\\\",\\n    title=\\\"Device count by join type per week\\\") \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Intune/IntuneDevices-VisualizeDeviceJoinTypebyWeek.kql", "query_name": "IntuneDevices-VisualizeDeviceJoinTypebyWeek", "attributes": {}}, {"query": "\"//Visualize when your devices last contacted Intune\\n\\n//Data connector required for this query - Intune data sent to Sentinel workspace\\n\\nIntuneDevices\\n| where TimeGenerated > ago(90d)\\n| where isnotempty(LastContact)\\n//Retrieve latest record for each DeviceId\\n| summarize arg_max(TimeGenerated, *) by DeviceId\\n//Convert string to datetime format\\n| extend LastContactTime = todatetime(LastContact)\\n| project DeviceId, LastContactTime\\n//Exclude devices reporting as 0001-01-01\\n| where LastContactTime <> todatetime('0001-01-01T00:00:00Z')\\n//Group by month and render chart\\n| summarize ['Device Count']=count()by startofmonth(LastContactTime)\\n| render columnchart with (title=\\\"Intune devices by last contact time\\\", xtitle=\\\"Month\\\")\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Intune/IntuneDevices-VisualizeLastContact.kql", "query_name": "IntuneDevices-VisualizeLastContact", "attributes": {}}, {"query": "\"//Visualize devices in intune with the same intune and Azure AD Id per week by join type\\n\\n//Data connector required for this query - Intune data sent to Sentinel workspace\\n\\nIntuneDevices\\n| where TimeGenerated > ago (180d)\\n| summarize arg_max(TimeGenerated, *) by DeviceName, startofweek(TimeGenerated)\\n| where DeviceId == ReferenceId\\n| where OS == 'Windows'\\n| summarize count()by startofweek(TimeGenerated), JoinType\\n| where isnotempty( JoinType)\\n| render columnchart with (kind=unstacked, title=\\\"Devices with the same Azure AD and Intune device Id per week by join type\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Intune/IntuneDevices-VisualizeMatchingDeviceIds.kql", "query_name": "IntuneDevices-VisualizeMatchingDeviceIds", "attributes": {}}, {"query": "\"//Create a list of all tables in Sentinel, then iterate through the list to audit the LAQuery log table to see which are being actively used\\n\\n//Data connector required for this query - Log Analytics diagnostic settings enabled on your Sentinel workspace\\n\\nlet tablenames = search * \\n    | summarize make_set($table);\\nLAQueryLogs\\n| mv-apply table=toscalar(tablenames) to typeof(string) on (where QueryText contains ['table'])\\n| summarize QueryCount = count()by ['table']\\n| order by QueryCount\\n| render piechart \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Log%20Analytics/LAQuery-FindQueryStats.kql", "query_name": "LAQuery-FindQueryStats", "attributes": {}}, {"query": "\"//Find users querying your Log Analytics/Sentinel data for the first time\\n\\n//Data connector required for this query - Log Analytics diagnostic settings enabled on your Sentinel workspace\\n\\nlet knownusers=\\n    LAQueryLogs\\n    | where TimeGenerated > ago(180d) and TimeGenerated < ago(1d)\\n    | distinct AADEmail\\n    | where isnotempty(AADEmail);\\nLAQueryLogs\\n| where TimeGenerated > ago(1d)\\n| where AADEmail !in (knownusers)\\n| where isnotempty(AADEmail)\\n| project TimeGenerated, AADEmail, QueryText\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Log%20Analytics/LAQuery-NewUsersQueryingData.kql", "query_name": "LAQuery-NewUsersQueryingData", "attributes": {}}, {"query": "\"//Visualizes queries against your log analytics workspace categorized by users and service principals\\n\\n//Data connector required for this query - Log Analytics diagnostic settings enabled on your Sentinel workspace\\n\\nlet timeframe=45d;\\nLAQueryLogs\\n| where TimeGenerated > ago (timeframe)\\n| summarize Users=countif(isnotempty(AADEmail)), Playbooks=countif(isempty(AADEmail)) by bin(TimeGenerated, 1d)\\n| render columnchart with (kind=unstacked, ytitle=\\\"Queries Run\\\", title=\\\"Queries Run - Users vs Playbooks\\\") \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Log%20Analytics/LAQuery-UsersvsAutomationQueryStats.kql", "query_name": "LAQuery-UsersvsAutomationQueryStats", "attributes": {}}, {"query": "\"//Visualize how many queries you have run in your Sentinel workspace over the last year\\n\\nLAQueryLogs\\n| where TimeGenerated > ago (365d)\\n| where AADEmail == \\\"username@domain.com\\\"\\n| make-series Count=count() default=0 on TimeGenerated from ago(365d) to now() step 1d\\n| render timechart with (title=\\\"#365daysofKQL queries run per day\\\", ytitle=\\\"Count\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Log%20Analytics/LAQuery-VisualizeQueriesRun.kql", "query_name": "LAQuery-VisualizeQueriesRun", "attributes": {}}, {"query": "\"//Create a daily summary of activities completed by your O365 admins\\n\\n//Data connector required for this query - Office 365\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet timerange=14d;\\nIdentityInfo\\n| where TimeGenerated > ago(21d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| where AssignedRoles has_any (\\\"Global Administrator\\\", \\\"Exchange Administrator\\\", \\\"Teams Administrator\\\", \\\"SharePoint Administrator\\\")\\n| project UserId=AccountUPN\\n| join kind=inner (\\n    OfficeActivity\\n    | where TimeGenerated > ago(timerange)\\n    )\\n    on UserId\\n| summarize AdminActivities=make_list(Operation)by UserId, startofday(TimeGenerated)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/Audit-DailySummaryofO365AdminActivity.kql", "query_name": "Audit-DailySummaryofO365AdminActivity", "attributes": {}}, {"query": "\"//When Defender for Cloud detects a possible DNS lookup to a phishing domain attempt to find if the URL was part of an email phishing attack\\n\\n//Data connector required for this query - M365 Defender - Email* tables\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nlet suspiciousdomains=\\n    SecurityAlert\\n    | where AlertName startswith \\\"Communication with possible phishing domain\\\"\\n    | mv-expand todynamic(Entities)\\n    | extend DomainName = tostring(Entities.DomainName)\\n    | where isnotempty(DomainName)\\n    | distinct DomainName;\\nEmailEvents\\n| where EmailDirection == \\\"Inbound\\\"\\n| project\\n    TimeGenerated,\\n    SenderMailFromAddress,\\n    RecipientEmailAddress,\\n    EmailDirection,\\n    NetworkMessageId\\n| join kind=inner (EmailUrlInfo) on NetworkMessageId\\n| project\\n    TimeGenerated,\\n    SenderMailFromAddress,\\n    RecipientEmailAddress,\\n    EmailDirection,\\n    Url,\\n    UrlDomain\\n| where UrlDomain in~ (suspiciousdomains)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/EmailEvents-FindEmailswithPotentialPhishingURL.kql", "query_name": "EmailEvents-FindEmailswithPotentialPhishingURL", "attributes": {}}, {"query": "\"//When a malicious email is received, list all the users who received it and all the users who read it\\n\\n//Data connector required for this query - M365 Defender - Email* tables\\n//Data connector required for this query - Office 365\\n\\n//First find all the users who received the email\\nEmailEvents\\n| where EmailDirection == \\\"Inbound\\\"\\n//Add in your malicious subject or malicious sender address\\n| where Subject == \\\"Malicious Subject Name\\\" or SenderFromAddress == \\\"malicioususer@domain.com\\\"\\n| project RecipientEmailAddress, Subject, InternetMessageId, SenderFromAddress\\n//Combine that data with the OfficeActivity table which tracks whether an email was accessed\\n| join kind=inner (\\n    OfficeActivity\\n    | where Operation == \\\"MailItemsAccessed\\\"\\n    | mv-expand todynamic(Folders)\\n    | extend FolderItems = Folders.FolderItems\\n    | mv-expand FolderItems\\n    | extend InternetMessageId = tostring(FolderItems.InternetMessageId)\\n    | project UserId, InternetMessageId\\n    )\\n    on InternetMessageId\\n//Create summary of data listing the count and all the users who received the email vs the list and count of those that read it\\n| summarize\\n    ['Receipient Count']=dcount(RecipientEmailAddress),\\n    ['Users Who Received Email']=make_set(RecipientEmailAddress),\\n    ['Reader Count']=dcount(UserId),\\n    ['Users Who Read Email']=make_set(UserId)\\n    by SenderFromAddress, Subject, InternetMessageId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/EmailEvents-FindUsersWhoReadMaliciousEmail.kql", "query_name": "EmailEvents-FindUsersWhoReadMaliciousEmail", "attributes": {}}, {"query": "\"//When a macro is received via email from an external sender, find all users who receieved the same file\\n\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\n//Microsoft Sentinel query\\nEmailEvents\\n| where EmailDirection == \\\"Inbound\\\"\\n| project\\n    TimeGenerated,\\n    SenderMailFromAddress,\\n    RecipientEmailAddress,\\n    NetworkMessageId\\n| join kind=inner (EmailAttachmentInfo) on NetworkMessageId\\n| project\\n    TimeGenerated,\\n    SenderMailFromAddress,\\n    RecipientEmailAddress,\\n    FileName\\n| where FileName endswith \\\".xlsm\\\" or FileName endswith \\\".xstm\\\"\\n| summarize Recipient=make_set(RecipientEmailAddress) by FileName, SenderMailFromAddress\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nEmailEvents\\n| where EmailDirection == \\\"Inbound\\\"\\n| project\\n    Timestamp,\\n    SenderMailFromAddress,\\n    RecipientEmailAddress,\\n    NetworkMessageId\\n| join kind=inner (EmailAttachmentInfo) on NetworkMessageId\\n| project\\n    Timestamp,\\n    SenderMailFromAddress,\\n    RecipientEmailAddress,\\n    FileName\\n| where FileName endswith \\\".xlsm\\\" or FileName endswith \\\".xstm\\\"\\n| summarize Recipient=make_set(RecipientEmailAddress) by FileName, SenderMailFromAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/EmailEvents-MacroReceivedbyEmail.kql", "query_name": "EmailEvents-MacroReceivedbyEmail", "attributes": {}}, {"query": "\"//Visualize the most blocked domains sending email inbound to your users\\n\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\n//Microsoft Sentinel query\\nEmailEvents\\n| where TimeGenerated > ago (7d)\\n| where EmailDirection == \\\"Inbound\\\"\\n| where DeliveryAction == \\\"Blocked\\\"\\n| extend Domain = tostring(split(SenderMailFromAddress, \\\"@\\\")[-1])\\n| summarize BlockedCount=count()by Domain\\n| where isnotempty(Domain)\\n| sort by BlockedCount desc\\n| render barchart \\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nEmailEvents\\n| where Timestamp > ago (7d)\\n| where EmailDirection == \\\"Inbound\\\"\\n| where DeliveryAction == \\\"Blocked\\\"\\n| extend Domain = tostring(split(SenderMailFromAddress, \\\"@\\\")[-1])\\n| summarize BlockedCount=count()by Domain\\n| where isnotempty(Domain)\\n| sort by BlockedCount desc\\n| render barchart \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/EmailEvents-MostBlockedDomains.kql", "query_name": "EmailEvents-MostBlockedDomains", "attributes": {}}, {"query": "\"//Find senders that are potentially spamming your users for the first time. Useful at detecting business email compromise from partner companies.\\n\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\n//Set a threshold of the same email being received within a 10 minute period\\n//Microsoft Sentinel query\\nlet threshold = 500;\\n//First create a list of sender addresses that have previously sent you bulk email, hopefully this will let us exclude corporate communications and newsletters etc\\nlet knownbulkemail=\\n    EmailEvents\\n    | where TimeGenerated > ago(30d) and TimeGenerated < ago (1d)\\n    | project TimeGenerated, EmailDirection, DeliveryAction, RecipientEmailAddress, SenderFromAddress, Subject\\n    | where EmailDirection == \\\"Inbound\\\"\\n    | where DeliveryAction == \\\"Delivered\\\"\\n    | summarize RecipientCount=dcount(RecipientEmailAddress) by SenderFromAddress, Subject, bin(TimeGenerated, 10m)\\n    | where RecipientCount > threshold\\n    | distinct SenderFromAddress;\\n//Look in the last hour for any new senders that have sent over the threshold in a 10 minute period\\nEmailEvents\\n| where TimeGenerated > ago(1d)\\n| project TimeGenerated, EmailDirection, DeliveryAction, RecipientEmailAddress, SenderFromAddress, Subject\\n| where EmailDirection == \\\"Inbound\\\"\\n| where DeliveryAction == \\\"Delivered\\\"\\n| summarize RecipientCount=dcount(RecipientEmailAddress) by SenderFromAddress, Subject, bin(TimeGenerated, 10m)\\n| where SenderFromAddress !in (knownbulkemail) and RecipientCount > threshold\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nlet threshold = 500;\\n//First create a list of sender addresses that have previously sent you bulk email, hopefully this will let us exclude corporate communications and newsletters etc\\nlet knownbulkemail=\\n    EmailEvents\\n    | where Timestamp > ago(30d) and Timestamp < ago (1d)\\n    | project Timestamp, EmailDirection, DeliveryAction, RecipientEmailAddress, SenderFromAddress, Subject\\n    | where EmailDirection == \\\"Inbound\\\"\\n    | where DeliveryAction == \\\"Delivered\\\"\\n    | summarize RecipientCount=dcount(RecipientEmailAddress) by SenderFromAddress, Subject, bin(Timestamp, 10m)\\n    | where RecipientCount > threshold\\n    | distinct SenderFromAddress;\\n//Look in the last hour for any new senders that have sent over the threshold in a 10 minute period\\nEmailEvents\\n| where Timestamp > ago(1d)\\n| project Timestamp, EmailDirection, DeliveryAction, RecipientEmailAddress, SenderFromAddress, Subject\\n| where EmailDirection == \\\"Inbound\\\"\\n| where DeliveryAction == \\\"Delivered\\\"\\n| summarize RecipientCount=dcount(RecipientEmailAddress) by SenderFromAddress, Subject, bin(Timestamp, 10m)\\n| where SenderFromAddress !in (knownbulkemail) and RecipientCount > threshold\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/EmailEvents-PotentialNewSpammer.kql", "query_name": "EmailEvents-PotentialNewSpammer", "attributes": {}}, {"query": "\"//Visualize the deviation of email being blocked to your Office 365 tenant per day\\n//Query adapted from https://github.com/samikroy/kql-store/blob/main/Deviation%20in%20Security%20Events.md\\n\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\n//Find the average blocked email per day\\nlet AverageBlockedEmail = toscalar(EmailEvents\\n| where TimeGenerated > ago(250d)\\n| where DeliveryAction == \\\"Blocked\\\"\\n| summarize Count=count() by bin(TimeGenerated, 1d)\\n| summarize avg(Count));\\n//Find the total count of blocked email per day\\nEmailEvents\\n| where TimeGenerated > ago(250d)\\n| where DeliveryAction == \\\"Blocked\\\"\\n| summarize Count=count() by bin(TimeGenerated, 1d)\\n| extend Deviation = (Count - AverageBlockedEmail) / AverageBlockedEmail\\n| project-away Count\\n//Visualize the deviation per day\\n| render columnchart with (title=\\\"Deviation of email blocked per day\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/EmailEvents-VisualizeBlockedEmailDeviation.kql", "query_name": "EmailEvents-VisualizeBlockedEmailDeviation", "attributes": {}}, {"query": "\"//Visualize how much is email is being blocked as a percentage of total email over time\\n\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\nEmailEvents\\n| where TimeGenerated > ago (30d)\\n| where EmailDirection == \\\"Inbound\\\"\\n| summarize\\n    TotalCount=count(),\\n    BlockedCount=countif(DeliveryAction in (\\\"Blocked\\\", \\\"Junked\\\"))\\n    by bin(TimeGenerated, 6h)\\n| extend Percentage=(todouble(BlockedCount) * 100 / todouble(TotalCount))\\n| project-away TotalCount, BlockedCount\\n| render timechart with (title=\\\"Percentage of email blocked over time\\\", ymax=100)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/EmailEvents-VisualizeBlockedEmailPercentage.kql", "query_name": "EmailEvents-VisualizeBlockedEmailPercentage", "attributes": {}}, {"query": "\"//Visualize inbound email actions (Delivered, Junked, Blocked) per day over time\\n\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\n//Microsoft Sentinel query\\nEmailEvents\\n| where TimeGenerated > ago (90d)\\n| where EmailDirection == \\\"Inbound\\\"\\n| summarize Count=count()by DeliveryAction, bin(TimeGenerated, 1d)\\n| render columnchart with (kind=unstacked, title=\\\"Email delivery actions over time\\\")\\n\\n//Advanced Hunting query. Advanced hunting only retains 30 days data, so to show a similar visualization, we can slice the vents up into 6 hour blocks\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nEmailEvents\\n| where Timestamp > ago (30d)\\n| where EmailDirection == \\\"Inbound\\\"\\n| summarize count()by DeliveryAction, bin(Timestamp, 6h)\\n//Advanced hunting cannot visualize column charts as well as Sentinel so rendering as a timechart produces a better result\\n| render timechart  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/EmailEvents-VisualizeDeliveryActions.kql", "query_name": "EmailEvents-VisualizeDeliveryActions", "attributes": {}}, {"query": "\"//Visualize any post delivery actions such as email being quarantined or deleted by admins\\n\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\nEmailPostDeliveryEvents\\n| where TimeGenerated > ago (90d)\\n| where Action !in (\\\"None\\\", \\\"Unknown\\\")\\n| make-series Count=count() on TimeGenerated from ago(45d) to now() step 1d by Action\\n| render timechart with (title=\\\"Email post delivery actions over time\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/EmailEvents-VisualizePostDeliveryActions.kql", "query_name": "EmailEvents-VisualizePostDeliveryActions", "attributes": {}}, {"query": "\"// Finds guest accounts who were added to a Team and then downloaded documents straight away. \\n\\n//Data connector required for this query - Office 365\\n\\n// Startime = Amount of time to look back on, i.e last 7 days.\\n// Timeframe = looks for downloads for this period after being added to the Team, i.e 2 hours after being added.\\nlet starttime = 7d;\\nlet timeframe = 2h;\\nlet operations = dynamic([\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\"]);\\nOfficeActivity\\n| where TimeGenerated > ago(starttime)\\n| where Operation == \\\"MemberAdded\\\"\\n| mv-expand Members\\n| extend UserAdded = tostring(Members.UPN)\\n| where UserAdded contains \\\"#EXT#\\\"\\n| where CommunicationType == \\\"Team\\\"\\n| project TimeAdded=TimeGenerated, UserId=tolower(UserAdded)\\n| join kind=inner\\n    (\\n    OfficeActivity\\n    | where TimeGenerated > ago(starttime)\\n    | where Operation in (['operations'])\\n    )\\n    on UserId\\n| project DownloadTime=TimeGenerated, TimeAdded, FileName=SourceFileName, UserId\\n| where (DownloadTime - TimeAdded) between (0min .. timeframe)\\n//Optionally summarize the data into the activity by each guest\\n| summarize\\n    ['Count of Files Downloaded']=count(),\\n    ['List of Files Downloaded']=make_set(FileName)\\n    by UserId\\n| sort by ['Count of Files Downloaded'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/Office-DownloadsfromGuestafterAddedtoTeams.kql", "query_name": "Office-DownloadsfromGuestafterAddedtoTeams", "attributes": {}}, {"query": "\"//Detect anomalies in the amount of downloads from your Office 365 tenant by guest accounts.\\n\\n//Data connector required for this query - Office 365\\n\\n//Starttime and endtime = which period of data to look at, i.e from 21 days ago until today.\\nlet startdate=21d;\\nlet enddate=1d;\\n//Timeframe = time period to break the data up into, i.e 1 hour blocks.\\nlet timeframe=1h;\\n//Sensitivity = the lower the number the more sensitive the anomaly detection is, i.e it will find more anomalies, default is 1.5\\nlet sensitivity=2;\\n//Threshold = set this to tune out low count anomalies, i.e when total downloads are only over 300 per hour\\nlet threshold=300;\\nlet outlierusers=\\nOfficeActivity\\n| where TimeGenerated between (startofday(ago(startdate))..startofday(ago(enddate)))\\n| where Operation in (\\\"FileSyncDownloadedFull\\\",\\\"FileDownloaded\\\")\\n| where UserId contains \\\"#EXT#\\\"\\n| make-series GuestDownloads=count() on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserId\\n| extend outliers=series_decompose_anomalies(GuestDownloads, sensitivity)\\n| mv-expand TimeGenerated, GuestDownloads, outliers\\n| where outliers == 1 and GuestDownloads > threshold\\n//Optionally visualize the anomalies - remove everything below this line to just retrieve the data instead of visualizing\\n| distinct UserId;\\nOfficeActivity\\n| where TimeGenerated between (startofday(ago(startdate))..startofday(ago(enddate)))\\n| where Operation in (\\\"FileSyncDownloadedFull\\\",\\\"FileDownloaded\\\")\\n| where UserId contains \\\"#EXT#\\\"\\n| where UserId in (outlierusers)\\n| make-series GuestDownloads=count() default=0 on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserId \\n| render timechart with (ytitle=\\\"Download Count\\\",title=\\\"Anomalous Guest Downloads from Office 365\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-AnomalousDownloadsfromGuests.kql", "query_name": "OfficeActivity-AnomalousDownloadsfromGuests", "attributes": {}}, {"query": "\"//Detect anomalies in the amount of files shared to guests in your Office 365 tenant from your users.\\n\\n//Data connector required for this query - Office 365\\n\\n//Starttime and endtime = which period of data to look at, i.e from 21 days ago until today.\\nlet startdate=21d;\\nlet enddate=1d;\\n//Timeframe = time period to break the data up into, i.e 1 hour blocks.\\nlet timeframe=1h;\\n//Sensitivity = the lower the number the more sensitive the anomaly detection is, i.e it will find more anomalies, default is 1.5\\nlet sensitivity=2;\\n//Threshold = set a threshold to account for low volume anomailies, i.e moving from 1 file shared to 2 within an hour\\nlet threshold = 5;\\nlet outlierusers=\\nOfficeActivity\\n| where Operation in (\\\"AddedToSecureLink\\\",\\\"SecureLinkCreated\\\",\\\"SecureLinkUpdated\\\")\\n| where TargetUserOrGroupType == \\\"Guest\\\" or TargetUserOrGroupName contains \\\"#ext#\\\"\\n| make-series GuestFileShares=count() on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserId\\n| extend outliers=series_decompose_anomalies(GuestFileShares, sensitivity)\\n| mv-expand TimeGenerated, GuestFileShares, outliers\\n| where outliers == 1 and GuestFileShares > threshold\\n//Optionally visualize the anomalies - remove everything below this line to just retrieve the data instead of visualizing\\n| distinct UserId;\\nOfficeActivity\\n| where Operation in (\\\"AddedToSecureLink\\\",\\\"SecureLinkCreated\\\",\\\"SecureLinkUpdated\\\")\\n| where TargetUserOrGroupType == \\\"Guest\\\" or TargetUserOrGroupName contains \\\"#ext#\\\"\\n| where UserId in (outlierusers)\\n| make-series GuestFileShares=count() default=0 on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserId \\n| render timechart with (ytitle=\\\"Share Count\\\",title=\\\"Anomalous Files Shared to Guests\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-AnomalousGuestFileShares.kql", "query_name": "OfficeActivity-AnomalousGuestFileShares", "attributes": {}}, {"query": "\"//Find the top 20 guests who are downloading files from your tenant and calculate the percentage of total downloads from those users. Useful to see if you have a few guests responsible for most of the downloads in your tenant.\\n\\n//Data connector required for this query - Office 365\\n\\n//First find the count of all downloads by guests in your tenant\\nlet totalguestdownloads=\\n    OfficeActivity\\n    | where TimeGenerated > ago(30d)\\n    | where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n    | where UserId contains \\\"#EXT#\\\"\\n    | count\\n//Extend a fake column we will use to join our two queries\\n    | extend ['Total Download Count'] = Count, Constant=\\\"x\\\";\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId contains \\\"#EXT#\\\"\\n//Extend the same fake column to use to join our two queries\\n| extend Constant=\\\"x\\\"\\n| extend ['Guest UserPrincipalName'] = tostring(split(UserId, \\\"#\\\")[0])\\n//Summarize download count by each guest and join to our first query\\n| summarize ['Individual Download Count']=count()by ['Guest UserPrincipalName'], Constant\\n| join kind=fullouter totalguestdownloads on Constant\\n| project-away Constant, Constant1, Count\\n| sort by ['Individual Download Count'] desc \\n//Take the top 20 and then calculate the percentage\\n| take 20\\n| extend ['Percentage of Total Downloads']=(todouble(['Individual Download Count']) * 100 / todouble(['Total Download Count']))\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-CalculatePercentageofDownloadsforTopGuests.kql", "query_name": "OfficeActivity-CalculatePercentageofDownloadsforTopGuests", "attributes": {}}, {"query": "\"//Calculate the percentage that each guest domain is contributing to total downloads from your Office 365 tenant\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId contains \\\"#EXT#\\\"\\n| extend ['Guest UserPrincipalName'] = tostring(split(UserId, \\\"#\\\")[0])\\n| extend ['Guest Domain'] = tostring(split(['Guest UserPrincipalName'], \\\"_\\\")[-1])\\n| summarize Count=count() by ['Guest Domain']\\n| as T\\n| extend Percentage = round(100.0 * Count / toscalar (T\\n    | summarize sum(Count)), 2)\\n| project-reorder ['Guest Domain'], Count, Percentage\\n| sort by Percentage desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-CalculatePercentageofDownloadsperDomain.kql", "query_name": "OfficeActivity-CalculatePercentageofDownloadsperDomain", "attributes": {}}, {"query": "\"//Find the top 20 users who are downloading files from your tenant from untrusted devices and calculate the percentage of downloads from those users vs all untrusted downloads. Useful to see if you have a few users responsible for most of the downloads in your tenant.\\n\\n//Data connector required for this query - Office 365\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| where UserType == \\\"Member\\\"\\n| extend DeviceTrustType = tostring(DeviceDetail.trustType)\\n| distinct UserPrincipalName, IPAddress, DeviceTrustType\\n| join kind=inner(\\n    OfficeActivity\\n    | where TimeGenerated > ago(30d)\\n    | where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n    )\\n    on $left.UserPrincipalName == $right.UserId, $left.IPAddress == $right.ClientIP\\n| where isempty(DeviceTrustType)\\n| summarize Count=count() by UserPrincipalName\\n| as T\\n| extend Percentage = round(100.0 * Count / toscalar (T\\n    | summarize sum(Count)), 2)\\n| project-reorder UserPrincipalName, Count, Percentage\\n| top 20 by Percentage desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-CalculatePercentageofDownloadsUntrustedDevices.kql", "query_name": "OfficeActivity-CalculatePercentageofDownloadsUntrustedDevices", "attributes": {}}, {"query": "\"//Calculate the time Office 365 took to detect malware after the file was uploaded\\n\\n//Data connector required for this query - Office 365\\n\\n//First find the malware detection event\\nOfficeActivity\\n| where TimeGenerated > ago(60d)\\n| where Operation == \\\"FileMalwareDetected\\\"\\n| project\\n    DetectionTime=TimeGenerated,\\n    OfficeWorkload,\\n    ['File Name']=SourceFileName,\\n    ['File Location']=OfficeObjectId\\n//Then join back to the upload event on the same file location\\n| join kind=inner \\n    (\\n    OfficeActivity\\n    | where TimeGenerated > ago (60d)\\n    | where Operation in (\\\"FileUploaded\\\", \\\"FileSyncUploadedFull\\\")\\n    | project\\n        UploadTime=TimeGenerated,\\n        OfficeWorkload,\\n        ['File Name']=SourceFileName,\\n        ['File Location']=OfficeObjectId,\\n        ['Relative File URL']=SourceRelativeUrl\\n    | summarize min(UploadTime) by ['File Location'], UploadTime\\n    )\\n    on ['File Location']\\n//Calculate the time difference between upload and malware detection\\n| project\\n    ['File Name'],\\n    UploadTime,\\n    DetectionTime,\\n    ['Time Difference in Minutes']=datetime_diff(\\\"minute\\\", DetectionTime, UploadTime),\\n    ['File Location']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-CalculateTimetoDetectMalware.kql", "query_name": "OfficeActivity-CalculateTimetoDetectMalware", "attributes": {}}, {"query": "\"//Detects users with global or exchange administrator roles who have accessed email items from mailboxes other than their own\\n\\n//Data connector required for this query - Office 365\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nlet timeframe=30d;\\nlet adminusers=\\nIdentityInfo\\n| where TimeGenerated > ago(21d)\\n| where AssignedRoles has_any (\\\"Exchange Administrator\\\", \\\"Global Administrator\\\")\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| project UserId=AccountUPN;\\nOfficeActivity\\n| where TimeGenerated > ago(timeframe)\\n| where OfficeWorkload == \\\"Exchange\\\"\\n| where Operation == \\\"MailItemsAccessed\\\"\\n| where UserId in (adminusers)\\n| where UserId != MailboxOwnerUPN\\n| project AccessTime=TimeGenerated, UserId, MailboxOwnerUPN, Folders\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-DetectEmailsReadbyAdmins.kql", "query_name": "OfficeActivity-DetectEmailsReadbyAdmins", "attributes": {}}, {"query": "\"//Detect when an Exchange admin grants full mailbox access to another user\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where RecordType == \\\"ExchangeAdmin\\\"\\n| where Operation == \\\"Add-MailboxPermission\\\"\\n| parse-where Parameters with * 'Identity\\\",\\\"Value\\\":\\\"' TargetMailbox '\\\"' *\\n| parse-where Parameters with * 'User\\\",\\\"Value\\\":\\\"' UserGivenAccess '\\\"' *\\n| parse-where Parameters with * 'AccessRights\\\",\\\"Value\\\":\\\"' AccessRights '\\\"' *\\n| project\\n    TimeGenerated,\\n    Actor=UserId,\\n    ['Target Mailbox']=TargetMailbox,\\n    ['Target Mailbox DisplayName']=OfficeObjectId,\\n    ['User Granted Access']=UserGivenAccess,\\n    ['Access Type']=AccessRights\\n| where Actor != \\\"NT AUTHORITY\\\\\\\\SYSTEM (Microsoft.Exchange.Servicehost)\\\"\\n| sort by TimeGenerated desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-DetectFullMailboxAccess.kql", "query_name": "OfficeActivity-DetectFullMailboxAccess", "attributes": {}}, {"query": "\"//Detect when a new Exchange admin role is created and parse the permissions\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where Operation == \\\"New-RoleGroup\\\"\\n| where RecordType == \\\"ExchangeAdmin\\\"\\n| parse Parameters with * 'Name\\\",\\\"Value\\\":\\\"' ['Role Name'] '\\\"' *\\n| parse Parameters with * 'Roles\\\",\\\"Value\\\":\\\"' ['Permissions Added'] '\\\"' *\\n| project TimeGenerated, Actor=UserId, ['Role Name'], ['Permissions Added']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-DetectNewExchangeAdminRole.kql", "query_name": "OfficeActivity-DetectNewExchangeAdminRole", "attributes": {}}, {"query": "\"//Detect when a user is made an owner on multiple Teams in a short time frame.\\n\\n//Data connector required for this query - Office 365\\n\\n//Define a time period to check and the threshold of how many Teams to alert on.\\n//This example would find users added as an owner to 3 or more Teams within 30 minutes.\\nlet timeframe=30m;\\nlet threshold=3;\\nOfficeActivity\\n| where TimeGenerated > ago(1d)\\n| where Operation == \\\"MemberRoleChanged\\\"\\n| mv-expand Members\\n| extend RoleAdded = tostring(Members.Role)\\n| extend UserAdded = tostring(Members.UPN)\\n| where RoleAdded == 2\\n| project TimeGenerated, RoleAdded, UserAdded, TeamName\\n| summarize\\n    ['Number of Teams Made Owner']=dcount(TeamName), ['Team Names']=make_set(TeamName) by UserAdded, bin(TimeGenerated, timeframe)\\n| where ['Number of Teams Made Owner'] >= threshold\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-DetectUsermadeOwneronmultipleTeams.kql", "query_name": "OfficeActivity-DetectUsermadeOwneronmultipleTeams", "attributes": {}}, {"query": "\"//Detect when a new scoping policy is applied, scoping policies are used to limit permissions to Exchange mailboxes being accessed via OAuth. They should be configured with least privilege\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where Operation == \\\"New-ApplicationAccessPolicy\\\"\\n| extend GroupPolicyAppliedTo = tostring(parse_json(Parameters)[1].Value)\\n| extend AppId = tostring(parse_json(Parameters)[0].Value)\\n| extend AccessRight = tostring(parse_json(Parameters)[2].Value)\\n| project TimeGenerated, Actor=UserId, Operation, AccessRight, GroupPolicyAppliedTo, AppId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-ExchangeScopingPolicyApplied.kql", "query_name": "OfficeActivity-ExchangeScopingPolicyApplied", "attributes": {}}, {"query": "\"//Find when files are shared from OneDrive to third party guests\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago(7d)\\n| where OfficeWorkload == \\\"OneDrive\\\"\\n| where Operation in (\\\"SecureLinkCreated\\\", \\\"AddedToSecureLink\\\")\\n| where TargetUserOrGroupType == \\\"Guest\\\" or TargetUserOrGroupName contains \\\"#EXT#\\\"\\n| project\\n    TimeGenerated,\\n    ['User Who Shared']=UserId,\\n    ['Guest Granted Access']=TargetUserOrGroupName,\\n    ['File Shared']=OfficeObjectId\\n| sort by TimeGenerated desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-FilesSharedtoGuestsfromOnedrive.kql", "query_name": "OfficeActivity-FilesSharedtoGuestsfromOnedrive", "attributes": {}}, {"query": "\"//Find any new operations audited in Office 365 in the last 14 days vs the previous 180 days\\n\\n//Data connector required for this query - Office 365\\n\\nlet existingoperations=\\n    OfficeActivity\\n    | where TimeGenerated > ago(180d) and TimeGenerated < ago(14d)\\n    | distinct Operation;\\nOfficeActivity\\n| where TimeGenerated > ago(14d)\\n| summarize arg_min(TimeGenerated, *) by Operation\\n| where Operation !in (existingoperations)\\n| project ['Time First Seen']=TimeGenerated, Operation, OfficeWorkload\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-FindNewOperations.kql", "query_name": "OfficeActivity-FindNewOperations", "attributes": {}}, {"query": "\"//When Office 365 detects malware in OneDrive or SharePoint find any users that downloaded the same file\\n\\n//Data connector required for this query - Office 365\\n\\nlet malware=\\n    OfficeActivity\\n    | where TimeGenerated > ago(1d)\\n    | where Operation == \\\"FileMalwareDetected\\\"\\n    | distinct OfficeObjectId;\\nOfficeActivity\\n| where TimeGenerated > ago (1d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where OfficeObjectId in (malware)\\n| summarize ['Users who Downloaded']=make_set(UserId) by ['File Name']=OfficeObjectId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-FindUserswhoDownloadedMalware.kql", "query_name": "OfficeActivity-FindUserswhoDownloadedMalware", "attributes": {}}, {"query": "\"//Detect when a guest is added to multiple Teams in a short time frame.\\n\\n//Data connector required for this query - Office 365\\n\\n//Define a time period to check and the threshold of how many Teams to alert on.\\nlet timeframe=15m;\\nlet threshold=2;\\nOfficeActivity\\n| where TimeGenerated > ago(1d)\\n| where Operation == \\\"MemberAdded\\\"\\n| mv-expand Members\\n| extend UserAdded = tostring(Members.UPN)\\n| where UserAdded contains \\\"#EXT#\\\"\\n| where CommunicationType == \\\"Team\\\"\\n| summarize\\n    ['Number of Teams Guest Added To']=dcount(TeamName), ['Team Names']=make_set(TeamName) by UserAdded, bin(TimeGenerated, timeframe)\\n| where ['Number of Teams Guest Added To'] >= threshold\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-GuestAddedtoMultipleTeams.kql", "query_name": "OfficeActivity-GuestAddedtoMultipleTeams", "attributes": {}}, {"query": "\"//Summarize the total count of downloads from Office 365 for each of your guest domains\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId contains \\\"#EXT#\\\"\\n| extend ['Guest UserPrincipalName'] = tostring(split(UserId,\\\"#\\\")[0])\\n| extend ['Guest Domain'] = tostring(split(['Guest UserPrincipalName'],\\\"_\\\")[-1])\\n| project ['Guest Domain']\\n| summarize ['Download Count']=count()by ['Guest Domain']\\n| sort by ['Download Count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-GuestDomainsHighestDownloads.kql", "query_name": "OfficeActivity-GuestDomainsHighestDownloads", "attributes": {}}, {"query": "\"//Alerts when a file believed to be malware is uploaded to your Office 365 tenant in SharePoint or OneDrive\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation == \\\"FileMalwareDetected\\\"\\n| project\\n    TimeGenerated,\\n    OfficeWorkload,\\n    ['File Name']=SourceFileName,\\n    ['File Location']=OfficeObjectId,\\n    ['Relative File URL']=SourceRelativeUrl,\\n    ClientIP\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-MalwareDetected.kql", "query_name": "OfficeActivity-MalwareDetected", "attributes": {}}, {"query": "\"//Detect when a user shares multiple files to Azure AD guests over a short time frame.\\n\\n//Data connector required for this query - Office 365\\n\\n//Define a time period to check and the threshold of how many files to alert on.\\n//In this example it would detect when a user shares 10 or more files to a guest within 30 minutes\\nlet timeframe=30m;\\nlet threshold=10;\\nOfficeActivity\\n| where TimeGenerated > ago(1d)\\n| where Operation in (\\\"SecureLinkCreated\\\", \\\"AddedToSecureLink\\\")\\n| where TargetUserOrGroupType == \\\"Guest\\\" or TargetUserOrGroupName contains \\\"#EXT#\\\"\\n| summarize\\n    ['File Share Count']=dcount(OfficeObjectId),\\n    ['List of Files']=make_set(OfficeObjectId)\\n    by UserId, bin(TimeGenerated, timeframe)\\n| where ['File Share Count'] >= threshold\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-MultipleFilesSharedtoGuests.kql", "query_name": "OfficeActivity-MultipleFilesSharedtoGuests", "attributes": {}}, {"query": "\"//Detect when an app is installed into Teams for the first time compared to the previous timerange\\n\\n//Data connector required for this query - Office 365\\n\\nlet knownapps=\\n    OfficeActivity\\n    | where TimeGenerated > ago(180d) and TimeGenerated < ago(7d)\\n    | where OfficeWorkload == \\\"MicrosoftTeams\\\"\\n    | where Operation == \\\"AppInstalled\\\"\\n    | distinct AzureADAppId;\\nOfficeActivity\\n| where TimeGenerated > ago (7d)\\n| where OfficeWorkload == \\\"MicrosoftTeams\\\"\\n| where Operation == \\\"AppInstalled\\\"\\n| where AzureADAppId !in (knownapps)\\n| project TimeGenerated, UserId, AddonName, AzureADAppId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-NewTeamsAppInstalled.kql", "query_name": "OfficeActivity-NewTeamsAppInstalled", "attributes": {}}, {"query": "\"//Detect when a shared Teams channel is created\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where Operation == \\\"ChannelAdded\\\"\\n| where ChannelType == \\\"Shared\\\"\\n| project TimeGenerated, Actor=UserId, TeamName, ChannelType, ChannelName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-SharedTeamsChannelCreated.kql", "query_name": "OfficeActivity-SharedTeamsChannelCreated", "attributes": {}}, {"query": "\"//Summarize the total count and the list of files downloaded by guests in your Office 365 tenant\\n\\n//Data connector required for this query - Office 365\\n\\nlet timeframe=7d;\\nOfficeActivity\\n| where TimeGenerated > ago(timeframe)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId contains \\\"#EXT#\\\"\\n| summarize\\n    ['Count of Downloads']=count(),\\n    ['List of Files Downloaded']=make_set(OfficeObjectId)\\n    by UserId\\n| sort by ['Count of Downloads'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-SummarizeDownloadActivitybyGuests.kql", "query_name": "OfficeActivity-SummarizeDownloadActivitybyGuests", "attributes": {}}, {"query": "\"//Find any of your Teams that have had guests added to them in the last week and arrange by the Teams with the most guests added.\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago(7d)\\n| where Operation == \\\"MemberAdded\\\"\\n| mv-expand Members\\n| extend UserAdded = tostring(Members.UPN)\\n| where UserAdded contains \\\"#EXT#\\\"\\n| where CommunicationType == \\\"Team\\\"\\n| summarize\\n    ['Number of Guests Added']=dcount(UserAdded),\\n    ['List of Guests Added']=make_set(UserAdded)\\n    by TeamName\\n| sort by ['Number of Guests Added'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-SummarizeGuestsAddedtoTeams.kql", "query_name": "OfficeActivity-SummarizeGuestsAddedtoTeams", "attributes": {}}, {"query": "\"//Summarize the applications installed into Teams in the last month. Apps are grouped into the scope they were installed to - Team, Chat or User and by name and application id\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago (30d)\\n| where Operation == \\\"AppInstalled\\\"\\n| summarize\\n    ['App Installed to Team Scope']=countif(OperationScope == \\\"Team\\\"),\\n    ['App Installed to Chat Scope']=countif(OperationScope == \\\"Chat\\\"),\\n    ['App Installed to User Scope']=countif(OperationScope == \\\"User\\\")\\n    by AddonName, AzureADAppId\\n| sort by AddonName asc  \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-SummarizeTeamsAppInstalls.kql", "query_name": "OfficeActivity-SummarizeTeamsAppInstalls", "attributes": {}}, {"query": "\"//Create a weekly summary of Teams created and deleted in your Office 365 tenant\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in (\\\"TeamCreated\\\", \\\"TeamDeleted\\\")\\n| summarize\\n    ['Count of Teams Created']=dcountif(TeamName, Operation == \\\"TeamCreated\\\"),\\n    ['List of Teams Created']=make_set_if(TeamName, Operation == \\\"TeamCreated\\\"),\\n    ['Count of Teams Deleted']=dcountif(TeamName, Operation == \\\"TeamDeleted\\\"),\\n    ['List of Teams Deleted']=make_set_if(TeamName, Operation == \\\"TeamDeleted\\\")\\n    by Week=startofweek(TimeGenerated)\\n| sort by Week desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-SummarizeTeamsCreatedDeleted.kql", "query_name": "OfficeActivity-SummarizeTeamsCreatedDeleted", "attributes": {}}, {"query": "\"//Create a set of users external to your organization who have accessed Office files after being shared. Events are grouped by the user who shared the document, and what activities were performed against it and by which external account.\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| project LinkCreatedTime=TimeGenerated, Operation, UserWhoShared=UserId, OfficeObjectId\\n| where Operation in ('AddedToSecureLink', 'SecureLinkCreated', 'SecureLinkUpdated', 'SharingInvitationCreated')\\n| join kind=inner\\n    (OfficeActivity\\n    | project LinkClickedTime=TimeGenerated, Operation, UserWhoAccessed=UserId, OfficeObjectId)\\n    on OfficeObjectId\\n| where UserWhoAccessed !endswith \\\"yourdomain.com\\\" and UserWhoAccessed != \\\"app@sharepoint\\\"\\n| extend ExternalOperation=Operation1\\n| summarize ExternalUsers=make_set(UserWhoAccessed) by UserWhoShared, OfficeObjectId, ExternalOperation\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-SummaryofExternalActivity.kql", "query_name": "OfficeActivity-SummaryofExternalActivity", "attributes": {}}, {"query": "\"//Detect when the role for a user changes to owner or back to standard member in your any of your Teams\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where Operation == \\\"MemberRoleChanged\\\"\\n| mv-expand Members\\n| extend User = tostring(Members.UPN)\\n| extend x = tostring(Members.Role)\\n| extend Action = case(x == \\\"1\\\", strcat(\\\"User changed to member\\\"),\\n    x == \\\"2\\\", strcat(\\\"User changed to owner\\\"), \\\"unknown\\\")\\n| where Action in (\\\"User changed to member\\\", \\\"User changed to owner\\\")\\n| project\\n    TimeGenerated,\\n    TeamName,\\n    ActorType=UserType,\\n    Actor=UserId,\\n    UserAdded=User,\\n    Action\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-TeamsRoleChanges.kql", "query_name": "OfficeActivity-TeamsRoleChanges", "attributes": {}}, {"query": "\"//Find the top 20 of a collection of varied data sets, no real detections in here just interesting data that is captured\\n\\n//Data connector required for this query - Office 365\\n\\n//Top 20 files downloaded from your tenant\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| summarize Count=count()by OfficeObjectId\\n| top 20 by Count\\n\\n//Top 20 users downloading files from your tenant\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId !contains \\\"#EXT#\\\"\\n| summarize Count=count()by UserId\\n| top 20 by Count\\n\\n//Top 20 guests downloading files from your tenant\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId contains \\\"#EXT#\\\"\\n| extend ['Guest UserPrincipalName'] = tostring(split(UserId,\\\"#\\\")[0])\\n| summarize Count=count()by ['Guest UserPrincipalName']\\n| top 20 by Count\\n\\n//Top 20 downloads from your tenant by guest domain\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId contains \\\"#EXT#\\\"\\n| extend ['Guest UserPrincipalName'] = tostring(split(UserId,\\\"#\\\")[0])\\n| extend ['Guest Domain'] = tostring(split(['Guest UserPrincipalName'],\\\"_\\\")[-1])\\n| summarize Count=count()by ['Guest Domain']\\n| top 20 by Count\\n\\n//Top 20 users sharing files to guests\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where OfficeWorkload == \\\"OneDrive\\\"\\n| where Operation in (\\\"SecureLinkCreated\\\", \\\"AddedToSecureLink\\\")\\n| where TargetUserOrGroupType == \\\"Guest\\\" or TargetUserOrGroupName contains \\\"#EXT#\\\"\\n| summarize Count=count() by UserId\\n| top 20 by Count\\n\\n//Top 20 most shared files\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where OfficeWorkload == \\\"OneDrive\\\"\\n| where Operation in (\\\"SecureLinkCreated\\\", \\\"AddedToSecureLink\\\")\\n| summarize Count=count() by OfficeObjectId\\n| top 20 by Count\\n\\n//Top 20 guests with files shared to them\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where OfficeWorkload == \\\"OneDrive\\\"\\n| where Operation in (\\\"SecureLinkCreated\\\", \\\"AddedToSecureLink\\\")\\n| where TargetUserOrGroupType == \\\"Guest\\\" or TargetUserOrGroupName contains \\\"#EXT#\\\"\\n| summarize Count=count() by TargetUserOrGroupName\\n| top 20 by Count\\n\\n//Top 20 guests added to Teams by distinct Team name\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation == \\\"MemberAdded\\\"\\n| mv-expand Members\\n| extend UserAdded = tostring(Members.UPN)\\n| where UserAdded contains \\\"#EXT#\\\"\\n| where CommunicationType == \\\"Team\\\"\\n| where UserId != \\\"Microsoft Teams Sync\\\"\\n| summarize Count=dcount(TeamName) by UserId\\n| top 20 by Count\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-Top20RandomStats.kql", "query_name": "OfficeActivity-Top20RandomStats", "attributes": {}}, {"query": "\"//Visualises potentially anomalous download activities in your Office tenant over the set period. Time frames can be adjusted to suit. \\n\\n//Data connector required for this query - Office 365\\n\\n//Starttime and timeframe = how many days of data to look at and in what grouping, i.e 7 days of data over 1 hour periods.\\n//Threshold = the amount of total downloads required to be included in anomaly calculations. Reduces noise from low level anomalies, e.g going from 1 download to 3 downloads total.\\n//sensitivity = adjust to make the query more or less sensitive, the higher the value, the greater the anomaly required to be detected.\\nlet starttime = 7d;\\nlet timeframe = 1h;\\nlet threshold = 30;\\nlet sensitivity = 2;\\nlet operations = dynamic([\\\"FileSyncDownloadedFull\\\",\\\"FileDownloaded\\\"]);\\nlet outlierusers=\\nOfficeActivity\\n| where TimeGenerated > ago(starttime)\\n| where Operation in (['operations'])\\n| project TimeGenerated, UserId\\n| order by TimeGenerated\\n| summarize Events=count()by UserId, bin(TimeGenerated, timeframe)\\n| where Events > threshold\\n| summarize EventCount=make_list(Events),TimeGenerated=make_list(TimeGenerated) by UserId\\n| extend outliers=series_decompose_anomalies(EventCount,sensitivity)\\n| mv-expand TimeGenerated, EventCount, outliers\\n| where outliers == 1\\n| distinct UserId;\\nOfficeActivity\\n| where TimeGenerated > ago(starttime)\\n| where Operation in (['operations'])\\n| where UserId in (outlierusers)\\n| summarize DownloadCount=count()by UserId, bin(TimeGenerated, timeframe)\\n| render timechart\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-VisualisingAnomalousDownloads.kql", "query_name": "OfficeActivity-VisualisingAnomalousDownloads", "attributes": {}}, {"query": "\"//Visualize downloads from your Office 365 tenant by trust type (trusted/known by Azure Active Directory vs Unknown)\\n\\n//Data connector required for this query - Office 365\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//Query Azure AD logs to get a listing of each username, IPAddress and trust type\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where ResultType == 0\\n| where UserType == \\\"Member\\\"\\n| extend DeviceTrustType = tostring(DeviceDetail.trustType)\\n| distinct UserPrincipalName, IPAddress, DeviceTrustType\\n//Join to Office Activity download on username and IP and find download events\\n| join kind=inner(\\n    OfficeActivity\\n    | where TimeGenerated > ago(30d)\\n    | where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n    )\\n    on $left.UserPrincipalName == $right.UserId, $left.IPAddress == $right.ClientIP\\n//Summarize download events by whether the device is known or not\\n| summarize\\n    ['Trusted Devices']=countif(isnotempty(DeviceTrustType)),\\n    ['Untrusted Devices']=countif(isempty(DeviceTrustType))\\n    by bin(TimeGenerated, 1d)\\n| render timechart with (title=\\\"Downloads from Office 365 by device trust type\\\")\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-VisualizeDownloadsbyTrustType.kql", "query_name": "OfficeActivity-VisualizeDownloadsbyTrustType", "attributes": {}}, {"query": "\"//Visualize uploads vs downloads in your Office 365 tenant per day\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| project TimeGenerated, Operation\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileSyncUploadedFull\\\", \\\"FileDownloaded\\\", \\\"FileUploaded\\\")\\n| summarize\\n    ['Files Downloaded']=countif(Operation in (\\\"FileDownloaded\\\", \\\"FileSyncDownloadedFull\\\")),\\n    ['Files Uploaded']=countif(Operation in (\\\"FileSyncUploadedFull\\\", \\\"FileUploaded\\\"))\\n    by startofday(TimeGenerated)\\n| render columnchart\\n    with (\\n    kind=unstacked,\\n    title=\\\"Downloads vs Uploads in Office 365\\\",\\n    ytitle=\\\"Count\\\",\\n    xtitle=\\\"Day\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-VisualizeDownloadsvsUploads.kql", "query_name": "OfficeActivity-VisualizeDownloadsvsUploads", "attributes": {}}, {"query": "\"//Visualize the guest domains that have had the most files shares to them from your Office 365 tenant\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where Operation in~ (\\\"AddedToSecureLink\\\", \\\"SecureLinkCreated\\\", \\\"SecureLinkUpdated\\\")\\n| where TargetUserOrGroupType == \\\"Guest\\\" and TargetUserOrGroupName contains \\\"#ext#\\\"\\n| extend ['Guest UserPrincipalName'] = tostring(split(TargetUserOrGroupName, \\\"#\\\")[0])\\n| extend ['Guest Domain'] = tostring(split(['Guest UserPrincipalName'], \\\"_\\\")[-1])\\n| summarize Count=count() by ['Guest Domain']\\n| top 20 by Count\\n| render barchart with (title=\\\"Top guest domains with files shared to\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-VisualizeFileShareTopGuestDomains.kql", "query_name": "OfficeActivity-VisualizeFileShareTopGuestDomains", "attributes": {}}, {"query": "\"//Visualize the files shared to guests from Office 365 over time\\n\\n//Data connector required for this query - Office 365\\n\\nlet timerange=90d;\\nOfficeActivity\\n| where TimeGenerated > ago(timerange)\\n| where Operation in (\\\"SecureLinkCreated\\\", \\\"AddedToSecureLink\\\")\\n| where TargetUserOrGroupType == \\\"Guest\\\"\\n| summarize Count=count()by bin(TimeGenerated, 1d)\\n| render timechart with (ytitle=\\\"File Count\\\", title=\\\"Files shared with guests over time\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-VisualizeFilesSharedtoGuests.kql", "query_name": "OfficeActivity-VisualizeFilesSharedtoGuests", "attributes": {}}, {"query": "\"//Visualize how many files are being downloaded from your Office 365 tenant by guest accounts with trend\\n\\n//Data connector required for this query - Office 365\\n\\nlet StartDate = now(-90d);\\nlet EndDate = now();\\nOfficeActivity\\n| where TimeGenerated > ago(90d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId contains \\\"#ext#\\\"\\n| make-series TotalDownloads=count() on TimeGenerated in range(StartDate, EndDate, 1d)\\n| extend (RSquare, SplitIdx, Variance, RVariance, TrendLine)=series_fit_2lines(TotalDownloads)\\n| project TimeGenerated, TotalDownloads, TrendLine\\n| render timechart with (title=\\\"Guest downloads from Office 365 per day over time with trend\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-VisualizeGuestDownloadsfromO365withTrend.kql", "query_name": "OfficeActivity-VisualizeGuestDownloadsfromO365withTrend", "attributes": {}}, {"query": "\"//Visualize guests added vs removed from Teams per day over the last 30 days\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago(30d)\\n| where UserType == \\\"Regular\\\"\\n| where CommunicationType == \\\"Team\\\"\\n| where OfficeWorkload == \\\"MicrosoftTeams\\\" \\n| where Operation in (\\\"MemberAdded\\\", \\\"MemberRemoved\\\")\\n| mv-expand Members\\n| extend User = tostring(Members.UPN)\\n| where User contains \\\"#EXT#\\\"\\n| project TimeGenerated, Operation, User\\n| summarize\\n    ['Guests Added']=countif(Operation == \\\"MemberAdded\\\"),\\n    ['Guests Removed']=countif(Operation == \\\"MemberRemoved\\\")\\n    by startofday(TimeGenerated)\\n| render columnchart\\n    with (\\n    kind=unstacked,\\n    xtitle=\\\"Count\\\",\\n    ytitle=\\\"Day\\\",\\n    title=\\\"Guests Added vs Removed from Teams\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-VisualizeGuestsAddedRemovedfromTeams.kql", "query_name": "OfficeActivity-VisualizeGuestsAddedRemovedfromTeams", "attributes": {}}, {"query": "\"//Visualize total guests redeemed in Azure AD vs guests that have been added to a Team\\n\\n//Data connector required for this query - Office 365\\n\\nlet guestsredeemed=\\n    AuditLogs\\n    | where TimeGenerated > ago (90d)\\n    | where OperationName == \\\"Redeem external user invite\\\"\\n    | extend GuestRedeemed = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\n    | extend Activity = strcat(\\\"Guest Invite Redeemed\\\")\\n    | project TimeGenerated, GuestRedeemed, Activity;\\nlet guestsaddedtoteams=\\n    OfficeActivity\\n    | where TimeGenerated > ago(90d)\\n    | where Operation == \\\"MemberAdded\\\"\\n    | mv-expand Members\\n    | extend GuestAdded = tostring(Members.UPN)\\n    | where GuestAdded contains \\\"#EXT#\\\"\\n    | extend Activity = strcat(\\\"Guest Added to Team\\\")\\n    | project TimeGenerated, GuestAdded, Activity;\\nunion guestsredeemed, guestsaddedtoteams\\n| summarize ['Total Count']=count() by Activity, bin(TimeGenerated, 1d)\\n| render columnchart with (kind=unstacked, title=\\\"Total Guests Redeemed vs Guests Added to Teams\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-VisualizeGuestsRedeemedvsAddedtoTeams.kql", "query_name": "OfficeActivity-VisualizeGuestsRedeemedvsAddedtoTeams", "attributes": {}}, {"query": "\"//Visualize the top 20 files downloaded by Azure AD guests over the last month\\n\\n//Data connector required for this query - Office 365\\n\\nOfficeActivity\\n| where TimeGenerated > ago (30d)\\n| where Operation in (\\\"FileSyncDownloadedFull\\\", \\\"FileDownloaded\\\")\\n| where UserId contains \\\"#ext#\\\"\\n| summarize Count=count()by FileName=SourceFileName\\n| sort by Count desc\\n| take 20\\n| render barchart with (title=\\\"Top files downloaded by guests over the last month\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Office%20365/OfficeActivity-VisualizeTopGuestDownloads.kql", "query_name": "OfficeActivity-VisualizeTopGuestDownloads", "attributes": {}}, {"query": "\"//Parse all the relevant entities - hosts, accounts, IP addresses, files, groups, resources and times from Defender for Identity alerts\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where ProviderName == \\\"Azure Advanced Threat Protection\\\"\\n| summarize arg_max(TimeGenerated, *) by VendorOriginalId\\n| mv-expand todynamic(Entities)\\n| extend x = parse_json(Entities)\\n| extend Host = x.HostName\\n| extend Account = x.Name\\n| extend IP = x.Address\\n| extend File = x.File\\n| extend Group = x.Group\\n| extend ResourceId = x.ResourceName\\n| extend Time= x.Time\\n| summarize\\n    HostNames=make_set(Host),\\n    AccountNames=make_set(Account),\\n    IPAddresses=make_set(IP),\\n    Files=make_set(File),\\n    SecurityGroups=make_set(Group),\\n    Resources=make_set(ResourceId),\\n    TimeAccessed=make_set(Time)\\n    by TimeGenerated, SystemAlertId, AlertName, Description\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-DefenderforIdParser.kql", "query_name": "SecurityAlert-DefenderforIdParser", "attributes": {}}, {"query": "\"//When Defender for Identity alerts on user and group reconnaissance, parse the relevant accounts, hosts and groups affected\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where AlertName == \\\"User and group membership reconnaissance (SAMR)\\\"\\n| extend x = todynamic(Entities)\\n| mv-expand x\\n| parse x with * 'HostName\\\":\\\"' HostName '\\\",\\\"Id' *\\n| parse x with * 'FriendlyName\\\":\\\"' GroupName '\\\",\\\"Type\\\":\\\"security-group\\\"' *\\n| parse x with * '\\\"Name\\\":\\\"' AccountName '\\\",\\\"Sid\\\"' *\\n| summarize\\n    Accounts=make_list_if(AccountName, isnotempty(AccountName)),\\n    Hosts=make_list_if(HostName, isnotempty(HostName)),\\n    Groups=make_list_if(GroupName, isnotempty(GroupName))\\n    by VendorOriginalId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-DefenderforIDRecon.kql", "query_name": "SecurityAlert-DefenderforIDRecon", "attributes": {}}, {"query": "\"//List any new alert types found by the Defender product suite in the last week compared to the previous year\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\n//First find all the existing alerts from the last year excluding the last week\\nlet existingalerts=\\n    SecurityAlert\\n    | where TimeGenerated > ago(365d) and TimeGenerated < ago(7d)\\n    // Exclude alerts from Sentinel itself\\n    | where ProviderName != \\\"ASI Scheduled Alerts\\\"\\n    | distinct AlertName;\\n//Find new alerts triggered in the last week\\nSecurityAlert\\n| where TimeGenerated > ago(7d)\\n// Exclude alerts from Sentinel itself\\n| where ProviderName != \\\"ASI Scheduled Alerts\\\"\\n| where AlertName !in (existingalerts)\\n| distinct AlertName, ProviderName, ProductName\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-DetectNewAlerts.kql", "query_name": "SecurityAlert-DetectNewAlerts", "attributes": {}}, {"query": "\"//Detect when a device triggers a Defender for Endpoint alert where Defender for Identity has also detected a lateral movement path\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where ProviderName == \\\"MDATP\\\"\\n| project TimeGenerated, AlertName, CompromisedEntity\\n| join kind=inner (\\n    IdentityDirectoryEvents\\n    | where ActionType == \\\"Potential lateral movement path identified\\\")\\n    on $left.CompromisedEntity == $right.DeviceName\\n| distinct DeviceName, AlertName, AccountName, ReportId\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-DeviceAlertwithLateralMovement.kql", "query_name": "SecurityAlert-DeviceAlertwithLateralMovement", "attributes": {}}, {"query": "\"//Detect when Defender for Endpoint alerts on suspicious PowerShell usage. If command is encoded it will be decoded.\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where AlertName == \\\"Suspicious PowerShell command line\\\"\\n| mv-expand todynamic(Entities)\\n| extend CommandLine = tostring(Entities.CommandLine)\\n//This particular query looks for only encoded Powershell commands, if you want all Powershell commands just remove the lines below\\n| extend EncodedCommand = extract(@'\\\\s+([A-Za-z0-9+/]{20}\\\\S+$)', 1, CommandLine)\\n| where EncodedCommand != \\\"\\\"\\n| extend DecodedCommand = base64_decode_tostring(EncodedCommand)\\n| where DecodedCommand != \\\"\\\"\\n//\\n| project TimeGenerated, CompromisedEntity, AlertName, CommandLine, DecodedCommand\\n\\n//Advanced Hunting query - depending on the content of the decoded string AH can struggle to render the command occasionally\\n\\n//Data connector required for this query - Advanced Hunting license\\n\\nlet alertid=\\nAlertInfo\\n| where Title == @\\\"Suspicious PowerShell command line\\\"\\n| distinct AlertId;\\nAlertEvidence\\n| where AlertId in (alertid)\\n| where EntityType == \\\"Process\\\"\\n| extend EncodedCommand = extract(@'\\\\s+([A-Za-z0-9+/]{20}\\\\S+$)', 1, ProcessCommandLine)\\n| where EncodedCommand != \\\"\\\"\\n| extend DecodedCommand = base64_decode_tostring(EncodedCommand)\\n| where DecodedCommand != \\\"\\\"\\n| project Timestamp, AlertId, ProcessCommandLine, DecodedCommand\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-EncodedPowershell.kql", "query_name": "SecurityAlert-EncodedPowershell", "attributes": {}}, {"query": "\"//When Defender for Cloud Apps detects activity from an infrequent country, summarize the impact to your users\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\n//Microsoft Sentinel query\\n//Using the Security Alert table find any locations detected. This query looks back 7 days to find alerts as this can be an offline detection, but you can adjust.\\nlet suspiciouslocation=\\n    SecurityAlert\\n    | where TimeGenerated > ago(7d)\\n    | where AlertName == \\\"Activity from infrequent country\\\"\\n    | mv-expand todynamic(Entities)\\n    | project Entities\\n    | extend Location = tostring(parse_json(tostring(Entities.Location)).CountryCode)\\n    | where isnotempty(Location)\\n    | distinct Location;\\n//Take that location and send back through the sign in logs to find the blast radius\\nSigninLogs\\n| where TimeGenerated > ago(7d)\\n| where Location in (suspiciouslocation)\\n| summarize\\n    ['Count of distinct successful sign ins'] = dcountif(UserPrincipalName, (ResultType in(successCodes))),\\n    ['List of successful users']=make_set_if(UserPrincipalName, (ResultType in(successCodes))),\\n    ['Successful result codes'] = make_set_if(ResultType, (ResultType in(successCodes))),\\n    ['Count of distinct failed sign ins'] = dcountif(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['List of failed users'] = make_set_if(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['Failed result codes'] = make_set_if(ResultType, (ResultType in(failureCodes)))\\n    by Location\\n\\n//Advanced Hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n//Data connector required for this query - Advanced Hunting with Azure AD P2\\n\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\nlet alertid=\\nAlertInfo\\n| where Timestamp > ago(7d)\\n| where Title == @\\\"Activity from infrequent country\\\"\\n| distinct AlertId;\\nlet suspiciouslocation=\\nAlertEvidence\\n| where AlertId in (alertid)\\n| extend AF=parse_json(AdditionalFields)\\n| extend Location=tostring(AF.Location.CountryCode)\\n| where isnotempty(Location)\\n| distinct Location;\\nAADSignInEventsBeta\\n| where Timestamp > ago(7d)\\n| where Country in (suspiciouslocation)\\n| summarize\\n    ['Count of distinct successful sign ins'] = dcountif(AccountUpn, (ErrorCode in(successCodes))),\\n    ['List of successful users']=make_set_if(AccountUpn, (ErrorCode in(successCodes))),\\n    ['Successful result codes'] = make_set_if(ErrorCode, (ErrorCode in(successCodes))),\\n    ['Count of distinct failed sign ins'] = dcountif(AccountUpn, (ErrorCode in(failureCodes))),\\n    ['List of failed users'] = make_set_if(AccountUpn, (ErrorCode in(failureCodes))),\\n    ['Failed result codes'] = make_set_if(ErrorCode, (ErrorCode in(failureCodes)))\\n    by Country\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-FindBlastRadiusInfrequentCountry.kql", "query_name": "SecurityAlert-FindBlastRadiusInfrequentCountry", "attributes": {}}, {"query": "\"//When Defender for Cloud Apps detects password spray activity, summarize the impact to your users\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\n//Using the Security Alert table find any IP addresses associated with password spray activity. This query looks back 7 days to find alerts as this can be an offline detection, but you can adjust.\\n//Microsoft Sentinel query\\nlet maliciousip=\\n    SecurityAlert\\n    | where TimeGenerated > ago (7d)\\n    | where AlertName == \\\"Activity from a password-spray associated IP address\\\"\\n    | mv-expand todynamic(Entities)\\n    | project TimeGenerated, Entities\\n    | extend IPAddress = tostring(Entities.Address)\\n    | where isnotempty(IPAddress)\\n    | distinct IPAddress;\\n//Look back in your signin logs the last 30 days and summarize activity from that address\\nSigninLogs\\n| where TimeGenerated > ago(30d)\\n| where IPAddress in (maliciousip)\\n| summarize\\n    ['Count of distinct successful sign ins'] = dcountif(UserPrincipalName, (ResultType in(successCodes))),\\n    ['List of successful users']=make_set_if(UserPrincipalName, (ResultType in(successCodes))),\\n    ['Successful result codes'] = make_set_if(ResultType, (ResultType in(successCodes))),\\n    ['Count of distinct failed sign ins'] = dcountif(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['List of failed users'] = make_set_if(UserPrincipalName, (ResultType in(failureCodes))),\\n    ['Failed result codes'] = make_set_if(ResultType, (ResultType in(failureCodes)))\\n    by IPAddress\\n\\n//Advanced hunting query\\n\\n//Data connector required for this query - Advanced Hunting license\\n//Data connector required for this query - Advanced Hunting with Azure AD P2\\n\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\nlet alertid=\\nAlertInfo\\n| where Timestamp > ago(7d)\\n| where Title == @\\\"Activity from a password-spray associated IP address\\\"\\n| distinct AlertId;\\nlet maliciousip=\\nAlertEvidence\\n| where AlertId in (alertid)\\n| where EntityType == @\\\"Ip\\\"\\n| extend AF = parse_json(AdditionalFields)\\n| extend IPAddress = tostring(AF.Address)\\n| distinct IPAddress;\\nAADSignInEventsBeta\\n| where Timestamp > ago(30d)\\n| where IPAddress in (maliciousip)\\n| summarize\\n    ['Count of distinct successful sign ins'] = dcountif(AccountUpn, (ErrorCode in(successCodes))),\\n    ['List of successful users']=make_set_if(AccountUpn, (ErrorCode in(successCodes))),\\n    ['Successful result codes'] = make_set_if(ErrorCode, (ErrorCode in(successCodes))),\\n    ['Count of distinct failed sign ins'] = dcountif(AccountUpn, (ErrorCode in(failureCodes))),\\n    ['List of failed users'] = make_set_if(AccountUpn, (ErrorCode in(failureCodes))),\\n    ['Failed result codes'] = make_set_if(ErrorCode, (ErrorCode in(failureCodes)))\\n    by IPAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-FindBlastRadiusofPasswordSpray.kql", "query_name": "SecurityAlert-FindBlastRadiusofPasswordSpray", "attributes": {}}, {"query": "\"//Find the most phished users from the last 365 days\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where TimeGenerated > ago (365d)\\n| where ProviderName == \\\"OATP\\\"\\n| where AlertName in (\\\"Email messages containing malicious URL removed after delivery\\\", \\\"Email messages containing phish URLs removed after delivery\\\")\\n| mv-expand todynamic(Entities)\\n| project Entities\\n| extend User = tostring(Entities.MailboxPrimaryAddress)\\n| where isnotempty(User)\\n| summarize ['Count of Phishing Attempts']=count()by User\\n| order by ['Count of Phishing Attempts']\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-FindMostPhishedUsers.kql", "query_name": "SecurityAlert-FindMostPhishedUsers", "attributes": {}}, {"query": "\"//When Defender for Cloud detects communication with a DNS sinkhole, find the devices and processes initiating the connection\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nlet domain=\\n    SecurityAlert\\n    | where TimeGenerated > ago (1d)\\n    | where AlertName startswith \\\"Attempted communication with suspicious sinkholed domain\\\"\\n    | mv-expand todynamic(Entities)\\n    | extend DomainName = tostring(Entities.DomainName)\\n    | where isnotempty(DomainName)\\n    | distinct DomainName;\\nDeviceNetworkEvents\\n| where TimeGenerated > ago (7d)\\n| where RemoteUrl in~ (domain)\\n| project\\n    TimeGenerated,\\n    ActionType,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemoteUrl,\\n    RemotePort\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-FindNetworkConnectionsSinkholedDomain.kql", "query_name": "SecurityAlert-FindNetworkConnectionsSinkholedDomain", "attributes": {}}, {"query": "\"//When a user reports an email as potential phishing find all other users who received that email\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\nSecurityAlert\\n| where TimeGenerated > ago(1d)\\n| where ProviderName == \\\"OATP\\\"\\n| where AlertName has \\\"Email reported by user as malware or phish\\\"\\n| mv-expand todynamic(Entities)\\n| project Entities\\n| extend SenderMailFromAddress = tostring(Entities.P1Sender)\\n| extend Subject = tostring(Entities.Subject)\\n| where isnotempty(SenderMailFromAddress) and isnotempty(Subject)\\n| distinct SenderMailFromAddress, Subject\\n| join kind=inner(\\n    EmailEvents\\n    | where TimeGenerated > ago(2d)\\n    | project RecipientEmailAddress, SenderMailFromAddress, Subject\\n    )\\n    on SenderMailFromAddress, Subject\\n| summarize Recipients=make_set(RecipientEmailAddress) by Subject, SenderMailFromAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-FindRecipientsofPotentialPhishing.kql", "query_name": "SecurityAlert-FindRecipientsofPotentialPhishing", "attributes": {}}, {"query": "\"//When an anomalous token alert is flagged, find the specific risk events that flagged the alert\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - Azure Active Directory - AAD User Risk Events\\n\\nlet alerts=\\n    SecurityAlert\\n    | where TimeGenerated > ago(1d)\\n    | where AlertName == \\\"Anomalous Token\\\"\\n    | mv-expand todynamic(Entities)\\n    | project Entities\\n    | extend RequestId = tostring(Entities.SessionId)\\n    | distinct RequestId;\\n//Detections can be offline so retrieve a weeks worth of risk data\\nAADUserRiskEvents\\n| where TimeGenerated > ago(7d)\\n| where RequestId in (alerts)\\n| project TimeGenerated, UserPrincipalName, RiskEventType, RiskLevel, DetectionTimingType, IpAddress, Location\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-FindSigninsforAnomalousToken.kql", "query_name": "SecurityAlert-FindSigninsforAnomalousToken", "attributes": {}}, {"query": "\"//Parse the IP information from Security Alerts and find other users who have successfully signed on from the same IP addresses\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\nSecurityAlert\\n| where ProviderName in (\\\"MCAS\\\", \\\"IPC\\\")\\n| extend x = todynamic(Entities)\\n| mv-expand x\\n| parse-where x with * '\\\"Address\\\":\\\"' MaliciousIP '\\\"' *\\n//Exclude any corporate or trusted IP addresses\\n| where MaliciousIP != \\\"10.10.10.10\\\"\\n| project AlertTime=TimeGenerated, MaliciousIP, CompromisedEntity\\n| join kind=inner\\n    (\\n    SigninLogs\\n    | where ResultType in (\\\"0\\\",\\\"53003\\\",\\\"50158\\\")\\n    )\\n    on $left.MaliciousIP == $right.IPAddress\\n| where CompromisedEntity != UserPrincipalName\\n| distinct UserPrincipalName, AppDisplayName, IPAddress, UserAgent, ResultType, ResultDescription\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-FindUsersWhoSigninfromMaliciousIPs.kql", "query_name": "SecurityAlert-FindUsersWhoSigninfromMaliciousIPs", "attributes": {}}, {"query": "\"//Forecast the count of Azure AD Identity Protection Events events for the next 14 days based on the previous 30 days\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where ProviderName == \\\"IPC\\\"\\n| make-series [\\\"Azure AD Identity Protection Events\\\"]=count() on TimeGenerated from ago(30d) to now() + 14d step 1d\\n| extend [\\\"Azure AD Identity Protection Events Forecast\\\"] = series_decompose_forecast(['Azure AD Identity Protection Events'], toint(14d / 1d))\\n| render timechart \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-ForecastIdentityProtection.kql", "query_name": "SecurityAlert-ForecastIdentityProtection", "attributes": {}}, {"query": "\"//When Defender for Endpoint detects malware in an ISO file retrieve the ISO file name, which directory it was found in and associated file hashes\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where ProviderName == \\\"MDATP\\\"\\n| where AlertName == \\\"Malware was detected in an iso disc image file\\\"\\n| mv-expand todynamic(Entities)\\n| extend Hashes = Entities.FileHashes\\n| mv-expand Hashes\\n| extend ['ISO File Name'] = tostring(Entities.Name)\\n| extend Directory = tostring(Entities.Directory)\\n| extend ['Hash Type'] = tostring(Hashes.Algorithm)\\n| extend Hash = tostring(Hashes.Value)\\n| where isnotempty(['ISO File Name'])\\n| project\\n    TimeGenerated,\\n    CompromisedEntity,\\n    ['ISO File Name'],\\n    Directory,\\n    ['Hash Type'],\\n    Hash\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-MalwareDetectedinISO.kql", "query_name": "SecurityAlert-MalwareDetectedinISO", "attributes": {}}, {"query": "\"//Detect when a user or device triggers 3 or more unique alerts within a short time frame. This example uses a period of 4 hours\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where TimeGenerated > ago(1d)\\n| where isnotempty(CompromisedEntity) and CompromisedEntity != \\\"CompromisedEntity\\\"\\n| project TimeGenerated, ProviderName, AlertName, CompromisedEntity\\n| summarize\\n    ['Alert Names']=make_set(AlertName),\\n    ['Count of Unique Alerts']=dcount(AlertName)\\n    by CompromisedEntity, bin(TimeGenerated, 4h)\\n| where ['Count of Unique Alerts'] >= 3\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-MultipleAlertsTriggered.kql", "query_name": "SecurityAlert-MultipleAlertsTriggered", "attributes": {}}, {"query": "\"//Detect when the same user or device triggers 3 or more low severity alerts in the space of a day\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where TimeGenerated > ago (7d)\\n| where AlertSeverity == \\\"Low\\\"\\n| summarize\\n    ['Count of low severity alerts']=dcount(AlertName),\\n    ['List of low severity alerts']=make_set(AlertName)\\n    by CompromisedEntity, bin(TimeGenerated, 1d)\\n| where ['Count of low severity alerts'] >= 3\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-MultipleLowSeverityAlertsTriggered.kql", "query_name": "SecurityAlert-MultipleLowSeverityAlertsTriggered", "attributes": {}}, {"query": "\"//When Defender for Office 365 removes a malicious file from an email track down all device events with the same file hash\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\nlet filehashes=\\nSecurityAlert\\n| where TimeGenerated > ago (7d)\\n| where ProviderName == \\\"OATP\\\"\\n| where AlertName == \\\"Email messages containing malicious file removed after delivery\\u200b\\\"\\n| mv-expand todynamic(Entities)\\n| extend Files = Entities.Files\\n| project Files\\n| mv-expand Files\\n| extend FileHashes = Files.FileHashes\\n| mv-expand FileHashes\\n| extend FileHash = tolower(tostring(FileHashes.Value))\\n| where isnotempty( FileHash)\\n| distinct FileHash;\\nDeviceFileEvents\\n    | where TimeGenerated > ago(7d)\\n    | project\\n        TimeGenerated,\\n        ActionType,\\n        FileName,\\n        DeviceName,\\n        SHA256,\\n        InitiatingProcessAccountUpn \\n| where SHA256 in (filehashes)\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-ParseMaliciousFileInfoandFindDeviceEvents.kql", "query_name": "SecurityAlert-ParseMaliciousFileInfoandFindDeviceEvents", "attributes": {}}, {"query": "\"//Calculate the percentage of alerts that are high or critical per product\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where TimeGenerated > ago(30d)\\n| summarize\\n    ['Total Alert Count']=count(),\\n    ['Total High or Critical Count']=countif(AlertSeverity in (\\\"Critical\\\", \\\"High\\\"))\\n    by ProductName\\n| extend Percentage=(todouble(['Total High or Critical Count']) * 100 / todouble(['Total Alert Count']))\\n| project-reorder ProductName, ['Total Alert Count'], ['Total High or Critical Count'], Percentage\\n| sort by Percentage desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-PercentageofAlertsHighorCritical.kql", "query_name": "SecurityAlert-PercentageofAlertsHighorCritical", "attributes": {}}, {"query": "\"//When Defender for Cloud detects possible data transfer via DNS tunnel, use DNS logs to find any other devices that have queried the potentially malicious domain\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - DNS\\n\\nlet maliciousdomain=\\n    SecurityAlert\\n    | where AlertName contains \\\"via DNS tunnel\\\"\\n    | mv-expand todynamic(Entities)\\n    | project Entities\\n    | extend MaliciousDomain = tostring(Entities.DomainName)\\n    | where isnotempty(MaliciousDomain)\\n    | distinct MaliciousDomain;\\nDnsEvents\\n| where QueryType == \\\"A\\\"\\n| project Name, ClientIP\\n| where Name in~ (maliciousdomain)\\n| summarize ['List of Device IPs']=make_set(ClientIP) by Name\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-PossibleDNSDataTransfer.kql", "query_name": "SecurityAlert-PossibleDNSDataTransfer", "attributes": {}}, {"query": "\"//When Defender for Cloud detects communication with a possible phishing domain, use Defedner logs to find any network connections to that same domain\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - M365 Defender - Device* tables\\n\\nlet domain=\\n    SecurityAlert\\n    | where TimeGenerated > ago (7d)\\n    | where AlertName startswith \\\"Communication with possible phishing domain\\\"\\n    | mv-expand todynamic(Entities)\\n    | extend DomainName = tostring(Entities.DomainName)\\n    | where isnotempty(DomainName)\\n    | distinct DomainName;\\nDeviceNetworkEvents\\n| where TimeGenerated > ago (7d)\\n| where RemoteUrl in~ (domain)\\n| project\\n    TimeGenerated,\\n    ActionType,\\n    DeviceName,\\n    InitiatingProcessAccountName,\\n    InitiatingProcessCommandLine,\\n    LocalIP,\\n    RemoteIP,\\n    RemoteUrl,\\n    RemotePort\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-PotentialPhishingDomainCommunication.kql", "query_name": "SecurityAlert-PotentialPhishingDomainCommunication", "attributes": {}}, {"query": "\"//When a user is flagged for suspicious email sending patterns retrieve all the email they have sent around the time of the Alert\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - M365 Defender - Email* tables\\n\\nSecurityAlert\\n| where TimeGenerated > ago (7d)\\n| where ProviderName == \\\"OATP\\\"\\n| where AlertName == \\\"Suspicious email sending patterns detected\\\"\\n| mv-expand todynamic(Entities)\\n| extend SenderFromAddress = tolower(tostring(Entities.MailboxPrimaryAddress))\\n| project AlertTime=TimeGenerated, SenderFromAddress\\n| join kind=inner (\\n    EmailEvents\\n    )\\n    on SenderFromAddress\\n| where EmailDirection == \\\"Outbound\\\"\\n| where TimeGenerated between ((AlertTime - timespan(1h)) .. (AlertTime + timespan(1h)))\\n| project TimeGenerated, Subject, AttachmentCount, RecipientEmailAddress\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-RetrieveEmailforSuspiciousEmailPatterns.kql", "query_name": "SecurityAlert-RetrieveEmailforSuspiciousEmailPatterns", "attributes": {}}, {"query": "\"//When Defender for Cloud Apps detects a suspicious mailbox rule created, take that IP address and summarize sign in events for that user and IP address for the last 30 days.\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n//Data connector required for this query - Azure Active Directory - Signin Logs\\n\\n//If they have only signed in a few times from that IP it may a sign the account has been compromised and a threat actor has added mailbox rule\\nlet failureCodes = dynamic([50053, 50126, 50055]);\\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\\nSecurityAlert\\n| where TimeGenerated > ago(1d)\\n| where AlertName == \\\"Suspicious inbox manipulation rule\\\"\\n| extend IPAddress = tostring(parse_json(ExtendedProperties).[\\\"IP Addresses\\\"])\\n| project ['Alert Time']=TimeGenerated, Description, IPAddress, UserPrincipalName=CompromisedEntity\\n| join kind=inner(\\n    SigninLogs\\n    | where TimeGenerated > ago (30d)\\n    )\\n    on UserPrincipalName, IPAddress\\n| project\\n    TimeGenerated,\\n    ['Alert Time'],\\n    Description,\\n    ResultType,\\n    UserPrincipalName,\\n    IPAddress,\\n    NetworkLocationDetails\\n| summarize\\n    ['Count of successful sign ins from MFA IP Address'] = countif(ResultType in(successCodes)),\\n    ['Count of failed sign ins from MFA IP Address'] = countif(ResultType in(failureCodes))\\n    by UserPrincipalName, Description, IPAddress, NetworkLocationDetails, ['Alert Time']\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-SummarizeSigninsafterMailboxRule.kql", "query_name": "SecurityAlert-SummarizeSigninsafterMailboxRule", "attributes": {}}, {"query": "\"//When Defender for Identity detects suspected golden ticket usage, parse the relevant user accounts and host names\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where AlertName startswith \\\"Suspected Golden Ticket usage\\\"\\n| mv-expand todynamic(Entities)\\n| extend AccountName = tostring(Entities.Name)\\n| extend HostName = tostring(Entities.HostName)\\n| summarize\\n    Accounts=make_list_if(AccountName, isnotempty(AccountName)),\\n    Hosts=make_list_if(HostName, isnotempty(HostName))\\n    by VendorOriginalId\\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-SuspectedGoldenTicket.kql", "query_name": "SecurityAlert-SuspectedGoldenTicket", "attributes": {}}, {"query": "\"//Find the top 20 of a collection of varied data sets, no real detections in here just interesting data that is captured\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\n//Top 20 alerts triggered\\nSecurityAlert\\n| where TimeGenerated > ago (30d)\\n| where ProviderName != \\\"ASI Scheduled Alerts\\\"\\n| summarize Count=count() by AlertName\\n| top 20 by Count\\n\\n//Top 20 alerts high severity triggered\\nSecurityAlert\\n| where TimeGenerated > ago (30d)\\n| where ProviderName != \\\"ASI Scheduled Alerts\\\" and AlertSeverity == \\\"High\\\"\\n| summarize Count=count() by AlertName\\n| top 20 by Count\\n\\n//Top 20 users generating identity alerts\\nSecurityAlert\\n| where TimeGenerated > ago (30d)\\n| where ProviderName in (\\\"OATP\\\",\\\"IPC\\\",\\\"Azure Advanced Threat Protection\\\",\\\"MCAS\\\")\\n| summarize Count=count() by CompromisedEntity\\n| where CompromisedEntity != \\\"CompromisedEntity\\\" and isnotempty( CompromisedEntity)\\n| top 20 by Count\\n\\n//Top 20 devices triggering Defender alerts\\nSecurityAlert\\n| where TimeGenerated > ago (30d)\\n| where ProviderName == \\\"MDATP\\\"\\n| summarize Count=count() by CompromisedEntity\\n| where CompromisedEntity != \\\"CompromisedEntity\\\" and isnotempty( CompromisedEntity)\\n| top 20 by Count\\n\\n//Top 20 accounts by distinct alerts\\nSecurityAlert\\n| where TimeGenerated > ago (30d)\\n| where ProviderName in (\\\"OATP\\\",\\\"IPC\\\",\\\"Azure Advanced Threat Protection\\\",\\\"MCAS\\\")\\n| summarize Count=dcount(AlertName) by CompromisedEntity\\n| where CompromisedEntity != \\\"CompromisedEntity\\\" and isnotempty( CompromisedEntity)\\n| top 20 by Count\\n\\n//Top 20 devices by distinct alerts\\nSecurityAlert\\n| where TimeGenerated > ago (30d)\\n| where ProviderName == \\\"MDATP\\\"\\n| summarize Count=dcount(AlertName) by CompromisedEntity\\n| where CompromisedEntity != \\\"CompromisedEntity\\\" and isnotempty( CompromisedEntity)\\n| top 20 by Count\\n\\n//Top 20 users generating high severity identity alerts\\nSecurityAlert\\n| where TimeGenerated > ago (30d)\\n| where ProviderName in (\\\"OATP\\\",\\\"IPC\\\",\\\"Azure Advanced Threat Protection\\\",\\\"MCAS\\\") and AlertSeverity == \\\"High\\\"\\n| summarize Count=count() by CompromisedEntity\\n| where CompromisedEntity != \\\"CompromisedEntity\\\" and isnotempty( CompromisedEntity)\\n| top 20 by Count\\n\\n//Top 20 devices triggering high severity Defender alerts\\nSecurityAlert\\n| where TimeGenerated > ago (30d)\\n| where ProviderName == \\\"MDATP\\\" and AlertSeverity == \\\"High\\\"\\n| summarize Count=count() by CompromisedEntity\\n| where CompromisedEntity != \\\"CompromisedEntity\\\" and isnotempty( CompromisedEntity)\\n| top 20 by Count\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-Top20RandomStats.kql", "query_name": "SecurityAlert-Top20RandomStats", "attributes": {}}, {"query": "\"//Visualize your security alerts by MITRE ATT&CK tactic\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where TimeGenerated > ago(30d)\\n//Exclude Sentinel generated alerts if you want to. This may stop you double counting alerts, i.e generated by Azure AD Identity Protection and then again in Sentinel.\\n| where ProviderName != \\\"ASI Scheduled Alerts\\\"\\n//\\n| where isnotempty(Tactics) and Tactics != \\\"Unknown\\\"\\n| summarize arg_max(TimeGenerated, *) by VendorOriginalId\\n| summarize Count=count()by Tactics\\n| sort by Count desc\\n| render barchart with (title=\\\"Security alerts by MITRE ATT&CK tactic\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-VisualizeAlertsbyMITRE.kql", "query_name": "SecurityAlert-VisualizeAlertsbyMITRE", "attributes": {}}, {"query": "\"//Visualize the number of alerts generated per day by each Defender product\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where TimeGenerated > ago(14d)\\n| summarize Count=count() by ProductName, bin(TimeGenerated, 1d)\\n| where ProductName != \\\"Azure Sentinel\\\"\\n| render columnchart with (kind=unstacked, title=\\\"Alerts by Defender product per day\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-VisualizeAlertsbyProduct.kql", "query_name": "SecurityAlert-VisualizeAlertsbyProduct", "attributes": {}}, {"query": "\"//Visualize the severity of your MDE alerts (Informational, Low, Medium, High) per day\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where TimeGenerated > ago (14d)\\n| where ProviderName == \\\"MDATP\\\"\\n| summarize Count=count()by AlertSeverity, startofday(TimeGenerated)\\n| render columnchart with (kind=unstacked, ytitle=\\\"Alert Count\\\", xtitle=\\\"Day\\\", title=\\\"Defender for Endpoint alert severity per day\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-VisualizeMDEAlertSeverity.kql", "query_name": "SecurityAlert-VisualizeMDEAlertSeverity", "attributes": {}}, {"query": "\"//Visualize the most popular weaponized domains in the phishing emails your users receive\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where TimeGenerated > ago(365d)\\n| where ProviderName == \\\"OATP\\\"\\n| where AlertName in (\\\"Email messages containing malicious URL removed after delivery\\u200b\\\",\\\"Email messages containing phish URLs removed after delivery\\\")\\n| mv-expand todynamic(Entities)\\n| extend MaliciousURL = tostring(Entities.Url)\\n| project MaliciousURL\\n| parse-where MaliciousURL with * \\\"//\\\" ['Malicious Domain'] \\\"/\\\" *\\n| summarize Count=count() by ['Malicious Domain']\\n| sort by Count desc \\n| render barchart  \\n\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-VisualizeTopPhishingDomains.kql", "query_name": "SecurityAlert-VisualizeTopPhishingDomains", "attributes": {}}, {"query": "\"//Visualize your total alerts vs distinct entity alerts per week\\n\\n//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)\\n\\nSecurityAlert\\n| where TimeGenerated > ago(180d)\\n//Exclude alerts generated by Microsoft Sentinel itself if you don't wish to double count them\\n| where ProductName != \\\"ASI Scheduled Alerts\\\"\\n| where Status == \\\"New\\\"\\n| summarize\\n    ['Total Security Alerts']=count(),\\n    ['Unique Entity Alerts']=dcountif(CompromisedEntity, isnotempty(CompromisedEntity))\\n    by bin(TimeGenerated, 7d)\\n| render timechart with (title=\\\"Total Security Alerts vs Unique Entity Alerts\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Security%20Alert/SecurityAlert-VisualizeTotalAlertsvsUniqueAlerts.kql", "query_name": "SecurityAlert-VisualizeTotalAlertsvsUniqueAlerts", "attributes": {}}, {"query": "\"//Find user accounts with the 'password not required' flag set in Active Directory\\n\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nIdentityInfo\\n| where TimeGenerated > ago(30d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| extend UACFlags = tostring(UserAccountControl[0])\\n| where UACFlags == \\\"PasswordNotRequired\\\"\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/UEBA/IdentityInfo-FindAccountsPasswordNotRequired.kql", "query_name": "IdentityInfo-FindAccountsPasswordNotRequired", "attributes": {}}, {"query": "\"//Summarize accounts in our environment that have the same employee id (i.e regular and admin accounts)\\n\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nIdentityInfo\\n| where TimeGenerated > ago(30d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| where isnotempty(EmployeeId)\\n| summarize ['Count of accounts']=dcount(AccountUPN), ['List of accounts']=make_set(AccountUPN) by EmployeeId\\n| sort by ['Count of accounts'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/UEBA/IdentityInfo-FindAccountswithsameEmployeeId.kql", "query_name": "IdentityInfo-FindAccountswithsameEmployeeId", "attributes": {}}, {"query": "\"//Find accounts that are considered to have a high blast radius and currently at risk\\n\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nIdentityInfo\\n| where TimeGenerated > ago(30d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| where BlastRadius == \\\"High\\\"\\n| where RiskState == \\\"AtRisk\\\"\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/UEBA/IdentityInfo-FindAtRiskandHighBlastRadiusUsers.kql", "query_name": "IdentityInfo-FindAtRiskandHighBlastRadiusUsers", "attributes": {}}, {"query": "\"//Find Azure AD guest accounts that are considered to have a high blast radius\\n\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nIdentityInfo\\n| where TimeGenerated > ago(30d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| where UserType == \\\"Guest\\\" and BlastRadius == \\\"High\\\"\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/UEBA/IdentityInfo-FindGuestswithHighBlastRadius.kql", "query_name": "IdentityInfo-FindGuestswithHighBlastRadius", "attributes": {}}, {"query": "\"//Find user accounts that hold an Azure AD privileged role and are considered to have a high blast radius\\n\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nIdentityInfo\\n| where TimeGenerated > ago(30d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| where isnotempty(AssignedRoles) and AssignedRoles != \\\"[]\\\"\\n| where BlastRadius == \\\"High\\\"\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/UEBA/IdentityInfo-FindPrivAccountsHighBlastRadius.kql", "query_name": "IdentityInfo-FindPrivAccountsHighBlastRadius", "attributes": {}}, {"query": "\"//Find user accounts that are members of over 150 groups. These can cause issues with SAML claims.\\n//See https://docs.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-fed-group-claims\\n\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nIdentityInfo\\n| where TimeGenerated > ago(30d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| extend ['Group Count']=array_length(GroupMembership)\\n| sort by ['Group Count'] desc \\n| where ['Group Count'] > 150\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/UEBA/IdentityInfo-FindUserswithmanyGroups.kql", "query_name": "IdentityInfo-FindUserswithmanyGroups", "attributes": {}}, {"query": "\"//Visualize accounts by blast radius level\\n\\n//Data connector required for this query - Microsoft Sentinel UEBA\\n\\nIdentityInfo\\n| where TimeGenerated > ago(30d)\\n| summarize arg_max(TimeGenerated, *) by AccountUPN\\n| where isnotempty(BlastRadius)\\n| summarize Count=count()by BlastRadius\\n| order by Count\\n| render piechart with (title=\\\"Accounts by Microsoft Sentinel EUBA blast radius\\\")\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/UEBA/IdentityInfo-VisualizeBlastRadius.kql", "query_name": "IdentityInfo-VisualizeBlastRadius", "attributes": {}}, {"query": "\"//Find computers that have not sent any security events for over an hour\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where TimeGenerated > ago (1d)\\n| summarize ['Last Record Received']  = datetime_diff(\\\"minute\\\", now(), max(TimeGenerated)) by Computer\\n| project Computer, ['Last Record Received']\\n| where ['Last Record Received'] >= 60\\n| order by ['Last Record Received'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Windows%20Security%20Events/SecEvents-FindDevicesNoLongerSendingLogs.kql", "query_name": "SecEvents-FindDevicesNoLongerSendingLogs", "attributes": {}}, {"query": "\"//Use your Windows security log to find the users most at risk for lateral movement by finding those that have connected remotely to the most devices\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where TimeGenerated > ago (30d)\\n| where EventID == \\\"4624\\\"\\n| where LogonType == 10\\n| where SubjectDomainName == TargetDomainName\\n//Summarize total logins, distinct devices and then list all the devices each account has logged onto\\n//Account is dropped to lower case to make sure each account is only listed once, i.e Reprise99 and reprise99 are combined\\n| summarize\\n    ['Total logon count']=count(),\\n    ['Distinct device logon count']=dcount(Computer),\\n    ['List of devices']=make_set(Computer)\\n    by tolower(Account)\\n| sort by ['Distinct device logon count'] desc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Windows%20Security%20Events/SecEvents-FindLateralMovementUsers.kql", "query_name": "SecEvents-FindLateralMovementUsers", "attributes": {}}, {"query": "\"//Detect when a user connects to 3 or more unique devices via RDP over a 30 minute period\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where TimeGenerated > ago (1d)\\n| where EventID == \\\"4624\\\"\\n| where LogonType == 10\\n| where SubjectDomainName == TargetDomainName\\n//Account is dropped to lower case to make sure each account is only listed once, i.e Reprise99 and reprise99 are combined\\n| summarize\\n    ['Distinct device logon count']=dcount(Computer),\\n    ['List of devices']=make_set(Computer)\\n    by tolower(Account), bin(TimeGenerated, 30m)\\n//Find accounts that have logged on to 3 or more unique devices in less than 30 minutes\\n| where ['Distinct device logon count'] >= 3\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Windows%20Security%20Events/SecEvents-PotentialRDPRecon.kql", "query_name": "SecEvents-PotentialRDPRecon", "attributes": {}}, {"query": "\"//Create a summary of interactive and remote interactive (RDP) logons to your Windows devices using the security event logs\\n\\n//Data connector required for this query - Windows Security Events via AMA or Security Events via Legacy Agent\\n\\nSecurityEvent\\n| where TimeGenerated > ago (30d)\\n| where EventID == \\\"4624\\\"\\n| where LogonType in (\\\"2\\\", \\\"10\\\")\\n//Search for just domain logon events but matching subject and target domain name fields\\n| where SubjectDomainName == TargetDomainName\\n| summarize\\n    ['Interactive logon count']=countif(LogonType == 2),\\n    ['Interactive distinct logon count']=dcountif(Account, LogonType == 2),\\n    ['List of interactive logons']=make_set_if(Account, LogonType == 2),\\n    ['Remote interactive logon count']=countif(LogonType == 10),\\n    ['Remote interactive distinct logon count']=dcountif(Account, LogonType == 10),\\n    ['List of remote interactive logons']=make_set_if(Account, LogonType == 10)\\n    by Computer\\n| sort by Computer asc \"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Windows%20Security%20Events/SecEvents-SummarizeLogonEvents.kql", "query_name": "SecEvents-SummarizeLogonEvents", "attributes": {}}, {"query": "\"{\\n  \\\"version\\\": \\\"Notebook/1.0\\\",\\n  \\\"items\\\": [\\n    {\\n      \\\"type\\\": 11,\\n      \\\"content\\\": {\\n        \\\"version\\\": \\\"LinkItem/1.0\\\",\\n        \\\"style\\\": \\\"tabs\\\",\\n        \\\"links\\\": [\\n          {\\n            \\\"id\\\": \\\"1a2013a0-0c04-4ade-a7b3-10b1b3a1691f\\\",\\n            \\\"cellValue\\\": \\\"tab\\\",\\n            \\\"linkTarget\\\": \\\"parameter\\\",\\n            \\\"linkLabel\\\": \\\"Azure AD Sign-Ins\\\",\\n            \\\"subTarget\\\": \\\"azureadsign\\\",\\n            \\\"style\\\": \\\"link\\\"\\n          },\\n          {\\n            \\\"id\\\": \\\"b25342e2-48b6-4369-b4aa-4c4b100f5417\\\",\\n            \\\"cellValue\\\": \\\"tab\\\",\\n            \\\"linkTarget\\\": \\\"parameter\\\",\\n            \\\"linkLabel\\\": \\\"Azure AD Audit\\\",\\n            \\\"subTarget\\\": \\\"azureadaudit\\\",\\n            \\\"style\\\": \\\"link\\\"\\n          },\\n          {\\n            \\\"id\\\": \\\"2138f218-9a99-44ea-9cde-c981aefd1ea7\\\",\\n            \\\"cellValue\\\": \\\"tab\\\",\\n            \\\"linkTarget\\\": \\\"parameter\\\",\\n            \\\"linkLabel\\\": \\\"MFA Analytics\\\",\\n            \\\"subTarget\\\": \\\"mfa\\\",\\n            \\\"style\\\": \\\"link\\\"\\n          },\\n          {\\n            \\\"id\\\": \\\"1f23a0b2-df81-4c09-ab67-fcecf73f820e\\\",\\n            \\\"cellValue\\\": \\\"tab\\\",\\n            \\\"linkTarget\\\": \\\"parameter\\\",\\n            \\\"linkLabel\\\": \\\"Office 365 Analytics\\\",\\n            \\\"subTarget\\\": \\\"o365\\\",\\n            \\\"style\\\": \\\"link\\\"\\n          },\\n          {\\n            \\\"id\\\": \\\"55414398-f3a6-4170-b967-302f11d52be8\\\",\\n            \\\"cellValue\\\": \\\"tab\\\",\\n            \\\"linkTarget\\\": \\\"parameter\\\",\\n            \\\"linkLabel\\\": \\\"Sentinel Analytics\\\",\\n            \\\"subTarget\\\": \\\"sentinel\\\",\\n            \\\"style\\\": \\\"link\\\"\\n          }\\n        ]\\n      },\\n      \\\"name\\\": \\\"links - 0\\\"\\n    },\\n    {\\n      \\\"type\\\": 9,\\n      \\\"content\\\": {\\n        \\\"version\\\": \\\"KqlParameterItem/1.0\\\",\\n        \\\"parameters\\\": [\\n          {\\n            \\\"id\\\": \\\"7505c02c-5bdc-46d9-8ff8-72e5173ed77a\\\",\\n            \\\"version\\\": \\\"KqlParameterItem/1.0\\\",\\n            \\\"name\\\": \\\"Timerange\\\",\\n            \\\"label\\\": \\\"Time Range\\\",\\n            \\\"type\\\": 4,\\n            \\\"value\\\": {\\n              \\\"durationMs\\\": 2592000000\\n            },\\n            \\\"typeSettings\\\": {\\n              \\\"selectableValues\\\": [\\n                {\\n                  \\\"durationMs\\\": 259200000\\n                },\\n                {\\n                  \\\"durationMs\\\": 604800000\\n                },\\n                {\\n                  \\\"durationMs\\\": 1209600000\\n                },\\n                {\\n                  \\\"durationMs\\\": 2419200000\\n                },\\n                {\\n                  \\\"durationMs\\\": 2592000000\\n                },\\n                {\\n                  \\\"durationMs\\\": 5184000000\\n                },\\n                {\\n                  \\\"durationMs\\\": 7776000000\\n                }\\n              ]\\n            },\\n            \\\"timeContext\\\": {\\n              \\\"durationMs\\\": 86400000\\n            }\\n          }\\n        ],\\n        \\\"style\\\": \\\"pills\\\",\\n        \\\"queryType\\\": 0,\\n        \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\"\\n      },\\n      \\\"customWidth\\\": \\\"25\\\",\\n      \\\"name\\\": \\\"parameters - 2\\\"\\n    },\\n    {\\n      \\\"type\\\": 12,\\n      \\\"content\\\": {\\n        \\\"version\\\": \\\"NotebookGroup/1.0\\\",\\n        \\\"groupType\\\": \\\"editable\\\",\\n        \\\"items\\\": [\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"union SigninLogs, AAD*\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| summarize count() by Type, bin(TimeGenerated, 1d)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"Total Azure AD Signins per day\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"areachart\\\"\\n            },\\n            \\\"name\\\": \\\"query - 3\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SigninLogs\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| project TimeGenerated, ResultType, ConditionalAccessPolicies\\\\r\\\\n| where ResultType == 53003\\\\r\\\\n| extend FailedPolicy = tostring(ConditionalAccessPolicies[0].displayName)\\\\r\\\\n| where isnotempty(FailedPolicy)\\\\r\\\\n| summarize FailureCount=count()by FailedPolicy, bin(TimeGenerated, 1d)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"Conditional Access Policy Failures\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"unstackedbar\\\"\\n            },\\n            \\\"name\\\": \\\"query - 0\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"AADUserRiskEvents\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| summarize RiskEvents=count() by RiskEventType, bin(TimeGenerated, 1d)\\\\r\\\\n| where isnotempty( RiskEvents)\\\\r\\\\n| render timechart \\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"Risk Event Types per day\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"unstackedbar\\\"\\n            },\\n            \\\"name\\\": \\\"query - 1\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SigninLogs\\\\r\\\\n| project TimeGenerated, AuthenticationDetails\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| extend AuthMethod = tostring(parse_json(AuthenticationDetails)[0].authenticationMethod)\\\\r\\\\n| where AuthMethod != \\\\\\\"Previously satisfied\\\\\\\"\\\\r\\\\n| summarize\\\\r\\\\n    Password=countif(AuthMethod == \\\\\\\"Password\\\\\\\"),\\\\r\\\\n    Passwordless=countif(AuthMethod in (\\\\\\\"FIDO2 security key\\\\\\\", \\\\\\\"Passwordless phone sign-in\\\\\\\", \\\\\\\"Windows Hello for Business\\\\\\\"))\\\\r\\\\n    by bin(TimeGenerated,1d)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"Password vs Passwordless Sign Ins per day\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"unstackedbar\\\"\\n            },\\n            \\\"name\\\": \\\"query - 2\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"let StartDate = now(-180d);\\\\r\\\\nlet EndDate = now();\\\\r\\\\nAuditLogs\\\\r\\\\n| where OperationName == \\\\\\\"Redeem external user invite\\\\\\\"\\\\r\\\\n| make-series TotalInvites=count() on TimeGenerated in range(StartDate, EndDate, 1d)\\\\r\\\\n| extend (RSquare, SplitIdx, Variance, RVariance, TrendLine)=series_fit_2lines(TotalInvites)\\\\r\\\\n| project TimeGenerated, TotalInvites, TrendLine\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"Guest invites redeemed per day with trend\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"timechart\\\"\\n            },\\n            \\\"name\\\": \\\"query - 4\\\"\\n          }\\n        ]\\n      },\\n      \\\"conditionalVisibility\\\": {\\n        \\\"parameterName\\\": \\\"tab\\\",\\n        \\\"comparison\\\": \\\"isEqualTo\\\",\\n        \\\"value\\\": \\\"azureadsign\\\"\\n      },\\n      \\\"name\\\": \\\"group - 1\\\"\\n    },\\n    {\\n      \\\"type\\\": 12,\\n      \\\"content\\\": {\\n        \\\"version\\\": \\\"NotebookGroup/1.0\\\",\\n        \\\"groupType\\\": \\\"editable\\\",\\n        \\\"items\\\": [\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"AuditLogs\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where OperationName in (\\\\\\\"Reset password (self-service)\\\\\\\", \\\\\\\"Unlock user account (self-service)\\\\\\\")\\\\r\\\\n| summarize\\\\r\\\\n    PasswordReset=countif(OperationName == \\\\\\\"Reset password (self-service)\\\\\\\" and ResultDescription == \\\\\\\"Successfully completed reset.\\\\\\\"),\\\\r\\\\n    AccountUnlock=countif(OperationName == \\\\\\\"Unlock user account (self-service)\\\\\\\" and ResultDescription == \\\\\\\"Success\\\\\\\")\\\\r\\\\n    by bin(TimeGenerated,1d)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"Self Service Password Resets & Account Unlocks per day\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"timechart\\\"\\n            },\\n            \\\"name\\\": \\\"query - 0\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"AuditLogs\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where OperationName in (\\\\\\\"Redeem external user invite\\\\\\\", \\\\\\\"Invite external user\\\\\\\")\\\\r\\\\n| summarize count() by OperationName, bin(TimeGenerated, 1d)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"Guests Invites vs Redeemed per day\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"unstackedbar\\\"\\n            },\\n            \\\"name\\\": \\\"query - 1\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"AuditLogs\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where OperationName == \\\\\\\"Redeem external user invite\\\\\\\"\\\\r\\\\n| extend GuestEmail = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\\\\r\\\\n| extend UserDomain = tostring(split(GuestEmail, \\\\\\\"@\\\\\\\")[1])\\\\r\\\\n| where isnotempty(UserDomain)\\\\r\\\\n| project UserDomain\\\\r\\\\n| summarize DomainCount=count()by UserDomain\\\\r\\\\n| where DomainCount > 15\\\\r\\\\n| sort by DomainCount desc \\\",\\n              \\\"size\\\": 0,\\n              \\\"title\\\": \\\"Top Domains Redeeming Guest Invites\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"piechart\\\"\\n            },\\n            \\\"name\\\": \\\"query - 2\\\"\\n          }\\n        ]\\n      },\\n      \\\"conditionalVisibility\\\": {\\n        \\\"parameterName\\\": \\\"tab\\\",\\n        \\\"comparison\\\": \\\"isEqualTo\\\",\\n        \\\"value\\\": \\\"azureadaudit\\\"\\n      },\\n      \\\"name\\\": \\\"group - 4\\\"\\n    },\\n    {\\n      \\\"type\\\": 12,\\n      \\\"content\\\": {\\n        \\\"version\\\": \\\"NotebookGroup/1.0\\\",\\n        \\\"groupType\\\": \\\"editable\\\",\\n        \\\"items\\\": [\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SecurityIncident\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| summarize IncidentSeverity=dcount(IncidentNumber)by Severity, bin(TimeGenerated,1d)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"Microsoft Sentinel Incident Severity per day\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"linechart\\\"\\n            },\\n            \\\"name\\\": \\\"query - 0\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SecurityIncident\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where Status == \\\\\\\"New\\\\\\\" and ModifiedBy == \\\\\\\"Incident created from alert\\\\\\\"\\\\r\\\\n| summarize count() by Title\\\\r\\\\n| sort by count_ desc\\\\r\\\\n| take 10\\\",\\n              \\\"size\\\": 0,\\n              \\\"title\\\": \\\"Top Sentinel Incidents Triggered\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"table\\\",\\n              \\\"gridSettings\\\": {\\n                \\\"formatters\\\": [\\n                  {\\n                    \\\"columnMatch\\\": \\\"count_\\\",\\n                    \\\"formatter\\\": 3,\\n                    \\\"formatOptions\\\": {\\n                      \\\"palette\\\": \\\"blue\\\"\\n                    }\\n                  }\\n                ]\\n              }\\n            },\\n            \\\"customWidth\\\": \\\"50\\\",\\n            \\\"name\\\": \\\"query - 1\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SecurityIncident\\\\r\\\\n| where TimeGenerated > ago(180d)\\\\r\\\\n| where Status == \\\\\\\"New\\\\\\\" and ModifiedBy == \\\\\\\"Incident created from alert\\\\\\\"\\\\r\\\\n| summarize arg_max(TimeGenerated, *) by Title\\\\r\\\\n| extend ['Days Since Last Incident'] = datetime_diff(\\\\\\\"day\\\\\\\", now(), TimeGenerated)\\\\r\\\\n| project Title, ['Days Since Last Incident']\\\\r\\\\n| sort by ['Days Since Last Incident'] desc\\\\r\\\\n| take 10\\\",\\n              \\\"size\\\": 0,\\n              \\\"title\\\": \\\"Sentinel Incidents not Recently Triggered\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"gridSettings\\\": {\\n                \\\"formatters\\\": [\\n                  {\\n                    \\\"columnMatch\\\": \\\"Days Since Last Incident\\\",\\n                    \\\"formatter\\\": 3,\\n                    \\\"formatOptions\\\": {\\n                      \\\"palette\\\": \\\"coldHot\\\"\\n                    }\\n                  }\\n                ]\\n              }\\n            },\\n            \\\"customWidth\\\": \\\"50\\\",\\n            \\\"name\\\": \\\"query - 2\\\"\\n          }\\n        ]\\n      },\\n      \\\"conditionalVisibility\\\": {\\n        \\\"parameterName\\\": \\\"tab\\\",\\n        \\\"comparison\\\": \\\"isEqualTo\\\",\\n        \\\"value\\\": \\\"sentinel\\\"\\n      },\\n      \\\"name\\\": \\\"group - 6\\\"\\n    },\\n    {\\n      \\\"type\\\": 12,\\n      \\\"content\\\": {\\n        \\\"version\\\": \\\"NotebookGroup/1.0\\\",\\n        \\\"groupType\\\": \\\"editable\\\",\\n        \\\"items\\\": [\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"OfficeActivity\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| project TimeGenerated, Operation\\\\r\\\\n| where Operation in (\\\\\\\"FileSyncDownloadedFull\\\\\\\",\\\\\\\"FileSyncUploadedFull\\\\\\\",\\\\\\\"FileDownloaded\\\\\\\",\\\\\\\"FileUploaded\\\\\\\")\\\\r\\\\n| summarize FilesDownloaded=countif(Operation in (\\\\\\\"FileDownloaded\\\\\\\",\\\\\\\"FileSyncDownloadedFull\\\\\\\")),FilesUploaded=countif(Operation in (\\\\\\\"FileSyncUploadedFull\\\\\\\",\\\\\\\"FileUploaded\\\\\\\")) by bin(TimeGenerated,1d)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"File Uploads vs Downloads in Office 365 per day\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"unstackedbar\\\"\\n            },\\n            \\\"name\\\": \\\"query - 1\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"OfficeActivity\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where UserType == \\\\\\\"Regular\\\\\\\"\\\\r\\\\n| where CommunicationType == \\\\\\\"Team\\\\\\\"\\\\r\\\\n| where OfficeWorkload == \\\\\\\"MicrosoftTeams\\\\\\\" \\\\r\\\\n| where Operation in (\\\\\\\"MemberAdded\\\\\\\", \\\\\\\"MemberRemoved\\\\\\\")\\\\r\\\\n| extend User = tostring(Members[0].UPN)\\\\r\\\\n| where User contains \\\\\\\"#EXT\\\\\\\"\\\\r\\\\n| project TimeGenerated, Operation, User\\\\r\\\\n| summarize\\\\r\\\\n    GuestsAdded=countif(Operation == \\\\\\\"MemberAdded\\\\\\\"),\\\\r\\\\n    GuestsRemoved=countif(Operation == \\\\\\\"MemberRemoved\\\\\\\")\\\\r\\\\n    by bin(TimeGenerated,1d)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"Guests Added vs Removed to Teams per day\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"unstackedbar\\\"\\n            },\\n            \\\"name\\\": \\\"query - 2\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"IdentityInfo\\\\r\\\\n| where TimeGenerated > ago(21d)\\\\r\\\\n| where UserType == \\\\\\\"Guest\\\\\\\"\\\\r\\\\n| summarize arg_max(TimeGenerated, *) by AccountUPN, MailAddress\\\\r\\\\n| project UserId=tolower(AccountUPN), MailAddress\\\\r\\\\n| join kind=inner (\\\\r\\\\n    OfficeActivity\\\\r\\\\n    | where TimeGenerated {Timerange}\\\\r\\\\n    | where Operation in (\\\\\\\"FileSyncDownloadedFull\\\\\\\", \\\\\\\"FileDownloaded\\\\\\\")\\\\r\\\\n    )\\\\r\\\\n    on UserId\\\\r\\\\n| extend username = tostring(split(UserId,\\\\\\\"#\\\\\\\")[0])\\\\r\\\\n| parse MailAddress with * \\\\\\\"@\\\\\\\" userdomain \\\\r\\\\n| summarize FileCount=count() by userdomain\\\\r\\\\n| sort by FileCount desc\\\\r\\\\n| take 10\\\",\\n              \\\"size\\\": 0,\\n              \\\"title\\\": \\\"Top Guest Domains Downloading from Office 365\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"table\\\",\\n              \\\"gridSettings\\\": {\\n                \\\"formatters\\\": [\\n                  {\\n                    \\\"columnMatch\\\": \\\"FileCount\\\",\\n                    \\\"formatter\\\": 8,\\n                    \\\"formatOptions\\\": {\\n                      \\\"palette\\\": \\\"magenta\\\"\\n                    }\\n                  }\\n                ]\\n              }\\n            },\\n            \\\"customWidth\\\": \\\"33\\\",\\n            \\\"name\\\": \\\"query - 0\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SecurityAlert\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where ProviderName == \\\\\\\"OATP\\\\\\\"\\\\r\\\\n| where AlertName in (\\\\\\\"Email messages containing malicious URL removed after delivery\\u200b\\\\\\\",\\\\\\\"Email messages containing phish URLs removed after delivery\\\\\\\")\\\\r\\\\n| extend x = todynamic(Entities)\\\\r\\\\n| parse-where x with * '\\\\\\\"Url\\\\\\\":\\\\\\\"' MaliciousURL '\\\\\\\"' *\\\\r\\\\n| parse-where MaliciousURL with * \\\\\\\"//\\\\\\\" MaliciousDomain \\\\\\\"/\\\\\\\" *\\\\r\\\\n| project TimeGenerated, MaliciousDomain\\\\r\\\\n| summarize DomainCount=count() by MaliciousDomain\\\\r\\\\n| sort by DomainCount desc \\\\r\\\\n| take 10\\\",\\n              \\\"size\\\": 0,\\n              \\\"title\\\": \\\"Top Malicious Domains with Phishing Emails Removed\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"table\\\",\\n              \\\"gridSettings\\\": {\\n                \\\"formatters\\\": [\\n                  {\\n                    \\\"columnMatch\\\": \\\"DomainCount\\\",\\n                    \\\"formatter\\\": 8,\\n                    \\\"formatOptions\\\": {\\n                      \\\"palette\\\": \\\"orangeRed\\\"\\n                    }\\n                  }\\n                ]\\n              }\\n            },\\n            \\\"customWidth\\\": \\\"33\\\",\\n            \\\"name\\\": \\\"query - 3\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SecurityAlert\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where ProviderName == \\\\\\\"OATP\\\\\\\"\\\\r\\\\n| where AlertName in (\\\\\\\"Email messages containing malicious URL removed after delivery\\u200b\\\\\\\", \\\\\\\"Email messages containing malicious file removed after delivery\\u200b\\\\\\\")\\\\r\\\\n| extend x = todynamic(Entities)\\\\r\\\\n| mv-expand x\\\\r\\\\n| parse-where x with * 'MailboxPrimaryAddress\\\\\\\":\\\\\\\"' User '\\\\\\\"' *\\\\r\\\\n| summarize PhishingCount=count()by User\\\\r\\\\n| order by PhishingCount\\\",\\n              \\\"size\\\": 0,\\n              \\\"title\\\": \\\"Top Users Targeted by Phishing\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"gridSettings\\\": {\\n                \\\"formatters\\\": [\\n                  {\\n                    \\\"columnMatch\\\": \\\"PhishingCount\\\",\\n                    \\\"formatter\\\": 8,\\n                    \\\"formatOptions\\\": {\\n                      \\\"palette\\\": \\\"orangeRed\\\"\\n                    }\\n                  }\\n                ]\\n              }\\n            },\\n            \\\"customWidth\\\": \\\"33\\\",\\n            \\\"name\\\": \\\"query - 4\\\"\\n          }\\n        ]\\n      },\\n      \\\"conditionalVisibility\\\": {\\n        \\\"parameterName\\\": \\\"tab\\\",\\n        \\\"comparison\\\": \\\"isEqualTo\\\",\\n        \\\"value\\\": \\\"o365\\\"\\n      },\\n      \\\"name\\\": \\\"group - 7\\\"\\n    },\\n    {\\n      \\\"type\\\": 12,\\n      \\\"content\\\": {\\n        \\\"version\\\": \\\"NotebookGroup/1.0\\\",\\n        \\\"groupType\\\": \\\"editable\\\",\\n        \\\"items\\\": [\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SigninLogs\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where AuthenticationRequirement == \\\\\\\"multiFactorAuthentication\\\\\\\"\\\\r\\\\n| extend x=todynamic(AuthenticationDetails)\\\\r\\\\n| mv-expand x\\\\r\\\\n| project TimeGenerated, x\\\\r\\\\n| extend MFAResultStep = tostring(x.authenticationStepResultDetail)\\\\r\\\\n| summarize\\\\r\\\\n    MFARequired=countif(MFAResultStep == \\\\\\\"MFA completed in Azure AD\\\\\\\"),\\\\r\\\\n    PreviouslySatisfied=countif(MFAResultStep == \\\\\\\"MFA requirement satisfied by claim in the token\\\\\\\")\\\\r\\\\n    by bin(TimeGenerated, 1d)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"MFA Challenge vs MFA Previously Satisfied per day\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"timechart\\\"\\n            },\\n            \\\"name\\\": \\\"query - 2\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SigninLogs\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where AuthenticationRequirement == \\\\\\\"multiFactorAuthentication\\\\\\\"\\\\r\\\\n| extend x=todynamic(AuthenticationDetails)\\\\r\\\\n| mv-expand x\\\\r\\\\n| project TimeGenerated, x\\\\r\\\\n| where x.RequestSequence != \\\\\\\"1\\\\\\\"\\\\r\\\\n| where x.authenticationStepRequirement == \\\\\\\"Multi-factor authentication\\\\\\\"\\\\r\\\\n| extend MFAMethod = tostring(x.authenticationMethod)\\\\r\\\\n| summarize MFAMethodCount=count() by MFAMethod, bin(TimeGenerated, 1d)\\\\r\\\\n| where MFAMethod != \\\\\\\"Previously satisfied\\\\\\\" and isnotempty(MFAMethod)\\\",\\n              \\\"size\\\": 1,\\n              \\\"title\\\": \\\"MFA methods per day \\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"areachart\\\"\\n            },\\n            \\\"name\\\": \\\"query - 3\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SigninLogs\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where AuthenticationRequirement == \\\\\\\"multiFactorAuthentication\\\\\\\"\\\\r\\\\n| extend AuthMethod = tostring(parse_json(AuthenticationDetails)[0].authenticationMethod)\\\\r\\\\n| summarize count() by AuthMethod\\\\r\\\\n| where AuthMethod has_any (\\\\\\\"Text message\\\\\\\", \\\\\\\"Mobile app notification\\\\\\\", \\\\\\\"OATH verification code\\\\\\\", \\\\\\\"Passwordless phone sign-in\\\\\\\")\\\",\\n              \\\"size\\\": 2,\\n              \\\"title\\\": \\\"MFA Methods by Type\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"visualization\\\": \\\"piechart\\\"\\n            },\\n            \\\"customWidth\\\": \\\"33\\\",\\n            \\\"name\\\": \\\"query - 0\\\"\\n          },\\n          {\\n            \\\"type\\\": 3,\\n            \\\"content\\\": {\\n              \\\"version\\\": \\\"KqlItem/1.0\\\",\\n              \\\"query\\\": \\\"SigninLogs\\\\r\\\\n| where TimeGenerated {Timerange}\\\\r\\\\n| where ResultType == 0\\\\r\\\\n| summarize\\\\r\\\\n    TotalCount=count(),\\\\r\\\\n    MFACount=countif(AuthenticationRequirement == \\\\\\\"multiFactorAuthentication\\\\\\\"),\\\\r\\\\n    nonMFACount=countif(AuthenticationRequirement == \\\\\\\"singleFactorAuthentication\\\\\\\")\\\\r\\\\n    by AppDisplayName\\\\r\\\\n| project\\\\r\\\\n    AppDisplayName,\\\\r\\\\n    TotalCount,\\\\r\\\\n    MFACount,\\\\r\\\\n    nonMFACount,\\\\r\\\\n    MFAPercentage=(todouble(MFACount) * 100 / todouble(TotalCount))\\\\r\\\\n| sort by MFAPercentage asc, TotalCount desc\\\\r\\\\n| take 10\\\",\\n              \\\"size\\\": 0,\\n              \\\"title\\\": \\\"Most Popular Apps with the least MFA coverage\\\",\\n              \\\"queryType\\\": 0,\\n              \\\"resourceType\\\": \\\"microsoft.operationalinsights/workspaces\\\",\\n              \\\"gridSettings\\\": {\\n                \\\"formatters\\\": [\\n                  {\\n                    \\\"columnMatch\\\": \\\"MFAPercentage\\\",\\n                    \\\"formatter\\\": 8,\\n                    \\\"formatOptions\\\": {\\n                      \\\"palette\\\": \\\"red\\\"\\n                    },\\n                    \\\"numberFormat\\\": {\\n                      \\\"unit\\\": 1,\\n                      \\\"options\\\": {\\n                        \\\"style\\\": \\\"decimal\\\"\\n                      }\\n                    }\\n                  }\\n                ]\\n              }\\n            },\\n            \\\"customWidth\\\": \\\"66\\\",\\n            \\\"name\\\": \\\"query - 1\\\"\\n          }\\n        ]\\n      },\\n      \\\"conditionalVisibility\\\": {\\n        \\\"parameterName\\\": \\\"tab\\\",\\n        \\\"comparison\\\": \\\"isEqualTo\\\",\\n        \\\"value\\\": \\\"mfa\\\"\\n      },\\n      \\\"name\\\": \\\"group - 7\\\"\\n    }\\n  ],\\n  \\\"fromTemplateId\\\": \\\"sentinel-UserWorkbook\\\",\\n  \\\"$schema\\\": \\\"https://github.com/Microsoft/Application-Insights-Workbooks/blob/master/schema/workbook.json\\\"\\n}\"", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/Workbooks/365DaysofKQL-Day100.kql", "query_name": "365DaysofKQL-Day100", "attributes": {}}, {"query": "\"// Show OperationName and OperationCount\\n// See here: https://github.com/rod-trent/SentinelKQL/blob/master/IntuneActivityTypes.txt\\nIntuneAuditLogs\\n| summarize OperationCount=count() by OperationName \\n| sort by OperationNumberdesc\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit%20-%20Show%20OperationName%20and%20OperationCount.kql", "query_name": "Audit - Show OperationName and OperationCount", "attributes": {}}, {"query": "\"IntuneAuditLogs\\n| where OperationName contains \\\"patch\\\"\\n| extend User = todynamic(Properties).Actor.UPN\\n| extend Apps = todynamic(Properties).Actor.ApplicationName\\n| extend Device = todynamic(Properties).TargetObjectIds\\n//| extend Policy = todynamic(Properties).TargetDisplayNames\\n| extend Policy = replace_regex(tostring(todynamic(Properties).TargetDisplayNames), @'[\\\"\\\\[\\\\]]', \\\"\\\")\\n| mv-expand todynamic(Properties).Targets[0].ModifiedProperties\\n| extend Configuration = todynamic(Properties_Targets_0_ModifiedProperties).Name\\n| extend ['New Value'] = todynamic(Properties_Targets_0_ModifiedProperties).New\\n| extend ['Old Value'] = todynamic(Properties_Targets_0_ModifiedProperties).Old\\n| project TimeGenerated, Policy, Configuration, ['New Value'], ['Old Value'], User\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-ChangesinConfigurationProfiles.kql", "query_name": "Audit-ChangesinConfigurationProfiles", "attributes": {}}, {"query": "\"IntuneAuditLogs\\n| where OperationName contains \\\"Delete Manageddevice\\\"\\n| extend User = todynamic(Properties).Actor.UPN\\n| extend Application = todynamic(Properties).Actor.ApplicationName\\n| extend Device = replace_regex(tostring(todynamic(Properties).TargetObjectIds), @'[\\\"\\\\[\\\\]]', \\\"\\\")\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-DeletedDevices.kql", "query_name": "Audit-DeletedDevices", "attributes": {}}, {"query": "\"// Show client certificates that have been created, changed or deleted in Intune and who initiated that.\\nIntuneAuditLogs\\n| where OperationName has \\\"ClientCertificate\\\"\\n| extend User = tostring(todynamic(Properties).Actor.UPN)\\n| extend DeviceId = tostring(todynamic(Properties).TargetObjectIds[0])\\n| join kind=leftouter IntuneDevices on DeviceId // DeviceName from IntuneDevices\\n| distinct TimeGenerated, User, DeviceName, OperationName\\n| sort by TimeGenerated desc \\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-ShowClientCertificates.kql", "query_name": "Audit-ShowClientCertificates", "attributes": {}}, {"query": "\"// Show devices that have been deleted from Intune and who initiated that.\\nIntuneAuditLogs\\n| where OperationName has \\\"Delete ManagedDevice\\\"\\n| extend User = tostring(todynamic(Properties).Actor.UPN)\\n| extend DeviceId = tostring(todynamic(Properties).TargetObjectIds[0])\\n| join kind=leftouter IntuneDevices on DeviceId // DeviceName from IntuneDevices\\n| distinct TimeGenerated, User, DeviceName\\n| sort by TimeGenerated desc \\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-ShowDeletedDevices.kql", "query_name": "Audit-ShowDeletedDevices", "attributes": {}}, {"query": "\"// Show devices for which the enableLostMode was activated and who initiated that.\\nIntuneAuditLogs\\n| where OperationName has \\\"enableLostMode\\\"\\n| extend User = tostring(todynamic(Properties).Actor.UPN)\\n| extend DeviceId = tostring(todynamic(Properties).TargetObjectIds[0])\\n| join kind=leftouter IntuneDevices on DeviceId // DeviceName from IntuneDevices\\n| distinct TimeGenerated, User, DeviceName\\n| sort by TimeGenerated desc \\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-ShowEnableLostModeDevices.kql", "query_name": "Audit-ShowEnableLostModeDevices", "attributes": {}}, {"query": "\"// Show changes to Feature Update Policies and who created or changed them.\\nIntuneAuditLogs\\n| where OperationName has \\\"WindowsFeatureUpdateProfile\\\"\\n| extend User = todynamic(Properties).Actor.UPN\\n| extend ['Name of Policy'] = todynamic(Properties).TargetDisplayNames[0]\\n| extend Changes = todynamic(Properties).Targets[0].ModifiedProperties[0].Name\\n| project ['Name of Policy'], Changes, User\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-ShowFeatureUpdatePolicies.kql", "query_name": "Audit-ShowFeatureUpdatePolicies", "attributes": {}}, {"query": "\"// Show Devices for which the option \\u201cLocate Device\\u201c was used.\\nIntuneAuditLogs\\n| where OperationName has \\\"locateDevice\\\"\\n| extend User = tostring(todynamic(Properties).Actor.UPN)\\n| extend DeviceId = tostring(todynamic(Properties).TargetObjectIds[0])\\n| join kind=leftouter IntuneDevices on DeviceId // DeviceName from IntuneDevices\\n| distinct TimeGenerated, User, DeviceName\\n| sort by TimeGenerated desc \\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-ShowLocatedDevices.kql", "query_name": "Audit-ShowLocatedDevices", "attributes": {}}, {"query": "\"// Show devices that have been remote locked and who initiated that.\\nIntuneAuditLogs\\n| where OperationName has \\\"remoteLock\\\"\\n| extend User = todynamic(Properties).Actor.UPN\\n| extend IntuneDeviceID = todynamic(Properties).TargetObjectIds[0]\\n| project TimeGenerated, IntuneDeviceID, User\\n| sort by TimeGenerated desc \"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-ShowRemoteLockedDevices.kql", "query_name": "Audit-ShowRemoteLockedDevices", "attributes": {}}, {"query": "\"// Audit Actions\\nIntuneAuditLogs\\n| parse Properties with * ',\\\"TargetDisplayNames\\\":[\\\"' Object '\\\"],' *\\n| where Object != \\\"\\\"\\n| extend User = todynamic(Properties).Actor.UPN\\n| extend ['Azure Application'] = todynamic(Properties).Actor.ApplicationName\\n| extend DeviceID = replace_regex(tostring(todynamic(Properties).TargetObjectIds), @'[\\\"\\\\[\\\\]]', \\\"\\\")\\n| project OperationName, DeviceID, ['Task'] = Object, ['Azure Application'], User \"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-ShowWhatActionstookplacefromwhichAppOrUser.kql", "query_name": "Audit-ShowWhatActionstookplacefromwhichAppOrUser", "attributes": {}}, {"query": "\"// Show a list of Devices that have recieved the Wipe command in Intune and also display who or which application has wiped a device.\\nIntuneAuditLogs\\n| where OperationName contains \\\"wipe\\\"\\n| extend User = todynamic(Properties).Actor.UPN // Show the user (initiator) if present.\\n| extend Application = todynamic(Properties).Actor.ApplicationName // Show the application (initiator) if present.\\n| extend Device = replace_regex(tostring(todynamic(Properties).TargetObjectIds), @'[\\\"\\\\[\\\\]]', \\\"\\\") // Show target device.\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Audit/Audit-WipedDevices.kql", "query_name": "Audit-WipedDevices", "attributes": {}}, {"query": "\"// Intune devices that are compliant with OS, OS Version, and number of devices\\n// See here: https://github.com/rod-trent/SentinelKQL/blob/master/IntuneisCompliantByOSandOSVersion.txt\\nIntuneDeviceComplianceOrg \\n| where isnotempty(DeviceName)\\n| where ComplianceState == \\\"Compliant\\\"\\n| summarize count() by OSDescription, OSVersion\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Compliance/Compliance%20-%20Intune%20devices%20that%20are%20compliant%20with%20OS%2C%20OS%20Version%20and%20number%20of%20devices.kql", "query_name": "Compliance - Intune devices that are compliant with OS, OS Version and number of devices", "attributes": {}}, {"query": "\"// List of Devices that have DeviceHealthThreatLevel Status of Secured\\nIntuneDeviceComplianceOrg\\n| where isnotempty(DeviceHealthThreatLevel)\\n| where DeviceHealthThreatLevel == \\\"Secured\\\"\\n| project DeviceName, UserName , DeviceHealthThreatLevel\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Compliance/Compliance%20-%20List%20of%20Devices%20that%20have%20DeviceHealthThreatLevel%20Status%20of%20Secured.kql", "query_name": "Compliance - List of Devices that have DeviceHealthThreatLevel Status of Secured", "attributes": {}}, {"query": "\"IntuneDeviceComplianceOrg\\n| where todatetime(LastContact) > ago(30d)\\n| where ComplianceState == \\\"Not compliant\\\"\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| project ComplianceState, DeviceName, LastContact\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Compliance/Compliance-NotcompliantDevices.kql", "query_name": "Compliance-NotcompliantDevices", "attributes": {}}, {"query": "\"// Count of Company owned Devices that are Compliant or Not compliant\\nIntuneDeviceComplianceOrg\\n| where todatetime(LastContact) > ago(30d)\\n| where ComplianceState == \\\"Not compliant\\\" // Change to \\\"Compliant\\\" if you want to count only Compliant Devices\\n| where OwnerType == \\\"Company\\\"\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| project ComplianceState, DeviceName, LastContact\\n| summarize count(DeviceName)\\n\\n// Create a List with all devices:\\nIntuneDeviceComplianceOrg\\n| where todatetime(LastContact) > ago(30d)\\n| where ComplianceState == \\\"Not compliant\\\" // Change to \\\"Compliant\\\" if you want to count only Compliant Devices\\n| where OwnerType == \\\"Company\\\"\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| project ComplianceState, DeviceName, LastContact, OS\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Compliance/Compliance-NumberAndListOfCompanyOwnedDevicesWithComplianceStatus.kql", "query_name": "Compliance-NumberAndListOfCompanyOwnedDevicesWithComplianceStatus", "attributes": {}}, {"query": "\"let Monthly = \\nIntuneDeviceComplianceOrg\\n| where todatetime(LastContact) > ago(30d)\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| summarize count(DeviceName)\\n| extend CustomName=\\\"Active Devices\\\"\\n| extend MonthlyCount=count_DeviceName;\\nlet Weekly=\\nIntuneDeviceComplianceOrg\\n| where todatetime(LastContact) > ago(7d)\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| summarize count(DeviceName)\\n| extend CustomName=\\\"Active Devices\\\"\\n| extend WeeklyCount=count_DeviceName;\\nMonthly\\n| join kind=inner Weekly on CustomName\\n| project-rename ['Last 30 Days']=MonthlyCount, ['Last 7 Days'] = WeeklyCount, Description=CustomName\\n| project Description,['Last 7 Days'],['Last 30 Days']\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Compliance/Compliance-NumberOfActiveDevicesInTheLast7And30Days.kql", "query_name": "Compliance-NumberOfActiveDevicesInTheLast7And30Days", "attributes": {}}, {"query": "\"// Number of Company owned Devices that are Compliant or Not Compliant summarized by OS Platform\\nlet notcompliant =\\n    IntuneDeviceComplianceOrg\\n    | where ComplianceState == \\\"Not compliant\\\"\\n    | where OwnerType == \\\"Company\\\"\\n    | where OSDescription != \\\"\\\"\\n    | summarize arg_max(TimeGenerated, *) by DeviceName\\n    | project ComplianceState, DeviceName, LastContact, OSDescription, OS\\n    | summarize count(DeviceName) by OSDescription;\\nlet compliant =\\n    IntuneDeviceComplianceOrg\\n    | where ComplianceState == \\\"Compliant\\\"\\n    | where OwnerType == \\\"Company\\\"\\n    | where OSDescription != \\\"\\\"\\n    | summarize arg_max(TimeGenerated, *) by DeviceName\\n    | project ComplianceState, DeviceName, LastContact, OSDescription, OS\\n    | summarize count(DeviceName) by OSDescription;\\nnotcompliant\\n| join kind=inner compliant on OSDescription\\n| project-rename\\n    [\\\"Compliant\\\"]=count_DeviceName1,\\n    [\\\"Not Compliant\\\"]=count_DeviceName,\\n    [\\\"Platform\\\"]=OSDescription\\n| project [\\\"Platform\\\"], [\\\"Compliant\\\"], [\\\"Not Compliant\\\"]\\n| sort by Compliant desc \"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Compliance/Compliance-NumberOfCompanyOwnedDevicesThatAreCompliantOrNotCompliantSummarizedByOSPlatform.kql", "query_name": "Compliance-NumberOfCompanyOwnedDevicesThatAreCompliantOrNotCompliantSummarizedByOSPlatform", "attributes": {}}, {"query": "\"// Number of Devices with DeviceHealthThreatLevel Status\\nlet secured =\\nIntuneDeviceComplianceOrg\\n| where isnotempty(DeviceHealthThreatLevel)\\n| where DeviceHealthThreatLevel == \\\"Secured\\\"\\n| distinct DeviceName, UserName , DeviceHealthThreatLevel\\n| summarize count(DeviceName)\\n| extend ['Number of Devices'] = count_DeviceName\\n| extend Status = \\\"Secured\\\";\\nlet notsecured =\\nIntuneDeviceComplianceOrg\\n| where isnotempty(DeviceHealthThreatLevel)\\n| where DeviceHealthThreatLevel == \\\"Not Secured\\\"\\n| distinct  DeviceName, UserName , DeviceHealthThreatLevel\\n| summarize count(DeviceName)\\n| extend ['Number of Devices'] = count_DeviceName\\n| extend Status = \\\"Not Secured\\\";\\nlet unknown =\\nIntuneDeviceComplianceOrg\\n| where isnotempty(DeviceHealthThreatLevel)\\n| where DeviceHealthThreatLevel == \\\"Unknown\\\"\\n| distinct  DeviceName, UserName , DeviceHealthThreatLevel\\n| summarize count(DeviceName)\\n| extend ['Number of Devices'] = count_DeviceName\\n| extend Status = \\\"Unknown\\\";\\nsecured\\n| union notsecured, unknown\\n| project Status, ['Number of Devices']\\n| sort by ['Number of Devices']\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Compliance/Compliance-NumberofDeviceswithDeviceHealthThreatLevelStatus.kql", "query_name": "Compliance-NumberofDeviceswithDeviceHealthThreatLevelStatus", "attributes": {}}, {"query": "\"IntuneDevices\\n| where OS contains \\\"Windows\\\"\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| where todatetime(LastContact) > ago(30d) \\n| extend WindowsVersion = case(OSVersion contains '19041', \\\"20H1\\\", \\n                                OSVersion contains '19042', \\\"20H2\\\",    \\n                                OSVersion contains '19043', \\\"21H1\\\", \\n                                OSVersion contains '19044', \\\"21H2\\\",\\n                                OSVersion contains '18363', \\\"1909\\\",\\n                                OSVersion contains '22000', \\\"Win11 21H2\\\",\\n                                \\\"Unknown\\\")\\n| summarize Count=count() by OSVersion, WindowsVersion\\n| sort by Count desc\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device%20-%20Translate%20OS%20Build%20to%20Version.kql", "query_name": "Device - Translate OS Build to Version", "attributes": {}}, {"query": "\"// Visualize device compliance (compliant, non-compliant, managed by Config Manager, not evaluated or in grace period) per week over time\\nIntuneDevices\\n| where TimeGenerated > ago (30d)\\n| summarize arg_max(DeviceName, *) by DeviceName\\n| where isnotempty(CompliantState)\\n| summarize ComplianceCount=count()by CompliantState\\n| render piechart \\n    with (title=\\\"Device compliance\\\")\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device%20-%20Visualize%20device%20compliance.kql", "query_name": "Device - Visualize device compliance", "attributes": {}}, {"query": "\"// Compare OS Version changes between yesterday and today. It will calculate the difference (number of devices) between two days.\\nlet Yesterday=\\nIntuneDevices\\n| where TimeGenerated < ago(1d) \\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| where todatetime(LastContact) > ago(30d) \\n| summarize count() by OSVersion\\n| sort by OSVersion desc\\n| extend CustomName = OSVersion\\n| extend Version_Yesterday = count_;\\nlet Today=\\nIntuneDevices \\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| where todatetime(LastContact) > ago(30d) \\n| summarize count() by OSVersion\\n| sort by OSVersion desc\\n| extend CustomName = OSVersion\\n| extend Version_Today = count_;\\nYesterday\\n| join kind=inner Today on OSVersion\\n| project CustomName, Version_Today, Version_Yesterday, Difference = Version_Today-Version_Yesterday\\n| sort by CustomName desc\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-CompareOSBuildTodayAndYesterday.kql", "query_name": "Device-CompareOSBuildTodayAndYesterday", "attributes": {}}, {"query": "\"// Show the number of windows devices on 21H1, the date of EOL for 21H1 as well as a countdown in days.\\nIntuneDevices \\n| where OS has \\\"Windows\\\"\\n| extend Build = split(OSVersion, \\\".\\\")[2]\\n| where Build contains \\\"19043\\\"\\n| where SkuFamily == \\\"Enterprise\\\"\\n| summarize count(DeviceName) by tostring(Build)\\n| extend ['21H1 Enterprise - End of servicing'] = todatetime('2022-12-13')\\n| extend ['Countdown in Days'] = datetime_diff('day', now(), ['21H1 Enterprise - End of servicing'])\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-CountdownEndofLife21H1.kql", "query_name": "Device-CountdownEndofLife21H1", "attributes": {}}, {"query": "\"// List of Devices and the assigned PrimaryUser. Filtering devices without a PrimaryUser.\\nIntuneDevices\\n//| where OS == \\\"Windows\\\"\\n| where PrimaryUser !startswith \\\"000000\\\"\\n| project DeviceName, PrimaryUser\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-DevicesAndPrimaryUser.kql", "query_name": "Device-DevicesAndPrimaryUser", "attributes": {}}, {"query": "\"// Devices that are registered in Intune but not managed by it. Also shows User and Device Name as well when it was registered Intune.\\nIntuneDevices \\n| where DeviceState != \\\"Managed\\\"\\n| where SourceSystem == \\\"Microsoft Intune\\\"\\n| distinct UserName, DeviceName, SerialNumber, ['Joined Intune Date:'] = CreatedDate, JoinType\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-DevicesRegisteredButNotManagedByIntune.kql", "query_name": "Device-DevicesRegisteredButNotManagedByIntune", "attributes": {}}, {"query": "\"// List of Devices with no PrimaryUser\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| where PrimaryUser startswith \\\"000000\\\"\\n| project DeviceName, PrimaryUser\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-DevicesWithoutPrimaryUser.kql", "query_name": "Device-DevicesWithoutPrimaryUser", "attributes": {}}, {"query": "\"// Show EOL Dates and the number of devices effected for Win 11 21H2, Win 10 21H2, 21H1 and also 20H2.\\nlet Windows11_21H2 =\\n    IntuneDevices \\n    | where OS has \\\"Windows\\\"\\n    | extend Build = split(OSVersion, \\\".\\\")[2]\\n    | where Build contains \\\"22000\\\"\\n    | summarize count(DeviceName) by tostring(Build)\\n    | extend ['Win11_21H2 Home, Pro - End of servicing'] = \\\"2023-10-10\\\" \\n    | extend ['Win11_21H2 Enterprise - End of servicing'] = \\\"2024-10-08\\\" \\n    | extend CustomName=\\\"Number of Devices\\\";\\nlet 21H2 =\\n    IntuneDevices \\n    | where OS has \\\"Windows\\\"\\n    | extend Build = split(OSVersion, \\\".\\\")[2]\\n    | where Build contains \\\"19044\\\"\\n    | summarize count(DeviceName) by tostring(Build)\\n    | extend ['21H2 Home, Pro - End of servicing'] = \\\"2023-06-13\\\" \\n    | extend ['21H2 Enterprise - End of servicing'] = \\\"2024-06-11\\\" \\n    | extend CustomName=\\\"Number of Devices\\\";\\nlet 21H1 =\\n    IntuneDevices \\n    | where OS has \\\"Windows\\\"\\n    | extend Build = split(OSVersion, \\\".\\\")[2]\\n    | where Build contains \\\"19043\\\"\\n    | summarize count(DeviceName) by tostring(Build)\\n    | extend ['21H1 Home, Pro - End of servicing'] = \\\"2022-12-13\\\" \\n    | extend ['21H1 Enterprise - End of servicing'] = \\\"2022-12-13\\\" \\n    | extend CustomName=\\\"Number of Devices\\\";\\nlet 20H2 =\\n    IntuneDevices \\n    | where OS has \\\"Windows\\\"\\n    | extend Build = split(OSVersion, \\\".\\\")[2]\\n    | where Build contains \\\"19042\\\"\\n    | summarize count(DeviceName) by tostring(Build)\\n    | extend ['20H2 Home, Pro - End of servicing'] = \\\"End of servicing\\\" \\n    | extend ['20H2 Enterprise - End of servicing'] = \\\"2023-05-09\\\" \\n    | extend CustomName=\\\"Number of Devices\\\";\\n21H2\\n| join kind=inner 21H1 on CustomName\\n| join kind=inner 20H2 on CustomName\\n| join kind=inner Windows11_21H2 on CustomName\\n| project \\n    ['Number of Devices with 21H2'] = count_DeviceName, ['21H2 Home, Pro - End of servicing'], ['21H2 Enterprise - End of servicing'],\\n    ['Number of Devices with 21H1'] = count_DeviceName1, ['21H1 Home, Pro - End of servicing'], ['21H1 Enterprise - End of servicing'],\\n    ['Number of Devices with 20H2'] = count_DeviceName2,  ['20H2 Home, Pro - End of servicing'], ['20H2 Enterprise - End of servicing'],\\n    ['Number of Devices with Win11_21H2'] = count_DeviceName3, ['Win11_21H2 Home, Pro - End of servicing'], ['Win11_21H2 Enterprise - End of servicing']\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-EndofLife.kql", "query_name": "Device-EndofLife", "attributes": {}}, {"query": "\"// Show the percentage of free storage on devices\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| where StorageFree != \\\"0\\\" and StorageTotal != \\\"0\\\"\\n| where DeviceName != \\\"User deleted for this device\\\" and DeviceName != \\\"\\\"\\n| extend ['Free Storage'] = StorageFree\\n| extend ['Total Storage'] = StorageTotal\\n| extend Percentage = round(todouble(StorageFree) * 100 / todouble(StorageTotal), 2)\\n| distinct DeviceName, ['Free Storage'], ['Total Storage'], Percentage, UPN\\n| sort by Percentage asc \\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-FreeStorage.kql", "query_name": "Device-FreeStorage", "attributes": {}}, {"query": "\"// Number of iPhones and iPads on Version 14, 15, 16\\nlet version_16 =\\nIntuneDevices \\n| where OS == \\\"iOS/iPadOS\\\"\\n| where OSVersion contains  \\\"16\\\"\\n| summarize ['iOS 16'] = count(DeviceName)\\n| extend Dummy = \\\"Number of Devices\\\";\\nlet version_15 =\\nIntuneDevices \\n| where OS == \\\"iOS/iPadOS\\\"\\n| where OSVersion contains  \\\"15\\\"\\n| summarize ['iOS 15'] = count(DeviceName)\\n| extend Dummy = \\\"Number of Devices\\\";\\nlet version_14 =\\nIntuneDevices\\n| where OS == \\\"iOS/iPadOS\\\"\\n| where OSVersion contains  \\\"14\\\"\\n| summarize ['iOS 14'] = count(DeviceName)\\n| extend Dummy = \\\"Number of Devices\\\";\\nversion_16\\n| join kind=inner version_15 on Dummy \\n| join kind=inner version_14 on Dummy \\n| distinct Dummy, ['iOS 14'], ['iOS 15'], ['iOS 16']\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-iOSVersions.kql", "query_name": "Device-iOSVersions", "attributes": {}}, {"query": "\"// Show all devices and Join Types\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| where isnotempty(JoinType)\\n| distinct JoinType, DeviceName, DeviceRegistrationState\\n\\n// Show only Hybrid Azure AD Joined Devices:\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| where isnotempty(JoinType)\\n| where JoinType has \\\"Hybrid\\\" \\n| distinct JoinType, DeviceName, DeviceRegistrationState\\n\\n// Show only Azure AD Joined Devices:\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| where isnotempty(JoinType)\\n| where JoinType == \\\"Azure AD joined\\\" \\n| distinct JoinType, DeviceName, DeviceRegistrationState\\n\\n// Show only Azure AD registered Devices:\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| where isnotempty(JoinType)\\n| where JoinType == \\\"Azure AD registered\\\" \\n| distinct JoinType, DeviceName, DeviceRegistrationState\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-JoinTypes.kql", "query_name": "Device-JoinTypes", "attributes": {}}, {"query": "\"// Show a list of devices and timestamp the last time they successfully connected to Intune.\\nIntuneDeviceComplianceOrg\\n| where todatetime(LastContact) > ago(30d)\\n| extend Date=format_datetime(todatetime(LastContact), \\\"dd.MM.yyyy\\\")\\n| extend Time=format_datetime(todatetime(LastContact), \\\"hh:mm tt\\\")\\n| extend ['Last successful connection']=strcat(Date,\\\" \\\",Time)\\n| project DeviceName, ['Last successful connection']\\n| project-rename ['Name of the Device'] = DeviceName\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-LastTimeTheDeviceWasActive.kql", "query_name": "Device-LastTimeTheDeviceWasActive", "attributes": {}}, {"query": "\"// List of all Devices that where added to Intune with OS Platform information in a specific timeframe\\nIntuneDevices\\n| where CreatedDate contains \\\"2022-06\\\" # You can change the month and year if you want or delete the line completely\\n| where Ownership == \\\"Corporate\\\"\\n| project DeviceName, OS, OSVersion, UserName, CreatedDate\\n| summarize count(DeviceName) by OS\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-ListofallDevicesthatwhereaddedtoIntunewithOSPlatforminformation.kql", "query_name": "Device-ListofallDevicesthatwhereaddedtoIntunewithOSPlatforminformation", "attributes": {}}, {"query": "\"// Show a list of devices whose the OS Drive is not bitlocker encrypted.\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| where EncryptionStatusString == \\\"False\\\"\\n| where Ownership == \\\"Corporate\\\"\\n| where CompliantState == \\\"Noncompliant\\\"\\n| project DeviceName, EncryptionStatusString, CompliantState\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-ListofDevicesThatAreNotBitlockerEncrypted.kql", "query_name": "Device-ListofDevicesThatAreNotBitlockerEncrypted", "attributes": {}}, {"query": "\"// List of device models and Manufacturers and number of devices for each model\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| summarize count(DeviceName) by Model, Manufacturer\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-NumberOfDevicesAndManufacturers.kql", "query_name": "Device-NumberOfDevicesAndManufacturers", "attributes": {}}, {"query": "\"// Number of devices that are managed by Intune or are Co-managed\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| summarize count(DeviceName) by ManagedBy\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-NumberOfDevicesThatAreManagedByIntuneOrAreCoManaged.kql", "query_name": "Device-NumberOfDevicesThatAreManagedByIntuneOrAreCoManaged", "attributes": {}}, {"query": "\"// Show all Windows Versions and Number of Devices with each Version\\nIntuneDevices\\n| where OS contains \\\"Windows\\\"\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| where todatetime(LastContact) > ago(30d) \\n| extend WindowsVersion = case(\\n    OSVersion contains '19041', \\\"20H1\\\", \\n    OSVersion contains '19042', \\\"20H2\\\",    \\n    OSVersion contains '19043', \\\"21H1\\\", \\n    OSVersion contains '19044', \\\"21H2\\\",\\n    OSVersion contains '18363', \\\"1909\\\",\\n    OSVersion contains '22000', \\\"Win11 21H2\\\",\\n    OSVersion contains '22621', \\\"Win11 Insider (22H2)\\\",\\n    \\\"Unknown\\\")\\n| summarize ['Number of Devices']=count(DeviceName) by WindowsVersion\\n| distinct WindowsVersion, ['Number of Devices'] \\n| sort by ['Number of Devices'] desc\\n//| where WindowsVersion != \\\"Unknown\\\" // Activate this line to show only Devices that have reported the Windows Version\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-ShowallWindowsVersionsandNumberofDeviceswitheachVersion.kql", "query_name": "Device-ShowallWindowsVersionsandNumberofDeviceswitheachVersion", "attributes": {}}, {"query": "\"// Jailbroken devices in Intune\\nIntuneDevices \\n| where OS == \\\"iOS/iPadOS\\\"\\n| where Ownership == \\\"Corporate\\\"\\n| where JailBroken == \\\"True\\\"\\n| project JailBroken, DeviceName, UPN\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-ShowiOSDeviceswithJailbreak.kql", "query_name": "Device-ShowiOSDeviceswithJailbreak", "attributes": {}}, {"query": "\"// This query uses logs from Azure.\\n// Show Device Logins for Azure joined devices. Result will show success, failure, login status, error codes as well as the location (Country, State, City) of the device.\\nSigninLogs\\n| where OperationName == \\\"Sign-in activity\\\"\\n| where UserDisplayName != \\\"On-Premises Directory Synchronization Service Account\\\"\\n| where isnotempty(Status)\\n| extend Login_Status = tostring(todynamic(Status).errorCode) // Check the error code here: https://login.microsoftonline.com/error\\n| extend Login_Status_Info = tostring(todynamic(Status).failureReason)\\n| extend Device_Join_Status = tostring(todynamic(DeviceDetail).trustType)\\n| extend location_country = tostring(todynamic(LocationDetails).countryOrRegion)\\n| extend location_city = tostring(todynamic(LocationDetails).city)\\n| extend location_state = tostring(todynamic(LocationDetails).state)\\n| extend Location = strcat(location_country, \\\" \\\", \\\"/\\\", \\\" \\\", location_state, \\\" \\\", \\\"/\\\",\\\" \\\", location_city)\\n| extend Authentication_Method = tostring(todynamic(AuthenticationDetails).[0].authenticationMethod)\\n| extend Authentication_Detail = tostring(todynamic(AuthenticationDetails).[0].authenticationStepResultDetail)\\n| extend Authentication_Success = tostring(todynamic(AuthenticationDetails).[0].succeeded)\\n| where isnotempty(Device_Join_Status) \\n| where AppDisplayName == \\\"Windows Sign In\\\"\\n| project TimeGenerated, UserDisplayName, AppDisplayName, Login_Status, Login_Status_Info, Device_Join_Status, Location,  Authentication_Method, Authentication_Detail, Authentication_Success\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-SignIns.kql", "query_name": "Device-SignIns", "attributes": {}}, {"query": "\"// Out-of-support Android Versions\\nIntuneDevices \\n| where OS has \\\"Android\\\"\\n| extend Version = todecimal(OSVersion)\\n| where Version < 10\\n| where DeviceName != \\\"User deleted for this device\\\"\\n| where Ownership == \\\"Corporate\\\"\\n| project DeviceName, UserName , Version, Ownership\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-UnsupportedAndroidVersions.kql", "query_name": "Device-UnsupportedAndroidVersions", "attributes": {}}, {"query": "\"// Out-of-support iOS Versions\\nIntuneDevices \\n| where OS has \\\"iOS\\\"\\n| extend Version = todecimal(OSVersion)\\n| where Version < 13\\n| where DeviceName != \\\"User deleted for this device\\\"\\n| where Ownership == \\\"Corporate\\\"\\n| project DeviceName, Version, Ownership\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-UnsupportediOSVersions.kql", "query_name": "Device-UnsupportediOSVersions", "attributes": {}}, {"query": "\"// Visualize Android Versions and filtering for devices that had a connection to intune in the last 30 days.\\nIntuneDevices\\n| where OS contains \\\"Android\\\"\\n| where todatetime(LastContact) > ago(30d) \\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| summarize Versionen=count() by OSVersion\\n| sort by Versionen desc \\n| render piechart with (title=\\\"Android Versions\\\")\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-VisualizeAndroidVersions.kql", "query_name": "Device-VisualizeAndroidVersions", "attributes": {}}, {"query": "\"// Visualize Number of Devices with different SKU (Pro and Enterprise Versions)\\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| where todatetime(LastContact) > ago(30d) // filter for devices that have contacted intune in the last 30 days\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| summarize Number=count() by SkuFamily\\n| render piechart \\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-VisualizeNumberofDeviceswithdifferentSKU.kql", "query_name": "Device-VisualizeNumberofDeviceswithdifferentSKU", "attributes": {}}, {"query": "\"// Visualize the join type (Azure AD joined, Azure AD registered or Hybrid joined) of your MEM/Intune devices per week\\n// See here: https://github.com/reprise99/Sentinel-Queries/blob/main/Intune/IntuneDevices-VisualizeDeviceJoinTypebyWeek.kql\\nIntuneDevices\\n| where todatetime(LastContact) > ago (30d) // Filter only devices the have contacted Intune in the last 30 days\\n| summarize arg_max(TimeGenerated, *) by DeviceName, startofweek(TimeGenerated)\\n| where OS == \\\"Windows\\\"\\n| summarize JoinSummary=count()by JoinType, startofweek(TimeGenerated)\\n| where isnotempty(JoinType)\\n| render columnchart\\n    with (\\n    kind=unstacked,\\n    ytitle=\\\"Device Count\\\",\\n    xtitle=\\\"Week\\\",\\n    title=\\\"Device Number by join type per week\\\") \\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-VisualizeTheJoinType.kql", "query_name": "Device-VisualizeTheJoinType", "attributes": {}}, {"query": "\"// Visualize the Windows Build Numbers and the number of Devices \\nIntuneDevices\\n| where OS == \\\"Windows\\\"\\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| where todatetime(LastContact) > ago(30d) // Include only Devices that had a connection with Intune in the last 30 days.\\n| summarize Devices = count() by OSVersion\\n| where OSVersion != \\\"0.0.0.0\\\" // Exclude devices that have not reported the Windows Build.\\n| sort by Devices\\n| render columnchart // Visualize the output.\\n    with (\\n    kind=unstacked,\\n    ytitle=\\\"Device Count\\\",\\n    xtitle=\\\"Windows Build\\\",\\n    title=\\\"Number of Devices by Windows Build\\\") \"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-VisualizetheWindowsBuildNumbersandthenumberofDevices.kql", "query_name": "Device-VisualizetheWindowsBuildNumbersandthenumberofDevices", "attributes": {}}, {"query": "\"// Visualize when your devices last contacted Intune\\n// See here: https://github.com/reprise99/Sentinel-Queries/blob/main/Intune/IntuneDevices-VisualizeLastContact.kql\\nIntuneDevices\\n| where TimeGenerated > ago(90d)\\n| where isnotempty(LastContact)\\n//Retrieve latest record for each DeviceId\\n| summarize arg_max(TimeGenerated, *) by DeviceId\\n//Convert string to datetime format\\n| extend LastContactTime = todatetime(LastContact)\\n| project DeviceId, LastContactTime\\n//Exclude devices reporting as 0001-01-01\\n| where LastContactTime <> todatetime('0001-01-01T00:00:00Z')\\n//Group by month and render chart\\n| summarize ['Device Count']=count()by startofmonth(LastContactTime)\\n| render columnchart with (title=\\\"Intune devices by last contact time\\\", xtitle=\\\"Month\\\")\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-VisualizeWhenYourDevicesLastContactedIntune.kql", "query_name": "Device-VisualizeWhenYourDevicesLastContactedIntune", "attributes": {}}, {"query": "\"// Visualize Windows Versions and filtering for devices that had a connection to intune in the last 30 days.\\nIntuneDevices\\n| where OS contains \\\"Windows\\\"\\n| where todatetime(LastContact) > ago(30d) \\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| summarize Versionen=count() by OSVersion\\n| sort by Versionen desc \\n| render piechart with ( title=\\\"Windows Build Versions\\\")\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Device/Device-VisualizeWindowsVersions.kql", "query_name": "Device-VisualizeWindowsVersions", "attributes": {}}, {"query": "\"// Show how long the Autopilot process took in seconds and minutes. Result also shows DeviceName for further troubleshooting if needed.\\nIntuneOperationalLogs\\n| extend DeviceId = tostring(todynamic(Properties).DeviceId)\\n| extend Time_Seconds = todynamic(Properties).TimeDiff\\n| extend Autopilot = todynamic(Properties).IsAutopilot\\n| extend Status = todynamic(Properties).Status\\n| extend Time_Minutes = Time_Seconds/60\\n| where Status == \\\"Completed\\\"\\n| where isnotempty(Autopilot)\\n| join kind=leftouter IntuneDevices on DeviceId \\n| project ['Is Autopilot?'] = Autopilot, Status, DeviceName, Time_Minutes, Time_Seconds \"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-AutopilotDuration.kql", "query_name": "Operational-AutopilotDuration", "attributes": {}}, {"query": "\"// Shows Devices where User did not reach Desktop even though Auopilot was successful. Result also shows DeviceName for further troubleshooting if needed.\\nIntuneOperationalLogs\\n| extend DeviceId = tostring(todynamic(Properties).DeviceId)\\n| extend DidUserReachDesktop = todynamic(Properties).DidUserReachDesktop\\n| extend Autopilot = todynamic(Properties).IsAutopilot\\n| where isnotempty(DidUserReachDesktop)\\n| join kind=leftouter IntuneDevices on DeviceId \\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| project DeviceName, Autopilot, DidUserReachDesktop\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-DidUserReachDesktop.kql", "query_name": "Operational-DidUserReachDesktop", "attributes": {}}, {"query": "\"IntuneOperationalLogs \\n| where TimeGenerated > ago(30d) // look for devices that were active in the last 30 days\\n| where OperationName == \\\"Enrollment\\\" // Filter for enrollments\\n| extend Type = todynamic(Properties).EnrollmentType // Look into properties for the enrollment type\\n| summarize count(OperationName) by tostring(Type)\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-EnrollmentTypes.kql", "query_name": "Operational-EnrollmentTypes", "attributes": {}}, {"query": "\"IntuneOperationalLogs \\n| where TimeGenerated > ago(30d) \\n| where OperationName == \\\"ESPEnrollment\\\" // Filter for devices with ESP Enrollment\\n| extend Type = todynamic(Properties).EnrollmentTypeMessage\\n| extend ESPPolicy = todynamic(Properties).ESPPolicyName // Show ESP Profile if present\\n| where Type != \\\"\\\"\\n| summarize count(OperationName) by tostring(Type), tostring(ESPPolicy)\\n| project Type, ESPPolicy, count_OperationName\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-ESPEnrollmentsWithProfileName.kql", "query_name": "Operational-ESPEnrollmentsWithProfileName", "attributes": {}}, {"query": "\"// Show a list of Devices, with Device Name, Result and OS that have been enrolled to Intune.\\nIntuneOperationalLogs \\n| where TimeGenerated > ago(7d) // Change the value in () as you desire e.g. 12h, 10d, 30d. d = day, h = hour.\\n| extend DeviceId = tostring(todynamic(Properties).IntuneDeviceId)\\n| extend OS = tostring(todynamic(Properties).Os)\\n| where Result == \\\"Success\\\"\\n| where OperationName has \\\"Enrollment\\\"\\n//| where OS == \\\"Windows\\\" // You can filter by OS Platform e.g. iOS, Android, Windows. Just replace the vaule between the \\\" \\\" and delete the // infront of |.\\n| join kind=leftouter IntuneDevices on DeviceId // DeviceName from IntuneDevices. Can be delayed.\\n| project TimeGenerated, DeviceId, DeviceName, Result, OperationName, OS\\n| summarize TimeGenerated = max(TimeGenerated) by DeviceId, DeviceName, Result, OperationName, OS\\n| sort by TimeGenerated desc\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-LatestDeviceEnrollments.kql", "query_name": "Operational-LatestDeviceEnrollments", "attributes": {}}, {"query": "\"// Number of Successful Enrollments by OS\\n// See here: https://github.com/rod-trent/SentinelKQL/blob/master/IntuneCountofSuccessfulEnrollmentsbyOS.txt\\nIntuneOperationalLogs \\n| where OperationName == \\\"Enrollment\\\" and Result == \\\"Success\\\"\\n| extend OS = tostring(todynamic(Properties).Os\\n| summarize count() by OS\\n\\n// Failed enrollments\\nIntuneOperationalLogs \\n| where OperationName == \\\"Enrollment\\\" and Result == \\\"Failed\\\"\\n| extend OS = tostring(todynamic(Properties).Os\\n| summarize count() by OS\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-NumberOfSuccessfulEnrollmentsbyOS.kql", "query_name": "Operational-NumberOfSuccessfulEnrollmentsbyOS", "attributes": {}}, {"query": "\"// Show the OS Build of Windows during Autopilot. Result also shows DeviceName for analyzing any future update or upgrade events.\\nIntuneOperationalLogs\\n| extend DeviceId = tostring(todynamic(Properties).DeviceId)\\n| extend Version = todynamic(Properties).Version\\n| where isnotempty(Version)\\n| join kind=leftouter IntuneDevices on DeviceId \\n| summarize arg_max(TimeGenerated, *) by DeviceName\\n| project DeviceName, ['OS Build during Autopilot'] = Version\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-OSBuildDuringAutopilot.kql", "query_name": "Operational-OSBuildDuringAutopilot", "attributes": {}}, {"query": "\"//Intune Enrollment Failure Reasons - Devices not supported by time, failure type, and operating system\\nIntuneOperationalLogs\\n| extend FailureCategory_ = todynamic(Properties).FailureCategory\\n| where FailureCategory_ == \\\"DeviceNotSupported\\\"\\n| extend OS = todynamic(Properties).Os\\n| extend Reason = todynamic(Properties).FailureReason\\n| extend Type = todynamic(Properties).EnrollmentType\\n| extend DeviceId = tostring(todynamic(Properties).AADDeviceId)\\n| project FailureCategory_ , Reason, Type, OS, DeviceId\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-ShowIntuneEnrollmentNotSupportedDevices.kql", "query_name": "Operational-ShowIntuneEnrollmentNotSupportedDevices", "attributes": {}}, {"query": "\"// Show Users that abandoned the Intune Enrollment\\n// Inspiration: https://github.com/rod-trent/SentinelKQL/blob/master/Intune-Enrollmentsabandonedbytheuser.txt\\nIntuneOperationalLogs\\n| where TimeGenerated > ago(7d) // Change the value in () as you desire e.g. 12h, 10d, 30d. d = day, h = hour.\\n| where OperationName == \\\"Enrollment\\\" \\n| where Result == \\\"Fail\\\"\\n| extend EnrollmentType = tostring(todynamic(Properties).EnrollmentType)\\n| extend FailureReason = tostring(todynamic(Properties).FailureReason)\\n| extend OS = tostring(todynamic(Properties).Os)\\n| extend OSVersion = tostring(todynamic(Properties).OsVersion)\\n| extend UserID = tostring(todynamic(Properties).IntuneUserId) // You will find the User in your Azure AD.\\n| where FailureReason == \\\"UserAbandonment\\\"\\n| project\\n    TimeGenerated,\\n    FailureReason,\\n    UserID,\\n    OS,\\n    OSVersion,\\n    OperationName,\\n    EnrollmentType\\n| sort by TimeGenerated desc \"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-ShowUsersThatAbandonedTheIntuneEnrollment.kql", "query_name": "Operational-ShowUsersThatAbandonedTheIntuneEnrollment", "attributes": {}}, {"query": "\"// Visualize Enrollment Statistics (Success and Fail) over time\\nIntuneOperationalLogs\\n| where  OperationName == \\\"Enrollment\\\"\\n| where TimeGenerated > ago(365d)\\n| extend DeviceId = tostring(todynamic(Properties).IntuneDeviceId)\\n| join kind=leftouter IntuneDevices on DeviceId \\n| summarize arg_max(DeviceId, *) by DeviceId, startofweek(TimeGenerated)\\n//| where Result == \\\"Success\\\" // Filter for success or Fail\\n| summarize EnrollmentCount=count()by Result, startofweek(TimeGenerated)\\n| render timechart  \\n    with (\\n    ytitle=\\\"Device Count\\\",\\n    xtitle=\\\"Week\\\",\\n    title=\\\"Enrollments per week over time\\\")\\n\"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-VisualizeEnrollmentStatistics.kql", "query_name": "Operational-VisualizeEnrollmentStatistics", "attributes": {}}, {"query": "\"// Visualize failed Device Deployments\\nIntuneOperationalLogs \\n| extend OS = tostring(todynamic(Properties).Os)\\n| where OS == \\\"Windows\\\"\\n| extend DeviceId = tostring(todynamic(Properties).AADDeviceId)\\n| where Result == \\\"Fail\\\"\\n| join kind=leftouter IntuneDevices on DeviceId\\n| project TimeGenerated, DeviceId, DeviceName\\n| summarize TimeGenerated = max(TimeGenerated) by DeviceId, DeviceName\\n| summarize [\\\"Number of devices that failed deployment\\\"] = count() by DeviceId, DeviceName, TimeGenerated\\n| render timechart \\n   with (\\n    kind=unstacked,\\n    ytitle=\\\"Device Count\\\",\\n    xtitle=\\\"Date\\\",\\n    title=\\\"Number of devices that failed deployment\\\") \"", "source_path": "https://github.com/ugurkocde/KQL_Intune/tree/main/Operational/Operational-VisualizefailedDeviceDeployments.kql", "query_name": "Operational-VisualizefailedDeviceDeployments", "attributes": {}}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| where AppDisplayName == \"Microsoft Teams\"\n| project TimeGenerated, Location, IPAddress, UserAgent\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| where AppDisplayName == \"Microsoft Teams\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| where AppDisplayName == \"Microsoft Teams\"\n| project TimeGenerated, Location, IPAddress, UserAgent\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where TimeGenerated > ago(14d)\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14h)\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14m)\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated between (ago(14d) .. ago(7d))\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated between (ago(14h) .. ago(7h))\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated between (ago(14m) .. ago(7m))\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName =~ \"reprise_99@TESTdomain.com\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName contains \"reprise_99\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName startswith \"reprise_99\"\n\nSigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName endswith \"testdomain.com\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where AppDisplayName has \"Teams\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where AppDisplayName has_any (\"Teams\",\"Outlook\")\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where AppDisplayName has_all (\"Teams\",\"Outlook\")\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where * contains \"reprise_99\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName != \"reprise_99@testdomain.com\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName !contains \"reprise_99\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where AppDisplayName !has \"Teams\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| where AppDisplayName == \"Microsoft Teams\"\n| project TimeGenerated, Location, IPAddress, UserAgent\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "| project LogTime=TimeGenerated, SigninLocation=Location, IP=IPAddress, Agent=UserAgent\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "| project LocalTime=TimeGenerated+5h, Location, IPAddress, UserAgent\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| project-away UserAgent\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| where AppDisplayName == \"Microsoft Teams\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize count() by AppDisplayName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize AppCount=count() by AppDisplayName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize DistinctAppCount=dcount(AppDisplayName) by AppDisplayName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize arg_max(TimeGenerated, *) by UserPrincipalName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize arg_min(TimeGenerated, *) by UserPrincipalName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize TeamsLogons=countif(AppDisplayName has \"Teams\"), SharePointLogons=countif(AppDisplayName has \"SharePoint\")\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize AppCount=count() by AppDisplayName, bin(TimeGenerated, 1d)\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize TeamsLogons=countif(AppDisplayName has \"Teams\"), SharePointLogons=countif(AppDisplayName has \"SharePoint\") by bin(TimeGenerated, 1d)\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize AppList=make_set(AppDisplayName) by UserPrincipalName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize AppList=make_set(AppDisplayName) by UserPrincipalName, bin(TimeGenerated, 1d)\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize AppCount=count()by AppDisplayName\n| render piechart\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize AppCount=count()by AppDisplayName\n| render columnchart\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize AppCount=count()by AppDisplayName\n| render barchart\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize SigninCount=count() by bin(TimeGenerated, 1d)\n| render timechart\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize SigninCount=count() by bin(TimeGenerated, 1d)\n| render areachart\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize SigninCount=count() by bin(TimeGenerated, 1d)\n| render columnchart\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize SigninCount=count() by bin(TimeGenerated, 1d)\n| render barchart\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize SigninCount=count() by AppDisplayName, bin(TimeGenerated, 1d)\n| render columnchart\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize SigninCount=count() by bin(TimeGenerated, 1d)\n| render columnchart with (kind=unstacked)\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where UserPrincipalName == \"reprise_99@testdomain.com\"\n| where ResultType == \"0\"\n| summarize SigninCount=count() by AppDisplayName, bin(TimeGenerated, 1d)\n| render columnchart with (kind=unstacked, ytitle=\"Total Sign Ins\", xtitle=\"Day\", title=\"Application Signins Per Day\")\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| where TimeGenerated > ago(14d)\n| where ResultType == \"0\"\n| summarize TeamsCount=countif(AppDisplayName has \"Teams\"), OneDrive=countif(AppDisplayName has \"OneDrive\"), SharePointCount=countif(AppDisplayName has \"SharePoint\") by bin(TimeGenerated, 1d)\n| render columnchart with (kind=unstacked, ytitle=\"Sign In Count\", xtitle=\"Day\", title=\"Teams vs OneDrive vs SharePoint Sign Ins Per Day\")\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "let ExampleText = datatable(TestData:string)\n[\n'Name=Reprise99,UPNSuffix=testdomain.com,AadTenantId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User,Type=account'\n];\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "let ExampleText = datatable(TestData:string)\n[\n'Name=Reprise99,UPNSuffix=testdomain.com,AadTenantId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User,Type=account'\n];\nExampleText\n| parse TestData with * 'Name=' DisplayName ',' *\n| project DisplayName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "let ExampleText = datatable(TestData:string)\n[\n'Name=Reprise99,UPNSuffix=testdomain.com,AadTenantId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User,Type=account'\n];\nExampleText\n| parse TestData with * 'Name=' DisplayName ',UPNSuffix=' DomainSuffix ',AadTenantId=' AzureADTenantId ',' *\n| project DisplayName, DomainSuffix, AzureADTenantId\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "let ExampleText = datatable(TestData:string)\n[\n'Name=Reprise99,UPNSuffix=testdomain.com,AadTenantId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User,Type=account',\n];\nExampleText\n| parse TestData with * 'Name=' DisplayName ',UPNSuffix=' DomainSuffix ',AadTenantId=' AzureADTenantId ',' *\n| project DisplayName, DomainSuffix, AzureADTenantId\n| parse DomainSuffix with * '.' TopLevelDomain\n| project DisplayName, DomainSuffix, TopLevelDomain, AzureADTenantId\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "let ExampleText = datatable(TestData:string)\n[\n'Name=Reprise99,UPNSuffix=testdomain.com,AadTenantId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User,Type=account',\n'Display=Reprise99,UPN=testdomain.com,AadDirectoryId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadObjectId=cf6f2df6-b754-48dc-b7bc-c8339caf211,Name=Test User,AccountType=account'\n]\n;\nExampleText\n| parse TestData with * 'Name=' DisplayName ',UPNSuffix=' DomainSuffix ',AadTenantId=' AzureADTenantId ',' *\n| project DisplayName, DomainSuffix, AzureADTenantId\n| parse DomainSuffix with * '.' TopLevelDomain\n| project DisplayName, DomainSuffix, TopLevelDomain, AzureADTenantId\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "let ExampleText = datatable(TestData:string)\n[\n'Name=Reprise99,UPNSuffix=testdomain.com,AadTenantId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User,Type=account',\n'Display=Reprise99,UPN=testdomain.com,AadDirectoryId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadObjectId=cf6f2df6-b754-48dc-b7bc-c8339caf211,Name=Test User,AccountType=account'\n]\n;\nExampleText\n| parse-where TestData with * 'Name=' DisplayName ',UPNSuffix=' DomainSuffix ',AadTenantId=' AzureADTenantId ',' *\n| project DisplayName, DomainSuffix, AzureADTenantId\n| parse DomainSuffix with * '.' TopLevelDomain\n| project DisplayName, DomainSuffix, TopLevelDomain, AzureADTenantId\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "let ExampleText = datatable(TestData:string)\n[\n'Name=Reprise99,UPNSuffix=testdomain.com,AadTenantId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User,Type=account',\n]\n;\nExampleText\n| extend SplitData = split(TestData,',')\n| project SplitData\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "let ExampleText = datatable(TestData:string)\n[\n'Name=Reprise99,UPNSuffix=testdomain.com,AadTenantId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User,Type=account',\n]\n;\nExampleText\n| extend Name = split(TestData,',')[0]\n| extend DomainSuffix = split(TestData,',')[1]\n| extend AzureADTenantId = split(TestData,',')[2]\n| extend AzureADUserId = split(TestData,',')[3]\n| extend DisplayName = split(TestData,',')[4]\n| extend AccountType = split(TestData,',')[5]\n| project Name, DomainSuffix, AzureADTenantId, AzureADUserId, DisplayName, AccountType\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "let ExampleText = datatable(TestData:string)\n[\n'Name=Reprise99,UPNSuffix=testdomain.com,AadTenantId=345c1234-a833-43e4-1d34-123440a5bcdd1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User,Type=account',\n'Name=Reprise103,UPNSuffix=testdomain.com,AadTenantId=331c1234-a841-43e5-1d31-12220a5bcee1,AadUserId=cf6f2df6-b754-48dc-b7bc-c8339caf211,DisplayName=Test User 2,Type=account'\n]\n;\nExampleText\n| extend Name = split(TestData,',')[0]\n| extend DomainSuffix = split(TestData,',')[1]\n| extend AzureADTenantId = split(TestData,',')[2]\n| extend AzureADUserId = split(TestData,',')[3]\n| extend DisplayName = split(TestData,',')[4]\n| extend AccountType = split(TestData,',')[5]\n| project Name, DomainSuffix, AzureADTenantId, AzureADUserId, DisplayName, AccountType\n| where Name contains \"Reprise99\"\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor)", "query": "\n```kql\nSigninLogs\n| where AppDisplayName in~ (\"Azure Active Directory PowerShell\",\"Microsoft Graph PowerShell\",\"Microsoft Azure PowerShell\") or UserAgent contains \"WindowsPowerShell\"\n| project TimeGenerated, AppDisplayName, UserPrincipalName, IPAddress, UserAgent\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Reset user password\"\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend UserAgent = tostring(AdditionalDetails[0].value)\n| where UserAgent contains \"WindowsPowerShell\"\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], Target, UserAgent\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName has \"Update application \u2013 Certificates and secrets management\"\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Target Application Name'] = tostring(TargetResources[0].displayName)\n| extend ['Target Application ObjectId'] = tostring(TargetResources[0].id)\n| where isnotempty(Actor)\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['Target Application Name'], ['Target Application ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName has \"Update application \u2013 Certificates and secrets management\"\n| extend ['Service Principal Actor Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Service Principal Actor ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| extend ['Target Application Name'] = tostring(TargetResources[0].displayName)\n| extend ['Target Application ObjectId'] = tostring(TargetResources[0].id)\n| where isnotempty( ['Service Principal Actor ObjectId'])\n| project TimeGenerated, OperationName, ['Service Principal Actor Name'], ['Service Principal Actor ObjectId'], ['Target Application Name'], ['Target Application ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add service principal credentials\"\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Target Service Principal Name'] = tostring(TargetResources[0].displayName)\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| where isnotempty(Actor)\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['Target Service Principal Name'], ['Target Service Principal ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add service principal credentials\"\n| extend ['Service Principal Actor Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Service Principal Actor ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| extend ['Target Service Principal Name'] = tostring(TargetResources[0].displayName)\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| where ['Service Principal Actor Name'] != \"Managed Service Identity\"\n| where isnotempty( ['Service Principal Actor ObjectId'])\n| project TimeGenerated, OperationName, ['Service Principal Actor Name'], ['Service Principal Actor ObjectId'], ['Target Service Principal Name'], ['Target Service Principal ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add app role assignment to service principal\"\n| where Result == \"success\"\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend ['App Role Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)\n| where isnotempty(Actor)\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['App Role Name']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add app role assignment to service principal\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| extend RoleAdded = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| where TargetResources[0].type == \"ServicePrincipal\"\n| where isnotempty(['Actor Service Principal ObjectId'])\n| extend ['Target Service Principal Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[6].newValue)))\n| extend ['Target Service Principal ObjectId'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[5].newValue)))\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], ['Target Service Principal Name'], ['Target Service Principal ObjectId'], RoleAdded\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add application\"\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Application Created Name'] = tostring(TargetResources[0].displayName)\n| extend ['Application Created ObjectId'] = tostring(TargetResources[0].id)\n| where isnotempty(Actor)\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['Application Created Name'], ['Application Created ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add application\"\n| extend ['Application Created Name'] = tostring(TargetResources[0].displayName)\n| extend ['Application Created ObjectId'] = tostring(TargetResources[0].id)\n| extend ['Service Principal Actor ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| extend ['Service Principal Actor Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| where isnotempty( ['Service Principal Actor ObjectId'])\n| project TimeGenerated, OperationName, ['Service Principal Actor Name'], ['Service Principal Actor ObjectId'], ['Application Created Name'], ['Application Created ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add service principal\"\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend ['Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| extend ['Service Principal Name'] = tostring(TargetResources[0].displayName)\n| where isnotempty(Actor)\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['Service Principal Name'], ['Service Principal ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add service principal\"\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Service Principal Created Name'] = tostring(TargetResources[0].displayName)\n| extend ['Service Principal Created ObjectId'] = tostring(TargetResources[0].id)\n| where ['Actor Service Principal Name'] != \"Managed Service Identity\"\n| where isnotempty(['Actor Service Principal ObjectId'])\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], ['Service Principal Created Name'], ['Service Principal Created ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add owner to application\"\n| where TargetResources[0].type == \"User\"\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| extend ['Application Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Application ObjectId'] = tostring(TargetResources[1].id)\n| where isnotempty( Actor)\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], Target, ['Application Name'], ['Application ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, service principal as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add owner to application\"\n| where TargetResources[0].type == \"ServicePrincipal\"\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend ['Target Application Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Target Application ObjectId'] = tostring(TargetResources[1].id)\n| extend ['Subject Service Principal Name'] = tostring(TargetResources[0].displayName)\n| extend ['Subject Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| where isnotempty( Actor)\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['Target Application Name'], ['Target Application ObjectId'], ['Subject Service Principal Name'], ['Subject Service Principal ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add owner to application\"\n| where TargetResources[0].type == \"User\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where isnotempty(['Actor Service Principal ObjectId'])\n| extend ['Subject Service Principal Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Subject Service Principal ObjectId'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], ['Subject Service Principal Name'], ['Subject Service Principal ObjectId'], Target\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service Principal as actor, service principal as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add owner to application\"\n| where TargetResources[0].type == \"ServicePrincipal\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where isnotempty(['Actor Service Principal ObjectId'])\n| extend ['Subject Service Principal Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Subject Service Principal ObjectId'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\n| extend ['Target Service Principal Name'] = tostring(TargetResources[0].displayName)\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], ['Subject Service Principal Name'], ['Subject Service Principal ObjectId'], ['Target Service Principal Name'], ['Target Service Principal ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add owner to service principal\"\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Service Principal Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| where TargetResources[0].type == \"User\"\n| where isnotempty(Actor)\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], Target, ['Service Principal Name'], ['Service Principal ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, Service Principal as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add owner to service principal\"\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| where TargetResources[0].type == \"ServicePrincipal\"\n| where isnotempty(Actor)\n| extend ['Subject Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| extend ['Subject Service Principal Name'] = tostring(TargetResources[0].displayName)\n| extend ['Target Service Principal Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Target Service Principal ObjectId'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['Subject Service Principal Name'], ['Subject Service Principal ObjectId'], ['Target Service Principal Name'], ['Target Service Principal ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service Principal as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add owner to service principal\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where isnotempty( ['Actor Service Principal ObjectId'])\n| extend ['Target Service Principal Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[1].id)\n| where TargetResources[0].type == \"User\"\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], ['Target Service Principal Name'], ['Target Service Principal ObjectId'],Target\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor, Service Principal as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add owner to service principal\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where isnotempty( ['Actor Service Principal ObjectId'])\n| extend ['Target Service Principal Name'] = tostring(TargetResources[0].displayName)\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| where TargetResources[0].type == \"ServicePrincipal\"\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], ['Target Service Principal Name'], ['Target Service Principal ObjectId']\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add member to role\"\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| where TargetResources[0].type == \"User\"\n| where Identity != \"MS-PIM\"\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| extend RoleAdded = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], Target, RoleAdded\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, service principal as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add member to role\"\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| where Identity != \"MS-PIM\"\n| where TargetResources[0].type == \"ServicePrincipal\"\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| extend ['Service Principal Name Added'] = tostring(TargetResources[0].displayName)\n| extend ['Service Principal ObjectId Added'] = tostring(TargetResources[0].id)\n| extend RoleAdded = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['Service Principal Name Added'], ['Service Principal ObjectId Added'],RoleAdded\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add member to role\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where TargetResources[0].type == \"User\"\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| extend RoleAdded = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'],Target, RoleAdded\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor, service principal as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add member to role\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where isnotempty( ['Actor Service Principal ObjectId'])\n| where ['Actor Service Principal Name'] != \"MS-PIM\"\n| where TargetResources[0].type == \"ServicePrincipal\"\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| extend ['Target Service Principal Name'] = tostring(TargetResources[0].displayName)\n| extend RoleAdded = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'],['Target Service Principal Name'], ['Target Service Principal ObjectId'], RoleAdded\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where TimeGenerated > ago(30m)\n| where OperationName == \"Add owner to group\"\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| where TargetResources[0].type == \"User\"\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| where GroupName in~ (\"PrivilegedGroup1\",\"PrivilegedGroup2\")\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], Target, GroupName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, service principal as target)", "query": "\n```kql\nAuditLogs\n| where TimeGenerated > ago(30m)\n| where OperationName == \"Add owner to group\"\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| where TargetResources[0].type == \"ServicePrincipal\"\n| extend ['Target Service Principal Name'] = tostring(TargetResources[0].displayName)\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| where GroupName in~ (\"PrivilegedGroup1\",\"PrivilegedGroup2\")\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['Target Service Principal Name'], ['Target Service Principal ObjectId'], GroupName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service principal as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add owner to group\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where isnotempty(['Actor Service Principal ObjectId'])\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| where TargetResources[0].type == \"User\"\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| where GroupName in~ (\"PrivilegedGroup1\",\"PrivilegedGroup2\")\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], Target, GroupName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service Principal as actor, service principal as target)", "query": "\n```kql\nAuditLogs\n| where TimeGenerated > ago(30m)\n| where OperationName == \"Add owner to group\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where isnotempty(['Actor Service Principal ObjectId'])\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| where TargetResources[0].type == \"ServicePrincipal\"\n| extend ['Target Service Principal Name'] = tostring(TargetResources[0].displayName)\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[0].id)\n| where GroupName in~ (\"PrivilegedGroup1\",\"PrivilegedGroup2\")\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], ['Target Service Principal Name'], ['Target Service Principal ObjectId'], GroupName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add member to group\"\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| where TargetResources[0].type == \"User\"\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| where GroupName in~ (\"PrivilegedGroup1\",\"PrivilegedGroup2\")\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], Target, GroupName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (User as actor, Service Principal as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add member to group\"\n| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)\n| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Target Service Principal Name'] = tostring(TargetResources[0].id)\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[0].displayName)\n| where GroupName in~ (\"PrivilegedGroup1\",\"PrivilegedGroup2\")\n| where TargetResources[0].type == \"ServicePrincipal\"\n| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['Target Service Principal Name'], ['Target Service Principal ObjectId'], GroupName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service Principal as actor, user as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add member to group\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where isnotempty(['Actor Service Principal ObjectId'])\n| where ['Actor Service Principal Name'] != \"MS-PIM\"\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| where TargetResources[0].type == \"User\"\n| where GroupName in~ (\"PrivilegedGroup1\",\"PrivilegedGroup2\")\n| extend Target = tostring(TargetResources[0].userPrincipalName)\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], Target, GroupName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "### Detection Query (Service Principal as actor, service principal as target)", "query": "\n```kql\nAuditLogs\n| where OperationName == \"Add member to group\"\n| extend ['Actor Service Principal Name'] = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend ['Actor Service Principal ObjectId'] = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n| where isnotempty(['Actor Service Principal ObjectId'])\n| where ['Actor Service Principal Name'] != \"MS-PIM\"\n| where TargetResources[0].type == \"ServicePrincipal\"\n| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))\n| extend ['Target Service Principal Name'] = tostring(TargetResources[0].id)\n| extend ['Target Service Principal ObjectId'] = tostring(TargetResources[0].displayName)\n| where GroupName in~ (\"PrivilegedGroup1\",\"PrivilegedGroup2\")\n| project TimeGenerated, OperationName, ['Actor Service Principal Name'], ['Actor Service Principal ObjectId'], ['Target Service Principal Name'], ['Target Service Principal ObjectId'], GroupName\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "SigninLogs\n| take 10\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "AADNonInteractiveUserSignInLogs\n| take 10\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "AADSignInEventsBeta\n| where LogonType == @\"[\"\"interactiveUser\"\"]\"\n| take 10\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "AADSignInEventsBeta\n| where LogonType == @\"[\"\"nonInteractiveUser\"\"]\"\n| take 10\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "AADServicePrincipalSignInLogs\n| take 10\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "AADManagedIdentitySignInLogs\n| take 10\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "AADSpnSignInEventsBeta\n| where IsManagedIdentity == 0\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}, {"query_name": "n/a", "query": "AADSpnSignInEventsBeta\n| where IsManagedIdentity == 1\n```", "source_path": "https://github.com/reprise99/Sentinel-Queries/tree/main/README.md"}]